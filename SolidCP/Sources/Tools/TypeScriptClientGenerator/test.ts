//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AutoDiscoveryClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    isInstalled(providerName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/AutoDiscovery/IsInstalled/{providerName}";
        if (providerName === undefined || providerName === null)
            throw new Error("The parameter 'providerName' must be defined.");
        url_ = url_.replace("{providerName}", encodeURIComponent("" + providerName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsInstalled(_response);
        });
    }

    protected processIsInstalled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getServerFilePath(): Promise<void> {
        let url_ = this.baseUrl + "/api/AutoDiscovery/GetServerFilePath";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServerFilePath(_response);
        });
    }

    protected processGetServerFilePath(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getServerVersion(): Promise<void> {
        let url_ = this.baseUrl + "/api/AutoDiscovery/GetServerVersion";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServerVersion(_response);
        });
    }

    protected processGetServerVersion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOSPlatform(): Promise<void> {
        let url_ = this.baseUrl + "/api/AutoDiscovery/GetOSPlatform";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOSPlatform(_response);
        });
    }

    protected processGetOSPlatform(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getServerPasswordIsSHA256(): Promise<void> {
        let url_ = this.baseUrl + "/api/AutoDiscovery/GetServerPasswordIsSHA256";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServerPasswordIsSHA256(_response);
        });
    }

    protected processGetServerPasswordIsSHA256(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BlackBerryClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createBlackBerryUser(primaryEmailAddress: string): Promise<void> {
        let url_ = this.baseUrl + "/api/BlackBerry/CreateBlackBerryUser/{primaryEmailAddress}";
        if (primaryEmailAddress === undefined || primaryEmailAddress === null)
            throw new Error("The parameter 'primaryEmailAddress' must be defined.");
        url_ = url_.replace("{primaryEmailAddress}", encodeURIComponent("" + primaryEmailAddress));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateBlackBerryUser(_response);
        });
    }

    protected processCreateBlackBerryUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteBlackBerryUser(primaryEmailAddress: string): Promise<void> {
        let url_ = this.baseUrl + "/api/BlackBerry/DeleteBlackBerryUser/{primaryEmailAddress}";
        if (primaryEmailAddress === undefined || primaryEmailAddress === null)
            throw new Error("The parameter 'primaryEmailAddress' must be defined.");
        url_ = url_.replace("{primaryEmailAddress}", encodeURIComponent("" + primaryEmailAddress));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteBlackBerryUser(_response);
        });
    }

    protected processDeleteBlackBerryUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getBlackBerryUserStats(primaryEmailAddress: string): Promise<void> {
        let url_ = this.baseUrl + "/api/BlackBerry/GetBlackBerryUserStats/{primaryEmailAddress}";
        if (primaryEmailAddress === undefined || primaryEmailAddress === null)
            throw new Error("The parameter 'primaryEmailAddress' must be defined.");
        url_ = url_.replace("{primaryEmailAddress}", encodeURIComponent("" + primaryEmailAddress));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBlackBerryUserStats(_response);
        });
    }

    protected processGetBlackBerryUserStats(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setActivationPasswordWithExpirationTime(primaryEmailAddress: string, password: string, time: number): Promise<void> {
        let url_ = this.baseUrl + "/api/BlackBerry/SetActivationPasswordWithExpirationTime/{primaryEmailAddress}/{password}?";
        if (primaryEmailAddress === undefined || primaryEmailAddress === null)
            throw new Error("The parameter 'primaryEmailAddress' must be defined.");
        url_ = url_.replace("{primaryEmailAddress}", encodeURIComponent("" + primaryEmailAddress));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        if (time === undefined || time === null)
            throw new Error("The parameter 'time' must be defined and cannot be null.");
        else
            url_ += "time=" + encodeURIComponent("" + time) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetActivationPasswordWithExpirationTime(_response);
        });
    }

    protected processSetActivationPasswordWithExpirationTime(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setEmailActivationPassword(primaryEmailAddress: string): Promise<void> {
        let url_ = this.baseUrl + "/api/BlackBerry/SetEmailActivationPassword/{primaryEmailAddress}";
        if (primaryEmailAddress === undefined || primaryEmailAddress === null)
            throw new Error("The parameter 'primaryEmailAddress' must be defined.");
        url_ = url_.replace("{primaryEmailAddress}", encodeURIComponent("" + primaryEmailAddress));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetEmailActivationPassword(_response);
        });
    }

    protected processSetEmailActivationPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteDataFromBlackBerryDevice(primaryEmailAddress: string): Promise<void> {
        let url_ = this.baseUrl + "/api/BlackBerry/DeleteDataFromBlackBerryDevice/{primaryEmailAddress}";
        if (primaryEmailAddress === undefined || primaryEmailAddress === null)
            throw new Error("The parameter 'primaryEmailAddress' must be defined.");
        url_ = url_.replace("{primaryEmailAddress}", encodeURIComponent("" + primaryEmailAddress));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDataFromBlackBerryDevice(_response);
        });
    }

    protected processDeleteDataFromBlackBerryDevice(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CRMClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createOrganization(organizationId: string, organizationUniqueName: string, organizationFriendlyName: string, baseLanguageCode: number, ou: string, baseCurrencyCode: string, baseCurrencyName: string, baseCurrencySymbol: string, initialUserDomainName: string, initialUserFirstName: string, initialUserLastName: string, initialUserPrimaryEmail: string, organizationCollation: string, maxSize: number): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/CreateOrganization/{organizationUniqueName}/{organizationFriendlyName}/{ou}/{baseCurrencyCode}/{baseCurrencyName}/{baseCurrencySymbol}/{initialUserDomainName}/{initialUserFirstName}/{initialUserLastName}/{initialUserPrimaryEmail}/{organizationCollation}?";
        if (organizationUniqueName === undefined || organizationUniqueName === null)
            throw new Error("The parameter 'organizationUniqueName' must be defined.");
        url_ = url_.replace("{organizationUniqueName}", encodeURIComponent("" + organizationUniqueName));
        if (organizationFriendlyName === undefined || organizationFriendlyName === null)
            throw new Error("The parameter 'organizationFriendlyName' must be defined.");
        url_ = url_.replace("{organizationFriendlyName}", encodeURIComponent("" + organizationFriendlyName));
        if (ou === undefined || ou === null)
            throw new Error("The parameter 'ou' must be defined.");
        url_ = url_.replace("{ou}", encodeURIComponent("" + ou));
        if (baseCurrencyCode === undefined || baseCurrencyCode === null)
            throw new Error("The parameter 'baseCurrencyCode' must be defined.");
        url_ = url_.replace("{baseCurrencyCode}", encodeURIComponent("" + baseCurrencyCode));
        if (baseCurrencyName === undefined || baseCurrencyName === null)
            throw new Error("The parameter 'baseCurrencyName' must be defined.");
        url_ = url_.replace("{baseCurrencyName}", encodeURIComponent("" + baseCurrencyName));
        if (baseCurrencySymbol === undefined || baseCurrencySymbol === null)
            throw new Error("The parameter 'baseCurrencySymbol' must be defined.");
        url_ = url_.replace("{baseCurrencySymbol}", encodeURIComponent("" + baseCurrencySymbol));
        if (initialUserDomainName === undefined || initialUserDomainName === null)
            throw new Error("The parameter 'initialUserDomainName' must be defined.");
        url_ = url_.replace("{initialUserDomainName}", encodeURIComponent("" + initialUserDomainName));
        if (initialUserFirstName === undefined || initialUserFirstName === null)
            throw new Error("The parameter 'initialUserFirstName' must be defined.");
        url_ = url_.replace("{initialUserFirstName}", encodeURIComponent("" + initialUserFirstName));
        if (initialUserLastName === undefined || initialUserLastName === null)
            throw new Error("The parameter 'initialUserLastName' must be defined.");
        url_ = url_.replace("{initialUserLastName}", encodeURIComponent("" + initialUserLastName));
        if (initialUserPrimaryEmail === undefined || initialUserPrimaryEmail === null)
            throw new Error("The parameter 'initialUserPrimaryEmail' must be defined.");
        url_ = url_.replace("{initialUserPrimaryEmail}", encodeURIComponent("" + initialUserPrimaryEmail));
        if (organizationCollation === undefined || organizationCollation === null)
            throw new Error("The parameter 'organizationCollation' must be defined.");
        url_ = url_.replace("{organizationCollation}", encodeURIComponent("" + organizationCollation));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined and cannot be null.");
        else
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (baseLanguageCode === undefined || baseLanguageCode === null)
            throw new Error("The parameter 'baseLanguageCode' must be defined and cannot be null.");
        else
            url_ += "baseLanguageCode=" + encodeURIComponent("" + baseLanguageCode) + "&";
        if (maxSize === undefined || maxSize === null)
            throw new Error("The parameter 'maxSize' must be defined and cannot be null.");
        else
            url_ += "maxSize=" + encodeURIComponent("" + maxSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrganization(_response);
        });
    }

    protected processCreateOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSupportedCollationNames(): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/GetSupportedCollationNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSupportedCollationNames(_response);
        });
    }

    protected processGetSupportedCollationNames(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCurrencyList(): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/GetCurrencyList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrencyList(_response);
        });
    }

    protected processGetCurrencyList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getInstalledLanguagePacks(): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/GetInstalledLanguagePacks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInstalledLanguagePacks(_response);
        });
    }

    protected processGetInstalledLanguagePacks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteOrganization(orgId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/DeleteOrganization?";
        if (orgId === undefined || orgId === null)
            throw new Error("The parameter 'orgId' must be defined and cannot be null.");
        else
            url_ += "orgId=" + encodeURIComponent("" + orgId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOrganization(_response);
        });
    }

    protected processDeleteOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createCRMUser(orgName: string, organizationId: string, baseUnitId: string, cALType: number, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/CreateCRMUser/{orgName}?";
        if (orgName === undefined || orgName === null)
            throw new Error("The parameter 'orgName' must be defined.");
        url_ = url_.replace("{orgName}", encodeURIComponent("" + orgName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined and cannot be null.");
        else
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (baseUnitId === undefined || baseUnitId === null)
            throw new Error("The parameter 'baseUnitId' must be defined and cannot be null.");
        else
            url_ += "baseUnitId=" + encodeURIComponent("" + baseUnitId) + "&";
        if (cALType === undefined || cALType === null)
            throw new Error("The parameter 'cALType' must be defined and cannot be null.");
        else
            url_ += "CALType=" + encodeURIComponent("" + cALType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCRMUser(_response);
        });
    }

    protected processCreateCRMUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOrganizationBusinessUnits(organizationId: string, orgName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/GetOrganizationBusinessUnits/{orgName}?";
        if (orgName === undefined || orgName === null)
            throw new Error("The parameter 'orgName' must be defined.");
        url_ = url_.replace("{orgName}", encodeURIComponent("" + orgName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined and cannot be null.");
        else
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrganizationBusinessUnits(_response);
        });
    }

    protected processGetOrganizationBusinessUnits(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAllCrmRoles(orgName: string, businessUnitId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/GetAllCrmRoles/{orgName}?";
        if (orgName === undefined || orgName === null)
            throw new Error("The parameter 'orgName' must be defined.");
        url_ = url_.replace("{orgName}", encodeURIComponent("" + orgName));
        if (businessUnitId === undefined || businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' must be defined and cannot be null.");
        else
            url_ += "businessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCrmRoles(_response);
        });
    }

    protected processGetAllCrmRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCrmUserRoles(orgName: string, userId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/GetCrmUserRoles/{orgName}?";
        if (orgName === undefined || orgName === null)
            throw new Error("The parameter 'orgName' must be defined.");
        url_ = url_.replace("{orgName}", encodeURIComponent("" + orgName));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCrmUserRoles(_response);
        });
    }

    protected processGetCrmUserRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setUserRoles(orgName: string, userId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/SetUserRoles/{orgName}?";
        if (orgName === undefined || orgName === null)
            throw new Error("The parameter 'orgName' must be defined.");
        url_ = url_.replace("{orgName}", encodeURIComponent("" + orgName));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetUserRoles(_response);
        });
    }

    protected processSetUserRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setUserCALType(orgName: string, userId: string, cALType: number): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/SetUserCALType/{orgName}?";
        if (orgName === undefined || orgName === null)
            throw new Error("The parameter 'orgName' must be defined.");
        url_ = url_.replace("{orgName}", encodeURIComponent("" + orgName));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (cALType === undefined || cALType === null)
            throw new Error("The parameter 'cALType' must be defined and cannot be null.");
        else
            url_ += "CALType=" + encodeURIComponent("" + cALType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetUserCALType(_response);
        });
    }

    protected processSetUserCALType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCrmUserByDomainName(domainName: string, orgName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/GetCrmUserByDomainName/{domainName}/{orgName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        if (orgName === undefined || orgName === null)
            throw new Error("The parameter 'orgName' must be defined.");
        url_ = url_.replace("{orgName}", encodeURIComponent("" + orgName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCrmUserByDomainName(_response);
        });
    }

    protected processGetCrmUserByDomainName(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCrmUserById(crmUserId: string, orgName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/GetCrmUserById/{orgName}?";
        if (orgName === undefined || orgName === null)
            throw new Error("The parameter 'orgName' must be defined.");
        url_ = url_.replace("{orgName}", encodeURIComponent("" + orgName));
        if (crmUserId === undefined || crmUserId === null)
            throw new Error("The parameter 'crmUserId' must be defined and cannot be null.");
        else
            url_ += "crmUserId=" + encodeURIComponent("" + crmUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCrmUserById(_response);
        });
    }

    protected processGetCrmUserById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeUserState(disable: boolean, orgName: string, crmUserId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/ChangeUserState/{orgName}?";
        if (orgName === undefined || orgName === null)
            throw new Error("The parameter 'orgName' must be defined.");
        url_ = url_.replace("{orgName}", encodeURIComponent("" + orgName));
        if (disable === undefined || disable === null)
            throw new Error("The parameter 'disable' must be defined and cannot be null.");
        else
            url_ += "disable=" + encodeURIComponent("" + disable) + "&";
        if (crmUserId === undefined || crmUserId === null)
            throw new Error("The parameter 'crmUserId' must be defined and cannot be null.");
        else
            url_ += "crmUserId=" + encodeURIComponent("" + crmUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeUserState(_response);
        });
    }

    protected processChangeUserState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDBSize(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/GetDBSize?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined and cannot be null.");
        else
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDBSize(_response);
        });
    }

    protected processGetDBSize(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMaxDBSize(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/GetMaxDBSize?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined and cannot be null.");
        else
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMaxDBSize(_response);
        });
    }

    protected processGetMaxDBSize(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setMaxDBSize(organizationId: string, maxSize: number): Promise<void> {
        let url_ = this.baseUrl + "/api/CRM/SetMaxDBSize?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined and cannot be null.");
        else
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (maxSize === undefined || maxSize === null)
            throw new Error("The parameter 'maxSize' must be defined and cannot be null.");
        else
            url_ += "maxSize=" + encodeURIComponent("" + maxSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetMaxDBSize(_response);
        });
    }

    protected processSetMaxDBSize(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DatabaseServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    checkConnectivity(databaseName: string, username: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/CheckConnectivity/{databaseName}/{username}/{password}";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckConnectivity(_response);
        });
    }

    protected processCheckConnectivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    executeSqlQuery(databaseName: string, commandText: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/ExecuteSqlQuery/{databaseName}/{commandText}";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        if (commandText === undefined || commandText === null)
            throw new Error("The parameter 'commandText' must be defined.");
        url_ = url_.replace("{commandText}", encodeURIComponent("" + commandText));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteSqlQuery(_response);
        });
    }

    protected processExecuteSqlQuery(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    executeSqlNonQuery(databaseName: string, commandText: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/ExecuteSqlNonQuery/{databaseName}/{commandText}";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        if (commandText === undefined || commandText === null)
            throw new Error("The parameter 'commandText' must be defined.");
        url_ = url_.replace("{commandText}", encodeURIComponent("" + commandText));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteSqlNonQuery(_response);
        });
    }

    protected processExecuteSqlNonQuery(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    executeSqlQuerySafe(databaseName: string, username: string, password: string, commandText: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/ExecuteSqlQuerySafe/{databaseName}/{username}/{password}/{commandText}";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        if (commandText === undefined || commandText === null)
            throw new Error("The parameter 'commandText' must be defined.");
        url_ = url_.replace("{commandText}", encodeURIComponent("" + commandText));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteSqlQuerySafe(_response);
        });
    }

    protected processExecuteSqlQuerySafe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    executeSqlNonQuerySafe(databaseName: string, username: string, password: string, commandText: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/ExecuteSqlNonQuerySafe/{databaseName}/{username}/{password}/{commandText}";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        if (commandText === undefined || commandText === null)
            throw new Error("The parameter 'commandText' must be defined.");
        url_ = url_.replace("{commandText}", encodeURIComponent("" + commandText));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteSqlNonQuerySafe(_response);
        });
    }

    protected processExecuteSqlNonQuerySafe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    databaseExists(databaseName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/DatabaseExists/{databaseName}";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDatabaseExists(_response);
        });
    }

    protected processDatabaseExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDatabases(): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/GetDatabases";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDatabases(_response);
        });
    }

    protected processGetDatabases(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDatabase(databaseName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/GetDatabase/{databaseName}";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDatabase(_response);
        });
    }

    protected processGetDatabase(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createDatabase(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/CreateDatabase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDatabase(_response);
        });
    }

    protected processCreateDatabase(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateDatabase(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/UpdateDatabase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDatabase(_response);
        });
    }

    protected processUpdateDatabase(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteDatabase(databaseName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/DeleteDatabase/{databaseName}";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDatabase(_response);
        });
    }

    protected processDeleteDatabase(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    truncateDatabase(databaseName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/TruncateDatabase/{databaseName}";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTruncateDatabase(_response);
        });
    }

    protected processTruncateDatabase(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getTempFileBinaryChunk(path: string, offset: number, length: number): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/GetTempFileBinaryChunk/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (offset === undefined || offset === null)
            throw new Error("The parameter 'offset' must be defined and cannot be null.");
        else
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (length === undefined || length === null)
            throw new Error("The parameter 'length' must be defined and cannot be null.");
        else
            url_ += "length=" + encodeURIComponent("" + length) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTempFileBinaryChunk(_response);
        });
    }

    protected processGetTempFileBinaryChunk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    appendTempFileBinaryChunk(fileName: string, path: string, chunk: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/AppendTempFileBinaryChunk/{fileName}/{path}?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (chunk === undefined || chunk === null)
            throw new Error("The parameter 'chunk' must be defined and cannot be null.");
        else
            url_ += "chunk=" + encodeURIComponent("" + chunk) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAppendTempFileBinaryChunk(_response);
        });
    }

    protected processAppendTempFileBinaryChunk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    backupDatabase(databaseName: string, backupName: string, zipBackup: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/BackupDatabase/{databaseName}/{backupName}?";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        if (backupName === undefined || backupName === null)
            throw new Error("The parameter 'backupName' must be defined.");
        url_ = url_.replace("{backupName}", encodeURIComponent("" + backupName));
        if (zipBackup === undefined || zipBackup === null)
            throw new Error("The parameter 'zipBackup' must be defined and cannot be null.");
        else
            url_ += "zipBackup=" + encodeURIComponent("" + zipBackup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBackupDatabase(_response);
        });
    }

    protected processBackupDatabase(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    restoreDatabase(databaseName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/RestoreDatabase/{databaseName}";
        if (databaseName === undefined || databaseName === null)
            throw new Error("The parameter 'databaseName' must be defined.");
        url_ = url_.replace("{databaseName}", encodeURIComponent("" + databaseName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRestoreDatabase(_response);
        });
    }

    protected processRestoreDatabase(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    userExists(userName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/UserExists/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserExists(_response);
        });
    }

    protected processUserExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUsers(): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUser(username: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/GetUser/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createUser(password: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/CreateUser/{password}";
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateUser(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUser(username: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/DeleteUser/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeUserPassword(username: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DatabaseServer/ChangeUserPassword/{username}/{password}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeUserPassword(_response);
        });
    }

    protected processChangeUserPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DNSServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    zoneExists(zoneName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/ZoneExists/{zoneName}";
        if (zoneName === undefined || zoneName === null)
            throw new Error("The parameter 'zoneName' must be defined.");
        url_ = url_.replace("{zoneName}", encodeURIComponent("" + zoneName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processZoneExists(_response);
        });
    }

    protected processZoneExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getZones(): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/GetZones";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetZones(_response);
        });
    }

    protected processGetZones(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addPrimaryZone(zoneName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/AddPrimaryZone/{zoneName}";
        if (zoneName === undefined || zoneName === null)
            throw new Error("The parameter 'zoneName' must be defined.");
        url_ = url_.replace("{zoneName}", encodeURIComponent("" + zoneName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddPrimaryZone(_response);
        });
    }

    protected processAddPrimaryZone(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addSecondaryZone(zoneName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/AddSecondaryZone/{zoneName}";
        if (zoneName === undefined || zoneName === null)
            throw new Error("The parameter 'zoneName' must be defined.");
        url_ = url_.replace("{zoneName}", encodeURIComponent("" + zoneName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddSecondaryZone(_response);
        });
    }

    protected processAddSecondaryZone(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteZone(zoneName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/DeleteZone/{zoneName}";
        if (zoneName === undefined || zoneName === null)
            throw new Error("The parameter 'zoneName' must be defined.");
        url_ = url_.replace("{zoneName}", encodeURIComponent("" + zoneName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteZone(_response);
        });
    }

    protected processDeleteZone(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateSoaRecord(zoneName: string, host: string, primaryNsServer: string, primaryPerson: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/UpdateSoaRecord/{zoneName}/{host}/{primaryNsServer}/{primaryPerson}";
        if (zoneName === undefined || zoneName === null)
            throw new Error("The parameter 'zoneName' must be defined.");
        url_ = url_.replace("{zoneName}", encodeURIComponent("" + zoneName));
        if (host === undefined || host === null)
            throw new Error("The parameter 'host' must be defined.");
        url_ = url_.replace("{host}", encodeURIComponent("" + host));
        if (primaryNsServer === undefined || primaryNsServer === null)
            throw new Error("The parameter 'primaryNsServer' must be defined.");
        url_ = url_.replace("{primaryNsServer}", encodeURIComponent("" + primaryNsServer));
        if (primaryPerson === undefined || primaryPerson === null)
            throw new Error("The parameter 'primaryPerson' must be defined.");
        url_ = url_.replace("{primaryPerson}", encodeURIComponent("" + primaryPerson));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSoaRecord(_response);
        });
    }

    protected processUpdateSoaRecord(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getZoneRecords(zoneName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/GetZoneRecords/{zoneName}";
        if (zoneName === undefined || zoneName === null)
            throw new Error("The parameter 'zoneName' must be defined.");
        url_ = url_.replace("{zoneName}", encodeURIComponent("" + zoneName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetZoneRecords(_response);
        });
    }

    protected processGetZoneRecords(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addZoneRecord(zoneName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/AddZoneRecord/{zoneName}";
        if (zoneName === undefined || zoneName === null)
            throw new Error("The parameter 'zoneName' must be defined.");
        url_ = url_.replace("{zoneName}", encodeURIComponent("" + zoneName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddZoneRecord(_response);
        });
    }

    protected processAddZoneRecord(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteZoneRecord(zoneName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/DeleteZoneRecord/{zoneName}";
        if (zoneName === undefined || zoneName === null)
            throw new Error("The parameter 'zoneName' must be defined.");
        url_ = url_.replace("{zoneName}", encodeURIComponent("" + zoneName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteZoneRecord(_response);
        });
    }

    protected processDeleteZoneRecord(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addZoneRecords(zoneName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/AddZoneRecords/{zoneName}";
        if (zoneName === undefined || zoneName === null)
            throw new Error("The parameter 'zoneName' must be defined.");
        url_ = url_.replace("{zoneName}", encodeURIComponent("" + zoneName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddZoneRecords(_response);
        });
    }

    protected processAddZoneRecords(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteZoneRecords(zoneName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/DNSServer/DeleteZoneRecords/{zoneName}";
        if (zoneName === undefined || zoneName === null)
            throw new Error("The parameter 'zoneName' must be defined.");
        url_ = url_.replace("{zoneName}", encodeURIComponent("" + zoneName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteZoneRecords(_response);
        });
    }

    protected processDeleteZoneRecords(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class EnterpriseStorageClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getFolders(organizationId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/GetFolders/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFolders(_response);
        });
    }

    protected processGetFolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFoldersWithoutFrsm(organizationId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/GetFoldersWithoutFrsm/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFoldersWithoutFrsm(_response);
        });
    }

    protected processGetFoldersWithoutFrsm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFolder(organizationId: string, folder: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/GetFolder/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFolder(_response);
        });
    }

    protected processGetFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createFolder(organizationId: string, folder: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/CreateFolder/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFolder(_response);
        });
    }

    protected processCreateFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteFolder(organizationId: string, folder: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/DeleteFolder/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFolder(_response);
        });
    }

    protected processDeleteFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setFolderWebDavRules(organizationId: string, folder: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/SetFolderWebDavRules/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetFolderWebDavRules(_response);
        });
    }

    protected processSetFolderWebDavRules(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFolderWebDavRules(organizationId: string, folder: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/GetFolderWebDavRules/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFolderWebDavRules(_response);
        });
    }

    protected processGetFolderWebDavRules(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkFileServicesInstallation(): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/CheckFileServicesInstallation";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckFileServicesInstallation(_response);
        });
    }

    protected processCheckFileServicesInstallation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    search(organizationId: string, searchText: string, userPrincipalName: string, recursive: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/Search/{organizationId}/{searchText}/{userPrincipalName}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (searchText === undefined || searchText === null)
            throw new Error("The parameter 'searchText' must be defined.");
        url_ = url_.replace("{searchText}", encodeURIComponent("" + searchText));
        if (userPrincipalName === undefined || userPrincipalName === null)
            throw new Error("The parameter 'userPrincipalName' must be defined.");
        url_ = url_.replace("{userPrincipalName}", encodeURIComponent("" + userPrincipalName));
        if (recursive === undefined || recursive === null)
            throw new Error("The parameter 'recursive' must be defined and cannot be null.");
        else
            url_ += "recursive=" + encodeURIComponent("" + recursive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    renameFolder(organizationId: string, originalFolder: string, newFolder: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/RenameFolder/{organizationId}/{originalFolder}/{newFolder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (originalFolder === undefined || originalFolder === null)
            throw new Error("The parameter 'originalFolder' must be defined.");
        url_ = url_.replace("{originalFolder}", encodeURIComponent("" + originalFolder));
        if (newFolder === undefined || newFolder === null)
            throw new Error("The parameter 'newFolder' must be defined.");
        url_ = url_.replace("{newFolder}", encodeURIComponent("" + newFolder));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameFolder(_response);
        });
    }

    protected processRenameFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getQuotasForOrganization(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/GetQuotasForOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuotasForOrganization(_response);
        });
    }

    protected processGetQuotasForOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    moveFolder(oldPath: string, newPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/EnterpriseStorage/MoveFolder/{oldPath}/{newPath}";
        if (oldPath === undefined || oldPath === null)
            throw new Error("The parameter 'oldPath' must be defined.");
        url_ = url_.replace("{oldPath}", encodeURIComponent("" + oldPath));
        if (newPath === undefined || newPath === null)
            throw new Error("The parameter 'newPath' must be defined.");
        url_ = url_.replace("{newPath}", encodeURIComponent("" + newPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveFolder(_response);
        });
    }

    protected processMoveFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ExchangeServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    checkAccountCredentials(username: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CheckAccountCredentials/{username}/{password}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckAccountCredentials(_response);
        });
    }

    protected processCheckAccountCredentials(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    extendToExchangeOrganization(organizationId: string, securityGroup: string, isConsumer: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/ExtendToExchangeOrganization/{organizationId}/{securityGroup}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (securityGroup === undefined || securityGroup === null)
            throw new Error("The parameter 'securityGroup' must be defined.");
        url_ = url_.replace("{securityGroup}", encodeURIComponent("" + securityGroup));
        if (isConsumer === undefined || isConsumer === null)
            throw new Error("The parameter 'isConsumer' must be defined and cannot be null.");
        else
            url_ += "IsConsumer=" + encodeURIComponent("" + isConsumer) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExtendToExchangeOrganization(_response);
        });
    }

    protected processExtendToExchangeOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createMailEnableUser(upn: string, organizationId: string, organizationDistinguishedName: string, securityGroup: string, organizationDomain: string, accountType: any, mailboxDatabase: string, offlineAddressBook: string, addressBookPolicy: string, accountName: string, enablePOP: boolean, enableIMAP: boolean, enableOWA: boolean, enableMAPI: boolean, enableActiveSync: boolean, issueWarningKB: number, prohibitSendKB: number, prohibitSendReceiveKB: number, keepDeletedItemsDays: number, maxRecipients: number, maxSendMessageSizeKB: number, maxReceiveMessageSizeKB: number, hideFromAddressBook: boolean, isConsumer: boolean, enabledLitigationHold: boolean, recoverabelItemsSpace: number, recoverabelItemsWarning: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CreateMailEnableUser/{upn}/{organizationId}/{organizationDistinguishedName}/{securityGroup}/{organizationDomain}/{mailboxDatabase}/{offlineAddressBook}/{addressBookPolicy}/{accountName}?";
        if (upn === undefined || upn === null)
            throw new Error("The parameter 'upn' must be defined.");
        url_ = url_.replace("{upn}", encodeURIComponent("" + upn));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (organizationDistinguishedName === undefined || organizationDistinguishedName === null)
            throw new Error("The parameter 'organizationDistinguishedName' must be defined.");
        url_ = url_.replace("{organizationDistinguishedName}", encodeURIComponent("" + organizationDistinguishedName));
        if (securityGroup === undefined || securityGroup === null)
            throw new Error("The parameter 'securityGroup' must be defined.");
        url_ = url_.replace("{securityGroup}", encodeURIComponent("" + securityGroup));
        if (organizationDomain === undefined || organizationDomain === null)
            throw new Error("The parameter 'organizationDomain' must be defined.");
        url_ = url_.replace("{organizationDomain}", encodeURIComponent("" + organizationDomain));
        if (mailboxDatabase === undefined || mailboxDatabase === null)
            throw new Error("The parameter 'mailboxDatabase' must be defined.");
        url_ = url_.replace("{mailboxDatabase}", encodeURIComponent("" + mailboxDatabase));
        if (offlineAddressBook === undefined || offlineAddressBook === null)
            throw new Error("The parameter 'offlineAddressBook' must be defined.");
        url_ = url_.replace("{offlineAddressBook}", encodeURIComponent("" + offlineAddressBook));
        if (addressBookPolicy === undefined || addressBookPolicy === null)
            throw new Error("The parameter 'addressBookPolicy' must be defined.");
        url_ = url_.replace("{addressBookPolicy}", encodeURIComponent("" + addressBookPolicy));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (accountType === undefined || accountType === null)
            throw new Error("The parameter 'accountType' must be defined and cannot be null.");
        else
            url_ += "accountType=" + encodeURIComponent("" + accountType) + "&";
        if (enablePOP === undefined || enablePOP === null)
            throw new Error("The parameter 'enablePOP' must be defined and cannot be null.");
        else
            url_ += "enablePOP=" + encodeURIComponent("" + enablePOP) + "&";
        if (enableIMAP === undefined || enableIMAP === null)
            throw new Error("The parameter 'enableIMAP' must be defined and cannot be null.");
        else
            url_ += "enableIMAP=" + encodeURIComponent("" + enableIMAP) + "&";
        if (enableOWA === undefined || enableOWA === null)
            throw new Error("The parameter 'enableOWA' must be defined and cannot be null.");
        else
            url_ += "enableOWA=" + encodeURIComponent("" + enableOWA) + "&";
        if (enableMAPI === undefined || enableMAPI === null)
            throw new Error("The parameter 'enableMAPI' must be defined and cannot be null.");
        else
            url_ += "enableMAPI=" + encodeURIComponent("" + enableMAPI) + "&";
        if (enableActiveSync === undefined || enableActiveSync === null)
            throw new Error("The parameter 'enableActiveSync' must be defined and cannot be null.");
        else
            url_ += "enableActiveSync=" + encodeURIComponent("" + enableActiveSync) + "&";
        if (issueWarningKB === undefined || issueWarningKB === null)
            throw new Error("The parameter 'issueWarningKB' must be defined and cannot be null.");
        else
            url_ += "issueWarningKB=" + encodeURIComponent("" + issueWarningKB) + "&";
        if (prohibitSendKB === undefined || prohibitSendKB === null)
            throw new Error("The parameter 'prohibitSendKB' must be defined and cannot be null.");
        else
            url_ += "prohibitSendKB=" + encodeURIComponent("" + prohibitSendKB) + "&";
        if (prohibitSendReceiveKB === undefined || prohibitSendReceiveKB === null)
            throw new Error("The parameter 'prohibitSendReceiveKB' must be defined and cannot be null.");
        else
            url_ += "prohibitSendReceiveKB=" + encodeURIComponent("" + prohibitSendReceiveKB) + "&";
        if (keepDeletedItemsDays === undefined || keepDeletedItemsDays === null)
            throw new Error("The parameter 'keepDeletedItemsDays' must be defined and cannot be null.");
        else
            url_ += "keepDeletedItemsDays=" + encodeURIComponent("" + keepDeletedItemsDays) + "&";
        if (maxRecipients === undefined || maxRecipients === null)
            throw new Error("The parameter 'maxRecipients' must be defined and cannot be null.");
        else
            url_ += "maxRecipients=" + encodeURIComponent("" + maxRecipients) + "&";
        if (maxSendMessageSizeKB === undefined || maxSendMessageSizeKB === null)
            throw new Error("The parameter 'maxSendMessageSizeKB' must be defined and cannot be null.");
        else
            url_ += "maxSendMessageSizeKB=" + encodeURIComponent("" + maxSendMessageSizeKB) + "&";
        if (maxReceiveMessageSizeKB === undefined || maxReceiveMessageSizeKB === null)
            throw new Error("The parameter 'maxReceiveMessageSizeKB' must be defined and cannot be null.");
        else
            url_ += "maxReceiveMessageSizeKB=" + encodeURIComponent("" + maxReceiveMessageSizeKB) + "&";
        if (hideFromAddressBook === undefined || hideFromAddressBook === null)
            throw new Error("The parameter 'hideFromAddressBook' must be defined and cannot be null.");
        else
            url_ += "hideFromAddressBook=" + encodeURIComponent("" + hideFromAddressBook) + "&";
        if (isConsumer === undefined || isConsumer === null)
            throw new Error("The parameter 'isConsumer' must be defined and cannot be null.");
        else
            url_ += "isConsumer=" + encodeURIComponent("" + isConsumer) + "&";
        if (enabledLitigationHold === undefined || enabledLitigationHold === null)
            throw new Error("The parameter 'enabledLitigationHold' must be defined and cannot be null.");
        else
            url_ += "enabledLitigationHold=" + encodeURIComponent("" + enabledLitigationHold) + "&";
        if (recoverabelItemsSpace === undefined || recoverabelItemsSpace === null)
            throw new Error("The parameter 'recoverabelItemsSpace' must be defined and cannot be null.");
        else
            url_ += "recoverabelItemsSpace=" + encodeURIComponent("" + recoverabelItemsSpace) + "&";
        if (recoverabelItemsWarning === undefined || recoverabelItemsWarning === null)
            throw new Error("The parameter 'recoverabelItemsWarning' must be defined and cannot be null.");
        else
            url_ += "recoverabelItemsWarning=" + encodeURIComponent("" + recoverabelItemsWarning) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMailEnableUser(_response);
        });
    }

    protected processCreateMailEnableUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createOrganizationOfflineAddressBook(organizationId: string, securityGroup: string, oabVirtualDir: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CreateOrganizationOfflineAddressBook/{organizationId}/{securityGroup}/{oabVirtualDir}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (securityGroup === undefined || securityGroup === null)
            throw new Error("The parameter 'securityGroup' must be defined.");
        url_ = url_.replace("{securityGroup}", encodeURIComponent("" + securityGroup));
        if (oabVirtualDir === undefined || oabVirtualDir === null)
            throw new Error("The parameter 'oabVirtualDir' must be defined.");
        url_ = url_.replace("{oabVirtualDir}", encodeURIComponent("" + oabVirtualDir));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrganizationOfflineAddressBook(_response);
        });
    }

    protected processCreateOrganizationOfflineAddressBook(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateOrganizationOfflineAddressBook(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/UpdateOrganizationOfflineAddressBook/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateOrganizationOfflineAddressBook(_response);
        });
    }

    protected processUpdateOrganizationOfflineAddressBook(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOABVirtualDirectory(): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetOABVirtualDirectory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOABVirtualDirectory(_response);
        });
    }

    protected processGetOABVirtualDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createOrganizationAddressBookPolicy(organizationId: string, gal: string, addressBook: string, roomList: string, oab: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CreateOrganizationAddressBookPolicy/{organizationId}/{gal}/{addressBook}/{roomList}/{oab}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (gal === undefined || gal === null)
            throw new Error("The parameter 'gal' must be defined.");
        url_ = url_.replace("{gal}", encodeURIComponent("" + gal));
        if (addressBook === undefined || addressBook === null)
            throw new Error("The parameter 'addressBook' must be defined.");
        url_ = url_.replace("{addressBook}", encodeURIComponent("" + addressBook));
        if (roomList === undefined || roomList === null)
            throw new Error("The parameter 'roomList' must be defined.");
        url_ = url_.replace("{roomList}", encodeURIComponent("" + roomList));
        if (oab === undefined || oab === null)
            throw new Error("The parameter 'oab' must be defined.");
        url_ = url_.replace("{oab}", encodeURIComponent("" + oab));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrganizationAddressBookPolicy(_response);
        });
    }

    protected processCreateOrganizationAddressBookPolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteOrganization(organizationId: string, distinguishedName: string, globalAddressList: string, addressList: string, roomList: string, offlineAddressBook: string, securityGroup: string, addressBookPolicy: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/DeleteOrganization/{organizationId}/{distinguishedName}/{globalAddressList}/{addressList}/{roomList}/{offlineAddressBook}/{securityGroup}/{addressBookPolicy}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (distinguishedName === undefined || distinguishedName === null)
            throw new Error("The parameter 'distinguishedName' must be defined.");
        url_ = url_.replace("{distinguishedName}", encodeURIComponent("" + distinguishedName));
        if (globalAddressList === undefined || globalAddressList === null)
            throw new Error("The parameter 'globalAddressList' must be defined.");
        url_ = url_.replace("{globalAddressList}", encodeURIComponent("" + globalAddressList));
        if (addressList === undefined || addressList === null)
            throw new Error("The parameter 'addressList' must be defined.");
        url_ = url_.replace("{addressList}", encodeURIComponent("" + addressList));
        if (roomList === undefined || roomList === null)
            throw new Error("The parameter 'roomList' must be defined.");
        url_ = url_.replace("{roomList}", encodeURIComponent("" + roomList));
        if (offlineAddressBook === undefined || offlineAddressBook === null)
            throw new Error("The parameter 'offlineAddressBook' must be defined.");
        url_ = url_.replace("{offlineAddressBook}", encodeURIComponent("" + offlineAddressBook));
        if (securityGroup === undefined || securityGroup === null)
            throw new Error("The parameter 'securityGroup' must be defined.");
        url_ = url_.replace("{securityGroup}", encodeURIComponent("" + securityGroup));
        if (addressBookPolicy === undefined || addressBookPolicy === null)
            throw new Error("The parameter 'addressBookPolicy' must be defined.");
        url_ = url_.replace("{addressBookPolicy}", encodeURIComponent("" + addressBookPolicy));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOrganization(_response);
        });
    }

    protected processDeleteOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setOrganizationStorageLimits(organizationDistinguishedName: string, issueWarningKB: number, prohibitSendKB: number, prohibitSendReceiveKB: number, keepDeletedItemsDays: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetOrganizationStorageLimits/{organizationDistinguishedName}?";
        if (organizationDistinguishedName === undefined || organizationDistinguishedName === null)
            throw new Error("The parameter 'organizationDistinguishedName' must be defined.");
        url_ = url_.replace("{organizationDistinguishedName}", encodeURIComponent("" + organizationDistinguishedName));
        if (issueWarningKB === undefined || issueWarningKB === null)
            throw new Error("The parameter 'issueWarningKB' must be defined and cannot be null.");
        else
            url_ += "issueWarningKB=" + encodeURIComponent("" + issueWarningKB) + "&";
        if (prohibitSendKB === undefined || prohibitSendKB === null)
            throw new Error("The parameter 'prohibitSendKB' must be defined and cannot be null.");
        else
            url_ += "prohibitSendKB=" + encodeURIComponent("" + prohibitSendKB) + "&";
        if (prohibitSendReceiveKB === undefined || prohibitSendReceiveKB === null)
            throw new Error("The parameter 'prohibitSendReceiveKB' must be defined and cannot be null.");
        else
            url_ += "prohibitSendReceiveKB=" + encodeURIComponent("" + prohibitSendReceiveKB) + "&";
        if (keepDeletedItemsDays === undefined || keepDeletedItemsDays === null)
            throw new Error("The parameter 'keepDeletedItemsDays' must be defined and cannot be null.");
        else
            url_ += "keepDeletedItemsDays=" + encodeURIComponent("" + keepDeletedItemsDays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetOrganizationStorageLimits(_response);
        });
    }

    protected processSetOrganizationStorageLimits(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMailboxesStatistics(organizationDistinguishedName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetMailboxesStatistics/{organizationDistinguishedName}";
        if (organizationDistinguishedName === undefined || organizationDistinguishedName === null)
            throw new Error("The parameter 'organizationDistinguishedName' must be defined.");
        url_ = url_.replace("{organizationDistinguishedName}", encodeURIComponent("" + organizationDistinguishedName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMailboxesStatistics(_response);
        });
    }

    protected processGetMailboxesStatistics(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addAuthoritativeDomain(domain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/AddAuthoritativeDomain/{domain}";
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddAuthoritativeDomain(_response);
        });
    }

    protected processAddAuthoritativeDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeAcceptedDomainType(domain: string, domainType: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/ChangeAcceptedDomainType/{domain}?";
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        if (domainType === undefined || domainType === null)
            throw new Error("The parameter 'domainType' must be defined and cannot be null.");
        else
            url_ += "domainType=" + encodeURIComponent("" + domainType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeAcceptedDomainType(_response);
        });
    }

    protected processChangeAcceptedDomainType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAuthoritativeDomains(): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetAuthoritativeDomains";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAuthoritativeDomains(_response);
        });
    }

    protected processGetAuthoritativeDomains(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteAuthoritativeDomain(domain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/DeleteAuthoritativeDomain/{domain}";
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAuthoritativeDomain(_response);
        });
    }

    protected processDeleteAuthoritativeDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteMailbox(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/DeleteMailbox/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMailbox(_response);
        });
    }

    protected processDeleteMailbox(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    disableMailbox(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/DisableMailbox/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDisableMailbox(_response);
        });
    }

    protected processDisableMailbox(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMailboxAutoReplySettings(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetMailboxAutoReplySettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMailboxAutoReplySettings(_response);
        });
    }

    protected processGetMailboxAutoReplySettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setMailboxAutoReplySettings(accountName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetMailboxAutoReplySettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetMailboxAutoReplySettings(_response);
        });
    }

    protected processSetMailboxAutoReplySettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMailboxGeneralSettings(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetMailboxGeneralSettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMailboxGeneralSettings(_response);
        });
    }

    protected processGetMailboxGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setMailboxGeneralSettings(accountName: string, hideFromAddressBook: boolean, disabled: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetMailboxGeneralSettings/{accountName}?";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (hideFromAddressBook === undefined || hideFromAddressBook === null)
            throw new Error("The parameter 'hideFromAddressBook' must be defined and cannot be null.");
        else
            url_ += "hideFromAddressBook=" + encodeURIComponent("" + hideFromAddressBook) + "&";
        if (disabled === undefined || disabled === null)
            throw new Error("The parameter 'disabled' must be defined and cannot be null.");
        else
            url_ += "disabled=" + encodeURIComponent("" + disabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetMailboxGeneralSettings(_response);
        });
    }

    protected processSetMailboxGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getResourceMailboxSettings(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetResourceMailboxSettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetResourceMailboxSettings(_response);
        });
    }

    protected processGetResourceMailboxSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setResourceMailboxSettings(accountName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetResourceMailboxSettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetResourceMailboxSettings(_response);
        });
    }

    protected processSetResourceMailboxSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMailboxMailFlowSettings(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetMailboxMailFlowSettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMailboxMailFlowSettings(_response);
        });
    }

    protected processGetMailboxMailFlowSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setMailboxMailFlowSettings(accountName: string, enableForwarding: boolean, saveSentItems: number, forwardingAccountName: string, forwardToBoth: boolean, requireSenderAuthentication: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetMailboxMailFlowSettings/{accountName}/{forwardingAccountName}?";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (forwardingAccountName === undefined || forwardingAccountName === null)
            throw new Error("The parameter 'forwardingAccountName' must be defined.");
        url_ = url_.replace("{forwardingAccountName}", encodeURIComponent("" + forwardingAccountName));
        if (enableForwarding === undefined || enableForwarding === null)
            throw new Error("The parameter 'enableForwarding' must be defined and cannot be null.");
        else
            url_ += "enableForwarding=" + encodeURIComponent("" + enableForwarding) + "&";
        if (saveSentItems === undefined || saveSentItems === null)
            throw new Error("The parameter 'saveSentItems' must be defined and cannot be null.");
        else
            url_ += "saveSentItems=" + encodeURIComponent("" + saveSentItems) + "&";
        if (forwardToBoth === undefined || forwardToBoth === null)
            throw new Error("The parameter 'forwardToBoth' must be defined and cannot be null.");
        else
            url_ += "forwardToBoth=" + encodeURIComponent("" + forwardToBoth) + "&";
        if (requireSenderAuthentication === undefined || requireSenderAuthentication === null)
            throw new Error("The parameter 'requireSenderAuthentication' must be defined and cannot be null.");
        else
            url_ += "requireSenderAuthentication=" + encodeURIComponent("" + requireSenderAuthentication) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetMailboxMailFlowSettings(_response);
        });
    }

    protected processSetMailboxMailFlowSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMailboxAdvancedSettings(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetMailboxAdvancedSettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMailboxAdvancedSettings(_response);
        });
    }

    protected processGetMailboxAdvancedSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setMailboxAdvancedSettings(organizationId: string, accountName: string, enablePOP: boolean, enableIMAP: boolean, enableOWA: boolean, enableMAPI: boolean, enableActiveSync: boolean, issueWarningKB: number, prohibitSendKB: number, prohibitSendReceiveKB: number, keepDeletedItemsDays: number, maxRecipients: number, maxSendMessageSizeKB: number, maxReceiveMessageSizeKB: number, enabledLitigationHold: boolean, recoverabelItemsSpace: number, recoverabelItemsWarning: number, litigationHoldUrl: string, litigationHoldMsg: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetMailboxAdvancedSettings/{organizationId}/{accountName}/{litigationHoldUrl}/{litigationHoldMsg}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (litigationHoldUrl === undefined || litigationHoldUrl === null)
            throw new Error("The parameter 'litigationHoldUrl' must be defined.");
        url_ = url_.replace("{litigationHoldUrl}", encodeURIComponent("" + litigationHoldUrl));
        if (litigationHoldMsg === undefined || litigationHoldMsg === null)
            throw new Error("The parameter 'litigationHoldMsg' must be defined.");
        url_ = url_.replace("{litigationHoldMsg}", encodeURIComponent("" + litigationHoldMsg));
        if (enablePOP === undefined || enablePOP === null)
            throw new Error("The parameter 'enablePOP' must be defined and cannot be null.");
        else
            url_ += "enablePOP=" + encodeURIComponent("" + enablePOP) + "&";
        if (enableIMAP === undefined || enableIMAP === null)
            throw new Error("The parameter 'enableIMAP' must be defined and cannot be null.");
        else
            url_ += "enableIMAP=" + encodeURIComponent("" + enableIMAP) + "&";
        if (enableOWA === undefined || enableOWA === null)
            throw new Error("The parameter 'enableOWA' must be defined and cannot be null.");
        else
            url_ += "enableOWA=" + encodeURIComponent("" + enableOWA) + "&";
        if (enableMAPI === undefined || enableMAPI === null)
            throw new Error("The parameter 'enableMAPI' must be defined and cannot be null.");
        else
            url_ += "enableMAPI=" + encodeURIComponent("" + enableMAPI) + "&";
        if (enableActiveSync === undefined || enableActiveSync === null)
            throw new Error("The parameter 'enableActiveSync' must be defined and cannot be null.");
        else
            url_ += "enableActiveSync=" + encodeURIComponent("" + enableActiveSync) + "&";
        if (issueWarningKB === undefined || issueWarningKB === null)
            throw new Error("The parameter 'issueWarningKB' must be defined and cannot be null.");
        else
            url_ += "issueWarningKB=" + encodeURIComponent("" + issueWarningKB) + "&";
        if (prohibitSendKB === undefined || prohibitSendKB === null)
            throw new Error("The parameter 'prohibitSendKB' must be defined and cannot be null.");
        else
            url_ += "prohibitSendKB=" + encodeURIComponent("" + prohibitSendKB) + "&";
        if (prohibitSendReceiveKB === undefined || prohibitSendReceiveKB === null)
            throw new Error("The parameter 'prohibitSendReceiveKB' must be defined and cannot be null.");
        else
            url_ += "prohibitSendReceiveKB=" + encodeURIComponent("" + prohibitSendReceiveKB) + "&";
        if (keepDeletedItemsDays === undefined || keepDeletedItemsDays === null)
            throw new Error("The parameter 'keepDeletedItemsDays' must be defined and cannot be null.");
        else
            url_ += "keepDeletedItemsDays=" + encodeURIComponent("" + keepDeletedItemsDays) + "&";
        if (maxRecipients === undefined || maxRecipients === null)
            throw new Error("The parameter 'maxRecipients' must be defined and cannot be null.");
        else
            url_ += "maxRecipients=" + encodeURIComponent("" + maxRecipients) + "&";
        if (maxSendMessageSizeKB === undefined || maxSendMessageSizeKB === null)
            throw new Error("The parameter 'maxSendMessageSizeKB' must be defined and cannot be null.");
        else
            url_ += "maxSendMessageSizeKB=" + encodeURIComponent("" + maxSendMessageSizeKB) + "&";
        if (maxReceiveMessageSizeKB === undefined || maxReceiveMessageSizeKB === null)
            throw new Error("The parameter 'maxReceiveMessageSizeKB' must be defined and cannot be null.");
        else
            url_ += "maxReceiveMessageSizeKB=" + encodeURIComponent("" + maxReceiveMessageSizeKB) + "&";
        if (enabledLitigationHold === undefined || enabledLitigationHold === null)
            throw new Error("The parameter 'enabledLitigationHold' must be defined and cannot be null.");
        else
            url_ += "enabledLitigationHold=" + encodeURIComponent("" + enabledLitigationHold) + "&";
        if (recoverabelItemsSpace === undefined || recoverabelItemsSpace === null)
            throw new Error("The parameter 'recoverabelItemsSpace' must be defined and cannot be null.");
        else
            url_ += "recoverabelItemsSpace=" + encodeURIComponent("" + recoverabelItemsSpace) + "&";
        if (recoverabelItemsWarning === undefined || recoverabelItemsWarning === null)
            throw new Error("The parameter 'recoverabelItemsWarning' must be defined and cannot be null.");
        else
            url_ += "recoverabelItemsWarning=" + encodeURIComponent("" + recoverabelItemsWarning) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetMailboxAdvancedSettings(_response);
        });
    }

    protected processSetMailboxAdvancedSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMailboxEmailAddresses(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetMailboxEmailAddresses/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMailboxEmailAddresses(_response);
        });
    }

    protected processGetMailboxEmailAddresses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setMailboxEmailAddresses(accountName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetMailboxEmailAddresses/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetMailboxEmailAddresses(_response);
        });
    }

    protected processSetMailboxEmailAddresses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setMailboxPrimaryEmailAddress(accountName: string, emailAddress: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetMailboxPrimaryEmailAddress/{accountName}/{emailAddress}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (emailAddress === undefined || emailAddress === null)
            throw new Error("The parameter 'emailAddress' must be defined.");
        url_ = url_.replace("{emailAddress}", encodeURIComponent("" + emailAddress));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetMailboxPrimaryEmailAddress(_response);
        });
    }

    protected processSetMailboxPrimaryEmailAddress(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setMailboxPermissions(organizationId: string, accountName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetMailboxPermissions/{organizationId}/{accountName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetMailboxPermissions(_response);
        });
    }

    protected processSetMailboxPermissions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMailboxPermissions(organizationId: string, accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetMailboxPermissions/{organizationId}/{accountName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMailboxPermissions(_response);
        });
    }

    protected processGetMailboxPermissions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMailboxStatistics(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetMailboxStatistics/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMailboxStatistics(_response);
        });
    }

    protected processGetMailboxStatistics(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDefaultPublicFolderMailbox(id: string, organizationId: string, organizationDistinguishedName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetDefaultPublicFolderMailbox/{id}/{organizationId}/{organizationDistinguishedName}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (organizationDistinguishedName === undefined || organizationDistinguishedName === null)
            throw new Error("The parameter 'organizationDistinguishedName' must be defined.");
        url_ = url_.replace("{organizationDistinguishedName}", encodeURIComponent("" + organizationDistinguishedName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDefaultPublicFolderMailbox(_response);
        });
    }

    protected processSetDefaultPublicFolderMailbox(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createJournalRule(journalEmail: string, scope: string, recipientEmail: string, enabled: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CreateJournalRule/{journalEmail}/{scope}/{recipientEmail}?";
        if (journalEmail === undefined || journalEmail === null)
            throw new Error("The parameter 'journalEmail' must be defined.");
        url_ = url_.replace("{journalEmail}", encodeURIComponent("" + journalEmail));
        if (scope === undefined || scope === null)
            throw new Error("The parameter 'scope' must be defined.");
        url_ = url_.replace("{scope}", encodeURIComponent("" + scope));
        if (recipientEmail === undefined || recipientEmail === null)
            throw new Error("The parameter 'recipientEmail' must be defined.");
        url_ = url_.replace("{recipientEmail}", encodeURIComponent("" + recipientEmail));
        if (enabled === undefined || enabled === null)
            throw new Error("The parameter 'enabled' must be defined and cannot be null.");
        else
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateJournalRule(_response);
        });
    }

    protected processCreateJournalRule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getJournalRule(journalEmail: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetJournalRule/{journalEmail}";
        if (journalEmail === undefined || journalEmail === null)
            throw new Error("The parameter 'journalEmail' must be defined.");
        url_ = url_.replace("{journalEmail}", encodeURIComponent("" + journalEmail));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJournalRule(_response);
        });
    }

    protected processGetJournalRule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setJournalRule(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetJournalRule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetJournalRule(_response);
        });
    }

    protected processSetJournalRule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeJournalRule(journalEmail: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/RemoveJournalRule/{journalEmail}";
        if (journalEmail === undefined || journalEmail === null)
            throw new Error("The parameter 'journalEmail' must be defined.");
        url_ = url_.replace("{journalEmail}", encodeURIComponent("" + journalEmail));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveJournalRule(_response);
        });
    }

    protected processRemoveJournalRule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createContact(organizationId: string, organizationDistinguishedName: string, contactDisplayName: string, contactAccountName: string, contactEmail: string, defaultOrganizationDomain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CreateContact/{organizationId}/{organizationDistinguishedName}/{contactDisplayName}/{contactAccountName}/{contactEmail}/{defaultOrganizationDomain}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (organizationDistinguishedName === undefined || organizationDistinguishedName === null)
            throw new Error("The parameter 'organizationDistinguishedName' must be defined.");
        url_ = url_.replace("{organizationDistinguishedName}", encodeURIComponent("" + organizationDistinguishedName));
        if (contactDisplayName === undefined || contactDisplayName === null)
            throw new Error("The parameter 'contactDisplayName' must be defined.");
        url_ = url_.replace("{contactDisplayName}", encodeURIComponent("" + contactDisplayName));
        if (contactAccountName === undefined || contactAccountName === null)
            throw new Error("The parameter 'contactAccountName' must be defined.");
        url_ = url_.replace("{contactAccountName}", encodeURIComponent("" + contactAccountName));
        if (contactEmail === undefined || contactEmail === null)
            throw new Error("The parameter 'contactEmail' must be defined.");
        url_ = url_.replace("{contactEmail}", encodeURIComponent("" + contactEmail));
        if (defaultOrganizationDomain === undefined || defaultOrganizationDomain === null)
            throw new Error("The parameter 'defaultOrganizationDomain' must be defined.");
        url_ = url_.replace("{defaultOrganizationDomain}", encodeURIComponent("" + defaultOrganizationDomain));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContact(_response);
        });
    }

    protected processCreateContact(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteContact(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/DeleteContact/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContact(_response);
        });
    }

    protected processDeleteContact(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getContactGeneralSettings(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetContactGeneralSettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactGeneralSettings(_response);
        });
    }

    protected processGetContactGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setContactGeneralSettings(accountName: string, displayName: string, email: string, hideFromAddressBook: boolean, firstName: string, initials: string, lastName: string, address: string, city: string, state: string, zip: string, country: string, jobTitle: string, company: string, department: string, office: string, managerAccountName: string, businessPhone: string, fax: string, homePhone: string, mobilePhone: string, pager: string, webPage: string, notes: string, useMapiRichTextFormat: number, defaultDomain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetContactGeneralSettings/{accountName}/{displayName}/{email}/{firstName}/{initials}/{lastName}/{address}/{city}/{state}/{zip}/{country}/{jobTitle}/{company}/{department}/{office}/{managerAccountName}/{businessPhone}/{fax}/{homePhone}/{mobilePhone}/{pager}/{webPage}/{notes}/{defaultDomain}?";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        if (firstName === undefined || firstName === null)
            throw new Error("The parameter 'firstName' must be defined.");
        url_ = url_.replace("{firstName}", encodeURIComponent("" + firstName));
        if (initials === undefined || initials === null)
            throw new Error("The parameter 'initials' must be defined.");
        url_ = url_.replace("{initials}", encodeURIComponent("" + initials));
        if (lastName === undefined || lastName === null)
            throw new Error("The parameter 'lastName' must be defined.");
        url_ = url_.replace("{lastName}", encodeURIComponent("" + lastName));
        if (address === undefined || address === null)
            throw new Error("The parameter 'address' must be defined.");
        url_ = url_.replace("{address}", encodeURIComponent("" + address));
        if (city === undefined || city === null)
            throw new Error("The parameter 'city' must be defined.");
        url_ = url_.replace("{city}", encodeURIComponent("" + city));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined.");
        url_ = url_.replace("{state}", encodeURIComponent("" + state));
        if (zip === undefined || zip === null)
            throw new Error("The parameter 'zip' must be defined.");
        url_ = url_.replace("{zip}", encodeURIComponent("" + zip));
        if (country === undefined || country === null)
            throw new Error("The parameter 'country' must be defined.");
        url_ = url_.replace("{country}", encodeURIComponent("" + country));
        if (jobTitle === undefined || jobTitle === null)
            throw new Error("The parameter 'jobTitle' must be defined.");
        url_ = url_.replace("{jobTitle}", encodeURIComponent("" + jobTitle));
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company));
        if (department === undefined || department === null)
            throw new Error("The parameter 'department' must be defined.");
        url_ = url_.replace("{department}", encodeURIComponent("" + department));
        if (office === undefined || office === null)
            throw new Error("The parameter 'office' must be defined.");
        url_ = url_.replace("{office}", encodeURIComponent("" + office));
        if (managerAccountName === undefined || managerAccountName === null)
            throw new Error("The parameter 'managerAccountName' must be defined.");
        url_ = url_.replace("{managerAccountName}", encodeURIComponent("" + managerAccountName));
        if (businessPhone === undefined || businessPhone === null)
            throw new Error("The parameter 'businessPhone' must be defined.");
        url_ = url_.replace("{businessPhone}", encodeURIComponent("" + businessPhone));
        if (fax === undefined || fax === null)
            throw new Error("The parameter 'fax' must be defined.");
        url_ = url_.replace("{fax}", encodeURIComponent("" + fax));
        if (homePhone === undefined || homePhone === null)
            throw new Error("The parameter 'homePhone' must be defined.");
        url_ = url_.replace("{homePhone}", encodeURIComponent("" + homePhone));
        if (mobilePhone === undefined || mobilePhone === null)
            throw new Error("The parameter 'mobilePhone' must be defined.");
        url_ = url_.replace("{mobilePhone}", encodeURIComponent("" + mobilePhone));
        if (pager === undefined || pager === null)
            throw new Error("The parameter 'pager' must be defined.");
        url_ = url_.replace("{pager}", encodeURIComponent("" + pager));
        if (webPage === undefined || webPage === null)
            throw new Error("The parameter 'webPage' must be defined.");
        url_ = url_.replace("{webPage}", encodeURIComponent("" + webPage));
        if (notes === undefined || notes === null)
            throw new Error("The parameter 'notes' must be defined.");
        url_ = url_.replace("{notes}", encodeURIComponent("" + notes));
        if (defaultDomain === undefined || defaultDomain === null)
            throw new Error("The parameter 'defaultDomain' must be defined.");
        url_ = url_.replace("{defaultDomain}", encodeURIComponent("" + defaultDomain));
        if (hideFromAddressBook === undefined || hideFromAddressBook === null)
            throw new Error("The parameter 'hideFromAddressBook' must be defined and cannot be null.");
        else
            url_ += "hideFromAddressBook=" + encodeURIComponent("" + hideFromAddressBook) + "&";
        if (useMapiRichTextFormat === undefined || useMapiRichTextFormat === null)
            throw new Error("The parameter 'useMapiRichTextFormat' must be defined and cannot be null.");
        else
            url_ += "useMapiRichTextFormat=" + encodeURIComponent("" + useMapiRichTextFormat) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetContactGeneralSettings(_response);
        });
    }

    protected processSetContactGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getContactMailFlowSettings(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetContactMailFlowSettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactMailFlowSettings(_response);
        });
    }

    protected processGetContactMailFlowSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setContactMailFlowSettings(accountName: string, requireSenderAuthentication: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetContactMailFlowSettings/{accountName}?";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (requireSenderAuthentication === undefined || requireSenderAuthentication === null)
            throw new Error("The parameter 'requireSenderAuthentication' must be defined and cannot be null.");
        else
            url_ += "requireSenderAuthentication=" + encodeURIComponent("" + requireSenderAuthentication) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetContactMailFlowSettings(_response);
        });
    }

    protected processSetContactMailFlowSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createDistributionList(organizationId: string, organizationDistinguishedName: string, displayName: string, accountName: string, name: string, domain: string, managedBy: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CreateDistributionList/{organizationId}/{organizationDistinguishedName}/{displayName}/{accountName}/{name}/{domain}/{managedBy}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (organizationDistinguishedName === undefined || organizationDistinguishedName === null)
            throw new Error("The parameter 'organizationDistinguishedName' must be defined.");
        url_ = url_.replace("{organizationDistinguishedName}", encodeURIComponent("" + organizationDistinguishedName));
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        if (managedBy === undefined || managedBy === null)
            throw new Error("The parameter 'managedBy' must be defined.");
        url_ = url_.replace("{managedBy}", encodeURIComponent("" + managedBy));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDistributionList(_response);
        });
    }

    protected processCreateDistributionList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteDistributionList(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/DeleteDistributionList/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDistributionList(_response);
        });
    }

    protected processDeleteDistributionList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDistributionListGeneralSettings(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetDistributionListGeneralSettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDistributionListGeneralSettings(_response);
        });
    }

    protected processGetDistributionListGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDistributionListGeneralSettings(accountName: string, displayName: string, hideFromAddressBook: boolean, managedBy: string, notes: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetDistributionListGeneralSettings/{accountName}/{displayName}/{managedBy}/{notes}?";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (managedBy === undefined || managedBy === null)
            throw new Error("The parameter 'managedBy' must be defined.");
        url_ = url_.replace("{managedBy}", encodeURIComponent("" + managedBy));
        if (notes === undefined || notes === null)
            throw new Error("The parameter 'notes' must be defined.");
        url_ = url_.replace("{notes}", encodeURIComponent("" + notes));
        if (hideFromAddressBook === undefined || hideFromAddressBook === null)
            throw new Error("The parameter 'hideFromAddressBook' must be defined and cannot be null.");
        else
            url_ += "hideFromAddressBook=" + encodeURIComponent("" + hideFromAddressBook) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDistributionListGeneralSettings(_response);
        });
    }

    protected processSetDistributionListGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDistributionListMailFlowSettings(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetDistributionListMailFlowSettings/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDistributionListMailFlowSettings(_response);
        });
    }

    protected processGetDistributionListMailFlowSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDistributionListMailFlowSettings(accountName: string, requireSenderAuthentication: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetDistributionListMailFlowSettings/{accountName}?";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (requireSenderAuthentication === undefined || requireSenderAuthentication === null)
            throw new Error("The parameter 'requireSenderAuthentication' must be defined and cannot be null.");
        else
            url_ += "requireSenderAuthentication=" + encodeURIComponent("" + requireSenderAuthentication) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDistributionListMailFlowSettings(_response);
        });
    }

    protected processSetDistributionListMailFlowSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDistributionListEmailAddresses(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetDistributionListEmailAddresses/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDistributionListEmailAddresses(_response);
        });
    }

    protected processGetDistributionListEmailAddresses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDistributionListEmailAddresses(accountName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetDistributionListEmailAddresses/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDistributionListEmailAddresses(_response);
        });
    }

    protected processSetDistributionListEmailAddresses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDistributionListPrimaryEmailAddress(accountName: string, emailAddress: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetDistributionListPrimaryEmailAddress/{accountName}/{emailAddress}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (emailAddress === undefined || emailAddress === null)
            throw new Error("The parameter 'emailAddress' must be defined.");
        url_ = url_.replace("{emailAddress}", encodeURIComponent("" + emailAddress));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDistributionListPrimaryEmailAddress(_response);
        });
    }

    protected processSetDistributionListPrimaryEmailAddress(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDistributionListPermissions(organizationId: string, accountName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetDistributionListPermissions/{organizationId}/{accountName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDistributionListPermissions(_response);
        });
    }

    protected processSetDistributionListPermissions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDistributionListPermissions(organizationId: string, accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetDistributionListPermissions/{organizationId}/{accountName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDistributionListPermissions(_response);
        });
    }

    protected processGetDistributionListPermissions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDisclaimer(name: string, text: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetDisclaimer/{name}/{text}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (text === undefined || text === null)
            throw new Error("The parameter 'text' must be defined.");
        url_ = url_.replace("{text}", encodeURIComponent("" + text));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDisclaimer(_response);
        });
    }

    protected processSetDisclaimer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeDisclaimer(name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/RemoveDisclaimer/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveDisclaimer(_response);
        });
    }

    protected processRemoveDisclaimer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addDisclamerMember(name: string, member: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/AddDisclamerMember/{name}/{member}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (member === undefined || member === null)
            throw new Error("The parameter 'member' must be defined.");
        url_ = url_.replace("{member}", encodeURIComponent("" + member));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddDisclamerMember(_response);
        });
    }

    protected processAddDisclamerMember(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeDisclamerMember(name: string, member: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/RemoveDisclamerMember/{name}/{member}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (member === undefined || member === null)
            throw new Error("The parameter 'member' must be defined.");
        url_ = url_.replace("{member}", encodeURIComponent("" + member));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveDisclamerMember(_response);
        });
    }

    protected processRemoveDisclamerMember(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createPublicFolder(organizationDistinguishedName: string, organizationId: string, securityGroup: string, parentFolder: string, folderName: string, mailEnabled: boolean, accountName: string, name: string, domain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CreatePublicFolder/{organizationDistinguishedName}/{organizationId}/{securityGroup}/{parentFolder}/{folderName}/{accountName}/{name}/{domain}?";
        if (organizationDistinguishedName === undefined || organizationDistinguishedName === null)
            throw new Error("The parameter 'organizationDistinguishedName' must be defined.");
        url_ = url_.replace("{organizationDistinguishedName}", encodeURIComponent("" + organizationDistinguishedName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (securityGroup === undefined || securityGroup === null)
            throw new Error("The parameter 'securityGroup' must be defined.");
        url_ = url_.replace("{securityGroup}", encodeURIComponent("" + securityGroup));
        if (parentFolder === undefined || parentFolder === null)
            throw new Error("The parameter 'parentFolder' must be defined.");
        url_ = url_.replace("{parentFolder}", encodeURIComponent("" + parentFolder));
        if (folderName === undefined || folderName === null)
            throw new Error("The parameter 'folderName' must be defined.");
        url_ = url_.replace("{folderName}", encodeURIComponent("" + folderName));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        if (mailEnabled === undefined || mailEnabled === null)
            throw new Error("The parameter 'mailEnabled' must be defined and cannot be null.");
        else
            url_ += "mailEnabled=" + encodeURIComponent("" + mailEnabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePublicFolder(_response);
        });
    }

    protected processCreatePublicFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deletePublicFolder(organizationId: string, folder: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/DeletePublicFolder/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePublicFolder(_response);
        });
    }

    protected processDeletePublicFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enableMailPublicFolder(organizationId: string, folder: string, accountName: string, name: string, domain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/EnableMailPublicFolder/{organizationId}/{folder}/{accountName}/{name}/{domain}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnableMailPublicFolder(_response);
        });
    }

    protected processEnableMailPublicFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    disableMailPublicFolder(organizationId: string, folder: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/DisableMailPublicFolder/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDisableMailPublicFolder(_response);
        });
    }

    protected processDisableMailPublicFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPublicFolderGeneralSettings(organizationId: string, folder: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetPublicFolderGeneralSettings/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicFolderGeneralSettings(_response);
        });
    }

    protected processGetPublicFolderGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setPublicFolderGeneralSettings(organizationId: string, folder: string, newFolderName: string, hideFromAddressBook: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetPublicFolderGeneralSettings/{organizationId}/{folder}/{newFolderName}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        if (newFolderName === undefined || newFolderName === null)
            throw new Error("The parameter 'newFolderName' must be defined.");
        url_ = url_.replace("{newFolderName}", encodeURIComponent("" + newFolderName));
        if (hideFromAddressBook === undefined || hideFromAddressBook === null)
            throw new Error("The parameter 'hideFromAddressBook' must be defined and cannot be null.");
        else
            url_ += "hideFromAddressBook=" + encodeURIComponent("" + hideFromAddressBook) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPublicFolderGeneralSettings(_response);
        });
    }

    protected processSetPublicFolderGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPublicFolderMailFlowSettings(organizationId: string, folder: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetPublicFolderMailFlowSettings/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicFolderMailFlowSettings(_response);
        });
    }

    protected processGetPublicFolderMailFlowSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setPublicFolderMailFlowSettings(organizationId: string, folder: string, requireSenderAuthentication: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetPublicFolderMailFlowSettings/{organizationId}/{folder}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        if (requireSenderAuthentication === undefined || requireSenderAuthentication === null)
            throw new Error("The parameter 'requireSenderAuthentication' must be defined and cannot be null.");
        else
            url_ += "requireSenderAuthentication=" + encodeURIComponent("" + requireSenderAuthentication) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPublicFolderMailFlowSettings(_response);
        });
    }

    protected processSetPublicFolderMailFlowSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPublicFolderEmailAddresses(organizationId: string, folder: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetPublicFolderEmailAddresses/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicFolderEmailAddresses(_response);
        });
    }

    protected processGetPublicFolderEmailAddresses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setPublicFolderEmailAddresses(organizationId: string, folder: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetPublicFolderEmailAddresses/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPublicFolderEmailAddresses(_response);
        });
    }

    protected processSetPublicFolderEmailAddresses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setPublicFolderPrimaryEmailAddress(organizationId: string, folder: string, emailAddress: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetPublicFolderPrimaryEmailAddress/{organizationId}/{folder}/{emailAddress}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        if (emailAddress === undefined || emailAddress === null)
            throw new Error("The parameter 'emailAddress' must be defined.");
        url_ = url_.replace("{emailAddress}", encodeURIComponent("" + emailAddress));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPublicFolderPrimaryEmailAddress(_response);
        });
    }

    protected processSetPublicFolderPrimaryEmailAddress(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPublicFoldersStatistics(organizationId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetPublicFoldersStatistics/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicFoldersStatistics(_response);
        });
    }

    protected processGetPublicFoldersStatistics(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPublicFoldersRecursive(organizationId: string, parent: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetPublicFoldersRecursive/{organizationId}/{parent}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (parent === undefined || parent === null)
            throw new Error("The parameter 'parent' must be defined.");
        url_ = url_.replace("{parent}", encodeURIComponent("" + parent));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicFoldersRecursive(_response);
        });
    }

    protected processGetPublicFoldersRecursive(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPublicFolderSize(organizationId: string, folder: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetPublicFolderSize/{organizationId}/{folder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicFolderSize(_response);
        });
    }

    protected processGetPublicFolderSize(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createOrganizationRootPublicFolder(organizationId: string, organizationDistinguishedName: string, securityGroup: string, organizationDomain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CreateOrganizationRootPublicFolder/{organizationId}/{organizationDistinguishedName}/{securityGroup}/{organizationDomain}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (organizationDistinguishedName === undefined || organizationDistinguishedName === null)
            throw new Error("The parameter 'organizationDistinguishedName' must be defined.");
        url_ = url_.replace("{organizationDistinguishedName}", encodeURIComponent("" + organizationDistinguishedName));
        if (securityGroup === undefined || securityGroup === null)
            throw new Error("The parameter 'securityGroup' must be defined.");
        url_ = url_.replace("{securityGroup}", encodeURIComponent("" + securityGroup));
        if (organizationDomain === undefined || organizationDomain === null)
            throw new Error("The parameter 'organizationDomain' must be defined.");
        url_ = url_.replace("{organizationDomain}", encodeURIComponent("" + organizationDomain));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrganizationRootPublicFolder(_response);
        });
    }

    protected processCreateOrganizationRootPublicFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createOrganizationActiveSyncPolicy(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CreateOrganizationActiveSyncPolicy/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrganizationActiveSyncPolicy(_response);
        });
    }

    protected processCreateOrganizationActiveSyncPolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getActiveSyncPolicy(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetActiveSyncPolicy/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActiveSyncPolicy(_response);
        });
    }

    protected processGetActiveSyncPolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setActiveSyncPolicy(id: string, allowNonProvisionableDevices: boolean, attachmentsEnabled: boolean, maxAttachmentSizeKB: number, uncAccessEnabled: boolean, wssAccessEnabled: boolean, devicePasswordEnabled: boolean, alphanumericPasswordRequired: boolean, passwordRecoveryEnabled: boolean, deviceEncryptionEnabled: boolean, allowSimplePassword: boolean, maxPasswordFailedAttempts: number, minPasswordLength: number, inactivityLockMin: number, passwordExpirationDays: number, passwordHistory: number, refreshInterval: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetActiveSyncPolicy/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (allowNonProvisionableDevices === undefined || allowNonProvisionableDevices === null)
            throw new Error("The parameter 'allowNonProvisionableDevices' must be defined and cannot be null.");
        else
            url_ += "allowNonProvisionableDevices=" + encodeURIComponent("" + allowNonProvisionableDevices) + "&";
        if (attachmentsEnabled === undefined || attachmentsEnabled === null)
            throw new Error("The parameter 'attachmentsEnabled' must be defined and cannot be null.");
        else
            url_ += "attachmentsEnabled=" + encodeURIComponent("" + attachmentsEnabled) + "&";
        if (maxAttachmentSizeKB === undefined || maxAttachmentSizeKB === null)
            throw new Error("The parameter 'maxAttachmentSizeKB' must be defined and cannot be null.");
        else
            url_ += "maxAttachmentSizeKB=" + encodeURIComponent("" + maxAttachmentSizeKB) + "&";
        if (uncAccessEnabled === undefined || uncAccessEnabled === null)
            throw new Error("The parameter 'uncAccessEnabled' must be defined and cannot be null.");
        else
            url_ += "uncAccessEnabled=" + encodeURIComponent("" + uncAccessEnabled) + "&";
        if (wssAccessEnabled === undefined || wssAccessEnabled === null)
            throw new Error("The parameter 'wssAccessEnabled' must be defined and cannot be null.");
        else
            url_ += "wssAccessEnabled=" + encodeURIComponent("" + wssAccessEnabled) + "&";
        if (devicePasswordEnabled === undefined || devicePasswordEnabled === null)
            throw new Error("The parameter 'devicePasswordEnabled' must be defined and cannot be null.");
        else
            url_ += "devicePasswordEnabled=" + encodeURIComponent("" + devicePasswordEnabled) + "&";
        if (alphanumericPasswordRequired === undefined || alphanumericPasswordRequired === null)
            throw new Error("The parameter 'alphanumericPasswordRequired' must be defined and cannot be null.");
        else
            url_ += "alphanumericPasswordRequired=" + encodeURIComponent("" + alphanumericPasswordRequired) + "&";
        if (passwordRecoveryEnabled === undefined || passwordRecoveryEnabled === null)
            throw new Error("The parameter 'passwordRecoveryEnabled' must be defined and cannot be null.");
        else
            url_ += "passwordRecoveryEnabled=" + encodeURIComponent("" + passwordRecoveryEnabled) + "&";
        if (deviceEncryptionEnabled === undefined || deviceEncryptionEnabled === null)
            throw new Error("The parameter 'deviceEncryptionEnabled' must be defined and cannot be null.");
        else
            url_ += "deviceEncryptionEnabled=" + encodeURIComponent("" + deviceEncryptionEnabled) + "&";
        if (allowSimplePassword === undefined || allowSimplePassword === null)
            throw new Error("The parameter 'allowSimplePassword' must be defined and cannot be null.");
        else
            url_ += "allowSimplePassword=" + encodeURIComponent("" + allowSimplePassword) + "&";
        if (maxPasswordFailedAttempts === undefined || maxPasswordFailedAttempts === null)
            throw new Error("The parameter 'maxPasswordFailedAttempts' must be defined and cannot be null.");
        else
            url_ += "maxPasswordFailedAttempts=" + encodeURIComponent("" + maxPasswordFailedAttempts) + "&";
        if (minPasswordLength === undefined || minPasswordLength === null)
            throw new Error("The parameter 'minPasswordLength' must be defined and cannot be null.");
        else
            url_ += "minPasswordLength=" + encodeURIComponent("" + minPasswordLength) + "&";
        if (inactivityLockMin === undefined || inactivityLockMin === null)
            throw new Error("The parameter 'inactivityLockMin' must be defined and cannot be null.");
        else
            url_ += "inactivityLockMin=" + encodeURIComponent("" + inactivityLockMin) + "&";
        if (passwordExpirationDays === undefined || passwordExpirationDays === null)
            throw new Error("The parameter 'passwordExpirationDays' must be defined and cannot be null.");
        else
            url_ += "passwordExpirationDays=" + encodeURIComponent("" + passwordExpirationDays) + "&";
        if (passwordHistory === undefined || passwordHistory === null)
            throw new Error("The parameter 'passwordHistory' must be defined and cannot be null.");
        else
            url_ += "passwordHistory=" + encodeURIComponent("" + passwordHistory) + "&";
        if (refreshInterval === undefined || refreshInterval === null)
            throw new Error("The parameter 'refreshInterval' must be defined and cannot be null.");
        else
            url_ += "refreshInterval=" + encodeURIComponent("" + refreshInterval) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetActiveSyncPolicy(_response);
        });
    }

    protected processSetActiveSyncPolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMobileDevices(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetMobileDevices/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMobileDevices(_response);
        });
    }

    protected processGetMobileDevices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMobileDevice(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetMobileDevice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMobileDevice(_response);
        });
    }

    protected processGetMobileDevice(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    wipeDataFromDevice(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/WipeDataFromDevice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWipeDataFromDevice(_response);
        });
    }

    protected processWipeDataFromDevice(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    cancelRemoteWipeRequest(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/CancelRemoteWipeRequest/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelRemoteWipeRequest(_response);
        });
    }

    protected processCancelRemoteWipeRequest(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeDevice(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/RemoveDevice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveDevice(_response);
        });
    }

    protected processRemoveDevice(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    exportMailBox(organizationId: string, accountName: string, storagePath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/ExportMailBox/{organizationId}/{accountName}/{storagePath}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (storagePath === undefined || storagePath === null)
            throw new Error("The parameter 'storagePath' must be defined.");
        url_ = url_.replace("{storagePath}", encodeURIComponent("" + storagePath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportMailBox(_response);
        });
    }

    protected processExportMailBox(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setMailBoxArchiving(organizationId: string, accountName: string, archive: boolean, archiveQuotaKB: number, archiveWarningQuotaKB: number, retentionPolicy: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetMailBoxArchiving/{organizationId}/{accountName}/{RetentionPolicy}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (retentionPolicy === undefined || retentionPolicy === null)
            throw new Error("The parameter 'retentionPolicy' must be defined.");
        url_ = url_.replace("{RetentionPolicy}", encodeURIComponent("" + retentionPolicy));
        if (archive === undefined || archive === null)
            throw new Error("The parameter 'archive' must be defined and cannot be null.");
        else
            url_ += "archive=" + encodeURIComponent("" + archive) + "&";
        if (archiveQuotaKB === undefined || archiveQuotaKB === null)
            throw new Error("The parameter 'archiveQuotaKB' must be defined and cannot be null.");
        else
            url_ += "archiveQuotaKB=" + encodeURIComponent("" + archiveQuotaKB) + "&";
        if (archiveWarningQuotaKB === undefined || archiveWarningQuotaKB === null)
            throw new Error("The parameter 'archiveWarningQuotaKB' must be defined and cannot be null.");
        else
            url_ += "archiveWarningQuotaKB=" + encodeURIComponent("" + archiveWarningQuotaKB) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetMailBoxArchiving(_response);
        });
    }

    protected processSetMailBoxArchiving(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setRetentionPolicyTag(identity: string, type: any, ageLimitForRetention: number, retentionAction: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetRetentionPolicyTag/{Identity}?";
        if (identity === undefined || identity === null)
            throw new Error("The parameter 'identity' must be defined.");
        url_ = url_.replace("{Identity}", encodeURIComponent("" + identity));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (ageLimitForRetention === undefined || ageLimitForRetention === null)
            throw new Error("The parameter 'ageLimitForRetention' must be defined and cannot be null.");
        else
            url_ += "AgeLimitForRetention=" + encodeURIComponent("" + ageLimitForRetention) + "&";
        if (retentionAction === undefined || retentionAction === null)
            throw new Error("The parameter 'retentionAction' must be defined and cannot be null.");
        else
            url_ += "RetentionAction=" + encodeURIComponent("" + retentionAction) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetRetentionPolicyTag(_response);
        });
    }

    protected processSetRetentionPolicyTag(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeRetentionPolicyTag(identity: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/RemoveRetentionPolicyTag/{Identity}";
        if (identity === undefined || identity === null)
            throw new Error("The parameter 'identity' must be defined.");
        url_ = url_.replace("{Identity}", encodeURIComponent("" + identity));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveRetentionPolicyTag(_response);
        });
    }

    protected processRemoveRetentionPolicyTag(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setRetentionPolicy(identity: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetRetentionPolicy/{Identity}";
        if (identity === undefined || identity === null)
            throw new Error("The parameter 'identity' must be defined.");
        url_ = url_.replace("{Identity}", encodeURIComponent("" + identity));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetRetentionPolicy(_response);
        });
    }

    protected processSetRetentionPolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeRetentionPolicy(identity: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/RemoveRetentionPolicy/{Identity}";
        if (identity === undefined || identity === null)
            throw new Error("The parameter 'identity' must be defined.");
        url_ = url_.replace("{Identity}", encodeURIComponent("" + identity));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveRetentionPolicy(_response);
        });
    }

    protected processRemoveRetentionPolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setPicture(accountName: string, picture: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/SetPicture/{accountName}?";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (picture === undefined || picture === null)
            throw new Error("The parameter 'picture' must be defined and cannot be null.");
        else
            url_ += "picture=" + encodeURIComponent("" + picture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPicture(_response);
        });
    }

    protected processSetPicture(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPicture(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ExchangeServer/GetPicture/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPicture(_response);
        });
    }

    protected processGetPicture(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class FTPServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    changeSiteState(siteId: string, state: any): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/ChangeSiteState/{siteId}?";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeSiteState(_response);
        });
    }

    protected processChangeSiteState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSiteState(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/GetSiteState/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSiteState(_response);
        });
    }

    protected processGetSiteState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    siteExists(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/SiteExists/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSiteExists(_response);
        });
    }

    protected processSiteExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSites(): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/GetSites";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSites(_response);
        });
    }

    protected processGetSites(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSite(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/GetSite/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSite(_response);
        });
    }

    protected processGetSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSite(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/CreateSite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSite(_response);
        });
    }

    protected processCreateSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateSite(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/UpdateSite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSite(_response);
        });
    }

    protected processUpdateSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSite(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/DeleteSite/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSite(_response);
        });
    }

    protected processDeleteSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    accountExists(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/AccountExists/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountExists(_response);
        });
    }

    protected processAccountExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAccounts(): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/GetAccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccounts(_response);
        });
    }

    protected processGetAccounts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAccount(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/GetAccount/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccount(_response);
        });
    }

    protected processGetAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createAccount(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/CreateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAccount(_response);
        });
    }

    protected processCreateAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateAccount(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/UpdateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAccount(_response);
        });
    }

    protected processUpdateAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteAccount(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/FTPServer/DeleteAccount/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAccount(_response);
        });
    }

    protected processDeleteAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class HeliconZooClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getEngines(): Promise<void> {
        let url_ = this.baseUrl + "/api/HeliconZoo/GetEngines";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEngines(_response);
        });
    }

    protected processGetEngines(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setEngines(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HeliconZoo/SetEngines";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetEngines(_response);
        });
    }

    protected processSetEngines(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    isEnginesEnabled(): Promise<void> {
        let url_ = this.baseUrl + "/api/HeliconZoo/IsEnginesEnabled";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsEnginesEnabled(_response);
        });
    }

    protected processIsEnginesEnabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    swithEnginesEnabled(enabled: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/HeliconZoo/SwithEnginesEnabled?";
        if (enabled === undefined || enabled === null)
            throw new Error("The parameter 'enabled' must be defined and cannot be null.");
        else
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSwithEnginesEnabled(_response);
        });
    }

    protected processSwithEnginesEnabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getEnabledEnginesForSite(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/HeliconZoo/GetEnabledEnginesForSite/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEnabledEnginesForSite(_response);
        });
    }

    protected processGetEnabledEnginesForSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setEnabledEnginesForSite(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HeliconZoo/SetEnabledEnginesForSite/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetEnabledEnginesForSite(_response);
        });
    }

    protected processSetEnabledEnginesForSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    isWebCosoleEnabled(): Promise<void> {
        let url_ = this.baseUrl + "/api/HeliconZoo/IsWebCosoleEnabled";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsWebCosoleEnabled(_response);
        });
    }

    protected processIsWebCosoleEnabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setWebCosoleEnabled(enabled: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/HeliconZoo/SetWebCosoleEnabled?";
        if (enabled === undefined || enabled === null)
            throw new Error("The parameter 'enabled' must be defined and cannot be null.");
        else
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetWebCosoleEnabled(_response);
        });
    }

    protected processSetWebCosoleEnabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class HostedSharePointServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getSupportedLanguages(): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/GetSupportedLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSupportedLanguages(_response);
        });
    }

    protected processGetSupportedLanguages(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSiteCollections(): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/GetSiteCollections";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSiteCollections(_response);
        });
    }

    protected processGetSiteCollections(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSiteCollection(url: string): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/GetSiteCollection/{url}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSiteCollection(_response);
        });
    }

    protected processGetSiteCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSiteCollection(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/CreateSiteCollection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSiteCollection(_response);
        });
    }

    protected processCreateSiteCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateQuotas(url: string, maxSize: number, warningSize: number): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/UpdateQuotas/{url}?";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        if (maxSize === undefined || maxSize === null)
            throw new Error("The parameter 'maxSize' must be defined and cannot be null.");
        else
            url_ += "maxSize=" + encodeURIComponent("" + maxSize) + "&";
        if (warningSize === undefined || warningSize === null)
            throw new Error("The parameter 'warningSize' must be defined and cannot be null.");
        else
            url_ += "warningSize=" + encodeURIComponent("" + warningSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateQuotas(_response);
        });
    }

    protected processUpdateQuotas(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    calculateSiteCollectionsDiskSpace(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/CalculateSiteCollectionsDiskSpace";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateSiteCollectionsDiskSpace(_response);
        });
    }

    protected processCalculateSiteCollectionsDiskSpace(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSiteCollection(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/DeleteSiteCollection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSiteCollection(_response);
        });
    }

    protected processDeleteSiteCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    backupSiteCollection(url: string, filename: string, zip: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/BackupSiteCollection/{url}/{filename}?";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        if (filename === undefined || filename === null)
            throw new Error("The parameter 'filename' must be defined.");
        url_ = url_.replace("{filename}", encodeURIComponent("" + filename));
        if (zip === undefined || zip === null)
            throw new Error("The parameter 'zip' must be defined and cannot be null.");
        else
            url_ += "zip=" + encodeURIComponent("" + zip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBackupSiteCollection(_response);
        });
    }

    protected processBackupSiteCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    restoreSiteCollection(filename: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/RestoreSiteCollection/{filename}";
        if (filename === undefined || filename === null)
            throw new Error("The parameter 'filename' must be defined.");
        url_ = url_.replace("{filename}", encodeURIComponent("" + filename));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRestoreSiteCollection(_response);
        });
    }

    protected processRestoreSiteCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getTempFileBinaryChunk(path: string, offset: number, length: number): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/GetTempFileBinaryChunk/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (offset === undefined || offset === null)
            throw new Error("The parameter 'offset' must be defined and cannot be null.");
        else
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (length === undefined || length === null)
            throw new Error("The parameter 'length' must be defined and cannot be null.");
        else
            url_ += "length=" + encodeURIComponent("" + length) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTempFileBinaryChunk(_response);
        });
    }

    protected processGetTempFileBinaryChunk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    appendTempFileBinaryChunk(fileName: string, path: string, chunk: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/AppendTempFileBinaryChunk/{fileName}/{path}?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (chunk === undefined || chunk === null)
            throw new Error("The parameter 'chunk' must be defined and cannot be null.");
        else
            url_ += "chunk=" + encodeURIComponent("" + chunk) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAppendTempFileBinaryChunk(_response);
        });
    }

    protected processAppendTempFileBinaryChunk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSiteCollectionSize(url: string): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/GetSiteCollectionSize/{url}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSiteCollectionSize(_response);
        });
    }

    protected processGetSiteCollectionSize(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setPeoplePickerOu(site: string, ou: string): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServer/SetPeoplePickerOu/{site}/{ou}";
        if (site === undefined || site === null)
            throw new Error("The parameter 'site' must be defined.");
        url_ = url_.replace("{site}", encodeURIComponent("" + site));
        if (ou === undefined || ou === null)
            throw new Error("The parameter 'ou' must be defined.");
        url_ = url_.replace("{ou}", encodeURIComponent("" + ou));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPeoplePickerOu(_response);
        });
    }

    protected processSetPeoplePickerOu(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class HostedSharePointServerEntClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    enterprise_GetSupportedLanguages(): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_GetSupportedLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_GetSupportedLanguages(_response);
        });
    }

    protected processEnterprise_GetSupportedLanguages(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_GetSiteCollections(): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_GetSiteCollections";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_GetSiteCollections(_response);
        });
    }

    protected processEnterprise_GetSiteCollections(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_GetSiteCollection(url: string): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_GetSiteCollection/{url}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_GetSiteCollection(_response);
        });
    }

    protected processEnterprise_GetSiteCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_CreateSiteCollection(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_CreateSiteCollection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_CreateSiteCollection(_response);
        });
    }

    protected processEnterprise_CreateSiteCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_UpdateQuotas(url: string, maxSize: number, warningSize: number): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_UpdateQuotas/{url}?";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        if (maxSize === undefined || maxSize === null)
            throw new Error("The parameter 'maxSize' must be defined and cannot be null.");
        else
            url_ += "maxSize=" + encodeURIComponent("" + maxSize) + "&";
        if (warningSize === undefined || warningSize === null)
            throw new Error("The parameter 'warningSize' must be defined and cannot be null.");
        else
            url_ += "warningSize=" + encodeURIComponent("" + warningSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_UpdateQuotas(_response);
        });
    }

    protected processEnterprise_UpdateQuotas(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_CalculateSiteCollectionsDiskSpace(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_CalculateSiteCollectionsDiskSpace";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_CalculateSiteCollectionsDiskSpace(_response);
        });
    }

    protected processEnterprise_CalculateSiteCollectionsDiskSpace(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_DeleteSiteCollection(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_DeleteSiteCollection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_DeleteSiteCollection(_response);
        });
    }

    protected processEnterprise_DeleteSiteCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_BackupSiteCollection(url: string, filename: string, zip: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_BackupSiteCollection/{url}/{filename}?";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        if (filename === undefined || filename === null)
            throw new Error("The parameter 'filename' must be defined.");
        url_ = url_.replace("{filename}", encodeURIComponent("" + filename));
        if (zip === undefined || zip === null)
            throw new Error("The parameter 'zip' must be defined and cannot be null.");
        else
            url_ += "zip=" + encodeURIComponent("" + zip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_BackupSiteCollection(_response);
        });
    }

    protected processEnterprise_BackupSiteCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_RestoreSiteCollection(filename: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_RestoreSiteCollection/{filename}";
        if (filename === undefined || filename === null)
            throw new Error("The parameter 'filename' must be defined.");
        url_ = url_.replace("{filename}", encodeURIComponent("" + filename));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_RestoreSiteCollection(_response);
        });
    }

    protected processEnterprise_RestoreSiteCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_GetTempFileBinaryChunk(path: string, offset: number, length: number): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_GetTempFileBinaryChunk/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (offset === undefined || offset === null)
            throw new Error("The parameter 'offset' must be defined and cannot be null.");
        else
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (length === undefined || length === null)
            throw new Error("The parameter 'length' must be defined and cannot be null.");
        else
            url_ += "length=" + encodeURIComponent("" + length) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_GetTempFileBinaryChunk(_response);
        });
    }

    protected processEnterprise_GetTempFileBinaryChunk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_AppendTempFileBinaryChunk(fileName: string, path: string, chunk: any): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_AppendTempFileBinaryChunk/{fileName}/{path}?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (chunk === undefined || chunk === null)
            throw new Error("The parameter 'chunk' must be defined and cannot be null.");
        else
            url_ += "chunk=" + encodeURIComponent("" + chunk) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_AppendTempFileBinaryChunk(_response);
        });
    }

    protected processEnterprise_AppendTempFileBinaryChunk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_GetSiteCollectionSize(url: string): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_GetSiteCollectionSize/{url}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_GetSiteCollectionSize(_response);
        });
    }

    protected processEnterprise_GetSiteCollectionSize(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enterprise_SetPeoplePickerOu(site: string, ou: string): Promise<void> {
        let url_ = this.baseUrl + "/api/HostedSharePointServerEnt/Enterprise_SetPeoplePickerOu/{site}/{ou}";
        if (site === undefined || site === null)
            throw new Error("The parameter 'site' must be defined.");
        url_ = url_.replace("{site}", encodeURIComponent("" + site));
        if (ou === undefined || ou === null)
            throw new Error("The parameter 'ou' must be defined.");
        url_ = url_.replace("{ou}", encodeURIComponent("" + ou));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnterprise_SetPeoplePickerOu(_response);
        });
    }

    protected processEnterprise_SetPeoplePickerOu(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LyncServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createOrganization(organizationId: string, sipDomain: string, enableConferencing: boolean, enableConferencingVideo: boolean, maxConferenceSize: number, enabledFederation: boolean, enabledEnterpriseVoice: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/CreateOrganization/{organizationId}/{sipDomain}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (sipDomain === undefined || sipDomain === null)
            throw new Error("The parameter 'sipDomain' must be defined.");
        url_ = url_.replace("{sipDomain}", encodeURIComponent("" + sipDomain));
        if (enableConferencing === undefined || enableConferencing === null)
            throw new Error("The parameter 'enableConferencing' must be defined and cannot be null.");
        else
            url_ += "enableConferencing=" + encodeURIComponent("" + enableConferencing) + "&";
        if (enableConferencingVideo === undefined || enableConferencingVideo === null)
            throw new Error("The parameter 'enableConferencingVideo' must be defined and cannot be null.");
        else
            url_ += "enableConferencingVideo=" + encodeURIComponent("" + enableConferencingVideo) + "&";
        if (maxConferenceSize === undefined || maxConferenceSize === null)
            throw new Error("The parameter 'maxConferenceSize' must be defined and cannot be null.");
        else
            url_ += "maxConferenceSize=" + encodeURIComponent("" + maxConferenceSize) + "&";
        if (enabledFederation === undefined || enabledFederation === null)
            throw new Error("The parameter 'enabledFederation' must be defined and cannot be null.");
        else
            url_ += "enabledFederation=" + encodeURIComponent("" + enabledFederation) + "&";
        if (enabledEnterpriseVoice === undefined || enabledEnterpriseVoice === null)
            throw new Error("The parameter 'enabledEnterpriseVoice' must be defined and cannot be null.");
        else
            url_ += "enabledEnterpriseVoice=" + encodeURIComponent("" + enabledEnterpriseVoice) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrganization(_response);
        });
    }

    protected processCreateOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOrganizationTenantId(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/GetOrganizationTenantId/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrganizationTenantId(_response);
        });
    }

    protected processGetOrganizationTenantId(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteOrganization(organizationId: string, sipDomain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/DeleteOrganization/{organizationId}/{sipDomain}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (sipDomain === undefined || sipDomain === null)
            throw new Error("The parameter 'sipDomain' must be defined.");
        url_ = url_.replace("{sipDomain}", encodeURIComponent("" + sipDomain));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOrganization(_response);
        });
    }

    protected processDeleteOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createUser(organizationId: string, userUpn: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/CreateUser/{organizationId}/{userUpn}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getLyncUserGeneralSettings(organizationId: string, userUpn: string): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/GetLyncUserGeneralSettings/{organizationId}/{userUpn}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLyncUserGeneralSettings(_response);
        });
    }

    protected processGetLyncUserGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setLyncUserGeneralSettings(organizationId: string, userUpn: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/SetLyncUserGeneralSettings/{organizationId}/{userUpn}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetLyncUserGeneralSettings(_response);
        });
    }

    protected processSetLyncUserGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setLyncUserPlan(organizationId: string, userUpn: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/SetLyncUserPlan/{organizationId}/{userUpn}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetLyncUserPlan(_response);
        });
    }

    protected processSetLyncUserPlan(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUser(userUpn: string): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/DeleteUser/{userUpn}";
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFederationDomains(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/GetFederationDomains/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFederationDomains(_response);
        });
    }

    protected processGetFederationDomains(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addFederationDomain(organizationId: string, domainName: string, proxyFqdn: string): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/AddFederationDomain/{organizationId}/{domainName}/{proxyFqdn}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        if (proxyFqdn === undefined || proxyFqdn === null)
            throw new Error("The parameter 'proxyFqdn' must be defined.");
        url_ = url_.replace("{proxyFqdn}", encodeURIComponent("" + proxyFqdn));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddFederationDomain(_response);
        });
    }

    protected processAddFederationDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeFederationDomain(organizationId: string, domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/RemoveFederationDomain/{organizationId}/{domainName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveFederationDomain(_response);
        });
    }

    protected processRemoveFederationDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    reloadConfiguration(): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/ReloadConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReloadConfiguration(_response);
        });
    }

    protected processReloadConfiguration(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPolicyList(type: any, name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/LyncServer/GetPolicyList/{name}?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPolicyList(_response);
        });
    }

    protected processGetPolicyList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MailServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    domainExists(domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/DomainExists/{domainName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDomainExists(_response);
        });
    }

    protected processDomainExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDomain(domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetDomain/{domainName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDomain(_response);
        });
    }

    protected processGetDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDomains(): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetDomains";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDomains(_response);
        });
    }

    protected processGetDomains(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createDomain(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/CreateDomain";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDomain(_response);
        });
    }

    protected processCreateDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateDomain(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/UpdateDomain";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDomain(_response);
        });
    }

    protected processUpdateDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteDomain(domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/DeleteDomain/{domainName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDomain(_response);
        });
    }

    protected processDeleteDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    domainAliasExists(domainName: string, aliasName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/DomainAliasExists/{domainName}/{aliasName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        if (aliasName === undefined || aliasName === null)
            throw new Error("The parameter 'aliasName' must be defined.");
        url_ = url_.replace("{aliasName}", encodeURIComponent("" + aliasName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDomainAliasExists(_response);
        });
    }

    protected processDomainAliasExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDomainAliases(domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetDomainAliases/{domainName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDomainAliases(_response);
        });
    }

    protected processGetDomainAliases(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addDomainAlias(domainName: string, aliasName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/AddDomainAlias/{domainName}/{aliasName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        if (aliasName === undefined || aliasName === null)
            throw new Error("The parameter 'aliasName' must be defined.");
        url_ = url_.replace("{aliasName}", encodeURIComponent("" + aliasName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddDomainAlias(_response);
        });
    }

    protected processAddDomainAlias(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteDomainAlias(domainName: string, aliasName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/DeleteDomainAlias/{domainName}/{aliasName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        if (aliasName === undefined || aliasName === null)
            throw new Error("The parameter 'aliasName' must be defined.");
        url_ = url_.replace("{aliasName}", encodeURIComponent("" + aliasName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDomainAlias(_response);
        });
    }

    protected processDeleteDomainAlias(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    accountExists(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/AccountExists/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountExists(_response);
        });
    }

    protected processAccountExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAccounts(domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetAccounts/{domainName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccounts(_response);
        });
    }

    protected processGetAccounts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAccount(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetAccount/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccount(_response);
        });
    }

    protected processGetAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createAccount(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/CreateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAccount(_response);
        });
    }

    protected processCreateAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateAccount(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/UpdateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAccount(_response);
        });
    }

    protected processUpdateAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteAccount(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/DeleteAccount/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAccount(_response);
        });
    }

    protected processDeleteAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    mailAliasExists(mailAliasName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/MailAliasExists/{mailAliasName}";
        if (mailAliasName === undefined || mailAliasName === null)
            throw new Error("The parameter 'mailAliasName' must be defined.");
        url_ = url_.replace("{mailAliasName}", encodeURIComponent("" + mailAliasName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMailAliasExists(_response);
        });
    }

    protected processMailAliasExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMailAliases(domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetMailAliases/{domainName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMailAliases(_response);
        });
    }

    protected processGetMailAliases(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMailAlias(mailAliasName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetMailAlias/{mailAliasName}";
        if (mailAliasName === undefined || mailAliasName === null)
            throw new Error("The parameter 'mailAliasName' must be defined.");
        url_ = url_.replace("{mailAliasName}", encodeURIComponent("" + mailAliasName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMailAlias(_response);
        });
    }

    protected processGetMailAlias(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createMailAlias(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/CreateMailAlias";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMailAlias(_response);
        });
    }

    protected processCreateMailAlias(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateMailAlias(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/UpdateMailAlias";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMailAlias(_response);
        });
    }

    protected processUpdateMailAlias(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteMailAlias(mailAliasName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/DeleteMailAlias/{mailAliasName}";
        if (mailAliasName === undefined || mailAliasName === null)
            throw new Error("The parameter 'mailAliasName' must be defined.");
        url_ = url_.replace("{mailAliasName}", encodeURIComponent("" + mailAliasName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMailAlias(_response);
        });
    }

    protected processDeleteMailAlias(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    groupExists(groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GroupExists/{groupName}";
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGroupExists(_response);
        });
    }

    protected processGroupExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGroups(domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetGroups/{domainName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroups(_response);
        });
    }

    protected processGetGroups(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGroup(groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetGroup/{groupName}";
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroup(_response);
        });
    }

    protected processGetGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createGroup(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/CreateGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateGroup(_response);
        });
    }

    protected processCreateGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateGroup(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/UpdateGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateGroup(_response);
        });
    }

    protected processUpdateGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteGroup(groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/DeleteGroup/{groupName}";
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteGroup(_response);
        });
    }

    protected processDeleteGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    listExists(listName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/ListExists/{listName}";
        if (listName === undefined || listName === null)
            throw new Error("The parameter 'listName' must be defined.");
        url_ = url_.replace("{listName}", encodeURIComponent("" + listName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListExists(_response);
        });
    }

    protected processListExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getLists(domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetLists/{domainName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLists(_response);
        });
    }

    protected processGetLists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getList(listName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/GetList/{listName}";
        if (listName === undefined || listName === null)
            throw new Error("The parameter 'listName' must be defined.");
        url_ = url_.replace("{listName}", encodeURIComponent("" + listName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createList(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateList(_response);
        });
    }

    protected processCreateList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateList(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/UpdateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateList(_response);
        });
    }

    protected processUpdateList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteList(listName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/MailServer/DeleteList/{listName}";
        if (listName === undefined || listName === null)
            throw new Error("The parameter 'listName' must be defined.");
        url_ = url_.replace("{listName}", encodeURIComponent("" + listName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteList(_response);
        });
    }

    protected processDeleteList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class OCSEdgeServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    addDomain(domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OCSEdgeServer/AddDomain/{domainName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddDomain(_response);
        });
    }

    protected processAddDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteDomain(domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OCSEdgeServer/DeleteDomain/{domainName}";
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDomain(_response);
        });
    }

    protected processDeleteDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class OCSServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createUser(userUpn: string, userDistinguishedName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OCSServer/CreateUser/{userUpn}/{userDistinguishedName}";
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        if (userDistinguishedName === undefined || userDistinguishedName === null)
            throw new Error("The parameter 'userDistinguishedName' must be defined.");
        url_ = url_.replace("{userDistinguishedName}", encodeURIComponent("" + userDistinguishedName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUserGeneralSettings(instanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OCSServer/GetUserGeneralSettings/{instanceId}";
        if (instanceId === undefined || instanceId === null)
            throw new Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserGeneralSettings(_response);
        });
    }

    protected processGetUserGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setUserGeneralSettings(instanceId: string, enabledForFederation: boolean, enabledForPublicIMConectivity: boolean, archiveInternalCommunications: boolean, archiveFederatedCommunications: boolean, enabledForEnhancedPresence: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/OCSServer/SetUserGeneralSettings/{instanceId}?";
        if (instanceId === undefined || instanceId === null)
            throw new Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        if (enabledForFederation === undefined || enabledForFederation === null)
            throw new Error("The parameter 'enabledForFederation' must be defined and cannot be null.");
        else
            url_ += "enabledForFederation=" + encodeURIComponent("" + enabledForFederation) + "&";
        if (enabledForPublicIMConectivity === undefined || enabledForPublicIMConectivity === null)
            throw new Error("The parameter 'enabledForPublicIMConectivity' must be defined and cannot be null.");
        else
            url_ += "enabledForPublicIMConectivity=" + encodeURIComponent("" + enabledForPublicIMConectivity) + "&";
        if (archiveInternalCommunications === undefined || archiveInternalCommunications === null)
            throw new Error("The parameter 'archiveInternalCommunications' must be defined and cannot be null.");
        else
            url_ += "archiveInternalCommunications=" + encodeURIComponent("" + archiveInternalCommunications) + "&";
        if (archiveFederatedCommunications === undefined || archiveFederatedCommunications === null)
            throw new Error("The parameter 'archiveFederatedCommunications' must be defined and cannot be null.");
        else
            url_ += "archiveFederatedCommunications=" + encodeURIComponent("" + archiveFederatedCommunications) + "&";
        if (enabledForEnhancedPresence === undefined || enabledForEnhancedPresence === null)
            throw new Error("The parameter 'enabledForEnhancedPresence' must be defined and cannot be null.");
        else
            url_ += "enabledForEnhancedPresence=" + encodeURIComponent("" + enabledForEnhancedPresence) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetUserGeneralSettings(_response);
        });
    }

    protected processSetUserGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUser(instanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OCSServer/DeleteUser/{instanceId}";
        if (instanceId === undefined || instanceId === null)
            throw new Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setUserPrimaryUri(instanceId: string, userUpn: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OCSServer/SetUserPrimaryUri/{instanceId}/{userUpn}";
        if (instanceId === undefined || instanceId === null)
            throw new Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetUserPrimaryUri(_response);
        });
    }

    protected processSetUserPrimaryUri(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class OperatingSystemClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createPackageFolder(initialPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/CreatePackageFolder/{initialPath}";
        if (initialPath === undefined || initialPath === null)
            throw new Error("The parameter 'initialPath' must be defined.");
        url_ = url_.replace("{initialPath}", encodeURIComponent("" + initialPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePackageFolder(_response);
        });
    }

    protected processCreatePackageFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    fileExists(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/FileExists/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFileExists(_response);
        });
    }

    protected processFileExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    directoryExists(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/DirectoryExists/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDirectoryExists(_response);
        });
    }

    protected processDirectoryExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFiles(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetFiles/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFiles(_response);
        });
    }

    protected processGetFiles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDirectoriesRecursive(rootFolder: string, path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetDirectoriesRecursive/{rootFolder}/{path}";
        if (rootFolder === undefined || rootFolder === null)
            throw new Error("The parameter 'rootFolder' must be defined.");
        url_ = url_.replace("{rootFolder}", encodeURIComponent("" + rootFolder));
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDirectoriesRecursive(_response);
        });
    }

    protected processGetDirectoriesRecursive(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFilesRecursive(rootFolder: string, path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetFilesRecursive/{rootFolder}/{path}";
        if (rootFolder === undefined || rootFolder === null)
            throw new Error("The parameter 'rootFolder' must be defined.");
        url_ = url_.replace("{rootFolder}", encodeURIComponent("" + rootFolder));
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFilesRecursive(_response);
        });
    }

    protected processGetFilesRecursive(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFilesRecursiveByPattern(rootFolder: string, path: string, pattern: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetFilesRecursiveByPattern/{rootFolder}/{path}/{pattern}";
        if (rootFolder === undefined || rootFolder === null)
            throw new Error("The parameter 'rootFolder' must be defined.");
        url_ = url_.replace("{rootFolder}", encodeURIComponent("" + rootFolder));
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (pattern === undefined || pattern === null)
            throw new Error("The parameter 'pattern' must be defined.");
        url_ = url_.replace("{pattern}", encodeURIComponent("" + pattern));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFilesRecursiveByPattern(_response);
        });
    }

    protected processGetFilesRecursiveByPattern(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFileBinaryContent(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetFileBinaryContent/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFileBinaryContent(_response);
        });
    }

    protected processGetFileBinaryContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFileBinaryContentUsingEncoding(path: string, encoding: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetFileBinaryContentUsingEncoding/{path}/{encoding}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (encoding === undefined || encoding === null)
            throw new Error("The parameter 'encoding' must be defined.");
        url_ = url_.replace("{encoding}", encodeURIComponent("" + encoding));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFileBinaryContentUsingEncoding(_response);
        });
    }

    protected processGetFileBinaryContentUsingEncoding(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFileBinaryChunk(path: string, offset: number, length: number): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetFileBinaryChunk/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (offset === undefined || offset === null)
            throw new Error("The parameter 'offset' must be defined and cannot be null.");
        else
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (length === undefined || length === null)
            throw new Error("The parameter 'length' must be defined and cannot be null.");
        else
            url_ += "length=" + encodeURIComponent("" + length) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFileBinaryChunk(_response);
        });
    }

    protected processGetFileBinaryChunk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFileTextContent(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetFileTextContent/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFileTextContent(_response);
        });
    }

    protected processGetFileTextContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/CreateFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFile(_response);
        });
    }

    protected processCreateFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createDirectory(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/CreateDirectory/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDirectory(_response);
        });
    }

    protected processCreateDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeFileAttributes(path: string, createdTime: string, changedTime: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/ChangeFileAttributes/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (createdTime === undefined || createdTime === null)
            throw new Error("The parameter 'createdTime' must be defined and cannot be null.");
        else
            url_ += "createdTime=" + encodeURIComponent("" + createdTime) + "&";
        if (changedTime === undefined || changedTime === null)
            throw new Error("The parameter 'changedTime' must be defined and cannot be null.");
        else
            url_ += "changedTime=" + encodeURIComponent("" + changedTime) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeFileAttributes(_response);
        });
    }

    protected processChangeFileAttributes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/DeleteFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFile(_response);
        });
    }

    protected processDeleteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteFiles(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/DeleteFiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFiles(_response);
        });
    }

    protected processDeleteFiles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteEmptyDirectories(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/DeleteEmptyDirectories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEmptyDirectories(_response);
        });
    }

    protected processDeleteEmptyDirectories(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateFileBinaryContent(path: string, content: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/UpdateFileBinaryContent/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (content === undefined || content === null)
            throw new Error("The parameter 'content' must be defined and cannot be null.");
        else
            url_ += "content=" + encodeURIComponent("" + content) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFileBinaryContent(_response);
        });
    }

    protected processUpdateFileBinaryContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateFileBinaryContentUsingEncoding(path: string, content: any, encoding: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/UpdateFileBinaryContentUsingEncoding/{path}/{encoding}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (encoding === undefined || encoding === null)
            throw new Error("The parameter 'encoding' must be defined.");
        url_ = url_.replace("{encoding}", encodeURIComponent("" + encoding));
        if (content === undefined || content === null)
            throw new Error("The parameter 'content' must be defined and cannot be null.");
        else
            url_ += "content=" + encodeURIComponent("" + content) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFileBinaryContentUsingEncoding(_response);
        });
    }

    protected processUpdateFileBinaryContentUsingEncoding(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    appendFileBinaryContent(path: string, chunk: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/AppendFileBinaryContent/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (chunk === undefined || chunk === null)
            throw new Error("The parameter 'chunk' must be defined and cannot be null.");
        else
            url_ += "chunk=" + encodeURIComponent("" + chunk) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAppendFileBinaryContent(_response);
        });
    }

    protected processAppendFileBinaryContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateFileTextContent(path: string, content: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/UpdateFileTextContent/{path}/{content}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (content === undefined || content === null)
            throw new Error("The parameter 'content' must be defined.");
        url_ = url_.replace("{content}", encodeURIComponent("" + content));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFileTextContent(_response);
        });
    }

    protected processUpdateFileTextContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    moveFile(sourcePath: string, destinationPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/MoveFile/{sourcePath}/{destinationPath}";
        if (sourcePath === undefined || sourcePath === null)
            throw new Error("The parameter 'sourcePath' must be defined.");
        url_ = url_.replace("{sourcePath}", encodeURIComponent("" + sourcePath));
        if (destinationPath === undefined || destinationPath === null)
            throw new Error("The parameter 'destinationPath' must be defined.");
        url_ = url_.replace("{destinationPath}", encodeURIComponent("" + destinationPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveFile(_response);
        });
    }

    protected processMoveFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    copyFile(sourcePath: string, destinationPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/CopyFile/{sourcePath}/{destinationPath}";
        if (sourcePath === undefined || sourcePath === null)
            throw new Error("The parameter 'sourcePath' must be defined.");
        url_ = url_.replace("{sourcePath}", encodeURIComponent("" + sourcePath));
        if (destinationPath === undefined || destinationPath === null)
            throw new Error("The parameter 'destinationPath' must be defined.");
        url_ = url_.replace("{destinationPath}", encodeURIComponent("" + destinationPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCopyFile(_response);
        });
    }

    protected processCopyFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOSPlatform(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetOSPlatform";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOSPlatform(_response);
        });
    }

    protected processGetOSPlatform(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    zipFiles(zipFile: string, rootPath: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/ZipFiles/{zipFile}/{rootPath}";
        if (zipFile === undefined || zipFile === null)
            throw new Error("The parameter 'zipFile' must be defined.");
        url_ = url_.replace("{zipFile}", encodeURIComponent("" + zipFile));
        if (rootPath === undefined || rootPath === null)
            throw new Error("The parameter 'rootPath' must be defined.");
        url_ = url_.replace("{rootPath}", encodeURIComponent("" + rootPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processZipFiles(_response);
        });
    }

    protected processZipFiles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    unzipFiles(zipFile: string, destFolder: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/UnzipFiles/{zipFile}/{destFolder}";
        if (zipFile === undefined || zipFile === null)
            throw new Error("The parameter 'zipFile' must be defined.");
        url_ = url_.replace("{zipFile}", encodeURIComponent("" + zipFile));
        if (destFolder === undefined || destFolder === null)
            throw new Error("The parameter 'destFolder' must be defined.");
        url_ = url_.replace("{destFolder}", encodeURIComponent("" + destFolder));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnzipFiles(_response);
        });
    }

    protected processUnzipFiles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createBackupZip(zipFile: string, rootPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/CreateBackupZip/{zipFile}/{rootPath}";
        if (zipFile === undefined || zipFile === null)
            throw new Error("The parameter 'zipFile' must be defined.");
        url_ = url_.replace("{zipFile}", encodeURIComponent("" + zipFile));
        if (rootPath === undefined || rootPath === null)
            throw new Error("The parameter 'rootPath' must be defined.");
        url_ = url_.replace("{rootPath}", encodeURIComponent("" + rootPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateBackupZip(_response);
        });
    }

    protected processCreateBackupZip(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createAccessDatabase(databasePath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/CreateAccessDatabase/{databasePath}";
        if (databasePath === undefined || databasePath === null)
            throw new Error("The parameter 'databasePath' must be defined.");
        url_ = url_.replace("{databasePath}", encodeURIComponent("" + databasePath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAccessDatabase(_response);
        });
    }

    protected processCreateAccessDatabase(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGroupNtfsPermissions(path: string, usersOU: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetGroupNtfsPermissions/{path}/{usersOU}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (usersOU === undefined || usersOU === null)
            throw new Error("The parameter 'usersOU' must be defined.");
        url_ = url_.replace("{usersOU}", encodeURIComponent("" + usersOU));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroupNtfsPermissions(_response);
        });
    }

    protected processGetGroupNtfsPermissions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    grantGroupNtfsPermissions(path: string, usersOU: string, resetChildPermissions: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GrantGroupNtfsPermissions/{path}/{usersOU}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (usersOU === undefined || usersOU === null)
            throw new Error("The parameter 'usersOU' must be defined.");
        url_ = url_.replace("{usersOU}", encodeURIComponent("" + usersOU));
        if (resetChildPermissions === undefined || resetChildPermissions === null)
            throw new Error("The parameter 'resetChildPermissions' must be defined and cannot be null.");
        else
            url_ += "resetChildPermissions=" + encodeURIComponent("" + resetChildPermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantGroupNtfsPermissions(_response);
        });
    }

    protected processGrantGroupNtfsPermissions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setQuotaLimitOnFolder(folderPath: string, shareNameDrive: string, quotaType: any, quotaLimit: string, mode: number, wmiUserName: string, wmiPassword: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/SetQuotaLimitOnFolder/{folderPath}/{shareNameDrive}/{quotaLimit}/{wmiUserName}/{wmiPassword}?";
        if (folderPath === undefined || folderPath === null)
            throw new Error("The parameter 'folderPath' must be defined.");
        url_ = url_.replace("{folderPath}", encodeURIComponent("" + folderPath));
        if (shareNameDrive === undefined || shareNameDrive === null)
            throw new Error("The parameter 'shareNameDrive' must be defined.");
        url_ = url_.replace("{shareNameDrive}", encodeURIComponent("" + shareNameDrive));
        if (quotaLimit === undefined || quotaLimit === null)
            throw new Error("The parameter 'quotaLimit' must be defined.");
        url_ = url_.replace("{quotaLimit}", encodeURIComponent("" + quotaLimit));
        if (wmiUserName === undefined || wmiUserName === null)
            throw new Error("The parameter 'wmiUserName' must be defined.");
        url_ = url_.replace("{wmiUserName}", encodeURIComponent("" + wmiUserName));
        if (wmiPassword === undefined || wmiPassword === null)
            throw new Error("The parameter 'wmiPassword' must be defined.");
        url_ = url_.replace("{wmiPassword}", encodeURIComponent("" + wmiPassword));
        if (quotaType === undefined || quotaType === null)
            throw new Error("The parameter 'quotaType' must be defined and cannot be null.");
        else
            url_ += "quotaType=" + encodeURIComponent("" + quotaType) + "&";
        if (mode === undefined || mode === null)
            throw new Error("The parameter 'mode' must be defined and cannot be null.");
        else
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetQuotaLimitOnFolder(_response);
        });
    }

    protected processSetQuotaLimitOnFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getQuotaOnFolder(folderPath: string, wmiUserName: string, wmiPassword: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetQuotaOnFolder/{folderPath}/{wmiUserName}/{wmiPassword}";
        if (folderPath === undefined || folderPath === null)
            throw new Error("The parameter 'folderPath' must be defined.");
        url_ = url_.replace("{folderPath}", encodeURIComponent("" + folderPath));
        if (wmiUserName === undefined || wmiUserName === null)
            throw new Error("The parameter 'wmiUserName' must be defined.");
        url_ = url_.replace("{wmiUserName}", encodeURIComponent("" + wmiUserName));
        if (wmiPassword === undefined || wmiPassword === null)
            throw new Error("The parameter 'wmiPassword' must be defined.");
        url_ = url_.replace("{wmiPassword}", encodeURIComponent("" + wmiPassword));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuotaOnFolder(_response);
        });
    }

    protected processGetQuotaOnFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteDirectoryRecursive(rootPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/DeleteDirectoryRecursive/{rootPath}";
        if (rootPath === undefined || rootPath === null)
            throw new Error("The parameter 'rootPath' must be defined.");
        url_ = url_.replace("{rootPath}", encodeURIComponent("" + rootPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDirectoryRecursive(_response);
        });
    }

    protected processDeleteDirectoryRecursive(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkFileServicesInstallation(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/CheckFileServicesInstallation";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckFileServicesInstallation(_response);
        });
    }

    protected processCheckFileServicesInstallation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installFsrmService(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/InstallFsrmService";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallFsrmService(_response);
        });
    }

    protected processInstallFsrmService(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFolderGraph(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetFolderGraph/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFolderGraph(_response);
        });
    }

    protected processGetFolderGraph(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    executeSyncActions(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/ExecuteSyncActions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteSyncActions(_response);
        });
    }

    protected processExecuteSyncActions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getInstalledOdbcDrivers(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetInstalledOdbcDrivers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInstalledOdbcDrivers(_response);
        });
    }

    protected processGetInstalledOdbcDrivers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDSNNames(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetDSNNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDSNNames(_response);
        });
    }

    protected processGetDSNNames(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDSN(dsnName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetDSN/{dsnName}";
        if (dsnName === undefined || dsnName === null)
            throw new Error("The parameter 'dsnName' must be defined.");
        url_ = url_.replace("{dsnName}", encodeURIComponent("" + dsnName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDSN(_response);
        });
    }

    protected processGetDSN(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createDSN(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/CreateDSN";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDSN(_response);
        });
    }

    protected processCreateDSN(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateDSN(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/UpdateDSN";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDSN(_response);
        });
    }

    protected processUpdateDSN(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteDSN(dsnName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/DeleteDSN/{dsnName}";
        if (dsnName === undefined || dsnName === null)
            throw new Error("The parameter 'dsnName' must be defined.");
        url_ = url_.replace("{dsnName}", encodeURIComponent("" + dsnName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDSN(_response);
        });
    }

    protected processDeleteDSN(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUnixPermissions(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetUnixPermissions/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUnixPermissions(_response);
        });
    }

    protected processGetUnixPermissions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    grantUnixPermissions(path: string, mode: any, resetChildPermissions: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GrantUnixPermissions/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (mode === undefined || mode === null)
            throw new Error("The parameter 'mode' must be defined and cannot be null.");
        else
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (resetChildPermissions === null)
            throw new Error("The parameter 'resetChildPermissions' cannot be null.");
        else if (resetChildPermissions !== undefined)
            url_ += "resetChildPermissions=" + encodeURIComponent("" + resetChildPermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantUnixPermissions(_response);
        });
    }

    protected processGrantUnixPermissions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeUnixFileOwner(path: string, owner: string, group: string, applyToChildren: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/ChangeUnixFileOwner/{path}/{owner}/{group}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner));
        if (group === undefined || group === null)
            throw new Error("The parameter 'group' must be defined.");
        url_ = url_.replace("{group}", encodeURIComponent("" + group));
        if (applyToChildren === null)
            throw new Error("The parameter 'applyToChildren' cannot be null.");
        else if (applyToChildren !== undefined)
            url_ += "applyToChildren=" + encodeURIComponent("" + applyToChildren) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeUnixFileOwner(_response);
        });
    }

    protected processChangeUnixFileOwner(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getTerminalServicesSessions(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetTerminalServicesSessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTerminalServicesSessions(_response);
        });
    }

    protected processGetTerminalServicesSessions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    closeTerminalServicesSession(sessionId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/CloseTerminalServicesSession?";
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined and cannot be null.");
        else
            url_ += "sessionId=" + encodeURIComponent("" + sessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCloseTerminalServicesSession(_response);
        });
    }

    protected processCloseTerminalServicesSession(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getLogNames(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetLogNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLogNames(_response);
        });
    }

    protected processGetLogNames(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getLogEntries(logName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetLogEntries/{logName}";
        if (logName === undefined || logName === null)
            throw new Error("The parameter 'logName' must be defined.");
        url_ = url_.replace("{logName}", encodeURIComponent("" + logName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLogEntries(_response);
        });
    }

    protected processGetLogEntries(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getLogEntriesPaged(logName: string, startRow: number, maximumRows: number): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetLogEntriesPaged/{logName}?";
        if (logName === undefined || logName === null)
            throw new Error("The parameter 'logName' must be defined.");
        url_ = url_.replace("{logName}", encodeURIComponent("" + logName));
        if (startRow === undefined || startRow === null)
            throw new Error("The parameter 'startRow' must be defined and cannot be null.");
        else
            url_ += "startRow=" + encodeURIComponent("" + startRow) + "&";
        if (maximumRows === undefined || maximumRows === null)
            throw new Error("The parameter 'maximumRows' must be defined and cannot be null.");
        else
            url_ += "maximumRows=" + encodeURIComponent("" + maximumRows) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLogEntriesPaged(_response);
        });
    }

    protected processGetLogEntriesPaged(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    clearLog(logName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/ClearLog/{logName}";
        if (logName === undefined || logName === null)
            throw new Error("The parameter 'logName' must be defined.");
        url_ = url_.replace("{logName}", encodeURIComponent("" + logName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearLog(_response);
        });
    }

    protected processClearLog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOSProcesses(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetOSProcesses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOSProcesses(_response);
        });
    }

    protected processGetOSProcesses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    terminateOSProcess(pid: number): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/TerminateOSProcess?";
        if (pid === undefined || pid === null)
            throw new Error("The parameter 'pid' must be defined and cannot be null.");
        else
            url_ += "pid=" + encodeURIComponent("" + pid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTerminateOSProcess(_response);
        });
    }

    protected processTerminateOSProcess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOSServices(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetOSServices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOSServices(_response);
        });
    }

    protected processGetOSServices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeOSServiceStatus(id: string, status: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/ChangeOSServiceStatus/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeOSServiceStatus(_response);
        });
    }

    protected processChangeOSServiceStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    rebootSystem(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/RebootSystem";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRebootSystem(_response);
        });
    }

    protected processRebootSystem(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMemory(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetMemory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMemory(_response);
        });
    }

    protected processGetMemory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    executeSystemCommand(path: string, args: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/ExecuteSystemCommand/{path}/{args}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (args === undefined || args === null)
            throw new Error("The parameter 'args' must be defined.");
        url_ = url_.replace("{args}", encodeURIComponent("" + args));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteSystemCommand(_response);
        });
    }

    protected processExecuteSystemCommand(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getWPIProducts(tabId: string, keywordId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetWPIProducts/{tabId}/{keywordId}";
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (keywordId === undefined || keywordId === null)
            throw new Error("The parameter 'keywordId' must be defined.");
        url_ = url_.replace("{keywordId}", encodeURIComponent("" + keywordId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWPIProducts(_response);
        });
    }

    protected processGetWPIProducts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getWPIProductsFiltered(filter: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetWPIProductsFiltered/{filter}";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined.");
        url_ = url_.replace("{filter}", encodeURIComponent("" + filter));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWPIProductsFiltered(_response);
        });
    }

    protected processGetWPIProductsFiltered(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getWPIProductById(productdId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetWPIProductById/{productdId}";
        if (productdId === undefined || productdId === null)
            throw new Error("The parameter 'productdId' must be defined.");
        url_ = url_.replace("{productdId}", encodeURIComponent("" + productdId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWPIProductById(_response);
        });
    }

    protected processGetWPIProductById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getWPITabs(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetWPITabs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWPITabs(_response);
        });
    }

    protected processGetWPITabs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    initWPIFeeds(feedUrls: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/InitWPIFeeds/{feedUrls}";
        if (feedUrls === undefined || feedUrls === null)
            throw new Error("The parameter 'feedUrls' must be defined.");
        url_ = url_.replace("{feedUrls}", encodeURIComponent("" + feedUrls));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInitWPIFeeds(_response);
        });
    }

    protected processInitWPIFeeds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getWPIKeywords(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetWPIKeywords";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWPIKeywords(_response);
        });
    }

    protected processGetWPIKeywords(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getWPIProductsWithDependencies(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetWPIProductsWithDependencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWPIProductsWithDependencies(_response);
        });
    }

    protected processGetWPIProductsWithDependencies(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installWPIProducts(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/InstallWPIProducts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallWPIProducts(_response);
        });
    }

    protected processInstallWPIProducts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    cancelInstallWPIProducts(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/CancelInstallWPIProducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelInstallWPIProducts(_response);
        });
    }

    protected processCancelInstallWPIProducts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getWPIStatus(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/GetWPIStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWPIStatus(_response);
        });
    }

    protected processGetWPIStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    wpiGetLogFileDirectory(): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/WpiGetLogFileDirectory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWpiGetLogFileDirectory(_response);
        });
    }

    protected processWpiGetLogFileDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    wpiGetLogsInDirectory(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/OperatingSystem/WpiGetLogsInDirectory/{Path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{Path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWpiGetLogsInDirectory(_response);
        });
    }

    protected processWpiGetLogsInDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class OrganizationsClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    organizationExists(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/OrganizationExists/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrganizationExists(_response);
        });
    }

    protected processOrganizationExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createOrganization(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/CreateOrganization/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrganization(_response);
        });
    }

    protected processCreateOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteOrganization(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/DeleteOrganization/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOrganization(_response);
        });
    }

    protected processDeleteOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createUser(organizationId: string, loginName: string, displayName: string, upn: string, password: string, enabled: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/CreateUser/{organizationId}/{loginName}/{displayName}/{upn}/{password}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (loginName === undefined || loginName === null)
            throw new Error("The parameter 'loginName' must be defined.");
        url_ = url_.replace("{loginName}", encodeURIComponent("" + loginName));
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (upn === undefined || upn === null)
            throw new Error("The parameter 'upn' must be defined.");
        url_ = url_.replace("{upn}", encodeURIComponent("" + upn));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        if (enabled === undefined || enabled === null)
            throw new Error("The parameter 'enabled' must be defined and cannot be null.");
        else
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    disableUser(loginName: string, organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/DisableUser/{loginName}/{organizationId}";
        if (loginName === undefined || loginName === null)
            throw new Error("The parameter 'loginName' must be defined.");
        url_ = url_.replace("{loginName}", encodeURIComponent("" + loginName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDisableUser(_response);
        });
    }

    protected processDisableUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUser(loginName: string, organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/DeleteUser/{loginName}/{organizationId}";
        if (loginName === undefined || loginName === null)
            throw new Error("The parameter 'loginName' must be defined.");
        url_ = url_.replace("{loginName}", encodeURIComponent("" + loginName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUserGeneralSettings(loginName: string, organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/GetUserGeneralSettings/{loginName}/{organizationId}";
        if (loginName === undefined || loginName === null)
            throw new Error("The parameter 'loginName' must be defined.");
        url_ = url_.replace("{loginName}", encodeURIComponent("" + loginName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserGeneralSettings(_response);
        });
    }

    protected processGetUserGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSecurityGroup(organizationId: string, groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/CreateSecurityGroup/{organizationId}/{groupName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSecurityGroup(_response);
        });
    }

    protected processCreateSecurityGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSecurityGroupGeneralSettings(groupName: string, organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/GetSecurityGroupGeneralSettings/{groupName}/{organizationId}";
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSecurityGroupGeneralSettings(_response);
        });
    }

    protected processGetSecurityGroupGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSecurityGroupsNotes(organizationId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/GetSecurityGroupsNotes/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSecurityGroupsNotes(_response);
        });
    }

    protected processGetSecurityGroupsNotes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSecurityGroup(groupName: string, organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/DeleteSecurityGroup/{groupName}/{organizationId}";
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSecurityGroup(_response);
        });
    }

    protected processDeleteSecurityGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setSecurityGroupGeneralSettings(organizationId: string, groupName: string, notes: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/SetSecurityGroupGeneralSettings/{organizationId}/{groupName}/{notes}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        if (notes === undefined || notes === null)
            throw new Error("The parameter 'notes' must be defined.");
        url_ = url_.replace("{notes}", encodeURIComponent("" + notes));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetSecurityGroupGeneralSettings(_response);
        });
    }

    protected processSetSecurityGroupGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addObjectToSecurityGroup(organizationId: string, accountName: string, groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/AddObjectToSecurityGroup/{organizationId}/{accountName}/{groupName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddObjectToSecurityGroup(_response);
        });
    }

    protected processAddObjectToSecurityGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteObjectFromSecurityGroup(organizationId: string, accountName: string, groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/DeleteObjectFromSecurityGroup/{organizationId}/{accountName}/{groupName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteObjectFromSecurityGroup(_response);
        });
    }

    protected processDeleteObjectFromSecurityGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setUserGeneralSettings(organizationId: string, accountName: string, displayName: string, password: string, hideFromAddressBook: boolean, disabled: boolean, locked: boolean, firstName: string, initials: string, lastName: string, address: string, city: string, state: string, zip: string, country: string, jobTitle: string, company: string, department: string, office: string, managerAccountName: string, businessPhone: string, fax: string, homePhone: string, mobilePhone: string, pager: string, webPage: string, notes: string, externalEmail: string, userMustChangePassword: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/SetUserGeneralSettings/{organizationId}/{accountName}/{displayName}/{password}/{firstName}/{initials}/{lastName}/{address}/{city}/{state}/{zip}/{country}/{jobTitle}/{company}/{department}/{office}/{managerAccountName}/{businessPhone}/{fax}/{homePhone}/{mobilePhone}/{pager}/{webPage}/{notes}/{externalEmail}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        if (firstName === undefined || firstName === null)
            throw new Error("The parameter 'firstName' must be defined.");
        url_ = url_.replace("{firstName}", encodeURIComponent("" + firstName));
        if (initials === undefined || initials === null)
            throw new Error("The parameter 'initials' must be defined.");
        url_ = url_.replace("{initials}", encodeURIComponent("" + initials));
        if (lastName === undefined || lastName === null)
            throw new Error("The parameter 'lastName' must be defined.");
        url_ = url_.replace("{lastName}", encodeURIComponent("" + lastName));
        if (address === undefined || address === null)
            throw new Error("The parameter 'address' must be defined.");
        url_ = url_.replace("{address}", encodeURIComponent("" + address));
        if (city === undefined || city === null)
            throw new Error("The parameter 'city' must be defined.");
        url_ = url_.replace("{city}", encodeURIComponent("" + city));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined.");
        url_ = url_.replace("{state}", encodeURIComponent("" + state));
        if (zip === undefined || zip === null)
            throw new Error("The parameter 'zip' must be defined.");
        url_ = url_.replace("{zip}", encodeURIComponent("" + zip));
        if (country === undefined || country === null)
            throw new Error("The parameter 'country' must be defined.");
        url_ = url_.replace("{country}", encodeURIComponent("" + country));
        if (jobTitle === undefined || jobTitle === null)
            throw new Error("The parameter 'jobTitle' must be defined.");
        url_ = url_.replace("{jobTitle}", encodeURIComponent("" + jobTitle));
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company));
        if (department === undefined || department === null)
            throw new Error("The parameter 'department' must be defined.");
        url_ = url_.replace("{department}", encodeURIComponent("" + department));
        if (office === undefined || office === null)
            throw new Error("The parameter 'office' must be defined.");
        url_ = url_.replace("{office}", encodeURIComponent("" + office));
        if (managerAccountName === undefined || managerAccountName === null)
            throw new Error("The parameter 'managerAccountName' must be defined.");
        url_ = url_.replace("{managerAccountName}", encodeURIComponent("" + managerAccountName));
        if (businessPhone === undefined || businessPhone === null)
            throw new Error("The parameter 'businessPhone' must be defined.");
        url_ = url_.replace("{businessPhone}", encodeURIComponent("" + businessPhone));
        if (fax === undefined || fax === null)
            throw new Error("The parameter 'fax' must be defined.");
        url_ = url_.replace("{fax}", encodeURIComponent("" + fax));
        if (homePhone === undefined || homePhone === null)
            throw new Error("The parameter 'homePhone' must be defined.");
        url_ = url_.replace("{homePhone}", encodeURIComponent("" + homePhone));
        if (mobilePhone === undefined || mobilePhone === null)
            throw new Error("The parameter 'mobilePhone' must be defined.");
        url_ = url_.replace("{mobilePhone}", encodeURIComponent("" + mobilePhone));
        if (pager === undefined || pager === null)
            throw new Error("The parameter 'pager' must be defined.");
        url_ = url_.replace("{pager}", encodeURIComponent("" + pager));
        if (webPage === undefined || webPage === null)
            throw new Error("The parameter 'webPage' must be defined.");
        url_ = url_.replace("{webPage}", encodeURIComponent("" + webPage));
        if (notes === undefined || notes === null)
            throw new Error("The parameter 'notes' must be defined.");
        url_ = url_.replace("{notes}", encodeURIComponent("" + notes));
        if (externalEmail === undefined || externalEmail === null)
            throw new Error("The parameter 'externalEmail' must be defined.");
        url_ = url_.replace("{externalEmail}", encodeURIComponent("" + externalEmail));
        if (hideFromAddressBook === undefined || hideFromAddressBook === null)
            throw new Error("The parameter 'hideFromAddressBook' must be defined and cannot be null.");
        else
            url_ += "hideFromAddressBook=" + encodeURIComponent("" + hideFromAddressBook) + "&";
        if (disabled === undefined || disabled === null)
            throw new Error("The parameter 'disabled' must be defined and cannot be null.");
        else
            url_ += "disabled=" + encodeURIComponent("" + disabled) + "&";
        if (locked === undefined || locked === null)
            throw new Error("The parameter 'locked' must be defined and cannot be null.");
        else
            url_ += "locked=" + encodeURIComponent("" + locked) + "&";
        if (userMustChangePassword === undefined || userMustChangePassword === null)
            throw new Error("The parameter 'userMustChangePassword' must be defined and cannot be null.");
        else
            url_ += "userMustChangePassword=" + encodeURIComponent("" + userMustChangePassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetUserGeneralSettings(_response);
        });
    }

    protected processSetUserGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setUserPassword(organizationId: string, accountName: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/SetUserPassword/{organizationId}/{accountName}/{password}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetUserPassword(_response);
        });
    }

    protected processSetUserPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setUserPrincipalName(organizationId: string, accountName: string, userPrincipalName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/SetUserPrincipalName/{organizationId}/{accountName}/{userPrincipalName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (userPrincipalName === undefined || userPrincipalName === null)
            throw new Error("The parameter 'userPrincipalName' must be defined.");
        url_ = url_.replace("{userPrincipalName}", encodeURIComponent("" + userPrincipalName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetUserPrincipalName(_response);
        });
    }

    protected processSetUserPrincipalName(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteOrganizationDomain(organizationDistinguishedName: string, domain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/DeleteOrganizationDomain/{organizationDistinguishedName}/{domain}";
        if (organizationDistinguishedName === undefined || organizationDistinguishedName === null)
            throw new Error("The parameter 'organizationDistinguishedName' must be defined.");
        url_ = url_.replace("{organizationDistinguishedName}", encodeURIComponent("" + organizationDistinguishedName));
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOrganizationDomain(_response);
        });
    }

    protected processDeleteOrganizationDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createOrganizationDomain(organizationDistinguishedName: string, domain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/CreateOrganizationDomain/{organizationDistinguishedName}/{domain}";
        if (organizationDistinguishedName === undefined || organizationDistinguishedName === null)
            throw new Error("The parameter 'organizationDistinguishedName' must be defined.");
        url_ = url_.replace("{organizationDistinguishedName}", encodeURIComponent("" + organizationDistinguishedName));
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrganizationDomain(_response);
        });
    }

    protected processCreateOrganizationDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPasswordPolicy(): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/GetPasswordPolicy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPasswordPolicy(_response);
        });
    }

    protected processGetPasswordPolicy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSamAccountNameByUserPrincipalName(organizationId: string, userPrincipalName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/GetSamAccountNameByUserPrincipalName/{organizationId}/{userPrincipalName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (userPrincipalName === undefined || userPrincipalName === null)
            throw new Error("The parameter 'userPrincipalName' must be defined.");
        url_ = url_.replace("{userPrincipalName}", encodeURIComponent("" + userPrincipalName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSamAccountNameByUserPrincipalName(_response);
        });
    }

    protected processGetSamAccountNameByUserPrincipalName(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    doesSamAccountNameExist(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/DoesSamAccountNameExist/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDoesSamAccountNameExist(_response);
        });
    }

    protected processDoesSamAccountNameExist(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDriveMaps(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/GetDriveMaps/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDriveMaps(_response);
        });
    }

    protected processGetDriveMaps(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createMappedDrive(organizationId: string, drive: string, labelAs: string, path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/CreateMappedDrive/{organizationId}/{drive}/{labelAs}/{path}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (drive === undefined || drive === null)
            throw new Error("The parameter 'drive' must be defined.");
        url_ = url_.replace("{drive}", encodeURIComponent("" + drive));
        if (labelAs === undefined || labelAs === null)
            throw new Error("The parameter 'labelAs' must be defined.");
        url_ = url_.replace("{labelAs}", encodeURIComponent("" + labelAs));
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMappedDrive(_response);
        });
    }

    protected processCreateMappedDrive(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteMappedDrive(organizationId: string, drive: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/DeleteMappedDrive/{organizationId}/{drive}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (drive === undefined || drive === null)
            throw new Error("The parameter 'drive' must be defined.");
        url_ = url_.replace("{drive}", encodeURIComponent("" + drive));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMappedDrive(_response);
        });
    }

    protected processDeleteMappedDrive(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteMappedDriveByPath(organizationId: string, path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/DeleteMappedDriveByPath/{organizationId}/{path}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMappedDriveByPath(_response);
        });
    }

    protected processDeleteMappedDriveByPath(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteMappedDrivesGPO(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/DeleteMappedDrivesGPO/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMappedDrivesGPO(_response);
        });
    }

    protected processDeleteMappedDrivesGPO(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDriveMapsTargetingFilter(organizationId: string, folderName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/SetDriveMapsTargetingFilter/{organizationId}/{folderName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (folderName === undefined || folderName === null)
            throw new Error("The parameter 'folderName' must be defined.");
        url_ = url_.replace("{folderName}", encodeURIComponent("" + folderName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDriveMapsTargetingFilter(_response);
        });
    }

    protected processSetDriveMapsTargetingFilter(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeDriveMapFolderPath(organizationId: string, oldFolder: string, newFolder: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/ChangeDriveMapFolderPath/{organizationId}/{oldFolder}/{newFolder}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (oldFolder === undefined || oldFolder === null)
            throw new Error("The parameter 'oldFolder' must be defined.");
        url_ = url_.replace("{oldFolder}", encodeURIComponent("" + oldFolder));
        if (newFolder === undefined || newFolder === null)
            throw new Error("The parameter 'newFolder' must be defined.");
        url_ = url_.replace("{newFolder}", encodeURIComponent("" + newFolder));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeDriveMapFolderPath(_response);
        });
    }

    protected processChangeDriveMapFolderPath(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOrganizationUsersWithExpiredPassword(organizationId: string, daysBeforeExpiration: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/GetOrganizationUsersWithExpiredPassword/{organizationId}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (daysBeforeExpiration === undefined || daysBeforeExpiration === null)
            throw new Error("The parameter 'daysBeforeExpiration' must be defined and cannot be null.");
        else
            url_ += "daysBeforeExpiration=" + encodeURIComponent("" + daysBeforeExpiration) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrganizationUsersWithExpiredPassword(_response);
        });
    }

    protected processGetOrganizationUsersWithExpiredPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    applyPasswordSettings(organizationId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/ApplyPasswordSettings/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplyPasswordSettings(_response);
        });
    }

    protected processApplyPasswordSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkPhoneNumberIsInUse(phoneNumber: string, userSamAccountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/CheckPhoneNumberIsInUse/{phoneNumber}/{userSamAccountName}";
        if (phoneNumber === undefined || phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' must be defined.");
        url_ = url_.replace("{phoneNumber}", encodeURIComponent("" + phoneNumber));
        if (userSamAccountName === undefined || userSamAccountName === null)
            throw new Error("The parameter 'userSamAccountName' must be defined.");
        url_ = url_.replace("{userSamAccountName}", encodeURIComponent("" + userSamAccountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckPhoneNumberIsInUse(_response);
        });
    }

    protected processCheckPhoneNumberIsInUse(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOrganizationUserWithExtraData(loginName: string, organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/GetOrganizationUserWithExtraData/{loginName}/{organizationId}";
        if (loginName === undefined || loginName === null)
            throw new Error("The parameter 'loginName' must be defined.");
        url_ = url_.replace("{loginName}", encodeURIComponent("" + loginName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrganizationUserWithExtraData(_response);
        });
    }

    protected processGetOrganizationUserWithExtraData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setOUAclPermissions(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/SetOUAclPermissions/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetOUAclPermissions(_response);
        });
    }

    protected processSetOUAclPermissions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUserGroups(userName: string, organizationId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/GetUserGroups/{userName}?";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined and cannot be null.");
        else
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserGroups(_response);
        });
    }

    protected processGetUserGroups(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RemoteDesktopServicesClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createCollection(organizationId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/CreateCollection/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCollection(_response);
        });
    }

    protected processCreateCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    editRdsCollectionSettings(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/EditRdsCollectionSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditRdsCollectionSettings(_response);
        });
    }

    protected processEditRdsCollectionSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getRdsUserSessions(collectionName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetRdsUserSessions/{collectionName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRdsUserSessions(_response);
        });
    }

    protected processGetRdsUserSessions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addRdsServersToDeployment(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/AddRdsServersToDeployment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddRdsServersToDeployment(_response);
        });
    }

    protected processAddRdsServersToDeployment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCollection(collectionName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetCollection/{collectionName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCollection(_response);
        });
    }

    protected processGetCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeCollection(organizationId: string, collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/RemoveCollection/{organizationId}/{collectionName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveCollection(_response);
        });
    }

    protected processRemoveCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setUsersInCollection(organizationId: string, collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/SetUsersInCollection/{organizationId}/{collectionName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetUsersInCollection(_response);
        });
    }

    protected processSetUsersInCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addSessionHostServerToCollection(organizationId: string, collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/AddSessionHostServerToCollection/{organizationId}/{collectionName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddSessionHostServerToCollection(_response);
        });
    }

    protected processAddSessionHostServerToCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addSessionHostServersToCollection(organizationId: string, collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/AddSessionHostServersToCollection/{organizationId}/{collectionName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddSessionHostServersToCollection(_response);
        });
    }

    protected processAddSessionHostServersToCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeSessionHostServerFromCollection(organizationId: string, collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/RemoveSessionHostServerFromCollection/{organizationId}/{collectionName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveSessionHostServerFromCollection(_response);
        });
    }

    protected processRemoveSessionHostServerFromCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeSessionHostServersFromCollection(organizationId: string, collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/RemoveSessionHostServersFromCollection/{organizationId}/{collectionName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveSessionHostServersFromCollection(_response);
        });
    }

    protected processRemoveSessionHostServersFromCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setRDServerNewConnectionAllowed(newConnectionAllowed: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/SetRDServerNewConnectionAllowed/{newConnectionAllowed}";
        if (newConnectionAllowed === undefined || newConnectionAllowed === null)
            throw new Error("The parameter 'newConnectionAllowed' must be defined.");
        url_ = url_.replace("{newConnectionAllowed}", encodeURIComponent("" + newConnectionAllowed));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetRDServerNewConnectionAllowed(_response);
        });
    }

    protected processSetRDServerNewConnectionAllowed(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAvailableRemoteApplications(collectionName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetAvailableRemoteApplications/{collectionName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAvailableRemoteApplications(_response);
        });
    }

    protected processGetAvailableRemoteApplications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCollectionRemoteApplications(collectionName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetCollectionRemoteApplications/{collectionName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCollectionRemoteApplications(_response);
        });
    }

    protected processGetCollectionRemoteApplications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addRemoteApplication(collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/AddRemoteApplication/{collectionName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddRemoteApplication(_response);
        });
    }

    protected processAddRemoteApplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addRemoteApplications(collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/AddRemoteApplications/{collectionName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddRemoteApplications(_response);
        });
    }

    protected processAddRemoteApplications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeRemoteApplication(collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/RemoveRemoteApplication/{collectionName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveRemoteApplication(_response);
        });
    }

    protected processRemoveRemoteApplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addSessionHostFeatureToServer(hostName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/AddSessionHostFeatureToServer/{hostName}";
        if (hostName === undefined || hostName === null)
            throw new Error("The parameter 'hostName' must be defined.");
        url_ = url_.replace("{hostName}", encodeURIComponent("" + hostName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddSessionHostFeatureToServer(_response);
        });
    }

    protected processAddSessionHostFeatureToServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkSessionHostFeatureInstallation(hostName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/CheckSessionHostFeatureInstallation/{hostName}";
        if (hostName === undefined || hostName === null)
            throw new Error("The parameter 'hostName' must be defined.");
        url_ = url_.replace("{hostName}", encodeURIComponent("" + hostName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckSessionHostFeatureInstallation(_response);
        });
    }

    protected processCheckSessionHostFeatureInstallation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkServerAvailability(hostName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/CheckServerAvailability/{hostName}";
        if (hostName === undefined || hostName === null)
            throw new Error("The parameter 'hostName' must be defined.");
        url_ = url_.replace("{hostName}", encodeURIComponent("" + hostName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckServerAvailability(_response);
        });
    }

    protected processCheckServerAvailability(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getApplicationUsers(collectionName: string, applicationName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetApplicationUsers/{collectionName}/{applicationName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        if (applicationName === undefined || applicationName === null)
            throw new Error("The parameter 'applicationName' must be defined.");
        url_ = url_.replace("{applicationName}", encodeURIComponent("" + applicationName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApplicationUsers(_response);
        });
    }

    protected processGetApplicationUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setApplicationUsers(collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/SetApplicationUsers/{collectionName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetApplicationUsers(_response);
        });
    }

    protected processSetApplicationUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkRDSServerAvaliable(hostname: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/CheckRDSServerAvaliable/{hostname}";
        if (hostname === undefined || hostname === null)
            throw new Error("The parameter 'hostname' must be defined.");
        url_ = url_.replace("{hostname}", encodeURIComponent("" + hostname));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckRDSServerAvaliable(_response);
        });
    }

    protected processCheckRDSServerAvaliable(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getServersExistingInCollections(): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetServersExistingInCollections";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServersExistingInCollections(_response);
        });
    }

    protected processGetServersExistingInCollections(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    logOffRdsUser(unifiedSessionId: string, hostServer: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/LogOffRdsUser/{unifiedSessionId}/{hostServer}";
        if (unifiedSessionId === undefined || unifiedSessionId === null)
            throw new Error("The parameter 'unifiedSessionId' must be defined.");
        url_ = url_.replace("{unifiedSessionId}", encodeURIComponent("" + unifiedSessionId));
        if (hostServer === undefined || hostServer === null)
            throw new Error("The parameter 'hostServer' must be defined.");
        url_ = url_.replace("{hostServer}", encodeURIComponent("" + hostServer));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogOffRdsUser(_response);
        });
    }

    protected processLogOffRdsUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getRdsCollectionSessionHosts(collectionName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetRdsCollectionSessionHosts/{collectionName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRdsCollectionSessionHosts(_response);
        });
    }

    protected processGetRdsCollectionSessionHosts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getRdsServerInfo(serverName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetRdsServerInfo/{serverName}";
        if (serverName === undefined || serverName === null)
            throw new Error("The parameter 'serverName' must be defined.");
        url_ = url_.replace("{serverName}", encodeURIComponent("" + serverName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRdsServerInfo(_response);
        });
    }

    protected processGetRdsServerInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getRdsServerStatus(serverName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetRdsServerStatus/{serverName}";
        if (serverName === undefined || serverName === null)
            throw new Error("The parameter 'serverName' must be defined.");
        url_ = url_.replace("{serverName}", encodeURIComponent("" + serverName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRdsServerStatus(_response);
        });
    }

    protected processGetRdsServerStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shutDownRdsServer(serverName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/ShutDownRdsServer/{serverName}";
        if (serverName === undefined || serverName === null)
            throw new Error("The parameter 'serverName' must be defined.");
        url_ = url_.replace("{serverName}", encodeURIComponent("" + serverName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShutDownRdsServer(_response);
        });
    }

    protected processShutDownRdsServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    restartRdsServer(serverName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/RestartRdsServer/{serverName}";
        if (serverName === undefined || serverName === null)
            throw new Error("The parameter 'serverName' must be defined.");
        url_ = url_.replace("{serverName}", encodeURIComponent("" + serverName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRestartRdsServer(_response);
        });
    }

    protected processRestartRdsServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    saveRdsCollectionLocalAdmins(organizationId: string, collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/SaveRdsCollectionLocalAdmins/{organizationId}/{collectionName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveRdsCollectionLocalAdmins(_response);
        });
    }

    protected processSaveRdsCollectionLocalAdmins(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getRdsCollectionLocalAdmins(organizationId: string, collectionName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetRdsCollectionLocalAdmins/{organizationId}/{collectionName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRdsCollectionLocalAdmins(_response);
        });
    }

    protected processGetRdsCollectionLocalAdmins(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    moveRdsServerToTenantOU(hostName: string, organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/MoveRdsServerToTenantOU/{hostName}/{organizationId}";
        if (hostName === undefined || hostName === null)
            throw new Error("The parameter 'hostName' must be defined.");
        url_ = url_.replace("{hostName}", encodeURIComponent("" + hostName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveRdsServerToTenantOU(_response);
        });
    }

    protected processMoveRdsServerToTenantOU(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeRdsServerFromTenantOU(hostName: string, organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/RemoveRdsServerFromTenantOU/{hostName}/{organizationId}";
        if (hostName === undefined || hostName === null)
            throw new Error("The parameter 'hostName' must be defined.");
        url_ = url_.replace("{hostName}", encodeURIComponent("" + hostName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveRdsServerFromTenantOU(_response);
        });
    }

    protected processRemoveRdsServerFromTenantOU(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installCertificate(certificate: any, password: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/InstallCertificate/{password}?";
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        if (certificate === undefined || certificate === null)
            throw new Error("The parameter 'certificate' must be defined and cannot be null.");
        else
            url_ += "certificate=" + encodeURIComponent("" + certificate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallCertificate(_response);
        });
    }

    protected processInstallCertificate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    moveSessionHostToRdsOU(hostName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/MoveSessionHostToRdsOU/{hostName}";
        if (hostName === undefined || hostName === null)
            throw new Error("The parameter 'hostName' must be defined.");
        url_ = url_.replace("{hostName}", encodeURIComponent("" + hostName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveSessionHostToRdsOU(_response);
        });
    }

    protected processMoveSessionHostToRdsOU(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    applyGPO(organizationId: string, collectionName: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/ApplyGPO/{organizationId}/{collectionName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplyGPO(_response);
        });
    }

    protected processApplyGPO(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shadowSession(sessionId: string, fqdName: string, control: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/ShadowSession/{sessionId}/{fqdName}?";
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        if (fqdName === undefined || fqdName === null)
            throw new Error("The parameter 'fqdName' must be defined.");
        url_ = url_.replace("{fqdName}", encodeURIComponent("" + fqdName));
        if (control === undefined || control === null)
            throw new Error("The parameter 'control' must be defined and cannot be null.");
        else
            url_ += "control=" + encodeURIComponent("" + control) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShadowSession(_response);
        });
    }

    protected processShadowSession(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    moveSessionHostsToCollectionOU(collectionName: string, organizationId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/MoveSessionHostsToCollectionOU/{collectionName}/{organizationId}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveSessionHostsToCollectionOU(_response);
        });
    }

    protected processMoveSessionHostsToCollectionOU(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getExistingCollection(collectionName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetExistingCollection/{collectionName}";
        if (collectionName === undefined || collectionName === null)
            throw new Error("The parameter 'collectionName' must be defined.");
        url_ = url_.replace("{collectionName}", encodeURIComponent("" + collectionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExistingCollection(_response);
        });
    }

    protected processGetExistingCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    importCollection(organizationId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/ImportCollection/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportCollection(_response);
        });
    }

    protected processImportCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    sendMessage(text: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/SendMessage/{text}";
        if (text === undefined || text === null)
            throw new Error("The parameter 'text' must be defined.");
        url_ = url_.replace("{text}", encodeURIComponent("" + text));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendMessage(_response);
        });
    }

    protected processSendMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getServerIp(hostName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/RemoteDesktopServices/GetServerIp/{hostName}";
        if (hostName === undefined || hostName === null)
            throw new Error("The parameter 'hostName' must be defined.");
        url_ = url_.replace("{hostName}", encodeURIComponent("" + hostName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServerIp(_response);
        });
    }

    protected processGetServerIp(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ServiceProviderClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    install(): Promise<void> {
        let url_ = this.baseUrl + "/api/ServiceProvider/Install";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstall(_response);
        });
    }

    protected processInstall(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getProviderDefaultSettings(): Promise<void> {
        let url_ = this.baseUrl + "/api/ServiceProvider/GetProviderDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProviderDefaultSettings(_response);
        });
    }

    protected processGetProviderDefaultSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    uninstall(): Promise<void> {
        let url_ = this.baseUrl + "/api/ServiceProvider/Uninstall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUninstall(_response);
        });
    }

    protected processUninstall(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    isInstalled(): Promise<void> {
        let url_ = this.baseUrl + "/api/ServiceProvider/IsInstalled";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsInstalled(_response);
        });
    }

    protected processIsInstalled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeServiceItemsState(enabled: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ServiceProvider/ChangeServiceItemsState?";
        if (enabled === undefined || enabled === null)
            throw new Error("The parameter 'enabled' must be defined and cannot be null.");
        else
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeServiceItemsState(_response);
        });
    }

    protected processChangeServiceItemsState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteServiceItems(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ServiceProvider/DeleteServiceItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteServiceItems(_response);
        });
    }

    protected processDeleteServiceItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getServiceItemsDiskSpace(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ServiceProvider/GetServiceItemsDiskSpace";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServiceItemsDiskSpace(_response);
        });
    }

    protected processGetServiceItemsDiskSpace(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getServiceItemsBandwidth(since: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/ServiceProvider/GetServiceItemsBandwidth?";
        if (since === undefined || since === null)
            throw new Error("The parameter 'since' must be defined and cannot be null.");
        else
            url_ += "since=" + encodeURIComponent("" + since) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServiceItemsBandwidth(_response);
        });
    }

    protected processGetServiceItemsBandwidth(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCryptoKey(): Promise<void> {
        let url_ = this.baseUrl + "/api/ServiceProvider/GetCryptoKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCryptoKey(_response);
        });
    }

    protected processGetCryptoKey(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SfBServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createOrganization(organizationId: string, sipDomain: string, enableConferencing: boolean, enableConferencingVideo: boolean, maxConferenceSize: number, enabledFederation: boolean, enabledEnterpriseVoice: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/CreateOrganization/{organizationId}/{sipDomain}?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (sipDomain === undefined || sipDomain === null)
            throw new Error("The parameter 'sipDomain' must be defined.");
        url_ = url_.replace("{sipDomain}", encodeURIComponent("" + sipDomain));
        if (enableConferencing === undefined || enableConferencing === null)
            throw new Error("The parameter 'enableConferencing' must be defined and cannot be null.");
        else
            url_ += "enableConferencing=" + encodeURIComponent("" + enableConferencing) + "&";
        if (enableConferencingVideo === undefined || enableConferencingVideo === null)
            throw new Error("The parameter 'enableConferencingVideo' must be defined and cannot be null.");
        else
            url_ += "enableConferencingVideo=" + encodeURIComponent("" + enableConferencingVideo) + "&";
        if (maxConferenceSize === undefined || maxConferenceSize === null)
            throw new Error("The parameter 'maxConferenceSize' must be defined and cannot be null.");
        else
            url_ += "maxConferenceSize=" + encodeURIComponent("" + maxConferenceSize) + "&";
        if (enabledFederation === undefined || enabledFederation === null)
            throw new Error("The parameter 'enabledFederation' must be defined and cannot be null.");
        else
            url_ += "enabledFederation=" + encodeURIComponent("" + enabledFederation) + "&";
        if (enabledEnterpriseVoice === undefined || enabledEnterpriseVoice === null)
            throw new Error("The parameter 'enabledEnterpriseVoice' must be defined and cannot be null.");
        else
            url_ += "enabledEnterpriseVoice=" + encodeURIComponent("" + enabledEnterpriseVoice) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrganization(_response);
        });
    }

    protected processCreateOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOrganizationTenantId(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/GetOrganizationTenantId/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrganizationTenantId(_response);
        });
    }

    protected processGetOrganizationTenantId(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteOrganization(organizationId: string, sipDomain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/DeleteOrganization/{organizationId}/{sipDomain}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (sipDomain === undefined || sipDomain === null)
            throw new Error("The parameter 'sipDomain' must be defined.");
        url_ = url_.replace("{sipDomain}", encodeURIComponent("" + sipDomain));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOrganization(_response);
        });
    }

    protected processDeleteOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createUser(organizationId: string, userUpn: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/CreateUser/{organizationId}/{userUpn}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSfBUserGeneralSettings(organizationId: string, userUpn: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/GetSfBUserGeneralSettings/{organizationId}/{userUpn}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSfBUserGeneralSettings(_response);
        });
    }

    protected processGetSfBUserGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setSfBUserGeneralSettings(organizationId: string, userUpn: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/SetSfBUserGeneralSettings/{organizationId}/{userUpn}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetSfBUserGeneralSettings(_response);
        });
    }

    protected processSetSfBUserGeneralSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setSfBUserPlan(organizationId: string, userUpn: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/SetSfBUserPlan/{organizationId}/{userUpn}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetSfBUserPlan(_response);
        });
    }

    protected processSetSfBUserPlan(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUser(userUpn: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/DeleteUser/{userUpn}";
        if (userUpn === undefined || userUpn === null)
            throw new Error("The parameter 'userUpn' must be defined.");
        url_ = url_.replace("{userUpn}", encodeURIComponent("" + userUpn));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFederationDomains(organizationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/GetFederationDomains/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFederationDomains(_response);
        });
    }

    protected processGetFederationDomains(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addFederationDomain(organizationId: string, domainName: string, proxyFqdn: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/AddFederationDomain/{organizationId}/{domainName}/{proxyFqdn}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        if (proxyFqdn === undefined || proxyFqdn === null)
            throw new Error("The parameter 'proxyFqdn' must be defined.");
        url_ = url_.replace("{proxyFqdn}", encodeURIComponent("" + proxyFqdn));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddFederationDomain(_response);
        });
    }

    protected processAddFederationDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeFederationDomain(organizationId: string, domainName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/RemoveFederationDomain/{organizationId}/{domainName}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveFederationDomain(_response);
        });
    }

    protected processRemoveFederationDomain(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    reloadConfiguration(): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/ReloadConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReloadConfiguration(_response);
        });
    }

    protected processReloadConfiguration(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPolicyList(type: any, name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SfBServer/GetPolicyList/{name}?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPolicyList(_response);
        });
    }

    protected processGetPolicyList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SharePointServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    extendVirtualServer(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/ExtendVirtualServer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExtendVirtualServer(_response);
        });
    }

    protected processExtendVirtualServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    unextendVirtualServer(url: string, deleteContent: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/UnextendVirtualServer/{url}?";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        if (deleteContent === undefined || deleteContent === null)
            throw new Error("The parameter 'deleteContent' must be defined and cannot be null.");
        else
            url_ += "deleteContent=" + encodeURIComponent("" + deleteContent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnextendVirtualServer(_response);
        });
    }

    protected processUnextendVirtualServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    backupVirtualServer(url: string, fileName: string, zipBackup: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/BackupVirtualServer/{url}/{fileName}?";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (zipBackup === undefined || zipBackup === null)
            throw new Error("The parameter 'zipBackup' must be defined and cannot be null.");
        else
            url_ += "zipBackup=" + encodeURIComponent("" + zipBackup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBackupVirtualServer(_response);
        });
    }

    protected processBackupVirtualServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    restoreVirtualServer(url: string, fileName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/RestoreVirtualServer/{url}/{fileName}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRestoreVirtualServer(_response);
        });
    }

    protected processRestoreVirtualServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getTempFileBinaryChunk(path: string, offset: number, length: number): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/GetTempFileBinaryChunk/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (offset === undefined || offset === null)
            throw new Error("The parameter 'offset' must be defined and cannot be null.");
        else
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (length === undefined || length === null)
            throw new Error("The parameter 'length' must be defined and cannot be null.");
        else
            url_ += "length=" + encodeURIComponent("" + length) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTempFileBinaryChunk(_response);
        });
    }

    protected processGetTempFileBinaryChunk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    appendTempFileBinaryChunk(fileName: string, path: string, chunk: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/AppendTempFileBinaryChunk/{fileName}/{path}?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (chunk === undefined || chunk === null)
            throw new Error("The parameter 'chunk' must be defined and cannot be null.");
        else
            url_ += "chunk=" + encodeURIComponent("" + chunk) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAppendTempFileBinaryChunk(_response);
        });
    }

    protected processAppendTempFileBinaryChunk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getInstalledWebParts(url: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/GetInstalledWebParts/{url}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInstalledWebParts(_response);
        });
    }

    protected processGetInstalledWebParts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installWebPartsPackage(url: string, packageName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/InstallWebPartsPackage/{url}/{packageName}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        if (packageName === undefined || packageName === null)
            throw new Error("The parameter 'packageName' must be defined.");
        url_ = url_.replace("{packageName}", encodeURIComponent("" + packageName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallWebPartsPackage(_response);
        });
    }

    protected processInstallWebPartsPackage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteWebPartsPackage(url: string, packageName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/DeleteWebPartsPackage/{url}/{packageName}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url));
        if (packageName === undefined || packageName === null)
            throw new Error("The parameter 'packageName' must be defined.");
        url_ = url_.replace("{packageName}", encodeURIComponent("" + packageName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteWebPartsPackage(_response);
        });
    }

    protected processDeleteWebPartsPackage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    userExists(username: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/UserExists/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserExists(_response);
        });
    }

    protected processUserExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUsers(): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUser(username: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/GetUser/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createUser(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateUser(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeUserPassword(username: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/ChangeUserPassword/{username}/{password}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeUserPassword(_response);
        });
    }

    protected processChangeUserPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUser(username: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/DeleteUser/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    groupExists(groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/GroupExists/{groupName}";
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGroupExists(_response);
        });
    }

    protected processGroupExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGroups(): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/GetGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroups(_response);
        });
    }

    protected processGetGroups(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGroup(groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/GetGroup/{groupName}";
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroup(_response);
        });
    }

    protected processGetGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createGroup(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/CreateGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateGroup(_response);
        });
    }

    protected processCreateGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateGroup(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/UpdateGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateGroup(_response);
        });
    }

    protected processUpdateGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteGroup(groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SharePointServer/DeleteGroup/{groupName}";
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteGroup(_response);
        });
    }

    protected processDeleteGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SpamExpertsClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    addDomainFilter(domain: string, password: string, email: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SpamExperts/AddDomainFilter/{domain}/{password}/{email}";
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddDomainFilter(_response);
        });
    }

    protected processAddDomainFilter(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addEmailFilter(name: string, domain: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SpamExperts/AddEmailFilter/{name}/{domain}/{password}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddEmailFilter(_response);
        });
    }

    protected processAddEmailFilter(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteDomainFilter(domain: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SpamExperts/DeleteDomainFilter/{domain}";
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDomainFilter(_response);
        });
    }

    protected processDeleteDomainFilter(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteEmailFilter(email: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SpamExperts/DeleteEmailFilter/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEmailFilter(_response);
        });
    }

    protected processDeleteEmailFilter(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDomainFilterDestinations(name: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/SpamExperts/SetDomainFilterDestinations/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDomainFilterDestinations(_response);
        });
    }

    protected processSetDomainFilterDestinations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDomainFilterUser(domain: string, password: string, email: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SpamExperts/SetDomainFilterUser/{domain}/{password}/{email}";
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDomainFilterUser(_response);
        });
    }

    protected processSetDomainFilterUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDomainFilterUserPassword(name: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SpamExperts/SetDomainFilterUserPassword/{name}/{password}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDomainFilterUserPassword(_response);
        });
    }

    protected processSetDomainFilterUserPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setEmailFilterUserPassword(email: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SpamExperts/SetEmailFilterUserPassword/{email}/{password}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetEmailFilterUserPassword(_response);
        });
    }

    protected processSetEmailFilterUserPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addDomainFilterAlias(domain: string, alias: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SpamExperts/AddDomainFilterAlias/{domain}/{alias}";
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        if (alias === undefined || alias === null)
            throw new Error("The parameter 'alias' must be defined.");
        url_ = url_.replace("{alias}", encodeURIComponent("" + alias));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddDomainFilterAlias(_response);
        });
    }

    protected processAddDomainFilterAlias(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteDomainFilterAlias(domain: string, alias: string): Promise<void> {
        let url_ = this.baseUrl + "/api/SpamExperts/DeleteDomainFilterAlias/{domain}/{alias}";
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        if (alias === undefined || alias === null)
            throw new Error("The parameter 'alias' must be defined.");
        url_ = url_.replace("{alias}", encodeURIComponent("" + alias));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDomainFilterAlias(_response);
        });
    }

    protected processDeleteDomainFilterAlias(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class StatisticsServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getServers(): Promise<void> {
        let url_ = this.baseUrl + "/api/StatisticsServer/GetServers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServers(_response);
        });
    }

    protected processGetServers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSiteId(siteName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StatisticsServer/GetSiteId/{siteName}";
        if (siteName === undefined || siteName === null)
            throw new Error("The parameter 'siteName' must be defined.");
        url_ = url_.replace("{siteName}", encodeURIComponent("" + siteName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSiteId(_response);
        });
    }

    protected processGetSiteId(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSites(): Promise<void> {
        let url_ = this.baseUrl + "/api/StatisticsServer/GetSites";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSites(_response);
        });
    }

    protected processGetSites(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSite(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StatisticsServer/GetSite/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSite(_response);
        });
    }

    protected processGetSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addSite(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/StatisticsServer/AddSite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddSite(_response);
        });
    }

    protected processAddSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateSite(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/StatisticsServer/UpdateSite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSite(_response);
        });
    }

    protected processUpdateSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSite(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StatisticsServer/DeleteSite/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSite(_response);
        });
    }

    protected processDeleteSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class StorageSpaceServicesClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAllDriveLetters(): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/GetAllDriveLetters";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllDriveLetters(_response);
        });
    }

    protected processGetAllDriveLetters(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSystemSubFolders(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/GetSystemSubFolders/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSystemSubFolders(_response);
        });
    }

    protected processGetSystemSubFolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateStorageSettings(fullPath: string, qouteSizeBytes: number, type: any): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/UpdateStorageSettings/{fullPath}?";
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined.");
        url_ = url_.replace("{fullPath}", encodeURIComponent("" + fullPath));
        if (qouteSizeBytes === undefined || qouteSizeBytes === null)
            throw new Error("The parameter 'qouteSizeBytes' must be defined and cannot be null.");
        else
            url_ += "qouteSizeBytes=" + encodeURIComponent("" + qouteSizeBytes) + "&";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateStorageSettings(_response);
        });
    }

    protected processUpdateStorageSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    clearStorageSettings(fullPath: string, uncPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/ClearStorageSettings/{fullPath}/{uncPath}";
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined.");
        url_ = url_.replace("{fullPath}", encodeURIComponent("" + fullPath));
        if (uncPath === undefined || uncPath === null)
            throw new Error("The parameter 'uncPath' must be defined.");
        url_ = url_.replace("{uncPath}", encodeURIComponent("" + uncPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearStorageSettings(_response);
        });
    }

    protected processClearStorageSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateFolderQuota(fullPath: string, qouteSizeBytes: number, type: any): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/UpdateFolderQuota/{fullPath}?";
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined.");
        url_ = url_.replace("{fullPath}", encodeURIComponent("" + fullPath));
        if (qouteSizeBytes === undefined || qouteSizeBytes === null)
            throw new Error("The parameter 'qouteSizeBytes' must be defined and cannot be null.");
        else
            url_ += "qouteSizeBytes=" + encodeURIComponent("" + qouteSizeBytes) + "&";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFolderQuota(_response);
        });
    }

    protected processUpdateFolderQuota(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createFolder(fullPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/CreateFolder/{fullPath}";
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined.");
        url_ = url_.replace("{fullPath}", encodeURIComponent("" + fullPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFolder(_response);
        });
    }

    protected processCreateFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shareFolder(fullPath: string, shareName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/ShareFolder/{fullPath}/{shareName}";
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined.");
        url_ = url_.replace("{fullPath}", encodeURIComponent("" + fullPath));
        if (shareName === undefined || shareName === null)
            throw new Error("The parameter 'shareName' must be defined.");
        url_ = url_.replace("{shareName}", encodeURIComponent("" + shareName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShareFolder(_response);
        });
    }

    protected processShareFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFolderQuota(fullPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/GetFolderQuota/{fullPath}";
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined.");
        url_ = url_.replace("{fullPath}", encodeURIComponent("" + fullPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFolderQuota(_response);
        });
    }

    protected processGetFolderQuota(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteFolder(fullPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/DeleteFolder/{fullPath}";
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined.");
        url_ = url_.replace("{fullPath}", encodeURIComponent("" + fullPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFolder(_response);
        });
    }

    protected processDeleteFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    renameFolder(originalPath: string, newName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/RenameFolder/{originalPath}/{newName}";
        if (originalPath === undefined || originalPath === null)
            throw new Error("The parameter 'originalPath' must be defined.");
        url_ = url_.replace("{originalPath}", encodeURIComponent("" + originalPath));
        if (newName === undefined || newName === null)
            throw new Error("The parameter 'newName' must be defined.");
        url_ = url_.replace("{newName}", encodeURIComponent("" + newName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameFolder(_response);
        });
    }

    protected processRenameFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    fileOrDirectoryExist(fullPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/FileOrDirectoryExist/{fullPath}";
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined.");
        url_ = url_.replace("{fullPath}", encodeURIComponent("" + fullPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFileOrDirectoryExist(_response);
        });
    }

    protected processFileOrDirectoryExist(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setFolderNtfsPermissions(fullPath: string, isProtected: boolean, preserveInheritance: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/SetFolderNtfsPermissions/{fullPath}?";
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined.");
        url_ = url_.replace("{fullPath}", encodeURIComponent("" + fullPath));
        if (isProtected === undefined || isProtected === null)
            throw new Error("The parameter 'isProtected' must be defined and cannot be null.");
        else
            url_ += "isProtected=" + encodeURIComponent("" + isProtected) + "&";
        if (preserveInheritance === undefined || preserveInheritance === null)
            throw new Error("The parameter 'preserveInheritance' must be defined and cannot be null.");
        else
            url_ += "preserveInheritance=" + encodeURIComponent("" + preserveInheritance) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetFolderNtfsPermissions(_response);
        });
    }

    protected processSetFolderNtfsPermissions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    search(searchText: string, recursive: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/Search/{searchText}?";
        if (searchText === undefined || searchText === null)
            throw new Error("The parameter 'searchText' must be defined.");
        url_ = url_.replace("{searchText}", encodeURIComponent("" + searchText));
        if (recursive === undefined || recursive === null)
            throw new Error("The parameter 'recursive' must be defined and cannot be null.");
        else
            url_ += "recursive=" + encodeURIComponent("" + recursive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFileBinaryChunk(path: string, offset: number, length: number): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/GetFileBinaryChunk/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (offset === undefined || offset === null)
            throw new Error("The parameter 'offset' must be defined and cannot be null.");
        else
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (length === undefined || length === null)
            throw new Error("The parameter 'length' must be defined and cannot be null.");
        else
            url_ += "length=" + encodeURIComponent("" + length) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFileBinaryChunk(_response);
        });
    }

    protected processGetFileBinaryChunk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeShare(fullPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/RemoveShare/{fullPath}";
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined.");
        url_ = url_.replace("{fullPath}", encodeURIComponent("" + fullPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveShare(_response);
        });
    }

    protected processRemoveShare(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shareSetAbeState(path: string, enabled: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/ShareSetAbeState/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (enabled === undefined || enabled === null)
            throw new Error("The parameter 'enabled' must be defined and cannot be null.");
        else
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShareSetAbeState(_response);
        });
    }

    protected processShareSetAbeState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shareSetEncyptDataAccess(path: string, enabled: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/ShareSetEncyptDataAccess/{path}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (enabled === undefined || enabled === null)
            throw new Error("The parameter 'enabled' must be defined and cannot be null.");
        else
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShareSetEncyptDataAccess(_response);
        });
    }

    protected processShareSetEncyptDataAccess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shareGetEncyptDataAccessStatus(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/ShareGetEncyptDataAccessStatus/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShareGetEncyptDataAccessStatus(_response);
        });
    }

    protected processShareGetEncyptDataAccessStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shareGetAbeState(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/StorageSpaceServices/ShareGetAbeState/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShareGetAbeState(_response);
        });
    }

    protected processShareGetAbeState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TestClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    echo(message: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Test/Echo/{message}";
        if (message === undefined || message === null)
            throw new Error("The parameter 'message' must be defined.");
        url_ = url_.replace("{message}", encodeURIComponent("" + message));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEcho(_response);
        });
    }

    protected processEcho(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    echoSettings(): Promise<void> {
        let url_ = this.baseUrl + "/api/Test/EchoSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEchoSettings(_response);
        });
    }

    protected processEchoSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    touch(): Promise<void> {
        let url_ = this.baseUrl + "/api/Test/Touch";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTouch(_response);
        });
    }

    protected processTouch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TestWithAuthenticationClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    echo(message: string): Promise<void> {
        let url_ = this.baseUrl + "/api/TestWithAuthentication/Echo/{message}";
        if (message === undefined || message === null)
            throw new Error("The parameter 'message' must be defined.");
        url_ = url_.replace("{message}", encodeURIComponent("" + message));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEcho(_response);
        });
    }

    protected processEcho(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    echoSettings(): Promise<void> {
        let url_ = this.baseUrl + "/api/TestWithAuthentication/EchoSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEchoSettings(_response);
        });
    }

    protected processEchoSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VirtualizationServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getVirtualMachine(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetVirtualMachine/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachine(_response);
        });
    }

    protected processGetVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineEx(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetVirtualMachineEx/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineEx(_response);
        });
    }

    protected processGetVirtualMachineEx(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachines(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetVirtualMachines";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachines(_response);
        });
    }

    protected processGetVirtualMachines(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineThumbnailImage(vmId: string, size: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetVirtualMachineThumbnailImage/{vmId}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined and cannot be null.");
        else
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineThumbnailImage(_response);
        });
    }

    protected processGetVirtualMachineThumbnailImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createVirtualMachine(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/CreateVirtualMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateVirtualMachine(_response);
        });
    }

    protected processCreateVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateVirtualMachine(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/UpdateVirtualMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateVirtualMachine(_response);
        });
    }

    protected processUpdateVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeVirtualMachineState(vmId: string, newState: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/ChangeVirtualMachineState/{vmId}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (newState === undefined || newState === null)
            throw new Error("The parameter 'newState' must be defined and cannot be null.");
        else
            url_ += "newState=" + encodeURIComponent("" + newState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeVirtualMachineState(_response);
        });
    }

    protected processChangeVirtualMachineState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shutDownVirtualMachine(vmId: string, force: boolean, reason: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/ShutDownVirtualMachine/{vmId}/{reason}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined.");
        url_ = url_.replace("{reason}", encodeURIComponent("" + reason));
        if (force === undefined || force === null)
            throw new Error("The parameter 'force' must be defined and cannot be null.");
        else
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShutDownVirtualMachine(_response);
        });
    }

    protected processShutDownVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineJobs(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetVirtualMachineJobs/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineJobs(_response);
        });
    }

    protected processGetVirtualMachineJobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    renameVirtualMachine(vmId: string, name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/RenameVirtualMachine/{vmId}/{name}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameVirtualMachine(_response);
        });
    }

    protected processRenameVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteVirtualMachine(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/DeleteVirtualMachine/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteVirtualMachine(_response);
        });
    }

    protected processDeleteVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    exportVirtualMachine(vmId: string, exportPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/ExportVirtualMachine/{vmId}/{exportPath}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (exportPath === undefined || exportPath === null)
            throw new Error("The parameter 'exportPath' must be defined.");
        url_ = url_.replace("{exportPath}", encodeURIComponent("" + exportPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportVirtualMachine(_response);
        });
    }

    protected processExportVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineSnapshots(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetVirtualMachineSnapshots/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineSnapshots(_response);
        });
    }

    protected processGetVirtualMachineSnapshots(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSnapshot(snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetSnapshot/{snapshotId}";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSnapshot(_response);
        });
    }

    protected processGetSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSnapshot(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/CreateSnapshot/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSnapshot(_response);
        });
    }

    protected processCreateSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    renameSnapshot(vmId: string, snapshotId: string, name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/RenameSnapshot/{vmId}/{snapshotId}/{name}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameSnapshot(_response);
        });
    }

    protected processRenameSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    applySnapshot(vmId: string, snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/ApplySnapshot/{vmId}/{snapshotId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplySnapshot(_response);
        });
    }

    protected processApplySnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSnapshot(snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/DeleteSnapshot/{snapshotId}";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSnapshot(_response);
        });
    }

    protected processDeleteSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSnapshotSubtree(snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/DeleteSnapshotSubtree/{snapshotId}";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSnapshotSubtree(_response);
        });
    }

    protected processDeleteSnapshotSubtree(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSnapshotThumbnailImage(snapshotId: string, size: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetSnapshotThumbnailImage/{snapshotId}?";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined and cannot be null.");
        else
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSnapshotThumbnailImage(_response);
        });
    }

    protected processGetSnapshotThumbnailImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getExternalSwitches(computerName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetExternalSwitches/{computerName}";
        if (computerName === undefined || computerName === null)
            throw new Error("The parameter 'computerName' must be defined.");
        url_ = url_.replace("{computerName}", encodeURIComponent("" + computerName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalSwitches(_response);
        });
    }

    protected processGetExternalSwitches(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSwitches(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetSwitches";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSwitches(_response);
        });
    }

    protected processGetSwitches(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    switchExists(switchId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/SwitchExists/{switchId}";
        if (switchId === undefined || switchId === null)
            throw new Error("The parameter 'switchId' must be defined.");
        url_ = url_.replace("{switchId}", encodeURIComponent("" + switchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSwitchExists(_response);
        });
    }

    protected processSwitchExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSwitch(name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/CreateSwitch/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSwitch(_response);
        });
    }

    protected processCreateSwitch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSwitch(switchId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/DeleteSwitch/{switchId}";
        if (switchId === undefined || switchId === null)
            throw new Error("The parameter 'switchId' must be defined.");
        url_ = url_.replace("{switchId}", encodeURIComponent("" + switchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSwitch(_response);
        });
    }

    protected processDeleteSwitch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getInsertedDVD(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetInsertedDVD/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInsertedDVD(_response);
        });
    }

    protected processGetInsertedDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    insertDVD(vmId: string, isoPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/InsertDVD/{vmId}/{isoPath}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (isoPath === undefined || isoPath === null)
            throw new Error("The parameter 'isoPath' must be defined.");
        url_ = url_.replace("{isoPath}", encodeURIComponent("" + isoPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertDVD(_response);
        });
    }

    protected processInsertDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    ejectDVD(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/EjectDVD/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEjectDVD(_response);
        });
    }

    protected processEjectDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getLibraryItems(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetLibraryItems/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLibraryItems(_response);
        });
    }

    protected processGetLibraryItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getKVPItems(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetKVPItems(_response);
        });
    }

    protected processGetKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getStandardKVPItems(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetStandardKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStandardKVPItems(_response);
        });
    }

    protected processGetStandardKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/AddKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddKVPItems(_response);
        });
    }

    protected processAddKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/RemoveKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveKVPItems(_response);
        });
    }

    protected processRemoveKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    modifyKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/ModifyKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModifyKVPItems(_response);
        });
    }

    protected processModifyKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualHardDiskInfo(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetVirtualHardDiskInfo/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualHardDiskInfo(_response);
        });
    }

    protected processGetVirtualHardDiskInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    mountVirtualHardDisk(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/MountVirtualHardDisk/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMountVirtualHardDisk(_response);
        });
    }

    protected processMountVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    unmountVirtualHardDisk(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/UnmountVirtualHardDisk/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnmountVirtualHardDisk(_response);
        });
    }

    protected processUnmountVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    expandVirtualHardDisk(vhdPath: string, sizeGB: number): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/ExpandVirtualHardDisk/{vhdPath}?";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        if (sizeGB === undefined || sizeGB === null)
            throw new Error("The parameter 'sizeGB' must be defined and cannot be null.");
        else
            url_ += "sizeGB=" + encodeURIComponent("" + sizeGB) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExpandVirtualHardDisk(_response);
        });
    }

    protected processExpandVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    convertVirtualHardDisk(sourcePath: string, destinationPath: string, diskType: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/ConvertVirtualHardDisk/{sourcePath}/{destinationPath}?";
        if (sourcePath === undefined || sourcePath === null)
            throw new Error("The parameter 'sourcePath' must be defined.");
        url_ = url_.replace("{sourcePath}", encodeURIComponent("" + sourcePath));
        if (destinationPath === undefined || destinationPath === null)
            throw new Error("The parameter 'destinationPath' must be defined.");
        url_ = url_.replace("{destinationPath}", encodeURIComponent("" + destinationPath));
        if (diskType === undefined || diskType === null)
            throw new Error("The parameter 'diskType' must be defined and cannot be null.");
        else
            url_ += "diskType=" + encodeURIComponent("" + diskType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConvertVirtualHardDisk(_response);
        });
    }

    protected processConvertVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteRemoteFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/DeleteRemoteFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRemoteFile(_response);
        });
    }

    protected processDeleteRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    expandDiskVolume(diskAddress: string, volumeName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/ExpandDiskVolume/{diskAddress}/{volumeName}";
        if (diskAddress === undefined || diskAddress === null)
            throw new Error("The parameter 'diskAddress' must be defined.");
        url_ = url_.replace("{diskAddress}", encodeURIComponent("" + diskAddress));
        if (volumeName === undefined || volumeName === null)
            throw new Error("The parameter 'volumeName' must be defined.");
        url_ = url_.replace("{volumeName}", encodeURIComponent("" + volumeName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExpandDiskVolume(_response);
        });
    }

    protected processExpandDiskVolume(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    readRemoteFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/ReadRemoteFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReadRemoteFile(_response);
        });
    }

    protected processReadRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    writeRemoteFile(path: string, content: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/WriteRemoteFile/{path}/{content}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (content === undefined || content === null)
            throw new Error("The parameter 'content' must be defined.");
        url_ = url_.replace("{content}", encodeURIComponent("" + content));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWriteRemoteFile(_response);
        });
    }

    protected processWriteRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getJob(jobId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetJob/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJob(_response);
        });
    }

    protected processGetJob(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAllJobs(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetAllJobs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllJobs(_response);
        });
    }

    protected processGetAllJobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeJobState(jobId: string, newState: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/ChangeJobState/{jobId}?";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        if (newState === undefined || newState === null)
            throw new Error("The parameter 'newState' must be defined and cannot be null.");
        else
            url_ += "newState=" + encodeURIComponent("" + newState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeJobState(_response);
        });
    }

    protected processChangeJobState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getProcessorCoresNumber(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer/GetProcessorCoresNumber";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProcessorCoresNumber(_response);
        });
    }

    protected processGetProcessorCoresNumber(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VirtualizationServer2012Client extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getVirtualMachine(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetVirtualMachine/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachine(_response);
        });
    }

    protected processGetVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineEx(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetVirtualMachineEx/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineEx(_response);
        });
    }

    protected processGetVirtualMachineEx(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachines(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetVirtualMachines";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachines(_response);
        });
    }

    protected processGetVirtualMachines(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineThumbnailImage(vmId: string, size: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetVirtualMachineThumbnailImage/{vmId}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined and cannot be null.");
        else
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineThumbnailImage(_response);
        });
    }

    protected processGetVirtualMachineThumbnailImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createVirtualMachine(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/CreateVirtualMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateVirtualMachine(_response);
        });
    }

    protected processCreateVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateVirtualMachine(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/UpdateVirtualMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateVirtualMachine(_response);
        });
    }

    protected processUpdateVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeVirtualMachineState(vmId: string, newState: any, clusterName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ChangeVirtualMachineState/{vmId}/{clusterName}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (clusterName === undefined || clusterName === null)
            throw new Error("The parameter 'clusterName' must be defined.");
        url_ = url_.replace("{clusterName}", encodeURIComponent("" + clusterName));
        if (newState === undefined || newState === null)
            throw new Error("The parameter 'newState' must be defined and cannot be null.");
        else
            url_ += "newState=" + encodeURIComponent("" + newState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeVirtualMachineState(_response);
        });
    }

    protected processChangeVirtualMachineState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shutDownVirtualMachine(vmId: string, force: boolean, reason: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ShutDownVirtualMachine/{vmId}/{reason}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined.");
        url_ = url_.replace("{reason}", encodeURIComponent("" + reason));
        if (force === undefined || force === null)
            throw new Error("The parameter 'force' must be defined and cannot be null.");
        else
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShutDownVirtualMachine(_response);
        });
    }

    protected processShutDownVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineJobs(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetVirtualMachineJobs/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineJobs(_response);
        });
    }

    protected processGetVirtualMachineJobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    renameVirtualMachine(vmId: string, name: string, clusterName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/RenameVirtualMachine/{vmId}/{name}/{clusterName}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (clusterName === undefined || clusterName === null)
            throw new Error("The parameter 'clusterName' must be defined.");
        url_ = url_.replace("{clusterName}", encodeURIComponent("" + clusterName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameVirtualMachine(_response);
        });
    }

    protected processRenameVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteVirtualMachine(vmId: string, clusterName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/DeleteVirtualMachine/{vmId}/{clusterName}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (clusterName === undefined || clusterName === null)
            throw new Error("The parameter 'clusterName' must be defined.");
        url_ = url_.replace("{clusterName}", encodeURIComponent("" + clusterName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteVirtualMachine(_response);
        });
    }

    protected processDeleteVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteVirtualMachineExtended(vmId: string, clusterName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/DeleteVirtualMachineExtended/{vmId}/{clusterName}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (clusterName === undefined || clusterName === null)
            throw new Error("The parameter 'clusterName' must be defined.");
        url_ = url_.replace("{clusterName}", encodeURIComponent("" + clusterName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteVirtualMachineExtended(_response);
        });
    }

    protected processDeleteVirtualMachineExtended(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    exportVirtualMachine(vmId: string, exportPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ExportVirtualMachine/{vmId}/{exportPath}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (exportPath === undefined || exportPath === null)
            throw new Error("The parameter 'exportPath' must be defined.");
        url_ = url_.replace("{exportPath}", encodeURIComponent("" + exportPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportVirtualMachine(_response);
        });
    }

    protected processExportVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    isTryToUpdateVirtualMachineWithoutRebootSuccess(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/IsTryToUpdateVirtualMachineWithoutRebootSuccess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsTryToUpdateVirtualMachineWithoutRebootSuccess(_response);
        });
    }

    protected processIsTryToUpdateVirtualMachineWithoutRebootSuccess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineSnapshots(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetVirtualMachineSnapshots/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineSnapshots(_response);
        });
    }

    protected processGetVirtualMachineSnapshots(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSnapshot(snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetSnapshot/{snapshotId}";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSnapshot(_response);
        });
    }

    protected processGetSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSnapshot(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/CreateSnapshot/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSnapshot(_response);
        });
    }

    protected processCreateSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    renameSnapshot(vmId: string, snapshotId: string, name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/RenameSnapshot/{vmId}/{snapshotId}/{name}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameSnapshot(_response);
        });
    }

    protected processRenameSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    applySnapshot(vmId: string, snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ApplySnapshot/{vmId}/{snapshotId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplySnapshot(_response);
        });
    }

    protected processApplySnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSnapshot(snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/DeleteSnapshot/{snapshotId}";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSnapshot(_response);
        });
    }

    protected processDeleteSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSnapshotSubtree(snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/DeleteSnapshotSubtree/{snapshotId}";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSnapshotSubtree(_response);
        });
    }

    protected processDeleteSnapshotSubtree(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSnapshotThumbnailImage(snapshotId: string, size: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetSnapshotThumbnailImage/{snapshotId}?";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined and cannot be null.");
        else
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSnapshotThumbnailImage(_response);
        });
    }

    protected processGetSnapshotThumbnailImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSecureBootTemplates(computerName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetSecureBootTemplates/{computerName}";
        if (computerName === undefined || computerName === null)
            throw new Error("The parameter 'computerName' must be defined.");
        url_ = url_.replace("{computerName}", encodeURIComponent("" + computerName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSecureBootTemplates(_response);
        });
    }

    protected processGetSecureBootTemplates(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getExternalSwitches(computerName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetExternalSwitches/{computerName}";
        if (computerName === undefined || computerName === null)
            throw new Error("The parameter 'computerName' must be defined.");
        url_ = url_.replace("{computerName}", encodeURIComponent("" + computerName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalSwitches(_response);
        });
    }

    protected processGetExternalSwitches(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getExternalSwitchesWMI(computerName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetExternalSwitchesWMI/{computerName}";
        if (computerName === undefined || computerName === null)
            throw new Error("The parameter 'computerName' must be defined.");
        url_ = url_.replace("{computerName}", encodeURIComponent("" + computerName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalSwitchesWMI(_response);
        });
    }

    protected processGetExternalSwitchesWMI(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getInternalSwitches(computerName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetInternalSwitches/{computerName}";
        if (computerName === undefined || computerName === null)
            throw new Error("The parameter 'computerName' must be defined.");
        url_ = url_.replace("{computerName}", encodeURIComponent("" + computerName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInternalSwitches(_response);
        });
    }

    protected processGetInternalSwitches(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSwitches(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetSwitches";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSwitches(_response);
        });
    }

    protected processGetSwitches(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    switchExists(switchId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/SwitchExists/{switchId}";
        if (switchId === undefined || switchId === null)
            throw new Error("The parameter 'switchId' must be defined.");
        url_ = url_.replace("{switchId}", encodeURIComponent("" + switchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSwitchExists(_response);
        });
    }

    protected processSwitchExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSwitch(name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/CreateSwitch/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSwitch(_response);
        });
    }

    protected processCreateSwitch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSwitch(switchId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/DeleteSwitch/{switchId}";
        if (switchId === undefined || switchId === null)
            throw new Error("The parameter 'switchId' must be defined.");
        url_ = url_.replace("{switchId}", encodeURIComponent("" + switchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSwitch(_response);
        });
    }

    protected processDeleteSwitch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachinesNetwordAdapterSettings(vmName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetVirtualMachinesNetwordAdapterSettings/{vmName}";
        if (vmName === undefined || vmName === null)
            throw new Error("The parameter 'vmName' must be defined.");
        url_ = url_.replace("{vmName}", encodeURIComponent("" + vmName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachinesNetwordAdapterSettings(_response);
        });
    }

    protected processGetVirtualMachinesNetwordAdapterSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    injectIPs(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/InjectIPs/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInjectIPs(_response);
        });
    }

    protected processInjectIPs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getInsertedDVD(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetInsertedDVD/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInsertedDVD(_response);
        });
    }

    protected processGetInsertedDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    insertDVD(vmId: string, isoPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/InsertDVD/{vmId}/{isoPath}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (isoPath === undefined || isoPath === null)
            throw new Error("The parameter 'isoPath' must be defined.");
        url_ = url_.replace("{isoPath}", encodeURIComponent("" + isoPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertDVD(_response);
        });
    }

    protected processInsertDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    ejectDVD(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/EjectDVD/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEjectDVD(_response);
        });
    }

    protected processEjectDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getKVPItems(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetKVPItems(_response);
        });
    }

    protected processGetKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getStandardKVPItems(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetStandardKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStandardKVPItems(_response);
        });
    }

    protected processGetStandardKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/AddKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddKVPItems(_response);
        });
    }

    protected processAddKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/RemoveKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveKVPItems(_response);
        });
    }

    protected processRemoveKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    modifyKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ModifyKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModifyKVPItems(_response);
        });
    }

    protected processModifyKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    isEmptyFolders(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/IsEmptyFolders/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsEmptyFolders(_response);
        });
    }

    protected processIsEmptyFolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    fileExists(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/FileExists/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFileExists(_response);
        });
    }

    protected processFileExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualHardDiskInfo(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetVirtualHardDiskInfo/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualHardDiskInfo(_response);
        });
    }

    protected processGetVirtualHardDiskInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    mountVirtualHardDisk(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/MountVirtualHardDisk/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMountVirtualHardDisk(_response);
        });
    }

    protected processMountVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    unmountVirtualHardDisk(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/UnmountVirtualHardDisk/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnmountVirtualHardDisk(_response);
        });
    }

    protected processUnmountVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    expandVirtualHardDisk(vhdPath: string, sizeGB: number): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ExpandVirtualHardDisk/{vhdPath}?";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        if (sizeGB === undefined || sizeGB === null)
            throw new Error("The parameter 'sizeGB' must be defined and cannot be null.");
        else
            url_ += "sizeGB=" + encodeURIComponent("" + sizeGB) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExpandVirtualHardDisk(_response);
        });
    }

    protected processExpandVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    convertVirtualHardDisk(sourcePath: string, destinationPath: string, diskType: any, blockSizeBytes: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ConvertVirtualHardDisk/{sourcePath}/{destinationPath}?";
        if (sourcePath === undefined || sourcePath === null)
            throw new Error("The parameter 'sourcePath' must be defined.");
        url_ = url_.replace("{sourcePath}", encodeURIComponent("" + sourcePath));
        if (destinationPath === undefined || destinationPath === null)
            throw new Error("The parameter 'destinationPath' must be defined.");
        url_ = url_.replace("{destinationPath}", encodeURIComponent("" + destinationPath));
        if (diskType === undefined || diskType === null)
            throw new Error("The parameter 'diskType' must be defined and cannot be null.");
        else
            url_ += "diskType=" + encodeURIComponent("" + diskType) + "&";
        if (blockSizeBytes === undefined || blockSizeBytes === null)
            throw new Error("The parameter 'blockSizeBytes' must be defined and cannot be null.");
        else
            url_ += "blockSizeBytes=" + encodeURIComponent("" + blockSizeBytes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConvertVirtualHardDisk(_response);
        });
    }

    protected processConvertVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createVirtualHardDisk(destinationPath: string, diskType: any, blockSizeBytes: any, sizeGB: number): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/CreateVirtualHardDisk/{destinationPath}?";
        if (destinationPath === undefined || destinationPath === null)
            throw new Error("The parameter 'destinationPath' must be defined.");
        url_ = url_.replace("{destinationPath}", encodeURIComponent("" + destinationPath));
        if (diskType === undefined || diskType === null)
            throw new Error("The parameter 'diskType' must be defined and cannot be null.");
        else
            url_ += "diskType=" + encodeURIComponent("" + diskType) + "&";
        if (blockSizeBytes === undefined || blockSizeBytes === null)
            throw new Error("The parameter 'blockSizeBytes' must be defined and cannot be null.");
        else
            url_ += "blockSizeBytes=" + encodeURIComponent("" + blockSizeBytes) + "&";
        if (sizeGB === undefined || sizeGB === null)
            throw new Error("The parameter 'sizeGB' must be defined and cannot be null.");
        else
            url_ += "sizeGB=" + encodeURIComponent("" + sizeGB) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateVirtualHardDisk(_response);
        });
    }

    protected processCreateVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteRemoteFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/DeleteRemoteFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRemoteFile(_response);
        });
    }

    protected processDeleteRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    expandDiskVolume(diskAddress: string, volumeName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ExpandDiskVolume/{diskAddress}/{volumeName}";
        if (diskAddress === undefined || diskAddress === null)
            throw new Error("The parameter 'diskAddress' must be defined.");
        url_ = url_.replace("{diskAddress}", encodeURIComponent("" + diskAddress));
        if (volumeName === undefined || volumeName === null)
            throw new Error("The parameter 'volumeName' must be defined.");
        url_ = url_.replace("{volumeName}", encodeURIComponent("" + volumeName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExpandDiskVolume(_response);
        });
    }

    protected processExpandDiskVolume(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    readRemoteFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ReadRemoteFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReadRemoteFile(_response);
        });
    }

    protected processReadRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    writeRemoteFile(path: string, content: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/WriteRemoteFile/{path}/{content}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (content === undefined || content === null)
            throw new Error("The parameter 'content' must be defined.");
        url_ = url_.replace("{content}", encodeURIComponent("" + content));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWriteRemoteFile(_response);
        });
    }

    protected processWriteRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getJob(jobId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetJob/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJob(_response);
        });
    }

    protected processGetJob(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAllJobs(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetAllJobs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllJobs(_response);
        });
    }

    protected processGetAllJobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    clearOldJobs(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ClearOldJobs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearOldJobs(_response);
        });
    }

    protected processClearOldJobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeJobState(jobId: string, newState: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ChangeJobState/{jobId}?";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        if (newState === undefined || newState === null)
            throw new Error("The parameter 'newState' must be defined and cannot be null.");
        else
            url_ += "newState=" + encodeURIComponent("" + newState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeJobState(_response);
        });
    }

    protected processChangeJobState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getProcessorCoresNumber(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetProcessorCoresNumber";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProcessorCoresNumber(_response);
        });
    }

    protected processGetProcessorCoresNumber(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVMConfigurationVersionSupportedList(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetVMConfigurationVersionSupportedList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVMConfigurationVersionSupportedList(_response);
        });
    }

    protected processGetVMConfigurationVersionSupportedList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCertificates(remoteServer: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetCertificates/{remoteServer}";
        if (remoteServer === undefined || remoteServer === null)
            throw new Error("The parameter 'remoteServer' must be defined.");
        url_ = url_.replace("{remoteServer}", encodeURIComponent("" + remoteServer));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCertificates(_response);
        });
    }

    protected processGetCertificates(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setReplicaServer(remoteServer: string, thumbprint: string, storagePath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/SetReplicaServer/{remoteServer}/{thumbprint}/{storagePath}";
        if (remoteServer === undefined || remoteServer === null)
            throw new Error("The parameter 'remoteServer' must be defined.");
        url_ = url_.replace("{remoteServer}", encodeURIComponent("" + remoteServer));
        if (thumbprint === undefined || thumbprint === null)
            throw new Error("The parameter 'thumbprint' must be defined.");
        url_ = url_.replace("{thumbprint}", encodeURIComponent("" + thumbprint));
        if (storagePath === undefined || storagePath === null)
            throw new Error("The parameter 'storagePath' must be defined.");
        url_ = url_.replace("{storagePath}", encodeURIComponent("" + storagePath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetReplicaServer(_response);
        });
    }

    protected processSetReplicaServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    unsetReplicaServer(remoteServer: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/UnsetReplicaServer/{remoteServer}";
        if (remoteServer === undefined || remoteServer === null)
            throw new Error("The parameter 'remoteServer' must be defined.");
        url_ = url_.replace("{remoteServer}", encodeURIComponent("" + remoteServer));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnsetReplicaServer(_response);
        });
    }

    protected processUnsetReplicaServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getReplicaServer(remoteServer: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetReplicaServer/{remoteServer}";
        if (remoteServer === undefined || remoteServer === null)
            throw new Error("The parameter 'remoteServer' must be defined.");
        url_ = url_.replace("{remoteServer}", encodeURIComponent("" + remoteServer));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReplicaServer(_response);
        });
    }

    protected processGetReplicaServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enableVmReplication(vmId: string, replicaServer: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/EnableVmReplication/{vmId}/{replicaServer}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (replicaServer === undefined || replicaServer === null)
            throw new Error("The parameter 'replicaServer' must be defined.");
        url_ = url_.replace("{replicaServer}", encodeURIComponent("" + replicaServer));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnableVmReplication(_response);
        });
    }

    protected processEnableVmReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setVmReplication(vmId: string, replicaServer: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/SetVmReplication/{vmId}/{replicaServer}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (replicaServer === undefined || replicaServer === null)
            throw new Error("The parameter 'replicaServer' must be defined.");
        url_ = url_.replace("{replicaServer}", encodeURIComponent("" + replicaServer));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetVmReplication(_response);
        });
    }

    protected processSetVmReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    testReplicationServer(vmId: string, replicaServer: string, localThumbprint: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/TestReplicationServer/{vmId}/{replicaServer}/{localThumbprint}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (replicaServer === undefined || replicaServer === null)
            throw new Error("The parameter 'replicaServer' must be defined.");
        url_ = url_.replace("{replicaServer}", encodeURIComponent("" + replicaServer));
        if (localThumbprint === undefined || localThumbprint === null)
            throw new Error("The parameter 'localThumbprint' must be defined.");
        url_ = url_.replace("{localThumbprint}", encodeURIComponent("" + localThumbprint));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestReplicationServer(_response);
        });
    }

    protected processTestReplicationServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    startInitialReplication(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/StartInitialReplication/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartInitialReplication(_response);
        });
    }

    protected processStartInitialReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getReplication(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetReplication/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReplication(_response);
        });
    }

    protected processGetReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    disableVmReplication(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/DisableVmReplication/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDisableVmReplication(_response);
        });
    }

    protected processDisableVmReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getReplicationInfo(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/GetReplicationInfo/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReplicationInfo(_response);
        });
    }

    protected processGetReplicationInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    pauseReplication(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/PauseReplication/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPauseReplication(_response);
        });
    }

    protected processPauseReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    resumeReplication(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ResumeReplication/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResumeReplication(_response);
        });
    }

    protected processResumeReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    executeCustomPsScript(script: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServer2012/ExecuteCustomPsScript/{script}";
        if (script === undefined || script === null)
            throw new Error("The parameter 'script' must be defined.");
        url_ = url_.replace("{script}", encodeURIComponent("" + script));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteCustomPsScript(_response);
        });
    }

    protected processExecuteCustomPsScript(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VirtualizationServerForPrivateCloudClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getVirtualMachine(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetVirtualMachine/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachine(_response);
        });
    }

    protected processGetVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineEx(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetVirtualMachineEx/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineEx(_response);
        });
    }

    protected processGetVirtualMachineEx(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachines(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetVirtualMachines";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachines(_response);
        });
    }

    protected processGetVirtualMachines(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineThumbnailImage(vmId: string, size: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetVirtualMachineThumbnailImage/{vmId}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined and cannot be null.");
        else
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineThumbnailImage(_response);
        });
    }

    protected processGetVirtualMachineThumbnailImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createVirtualMachine(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/CreateVirtualMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateVirtualMachine(_response);
        });
    }

    protected processCreateVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createVMFromVM(sourceName: string, taskGuid: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/CreateVMFromVM/{sourceName}?";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined.");
        url_ = url_.replace("{sourceName}", encodeURIComponent("" + sourceName));
        if (taskGuid === undefined || taskGuid === null)
            throw new Error("The parameter 'taskGuid' must be defined and cannot be null.");
        else
            url_ += "taskGuid=" + encodeURIComponent("" + taskGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateVMFromVM(_response);
        });
    }

    protected processCreateVMFromVM(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateVirtualMachine(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/UpdateVirtualMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateVirtualMachine(_response);
        });
    }

    protected processUpdateVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeVirtualMachineState(vmId: string, newState: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/ChangeVirtualMachineState/{vmId}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (newState === undefined || newState === null)
            throw new Error("The parameter 'newState' must be defined and cannot be null.");
        else
            url_ += "newState=" + encodeURIComponent("" + newState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeVirtualMachineState(_response);
        });
    }

    protected processChangeVirtualMachineState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shutDownVirtualMachine(vmId: string, force: boolean, reason: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/ShutDownVirtualMachine/{vmId}/{reason}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined.");
        url_ = url_.replace("{reason}", encodeURIComponent("" + reason));
        if (force === undefined || force === null)
            throw new Error("The parameter 'force' must be defined and cannot be null.");
        else
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShutDownVirtualMachine(_response);
        });
    }

    protected processShutDownVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineJobs(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetVirtualMachineJobs/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineJobs(_response);
        });
    }

    protected processGetVirtualMachineJobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    renameVirtualMachine(vmId: string, name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/RenameVirtualMachine/{vmId}/{name}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameVirtualMachine(_response);
        });
    }

    protected processRenameVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteVirtualMachine(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/DeleteVirtualMachine/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteVirtualMachine(_response);
        });
    }

    protected processDeleteVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineSnapshots(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetVirtualMachineSnapshots/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineSnapshots(_response);
        });
    }

    protected processGetVirtualMachineSnapshots(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSnapshot(snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetSnapshot/{snapshotId}";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSnapshot(_response);
        });
    }

    protected processGetSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSnapshot(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/CreateSnapshot/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSnapshot(_response);
        });
    }

    protected processCreateSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    renameSnapshot(vmId: string, snapshotId: string, name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/RenameSnapshot/{vmId}/{snapshotId}/{name}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameSnapshot(_response);
        });
    }

    protected processRenameSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    applySnapshot(vmId: string, snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/ApplySnapshot/{vmId}/{snapshotId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplySnapshot(_response);
        });
    }

    protected processApplySnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSnapshot(vmId: string, snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/DeleteSnapshot/{vmId}/{snapshotId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSnapshot(_response);
        });
    }

    protected processDeleteSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSnapshotSubtree(snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/DeleteSnapshotSubtree/{snapshotId}";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSnapshotSubtree(_response);
        });
    }

    protected processDeleteSnapshotSubtree(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSnapshotThumbnailImage(snapshotId: string, size: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetSnapshotThumbnailImage/{snapshotId}?";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined and cannot be null.");
        else
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSnapshotThumbnailImage(_response);
        });
    }

    protected processGetSnapshotThumbnailImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getExternalSwitches(computerName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetExternalSwitches/{computerName}";
        if (computerName === undefined || computerName === null)
            throw new Error("The parameter 'computerName' must be defined.");
        url_ = url_.replace("{computerName}", encodeURIComponent("" + computerName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalSwitches(_response);
        });
    }

    protected processGetExternalSwitches(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSwitches(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetSwitches";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSwitches(_response);
        });
    }

    protected processGetSwitches(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    switchExists(switchId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/SwitchExists/{switchId}";
        if (switchId === undefined || switchId === null)
            throw new Error("The parameter 'switchId' must be defined.");
        url_ = url_.replace("{switchId}", encodeURIComponent("" + switchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSwitchExists(_response);
        });
    }

    protected processSwitchExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSwitch(name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/CreateSwitch/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSwitch(_response);
        });
    }

    protected processCreateSwitch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSwitch(switchId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/DeleteSwitch/{switchId}";
        if (switchId === undefined || switchId === null)
            throw new Error("The parameter 'switchId' must be defined.");
        url_ = url_.replace("{switchId}", encodeURIComponent("" + switchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSwitch(_response);
        });
    }

    protected processDeleteSwitch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getInsertedDVD(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetInsertedDVD/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInsertedDVD(_response);
        });
    }

    protected processGetInsertedDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    insertDVD(vmId: string, isoPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/InsertDVD/{vmId}/{isoPath}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (isoPath === undefined || isoPath === null)
            throw new Error("The parameter 'isoPath' must be defined.");
        url_ = url_.replace("{isoPath}", encodeURIComponent("" + isoPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertDVD(_response);
        });
    }

    protected processInsertDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    ejectDVD(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/EjectDVD/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEjectDVD(_response);
        });
    }

    protected processEjectDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getLibraryItems(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetLibraryItems/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLibraryItems(_response);
        });
    }

    protected processGetLibraryItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOSLibraryItems(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetOSLibraryItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOSLibraryItems(_response);
        });
    }

    protected processGetOSLibraryItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getHosts(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetHosts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHosts(_response);
        });
    }

    protected processGetHosts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getClusters(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetClusters";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetClusters(_response);
        });
    }

    protected processGetClusters(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getKVPItems(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetKVPItems(_response);
        });
    }

    protected processGetKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getStandardKVPItems(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetStandardKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStandardKVPItems(_response);
        });
    }

    protected processGetStandardKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/AddKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddKVPItems(_response);
        });
    }

    protected processAddKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/RemoveKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveKVPItems(_response);
        });
    }

    protected processRemoveKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    modifyKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/ModifyKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModifyKVPItems(_response);
        });
    }

    protected processModifyKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualHardDiskInfo(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetVirtualHardDiskInfo/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualHardDiskInfo(_response);
        });
    }

    protected processGetVirtualHardDiskInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    mountVirtualHardDisk(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/MountVirtualHardDisk/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMountVirtualHardDisk(_response);
        });
    }

    protected processMountVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    unmountVirtualHardDisk(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/UnmountVirtualHardDisk/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnmountVirtualHardDisk(_response);
        });
    }

    protected processUnmountVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    expandVirtualHardDisk(vhdPath: string, sizeGB: number): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/ExpandVirtualHardDisk/{vhdPath}?";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        if (sizeGB === undefined || sizeGB === null)
            throw new Error("The parameter 'sizeGB' must be defined and cannot be null.");
        else
            url_ += "sizeGB=" + encodeURIComponent("" + sizeGB) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExpandVirtualHardDisk(_response);
        });
    }

    protected processExpandVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    convertVirtualHardDisk(sourcePath: string, destinationPath: string, diskType: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/ConvertVirtualHardDisk/{sourcePath}/{destinationPath}?";
        if (sourcePath === undefined || sourcePath === null)
            throw new Error("The parameter 'sourcePath' must be defined.");
        url_ = url_.replace("{sourcePath}", encodeURIComponent("" + sourcePath));
        if (destinationPath === undefined || destinationPath === null)
            throw new Error("The parameter 'destinationPath' must be defined.");
        url_ = url_.replace("{destinationPath}", encodeURIComponent("" + destinationPath));
        if (diskType === undefined || diskType === null)
            throw new Error("The parameter 'diskType' must be defined and cannot be null.");
        else
            url_ += "diskType=" + encodeURIComponent("" + diskType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConvertVirtualHardDisk(_response);
        });
    }

    protected processConvertVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteRemoteFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/DeleteRemoteFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRemoteFile(_response);
        });
    }

    protected processDeleteRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    expandDiskVolume(diskAddress: string, volumeName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/ExpandDiskVolume/{diskAddress}/{volumeName}";
        if (diskAddress === undefined || diskAddress === null)
            throw new Error("The parameter 'diskAddress' must be defined.");
        url_ = url_.replace("{diskAddress}", encodeURIComponent("" + diskAddress));
        if (volumeName === undefined || volumeName === null)
            throw new Error("The parameter 'volumeName' must be defined.");
        url_ = url_.replace("{volumeName}", encodeURIComponent("" + volumeName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExpandDiskVolume(_response);
        });
    }

    protected processExpandDiskVolume(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    readRemoteFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/ReadRemoteFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReadRemoteFile(_response);
        });
    }

    protected processReadRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    writeRemoteFile(path: string, content: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/WriteRemoteFile/{path}/{content}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (content === undefined || content === null)
            throw new Error("The parameter 'content' must be defined.");
        url_ = url_.replace("{content}", encodeURIComponent("" + content));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWriteRemoteFile(_response);
        });
    }

    protected processWriteRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getJob(jobId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetJob/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJob(_response);
        });
    }

    protected processGetJob(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAllJobs(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetAllJobs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllJobs(_response);
        });
    }

    protected processGetAllJobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeJobState(jobId: string, newState: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/ChangeJobState/{jobId}?";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        if (newState === undefined || newState === null)
            throw new Error("The parameter 'newState' must be defined and cannot be null.");
        else
            url_ += "newState=" + encodeURIComponent("" + newState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeJobState(_response);
        });
    }

    protected processChangeJobState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getProcessorCoresNumber(templateId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetProcessorCoresNumber/{templateId}";
        if (templateId === undefined || templateId === null)
            throw new Error("The parameter 'templateId' must be defined.");
        url_ = url_.replace("{templateId}", encodeURIComponent("" + templateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProcessorCoresNumber(_response);
        });
    }

    protected processGetProcessorCoresNumber(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkServerState(control: any, connString: string, connName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/CheckServerState/{connString}/{connName}?";
        if (connString === undefined || connString === null)
            throw new Error("The parameter 'connString' must be defined.");
        url_ = url_.replace("{connString}", encodeURIComponent("" + connString));
        if (connName === undefined || connName === null)
            throw new Error("The parameter 'connName' must be defined.");
        url_ = url_.replace("{connName}", encodeURIComponent("" + connName));
        if (control === undefined || control === null)
            throw new Error("The parameter 'control' must be defined and cannot be null.");
        else
            url_ += "control=" + encodeURIComponent("" + control) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckServerState(_response);
        });
    }

    protected processCheckServerState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDeviceEvents(serviceName: string, displayName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetDeviceEvents/{serviceName}/{displayName}";
        if (serviceName === undefined || serviceName === null)
            throw new Error("The parameter 'serviceName' must be defined.");
        url_ = url_.replace("{serviceName}", encodeURIComponent("" + serviceName));
        if (displayName === undefined || displayName === null)
            throw new Error("The parameter 'displayName' must be defined.");
        url_ = url_.replace("{displayName}", encodeURIComponent("" + displayName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDeviceEvents(_response);
        });
    }

    protected processGetDeviceEvents(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getMonitoringAlerts(serviceName: string, virtualMachineName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetMonitoringAlerts/{serviceName}/{virtualMachineName}";
        if (serviceName === undefined || serviceName === null)
            throw new Error("The parameter 'serviceName' must be defined.");
        url_ = url_.replace("{serviceName}", encodeURIComponent("" + serviceName));
        if (virtualMachineName === undefined || virtualMachineName === null)
            throw new Error("The parameter 'virtualMachineName' must be defined.");
        url_ = url_.replace("{virtualMachineName}", encodeURIComponent("" + virtualMachineName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMonitoringAlerts(_response);
        });
    }

    protected processGetMonitoringAlerts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPerfomanceValue(vmName: string, perf: any, startPeriod: string, endPeriod: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetPerfomanceValue/{VmName}?";
        if (vmName === undefined || vmName === null)
            throw new Error("The parameter 'vmName' must be defined.");
        url_ = url_.replace("{VmName}", encodeURIComponent("" + vmName));
        if (perf === undefined || perf === null)
            throw new Error("The parameter 'perf' must be defined and cannot be null.");
        else
            url_ += "perf=" + encodeURIComponent("" + perf) + "&";
        if (startPeriod === undefined || startPeriod === null)
            throw new Error("The parameter 'startPeriod' must be defined and cannot be null.");
        else
            url_ += "startPeriod=" + encodeURIComponent("" + startPeriod) + "&";
        if (endPeriod === undefined || endPeriod === null)
            throw new Error("The parameter 'endPeriod' must be defined and cannot be null.");
        else
            url_ += "endPeriod=" + encodeURIComponent("" + endPeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPerfomanceValue(_response);
        });
    }

    protected processGetPerfomanceValue(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    configureCreatedVMNetworkAdapters(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/ConfigureCreatedVMNetworkAdapters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfigureCreatedVMNetworkAdapters(_response);
        });
    }

    protected processConfigureCreatedVMNetworkAdapters(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    moveVM(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/MoveVM";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveVM(_response);
        });
    }

    protected processMoveVM(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualNetworkByHostName(hostName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerForPrivateCloud/GetVirtualNetworkByHostName/{hostName}";
        if (hostName === undefined || hostName === null)
            throw new Error("The parameter 'hostName' must be defined.");
        url_ = url_.replace("{hostName}", encodeURIComponent("" + hostName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualNetworkByHostName(_response);
        });
    }

    protected processGetVirtualNetworkByHostName(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VirtualizationServerProxmoxClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getVirtualMachine(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetVirtualMachine/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachine(_response);
        });
    }

    protected processGetVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineEx(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetVirtualMachineEx/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineEx(_response);
        });
    }

    protected processGetVirtualMachineEx(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachines(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetVirtualMachines";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachines(_response);
        });
    }

    protected processGetVirtualMachines(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineThumbnailImage(vmId: string, size: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetVirtualMachineThumbnailImage/{vmId}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined and cannot be null.");
        else
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineThumbnailImage(_response);
        });
    }

    protected processGetVirtualMachineThumbnailImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createVirtualMachine(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/CreateVirtualMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateVirtualMachine(_response);
        });
    }

    protected processCreateVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateVirtualMachine(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/UpdateVirtualMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateVirtualMachine(_response);
        });
    }

    protected processUpdateVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeVirtualMachineState(vmId: string, newState: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ChangeVirtualMachineState/{vmId}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (newState === undefined || newState === null)
            throw new Error("The parameter 'newState' must be defined and cannot be null.");
        else
            url_ += "newState=" + encodeURIComponent("" + newState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeVirtualMachineState(_response);
        });
    }

    protected processChangeVirtualMachineState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    shutDownVirtualMachine(vmId: string, force: boolean, reason: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ShutDownVirtualMachine/{vmId}/{reason}?";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined.");
        url_ = url_.replace("{reason}", encodeURIComponent("" + reason));
        if (force === undefined || force === null)
            throw new Error("The parameter 'force' must be defined and cannot be null.");
        else
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShutDownVirtualMachine(_response);
        });
    }

    protected processShutDownVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineJobs(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetVirtualMachineJobs/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineJobs(_response);
        });
    }

    protected processGetVirtualMachineJobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    renameVirtualMachine(vmId: string, name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/RenameVirtualMachine/{vmId}/{name}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameVirtualMachine(_response);
        });
    }

    protected processRenameVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteVirtualMachine(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/DeleteVirtualMachine/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteVirtualMachine(_response);
        });
    }

    protected processDeleteVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    exportVirtualMachine(vmId: string, exportPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ExportVirtualMachine/{vmId}/{exportPath}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (exportPath === undefined || exportPath === null)
            throw new Error("The parameter 'exportPath' must be defined.");
        url_ = url_.replace("{exportPath}", encodeURIComponent("" + exportPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportVirtualMachine(_response);
        });
    }

    protected processExportVirtualMachine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPveVncCredentials(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetPveVncCredentials/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPveVncCredentials(_response);
        });
    }

    protected processGetPveVncCredentials(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualMachineSnapshots(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetVirtualMachineSnapshots/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualMachineSnapshots(_response);
        });
    }

    protected processGetVirtualMachineSnapshots(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSnapshot(vmId: string, snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetSnapshot/{vmId}/{snapshotId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSnapshot(_response);
        });
    }

    protected processGetSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSnapshot(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/CreateSnapshot/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSnapshot(_response);
        });
    }

    protected processCreateSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    renameSnapshot(vmId: string, snapshotId: string, name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/RenameSnapshot/{vmId}/{snapshotId}/{name}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameSnapshot(_response);
        });
    }

    protected processRenameSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    applySnapshot(vmId: string, snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ApplySnapshot/{vmId}/{snapshotId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplySnapshot(_response);
        });
    }

    protected processApplySnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSnapshot(vmId: string, snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/DeleteSnapshot/{vmId}/{snapshotId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSnapshot(_response);
        });
    }

    protected processDeleteSnapshot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSnapshotSubtree(vmId: string, snapshotId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/DeleteSnapshotSubtree/{vmId}/{snapshotId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSnapshotSubtree(_response);
        });
    }

    protected processDeleteSnapshotSubtree(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSnapshotThumbnailImage(snapshotId: string, size: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetSnapshotThumbnailImage/{snapshotId}?";
        if (snapshotId === undefined || snapshotId === null)
            throw new Error("The parameter 'snapshotId' must be defined.");
        url_ = url_.replace("{snapshotId}", encodeURIComponent("" + snapshotId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined and cannot be null.");
        else
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSnapshotThumbnailImage(_response);
        });
    }

    protected processGetSnapshotThumbnailImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getExternalSwitches(computerName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetExternalSwitches/{computerName}";
        if (computerName === undefined || computerName === null)
            throw new Error("The parameter 'computerName' must be defined.");
        url_ = url_.replace("{computerName}", encodeURIComponent("" + computerName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalSwitches(_response);
        });
    }

    protected processGetExternalSwitches(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSwitches(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetSwitches";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSwitches(_response);
        });
    }

    protected processGetSwitches(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    switchExists(switchId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/SwitchExists/{switchId}";
        if (switchId === undefined || switchId === null)
            throw new Error("The parameter 'switchId' must be defined.");
        url_ = url_.replace("{switchId}", encodeURIComponent("" + switchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSwitchExists(_response);
        });
    }

    protected processSwitchExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSwitch(name: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/CreateSwitch/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSwitch(_response);
        });
    }

    protected processCreateSwitch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSwitch(switchId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/DeleteSwitch/{switchId}";
        if (switchId === undefined || switchId === null)
            throw new Error("The parameter 'switchId' must be defined.");
        url_ = url_.replace("{switchId}", encodeURIComponent("" + switchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSwitch(_response);
        });
    }

    protected processDeleteSwitch(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDVDISOs(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetDVDISOs/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDVDISOs(_response);
        });
    }

    protected processGetDVDISOs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getInsertedDVD(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetInsertedDVD/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInsertedDVD(_response);
        });
    }

    protected processGetInsertedDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    insertDVD(vmId: string, isoPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/InsertDVD/{vmId}/{isoPath}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (isoPath === undefined || isoPath === null)
            throw new Error("The parameter 'isoPath' must be defined.");
        url_ = url_.replace("{isoPath}", encodeURIComponent("" + isoPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertDVD(_response);
        });
    }

    protected processInsertDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    ejectDVD(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/EjectDVD/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEjectDVD(_response);
        });
    }

    protected processEjectDVD(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getKVPItems(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetKVPItems(_response);
        });
    }

    protected processGetKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getStandardKVPItems(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetStandardKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStandardKVPItems(_response);
        });
    }

    protected processGetStandardKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/AddKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddKVPItems(_response);
        });
    }

    protected processAddKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removeKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/RemoveKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveKVPItems(_response);
        });
    }

    protected processRemoveKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    modifyKVPItems(vmId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ModifyKVPItems/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModifyKVPItems(_response);
        });
    }

    protected processModifyKVPItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualHardDiskInfo(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetVirtualHardDiskInfo/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualHardDiskInfo(_response);
        });
    }

    protected processGetVirtualHardDiskInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    mountVirtualHardDisk(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/MountVirtualHardDisk/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMountVirtualHardDisk(_response);
        });
    }

    protected processMountVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    unmountVirtualHardDisk(vhdPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/UnmountVirtualHardDisk/{vhdPath}";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnmountVirtualHardDisk(_response);
        });
    }

    protected processUnmountVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    expandVirtualHardDisk(vhdPath: string, sizeGB: number): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ExpandVirtualHardDisk/{vhdPath}?";
        if (vhdPath === undefined || vhdPath === null)
            throw new Error("The parameter 'vhdPath' must be defined.");
        url_ = url_.replace("{vhdPath}", encodeURIComponent("" + vhdPath));
        if (sizeGB === undefined || sizeGB === null)
            throw new Error("The parameter 'sizeGB' must be defined and cannot be null.");
        else
            url_ += "sizeGB=" + encodeURIComponent("" + sizeGB) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExpandVirtualHardDisk(_response);
        });
    }

    protected processExpandVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    convertVirtualHardDisk(sourcePath: string, destinationPath: string, diskType: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ConvertVirtualHardDisk/{sourcePath}/{destinationPath}?";
        if (sourcePath === undefined || sourcePath === null)
            throw new Error("The parameter 'sourcePath' must be defined.");
        url_ = url_.replace("{sourcePath}", encodeURIComponent("" + sourcePath));
        if (destinationPath === undefined || destinationPath === null)
            throw new Error("The parameter 'destinationPath' must be defined.");
        url_ = url_.replace("{destinationPath}", encodeURIComponent("" + destinationPath));
        if (diskType === undefined || diskType === null)
            throw new Error("The parameter 'diskType' must be defined and cannot be null.");
        else
            url_ += "diskType=" + encodeURIComponent("" + diskType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConvertVirtualHardDisk(_response);
        });
    }

    protected processConvertVirtualHardDisk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteRemoteFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/DeleteRemoteFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRemoteFile(_response);
        });
    }

    protected processDeleteRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    expandDiskVolume(diskAddress: string, volumeName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ExpandDiskVolume/{diskAddress}/{volumeName}";
        if (diskAddress === undefined || diskAddress === null)
            throw new Error("The parameter 'diskAddress' must be defined.");
        url_ = url_.replace("{diskAddress}", encodeURIComponent("" + diskAddress));
        if (volumeName === undefined || volumeName === null)
            throw new Error("The parameter 'volumeName' must be defined.");
        url_ = url_.replace("{volumeName}", encodeURIComponent("" + volumeName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExpandDiskVolume(_response);
        });
    }

    protected processExpandDiskVolume(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    readRemoteFile(path: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ReadRemoteFile/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReadRemoteFile(_response);
        });
    }

    protected processReadRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    writeRemoteFile(path: string, content: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/WriteRemoteFile/{path}/{content}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (content === undefined || content === null)
            throw new Error("The parameter 'content' must be defined.");
        url_ = url_.replace("{content}", encodeURIComponent("" + content));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWriteRemoteFile(_response);
        });
    }

    protected processWriteRemoteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getJob(jobId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetJob/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJob(_response);
        });
    }

    protected processGetJob(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAllJobs(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetAllJobs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllJobs(_response);
        });
    }

    protected processGetAllJobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeJobState(jobId: string, newState: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ChangeJobState/{jobId}?";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        if (newState === undefined || newState === null)
            throw new Error("The parameter 'newState' must be defined and cannot be null.");
        else
            url_ += "newState=" + encodeURIComponent("" + newState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeJobState(_response);
        });
    }

    protected processChangeJobState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getProcessorCoresNumber(): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetProcessorCoresNumber";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProcessorCoresNumber(_response);
        });
    }

    protected processGetProcessorCoresNumber(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCertificates(remoteServer: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetCertificates/{remoteServer}";
        if (remoteServer === undefined || remoteServer === null)
            throw new Error("The parameter 'remoteServer' must be defined.");
        url_ = url_.replace("{remoteServer}", encodeURIComponent("" + remoteServer));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCertificates(_response);
        });
    }

    protected processGetCertificates(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setReplicaServer(remoteServer: string, thumbprint: string, storagePath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/SetReplicaServer/{remoteServer}/{thumbprint}/{storagePath}";
        if (remoteServer === undefined || remoteServer === null)
            throw new Error("The parameter 'remoteServer' must be defined.");
        url_ = url_.replace("{remoteServer}", encodeURIComponent("" + remoteServer));
        if (thumbprint === undefined || thumbprint === null)
            throw new Error("The parameter 'thumbprint' must be defined.");
        url_ = url_.replace("{thumbprint}", encodeURIComponent("" + thumbprint));
        if (storagePath === undefined || storagePath === null)
            throw new Error("The parameter 'storagePath' must be defined.");
        url_ = url_.replace("{storagePath}", encodeURIComponent("" + storagePath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetReplicaServer(_response);
        });
    }

    protected processSetReplicaServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    unsetReplicaServer(remoteServer: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/UnsetReplicaServer/{remoteServer}";
        if (remoteServer === undefined || remoteServer === null)
            throw new Error("The parameter 'remoteServer' must be defined.");
        url_ = url_.replace("{remoteServer}", encodeURIComponent("" + remoteServer));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnsetReplicaServer(_response);
        });
    }

    protected processUnsetReplicaServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getReplicaServer(remoteServer: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetReplicaServer/{remoteServer}";
        if (remoteServer === undefined || remoteServer === null)
            throw new Error("The parameter 'remoteServer' must be defined.");
        url_ = url_.replace("{remoteServer}", encodeURIComponent("" + remoteServer));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReplicaServer(_response);
        });
    }

    protected processGetReplicaServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enableVmReplication(vmId: string, replicaServer: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/EnableVmReplication/{vmId}/{replicaServer}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (replicaServer === undefined || replicaServer === null)
            throw new Error("The parameter 'replicaServer' must be defined.");
        url_ = url_.replace("{replicaServer}", encodeURIComponent("" + replicaServer));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnableVmReplication(_response);
        });
    }

    protected processEnableVmReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setVmReplication(vmId: string, replicaServer: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/SetVmReplication/{vmId}/{replicaServer}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (replicaServer === undefined || replicaServer === null)
            throw new Error("The parameter 'replicaServer' must be defined.");
        url_ = url_.replace("{replicaServer}", encodeURIComponent("" + replicaServer));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetVmReplication(_response);
        });
    }

    protected processSetVmReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    testReplicationServer(vmId: string, replicaServer: string, localThumbprint: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/TestReplicationServer/{vmId}/{replicaServer}/{localThumbprint}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        if (replicaServer === undefined || replicaServer === null)
            throw new Error("The parameter 'replicaServer' must be defined.");
        url_ = url_.replace("{replicaServer}", encodeURIComponent("" + replicaServer));
        if (localThumbprint === undefined || localThumbprint === null)
            throw new Error("The parameter 'localThumbprint' must be defined.");
        url_ = url_.replace("{localThumbprint}", encodeURIComponent("" + localThumbprint));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestReplicationServer(_response);
        });
    }

    protected processTestReplicationServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    startInitialReplication(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/StartInitialReplication/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartInitialReplication(_response);
        });
    }

    protected processStartInitialReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getReplication(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetReplication/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReplication(_response);
        });
    }

    protected processGetReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    disableVmReplication(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/DisableVmReplication/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDisableVmReplication(_response);
        });
    }

    protected processDisableVmReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getReplicationInfo(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/GetReplicationInfo/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReplicationInfo(_response);
        });
    }

    protected processGetReplicationInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    pauseReplication(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/PauseReplication/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPauseReplication(_response);
        });
    }

    protected processPauseReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    resumeReplication(vmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/VirtualizationServerProxmox/ResumeReplication/{vmId}";
        if (vmId === undefined || vmId === null)
            throw new Error("The parameter 'vmId' must be defined.");
        url_ = url_.replace("{vmId}", encodeURIComponent("" + vmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResumeReplication(_response);
        });
    }

    protected processResumeReplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class WebServerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    changeSiteState(siteId: string, state: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/ChangeSiteState/{siteId}?";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeSiteState(_response);
        });
    }

    protected processChangeSiteState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSiteState(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetSiteState/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSiteState(_response);
        });
    }

    protected processGetSiteState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSiteId(siteName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetSiteId/{siteName}";
        if (siteName === undefined || siteName === null)
            throw new Error("The parameter 'siteName' must be defined.");
        url_ = url_.replace("{siteName}", encodeURIComponent("" + siteName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSiteId(_response);
        });
    }

    protected processGetSiteId(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSitesAccounts(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetSitesAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSitesAccounts(_response);
        });
    }

    protected processGetSitesAccounts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    siteExists(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/SiteExists/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSiteExists(_response);
        });
    }

    protected processSiteExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSites(): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetSites";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSites(_response);
        });
    }

    protected processGetSites(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSite(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetSite/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSite(_response);
        });
    }

    protected processGetSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSiteBindings(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetSiteBindings/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSiteBindings(_response);
        });
    }

    protected processGetSiteBindings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSite(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/CreateSite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSite(_response);
        });
    }

    protected processCreateSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateSite(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateSite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSite(_response);
        });
    }

    protected processUpdateSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateSiteBindings(siteId: string, emptyBindingsAllowed: boolean, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateSiteBindings/{siteId}?";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (emptyBindingsAllowed === undefined || emptyBindingsAllowed === null)
            throw new Error("The parameter 'emptyBindingsAllowed' must be defined and cannot be null.");
        else
            url_ += "emptyBindingsAllowed=" + encodeURIComponent("" + emptyBindingsAllowed) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSiteBindings(_response);
        });
    }

    protected processUpdateSiteBindings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteSite(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DeleteSite/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSite(_response);
        });
    }

    protected processDeleteSite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeAppPoolState(siteId: string, state: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/ChangeAppPoolState/{siteId}?";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeAppPoolState(_response);
        });
    }

    protected processChangeAppPoolState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAppPoolState(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetAppPoolState/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAppPoolState(_response);
        });
    }

    protected processGetAppPoolState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    virtualDirectoryExists(siteId: string, directoryName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/VirtualDirectoryExists/{siteId}/{directoryName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (directoryName === undefined || directoryName === null)
            throw new Error("The parameter 'directoryName' must be defined.");
        url_ = url_.replace("{directoryName}", encodeURIComponent("" + directoryName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVirtualDirectoryExists(_response);
        });
    }

    protected processVirtualDirectoryExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualDirectories(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetVirtualDirectories/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualDirectories(_response);
        });
    }

    protected processGetVirtualDirectories(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getVirtualDirectory(siteId: string, directoryName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetVirtualDirectory/{siteId}/{directoryName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (directoryName === undefined || directoryName === null)
            throw new Error("The parameter 'directoryName' must be defined.");
        url_ = url_.replace("{directoryName}", encodeURIComponent("" + directoryName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVirtualDirectory(_response);
        });
    }

    protected processGetVirtualDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createVirtualDirectory(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/CreateVirtualDirectory/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateVirtualDirectory(_response);
        });
    }

    protected processCreateVirtualDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateVirtualDirectory(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateVirtualDirectory/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateVirtualDirectory(_response);
        });
    }

    protected processUpdateVirtualDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteVirtualDirectory(siteId: string, directoryName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DeleteVirtualDirectory/{siteId}/{directoryName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (directoryName === undefined || directoryName === null)
            throw new Error("The parameter 'directoryName' must be defined.");
        url_ = url_.replace("{directoryName}", encodeURIComponent("" + directoryName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteVirtualDirectory(_response);
        });
    }

    protected processDeleteVirtualDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    appVirtualDirectoryExists(siteId: string, directoryName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/AppVirtualDirectoryExists/{siteId}/{directoryName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (directoryName === undefined || directoryName === null)
            throw new Error("The parameter 'directoryName' must be defined.");
        url_ = url_.replace("{directoryName}", encodeURIComponent("" + directoryName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAppVirtualDirectoryExists(_response);
        });
    }

    protected processAppVirtualDirectoryExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAppVirtualDirectories(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetAppVirtualDirectories/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAppVirtualDirectories(_response);
        });
    }

    protected processGetAppVirtualDirectories(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAppVirtualDirectory(siteId: string, directoryName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetAppVirtualDirectory/{siteId}/{directoryName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (directoryName === undefined || directoryName === null)
            throw new Error("The parameter 'directoryName' must be defined.");
        url_ = url_.replace("{directoryName}", encodeURIComponent("" + directoryName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAppVirtualDirectory(_response);
        });
    }

    protected processGetAppVirtualDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createAppVirtualDirectory(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/CreateAppVirtualDirectory/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAppVirtualDirectory(_response);
        });
    }

    protected processCreateAppVirtualDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createEnterpriseStorageAppVirtualDirectory(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/CreateEnterpriseStorageAppVirtualDirectory/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEnterpriseStorageAppVirtualDirectory(_response);
        });
    }

    protected processCreateEnterpriseStorageAppVirtualDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateAppVirtualDirectory(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateAppVirtualDirectory/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAppVirtualDirectory(_response);
        });
    }

    protected processUpdateAppVirtualDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteAppVirtualDirectory(siteId: string, directoryName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DeleteAppVirtualDirectory/{siteId}/{directoryName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (directoryName === undefined || directoryName === null)
            throw new Error("The parameter 'directoryName' must be defined.");
        url_ = url_.replace("{directoryName}", encodeURIComponent("" + directoryName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAppVirtualDirectory(_response);
        });
    }

    protected processDeleteAppVirtualDirectory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    isFrontPageSystemInstalled(): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/IsFrontPageSystemInstalled";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsFrontPageSystemInstalled(_response);
        });
    }

    protected processIsFrontPageSystemInstalled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    isFrontPageInstalled(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/IsFrontPageInstalled/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsFrontPageInstalled(_response);
        });
    }

    protected processIsFrontPageInstalled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installFrontPage(siteId: string, username: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/InstallFrontPage/{siteId}/{username}/{password}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallFrontPage(_response);
        });
    }

    protected processInstallFrontPage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    uninstallFrontPage(siteId: string, username: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UninstallFrontPage/{siteId}/{username}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUninstallFrontPage(_response);
        });
    }

    protected processUninstallFrontPage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeFrontPagePassword(username: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/ChangeFrontPagePassword/{username}/{password}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeFrontPagePassword(_response);
        });
    }

    protected processChangeFrontPagePassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    isColdFusionSystemInstalled(): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/IsColdFusionSystemInstalled";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsColdFusionSystemInstalled(_response);
        });
    }

    protected processIsColdFusionSystemInstalled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    grantWebSiteAccess(path: string, siteId: string, permission: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GrantWebSiteAccess/{path}/{siteId}?";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (permission === undefined || permission === null)
            throw new Error("The parameter 'permission' must be defined and cannot be null.");
        else
            url_ += "permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantWebSiteAccess(_response);
        });
    }

    protected processGrantWebSiteAccess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installSecuredFolders(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/InstallSecuredFolders/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallSecuredFolders(_response);
        });
    }

    protected processInstallSecuredFolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    uninstallSecuredFolders(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UninstallSecuredFolders/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUninstallSecuredFolders(_response);
        });
    }

    protected processUninstallSecuredFolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFolders(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetFolders/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFolders(_response);
        });
    }

    protected processGetFolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getFolder(siteId: string, folderPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetFolder/{siteId}/{folderPath}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (folderPath === undefined || folderPath === null)
            throw new Error("The parameter 'folderPath' must be defined.");
        url_ = url_.replace("{folderPath}", encodeURIComponent("" + folderPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFolder(_response);
        });
    }

    protected processGetFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateFolder(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateFolder/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFolder(_response);
        });
    }

    protected processUpdateFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteFolder(siteId: string, folderPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DeleteFolder/{siteId}/{folderPath}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (folderPath === undefined || folderPath === null)
            throw new Error("The parameter 'folderPath' must be defined.");
        url_ = url_.replace("{folderPath}", encodeURIComponent("" + folderPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFolder(_response);
        });
    }

    protected processDeleteFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUsers(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetUsers/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUser(siteId: string, userName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetUser/{siteId}/{userName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateUser(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateUser/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUser(siteId: string, userName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DeleteUser/{siteId}/{userName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGroups(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetGroups/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroups(_response);
        });
    }

    protected processGetGroups(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGroup(siteId: string, groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetGroup/{siteId}/{groupName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroup(_response);
        });
    }

    protected processGetGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateGroup(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateGroup/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateGroup(_response);
        });
    }

    protected processUpdateGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteGroup(siteId: string, groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DeleteGroup/{siteId}/{groupName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteGroup(_response);
        });
    }

    protected processDeleteGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getHeliconApeStatus(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetHeliconApeStatus/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHeliconApeStatus(_response);
        });
    }

    protected processGetHeliconApeStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installHeliconApe(serviceId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/InstallHeliconApe/{ServiceId}";
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{ServiceId}", encodeURIComponent("" + serviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallHeliconApe(_response);
        });
    }

    protected processInstallHeliconApe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enableHeliconApe(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/EnableHeliconApe/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnableHeliconApe(_response);
        });
    }

    protected processEnableHeliconApe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    disableHeliconApe(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DisableHeliconApe/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDisableHeliconApe(_response);
        });
    }

    protected processDisableHeliconApe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getHeliconApeFolders(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetHeliconApeFolders/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHeliconApeFolders(_response);
        });
    }

    protected processGetHeliconApeFolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getHeliconApeHttpdFolder(): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetHeliconApeHttpdFolder";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHeliconApeHttpdFolder(_response);
        });
    }

    protected processGetHeliconApeHttpdFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getHeliconApeFolder(siteId: string, folderPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetHeliconApeFolder/{siteId}/{folderPath}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (folderPath === undefined || folderPath === null)
            throw new Error("The parameter 'folderPath' must be defined.");
        url_ = url_.replace("{folderPath}", encodeURIComponent("" + folderPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHeliconApeFolder(_response);
        });
    }

    protected processGetHeliconApeFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateHeliconApeFolder(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateHeliconApeFolder/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateHeliconApeFolder(_response);
        });
    }

    protected processUpdateHeliconApeFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateHeliconApeHttpdFolder(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateHeliconApeHttpdFolder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateHeliconApeHttpdFolder(_response);
        });
    }

    protected processUpdateHeliconApeHttpdFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteHeliconApeFolder(siteId: string, folderPath: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DeleteHeliconApeFolder/{siteId}/{folderPath}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (folderPath === undefined || folderPath === null)
            throw new Error("The parameter 'folderPath' must be defined.");
        url_ = url_.replace("{folderPath}", encodeURIComponent("" + folderPath));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteHeliconApeFolder(_response);
        });
    }

    protected processDeleteHeliconApeFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getHeliconApeUsers(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetHeliconApeUsers/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHeliconApeUsers(_response);
        });
    }

    protected processGetHeliconApeUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getHeliconApeUser(siteId: string, userName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetHeliconApeUser/{siteId}/{userName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHeliconApeUser(_response);
        });
    }

    protected processGetHeliconApeUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateHeliconApeUser(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateHeliconApeUser/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateHeliconApeUser(_response);
        });
    }

    protected processUpdateHeliconApeUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteHeliconApeUser(siteId: string, userName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DeleteHeliconApeUser/{siteId}/{userName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteHeliconApeUser(_response);
        });
    }

    protected processDeleteHeliconApeUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getHeliconApeGroups(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetHeliconApeGroups/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHeliconApeGroups(_response);
        });
    }

    protected processGetHeliconApeGroups(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getHeliconApeGroup(siteId: string, groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetHeliconApeGroup/{siteId}/{groupName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHeliconApeGroup(_response);
        });
    }

    protected processGetHeliconApeGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateHeliconApeGroup(siteId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/UpdateHeliconApeGroup/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateHeliconApeGroup(_response);
        });
    }

    protected processUpdateHeliconApeGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    grantWebDeployPublishingAccess(siteId: string, accountName: string, accountPassword: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GrantWebDeployPublishingAccess/{siteId}/{accountName}/{accountPassword}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (accountPassword === undefined || accountPassword === null)
            throw new Error("The parameter 'accountPassword' must be defined.");
        url_ = url_.replace("{accountPassword}", encodeURIComponent("" + accountPassword));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantWebDeployPublishingAccess(_response);
        });
    }

    protected processGrantWebDeployPublishingAccess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    revokeWebDeployPublishingAccess(siteId: string, accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/RevokeWebDeployPublishingAccess/{siteId}/{accountName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRevokeWebDeployPublishingAccess(_response);
        });
    }

    protected processRevokeWebDeployPublishingAccess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteHeliconApeGroup(siteId: string, groupName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DeleteHeliconApeGroup/{siteId}/{groupName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (groupName === undefined || groupName === null)
            throw new Error("The parameter 'groupName' must be defined.");
        url_ = url_.replace("{groupName}", encodeURIComponent("" + groupName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteHeliconApeGroup(_response);
        });
    }

    protected processDeleteHeliconApeGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getZooApplications(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetZooApplications/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetZooApplications(_response);
        });
    }

    protected processGetZooApplications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setZooEnvironmentVariable(siteId: string, appName: string, envName: string, envValue: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/SetZooEnvironmentVariable/{siteId}/{appName}/{envName}/{envValue}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (appName === undefined || appName === null)
            throw new Error("The parameter 'appName' must be defined.");
        url_ = url_.replace("{appName}", encodeURIComponent("" + appName));
        if (envName === undefined || envName === null)
            throw new Error("The parameter 'envName' must be defined.");
        url_ = url_.replace("{envName}", encodeURIComponent("" + envName));
        if (envValue === undefined || envValue === null)
            throw new Error("The parameter 'envValue' must be defined.");
        url_ = url_.replace("{envValue}", encodeURIComponent("" + envValue));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetZooEnvironmentVariable(_response);
        });
    }

    protected processSetZooEnvironmentVariable(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setZooConsoleEnabled(siteId: string, appName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/SetZooConsoleEnabled/{siteId}/{appName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (appName === undefined || appName === null)
            throw new Error("The parameter 'appName' must be defined.");
        url_ = url_.replace("{appName}", encodeURIComponent("" + appName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetZooConsoleEnabled(_response);
        });
    }

    protected processSetZooConsoleEnabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setZooConsoleDisabled(siteId: string, appName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/SetZooConsoleDisabled/{siteId}/{appName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (appName === undefined || appName === null)
            throw new Error("The parameter 'appName' must be defined.");
        url_ = url_.replace("{appName}", encodeURIComponent("" + appName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetZooConsoleDisabled(_response);
        });
    }

    protected processSetZooConsoleDisabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkLoadUserProfile(): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/CheckLoadUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckLoadUserProfile(_response);
        });
    }

    protected processCheckLoadUserProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enableLoadUserProfile(): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/EnableLoadUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnableLoadUserProfile(_response);
        });
    }

    protected processEnableLoadUserProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    initFeeds(userId: number, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/InitFeeds?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInitFeeds(_response);
        });
    }

    protected processInitFeeds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setResourceLanguage(userId: number, resourceLanguage: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/SetResourceLanguage/{resourceLanguage}?";
        if (resourceLanguage === undefined || resourceLanguage === null)
            throw new Error("The parameter 'resourceLanguage' must be defined.");
        url_ = url_.replace("{resourceLanguage}", encodeURIComponent("" + resourceLanguage));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetResourceLanguage(_response);
        });
    }

    protected processSetResourceLanguage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGalleryLanguages(userId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetGalleryLanguages?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGalleryLanguages(_response);
        });
    }

    protected processGetGalleryLanguages(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGalleryCategories(userId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetGalleryCategories?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGalleryCategories(_response);
        });
    }

    protected processGetGalleryCategories(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGalleryApplications(userId: number, categoryId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetGalleryApplications/{categoryId}?";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGalleryApplications(_response);
        });
    }

    protected processGetGalleryApplications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGalleryApplicationsFiltered(userId: number, pattern: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetGalleryApplicationsFiltered/{pattern}?";
        if (pattern === undefined || pattern === null)
            throw new Error("The parameter 'pattern' must be defined.");
        url_ = url_.replace("{pattern}", encodeURIComponent("" + pattern));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGalleryApplicationsFiltered(_response);
        });
    }

    protected processGetGalleryApplicationsFiltered(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    isMsDeployInstalled(): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/IsMsDeployInstalled";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsMsDeployInstalled(_response);
        });
    }

    protected processIsMsDeployInstalled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGalleryApplication(userId: number, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetGalleryApplication/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGalleryApplication(_response);
        });
    }

    protected processGetGalleryApplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGalleryApplicationStatus(userId: number, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetGalleryApplicationStatus/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGalleryApplicationStatus(_response);
        });
    }

    protected processGetGalleryApplicationStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    downloadGalleryApplication(userId: number, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DownloadGalleryApplication/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadGalleryApplication(_response);
        });
    }

    protected processDownloadGalleryApplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getGalleryApplicationParameters(userId: number, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetGalleryApplicationParameters/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGalleryApplicationParameters(_response);
        });
    }

    protected processGetGalleryApplicationParameters(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installGalleryApplication(userId: number, id: string, languageId: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/InstallGalleryApplication/{id}/{languageId}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (languageId === undefined || languageId === null)
            throw new Error("The parameter 'languageId' must be defined.");
        url_ = url_.replace("{languageId}", encodeURIComponent("" + languageId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallGalleryApplication(_response);
        });
    }

    protected processInstallGalleryApplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkWebManagementAccountExists(accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/CheckWebManagementAccountExists/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckWebManagementAccountExists(_response);
        });
    }

    protected processCheckWebManagementAccountExists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkWebManagementPasswordComplexity(accountPassword: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/CheckWebManagementPasswordComplexity/{accountPassword}";
        if (accountPassword === undefined || accountPassword === null)
            throw new Error("The parameter 'accountPassword' must be defined.");
        url_ = url_.replace("{accountPassword}", encodeURIComponent("" + accountPassword));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckWebManagementPasswordComplexity(_response);
        });
    }

    protected processCheckWebManagementPasswordComplexity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    grantWebManagementAccess(siteId: string, accountName: string, accountPassword: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GrantWebManagementAccess/{siteId}/{accountName}/{accountPassword}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (accountPassword === undefined || accountPassword === null)
            throw new Error("The parameter 'accountPassword' must be defined.");
        url_ = url_.replace("{accountPassword}", encodeURIComponent("" + accountPassword));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantWebManagementAccess(_response);
        });
    }

    protected processGrantWebManagementAccess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    revokeWebManagementAccess(siteId: string, accountName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/RevokeWebManagementAccess/{siteId}/{accountName}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRevokeWebManagementAccess(_response);
        });
    }

    protected processRevokeWebManagementAccess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    changeWebManagementAccessPassword(accountName: string, accountPassword: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/ChangeWebManagementAccessPassword/{accountName}/{accountPassword}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        if (accountPassword === undefined || accountPassword === null)
            throw new Error("The parameter 'accountPassword' must be defined.");
        url_ = url_.replace("{accountPassword}", encodeURIComponent("" + accountPassword));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeWebManagementAccessPassword(_response);
        });
    }

    protected processChangeWebManagementAccessPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    generateCSR(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GenerateCSR";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateCSR(_response);
        });
    }

    protected processGenerateCSR(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    generateRenewalCSR(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GenerateRenewalCSR";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateRenewalCSR(_response);
        });
    }

    protected processGenerateRenewalCSR(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCertificate(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCertificate(_response);
        });
    }

    protected processGetCertificate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installCertificate(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/InstallCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallCertificate(_response);
        });
    }

    protected processInstallCertificate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    lEInstallCertificate(email: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/LEInstallCertificate/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLEInstallCertificate(_response);
        });
    }

    protected processLEInstallCertificate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installPFX(certificate: any, password: string, body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/InstallPFX/{password}?";
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        if (certificate === undefined || certificate === null)
            throw new Error("The parameter 'certificate' must be defined and cannot be null.");
        else
            url_ += "certificate=" + encodeURIComponent("" + certificate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallPFX(_response);
        });
    }

    protected processInstallPFX(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    exportCertificate(serialNumber: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/ExportCertificate/{serialNumber}/{password}";
        if (serialNumber === undefined || serialNumber === null)
            throw new Error("The parameter 'serialNumber' must be defined.");
        url_ = url_.replace("{serialNumber}", encodeURIComponent("" + serialNumber));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportCertificate(_response);
        });
    }

    protected processExportCertificate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getServerCertificates(): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetServerCertificates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServerCertificates(_response);
        });
    }

    protected processGetServerCertificates(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteCertificate(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/DeleteCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCertificate(_response);
        });
    }

    protected processDeleteCertificate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    importCertificate(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/ImportCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportCertificate(_response);
        });
    }

    protected processImportCertificate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    checkCertificate(body: any): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/CheckCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckCertificate(_response);
        });
    }

    protected processCheckCertificate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getDirectoryBrowseEnabled(siteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/GetDirectoryBrowseEnabled/{siteId}";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDirectoryBrowseEnabled(_response);
        });
    }

    protected processGetDirectoryBrowseEnabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setDirectoryBrowseEnabled(siteId: string, enabled: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/WebServer/SetDirectoryBrowseEnabled/{siteId}?";
        if (siteId === undefined || siteId === null)
            throw new Error("The parameter 'siteId' must be defined.");
        url_ = url_.replace("{siteId}", encodeURIComponent("" + siteId));
        if (enabled === undefined || enabled === null)
            throw new Error("The parameter 'enabled' must be defined and cannot be null.");
        else
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDirectoryBrowseEnabled(_response);
        });
    }

    protected processSetDirectoryBrowseEnabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}