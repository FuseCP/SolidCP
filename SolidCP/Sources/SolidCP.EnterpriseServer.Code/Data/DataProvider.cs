// Copyright (c) 2016, SolidCP
// SolidCP is distributed under the Creative Commons Share-alike license
// 
// SolidCP is a fork of WebsitePanel:
// Copyright (c) 2015, Outercurve Foundation.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// - Redistributions of source code must  retain  the  above copyright notice, this
//   list of conditions and the following disclaimer.
//
// - Redistributions in binary form  must  reproduce the  above  copyright  notice,
//   this list of conditions  and  the  following  disclaimer in  the documentation
//   and/or other materials provided with the distribution.
//
// - Neither  the  name  of  the  Outercurve Foundation  nor   the   names  of  its
//   contributors may be used to endorse or  promote  products  derived  from  this
//   software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT  NOT  LIMITED TO, THE IMPLIED
// WARRANTIES  OF  MERCHANTABILITY   AND  FITNESS  FOR  A  PARTICULAR  PURPOSE  ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL,  SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT  OF  SUBSTITUTE  GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED AND ON
// ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT  LIABILITY,  OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING  IN  ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

using System;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Xml.Linq;
using System.Linq.Dynamic.Core;
using System.Text;
using System.Threading;

#if !EF64
using Microsoft.Data.SqlClient;
#else
using System.Data.SqlClient;
#endif

#if !NETFRAMEWORK && !NETSTANDARD
using Microsoft.EntityFrameworkCore;
#elif NETFRAMEWORK
using System.Data.Entity;
#endif
using System.Text.RegularExpressions;
using SolidCP.EnterpriseServer.Base.HostedSolution;
using SolidCP.Providers.HostedSolution;
using Microsoft.ApplicationBlocks.Data;
using System.Collections;
using System.Collections.Generic;
using Microsoft.Win32;
using SolidCP.Providers.OS;
using SolidCP.Providers.RemoteDesktopServices;
using SolidCP.Providers.DNS;
using SolidCP.Providers.DomainLookup;
using SolidCP.Providers.StorageSpaces;
using SolidCP.EnterpriseServer.Data;
using SolidCP.EnterpriseServer.Code;
using System.Net;
//using Humanizer.Localisation;
using System.Runtime.InteropServices.ComTypes;
using System.Runtime.ConstrainedExecution;

namespace SolidCP.EnterpriseServer
{
	/// <summary>
	/// Summary description for DataProvider.
	/// </summary>
	public class DataProvider : Data.DbContext
	{

		public const long MB = 1024 * 1024;

#if UseEntityFramework
		public bool? useEntityFramework = null;
		public bool? alwaysUseEntityFramework = null;
		public bool AlwaysUseEntityFramework
		{
			get
			{
				if (alwaysUseEntityFramework == null)
				{
					alwaysUseEntityFramework = false;
					var system = new SystemController(new ControllerBase(this));
					var settings = system.GetSystemSettings(EnterpriseServer.SystemSettings.DEBUG_SETTINGS);
					alwaysUseEntityFramework = settings
						.GetValueOrDefault(EnterpriseServer.SystemSettings.ALWAYS_USE_ENTITYFRAMEWORK, false);
				}
				return alwaysUseEntityFramework ?? false;
			}
			set { alwaysUseEntityFramework = value; }
		}
		public bool UseEntityFramework
		{
			get
			{
				return !IsSqlServer || !HasProcedures ||
					(useEntityFramework ??= 
						(DbSettings.AlwaysUseEntityFramework ||
						AlwaysUseEntityFramework));
			}
			set { useEntityFramework = value; }
		}
#else
		public const bool UseEntityFramework = false;
#endif

		ControllerBase Provider;
		ServerController serverController;
		protected ServerController ServerController => serverController ??= new ServerController(Provider);

		public DataProvider() : base() { Provider = null; }
		public DataProvider(ControllerBase provider): base() { Provider = provider; }
		public DataProvider(string connectionString): base(connectionString) { Provider = null; }

		private DataProvider local = null;
		public DataProvider Local => local ??= new DataProvider();
		public override void Dispose()
		{
			local?.Dispose();
			base.Dispose();
		}

		//public string ConnectionString => ConfigSettings.ConnectionString;
		private string ObjectQualifier
		{
			get
			{
				return "";
			}
		}

		#region System Settings

		public IDataReader GetSystemSettings(string settingsName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSystemSettings]
	@SettingsName nvarchar(50)
AS
BEGIN

	SET NOCOUNT ON;

    SELECT
		[PropertyName],
		[PropertyValue]
	FROM
		[dbo].[SystemSettings]
	WHERE
		[SettingsName] = @SettingsName;

END
			*/
				#endregion

				var settings = SystemSettings
					.Where(s => s.SettingsName == settingsName)
					.Select(s => new
					{
						s.PropertyName,
						s.PropertyValue
					});
				return EntityDataReader(settings);
			}
			return SqlHelper.ExecuteReader(
				 ConnectionString,
				 CommandType.StoredProcedure,
				 "GetSystemSettings",
				 new SqlParameter("@SettingsName", settingsName)
			);
		}

		public void SetSystemSettings(string settingsName, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetSystemSettings]
	@SettingsName nvarchar(50),
	@Xml ntext
AS
BEGIN
/*
XML Format:
<properties>
	<property name="" value=""/>
</properties>
*//*
				SET NOCOUNT ON;

				BEGIN TRAN
		DECLARE @idoc int;
				--Create an internal representation of the XML document.
				EXEC sp_xml_preparedocument @idoc OUTPUT, @xml;

		DELETE FROM[dbo].[SystemSettings] WHERE[SettingsName] = @SettingsName;

		INSERT INTO[dbo].[SystemSettings]
		(
			[SettingsName],
			[PropertyName],
			[PropertyValue]
		)
		SELECT
			@SettingsName,
			[XML].[PropertyName],
			[XML].[PropertyValue]
		FROM OPENXML(@idoc, '/properties/property',1) WITH
		(
			[PropertyName] nvarchar(50) '@name',
			[PropertyValue] ntext '@value'
		) AS XML;

		-- remove document
		EXEC sp_xml_removedocument @idoc;

	COMMIT TRAN;

		END
						*/
				#endregion

				using (var transaction = Database.BeginTransaction())
				{
					SystemSettings
						.Where(s => s.SettingsName == settingsName)
						.ExecuteDelete();

					var settings = XElement.Parse(xml)
						.Elements()
						.Select(e => new Data.Entities.SystemSetting
						{
							SettingsName = settingsName,
							PropertyName = (string)e.Attribute("name"),
							PropertyValue = (string)e.Attribute("value")
						});
					SystemSettings.AddRange(settings);
					SaveChanges();

					transaction.Commit();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					 ConnectionString,
					 CommandType.StoredProcedure,
					 "SetSystemSettings",
					 new SqlParameter("@SettingsName", settingsName),
					 new SqlParameter("@Xml", xml)
				);
			}
		}

		#endregion

		#region Theme Settings

		public DataSet GetThemes()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetThemes]
AS
BEGIN
	SET NOCOUNT ON;
    SELECT
		ThemeID,
		DisplayName,
		LTRName,
		RTLName,
		DisplayOrder
	FROM
		Themes
	WHERE
		Enabled = '1'
	ORDER BY 
		DisplayOrder;
END
				*/
				#endregion

				var themes = Themes
					.Where(t => t.Enabled == 1)
					.OrderBy(t => t.DisplayOrder)
					.Select(t => new
					{
						t.ThemeId,
						t.DisplayName,
						t.LTRName,
						t.RTLName,
						t.DisplayOrder
					});
				return EntityDataSet(themes);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetThemes");
			}
		}

		public DataSet GetThemeSettings(int ThemeID)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetThemeSettings]
(
	@ThemeID int
)
AS
BEGIN
	SET NOCOUNT ON;
    SELECT
		ThemeID,
		SettingsName,
		PropertyName,
		PropertyValue
	FROM
		ThemeSettings
	WHERE
		ThemeID = @ThemeID;
END
				*/
				#endregion

				var settings = ThemeSettings
					.Where(ts => ts.ThemeId == ThemeID)
					.Select(ts => new
					{
						ts.ThemeId,
						ts.SettingsName,
						ts.PropertyName,
						ts.PropertyValue
					});
				return EntityDataSet(settings);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetThemeSettings",
					 new SqlParameter("@ThemeID", ThemeID));
			}
		}

		public DataSet GetThemeSetting(int ThemeID, string SettingsName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetThemeSetting]
(
	@ThemeID int,
	@SettingsName NVARCHAR(255)
)
AS
BEGIN
	SET NOCOUNT ON;
    SELECT
		ThemeID,
		SettingsName,
		PropertyName,
		PropertyValue
	FROM
		ThemeSettings
	WHERE
		ThemeID = @ThemeID
		AND SettingsName = @SettingsName;
END
				*/
				#endregion

				var setting = ThemeSettings
					.Where(ts => ts.ThemeId == ThemeID && ts.SettingsName == SettingsName)
					.Select(ts => new
					{
						ts.ThemeId,
						ts.SettingsName,
						ts.PropertyName,
						ts.PropertyValue
					});
				return EntityDataSet(setting);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetThemeSetting",
					 new SqlParameter("@ThemeID", ThemeID),
					 new SqlParameter("@SettingsName", SettingsName));
			}
		}

		public bool CheckActorUserRights(int actorId, int? userId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CheckActorUserRights]
(
	@ActorID int,
	@UserID int
)
RETURNS bit
AS
BEGIN

IF @ActorID = -1 OR @UserID IS NULL
RETURN 1

-- check if the user requests himself
IF @ActorID = @UserID
BEGIN
	RETURN 1
END

DECLARE @IsPeer bit
DECLARE @OwnerID int

SELECT @IsPeer = IsPeer, @OwnerID = OwnerID FROM Users
WHERE UserID = @ActorID

IF @IsPeer = 1
SET @ActorID = @OwnerID

-- check if the user requests his owner
/*
IF @ActorID = @UserID
BEGIN
	RETURN 0
END
*//*
IF @ActorID = @UserID
BEGIN
	RETURN 1
END

DECLARE @ParentUserID int, @TmpUserID int
SET @TmpUserID = @UserID

WHILE 10 = 10
BEGIN

	SET @ParentUserID = NULL--reset var

	--get owner
	SELECT
		@ParentUserID = OwnerID
	FROM Users
	WHERE UserID = @TmpUserID

	IF @ParentUserID IS NULL --the last parent
		BREAK

	IF @ParentUserID = @ActorID
	RETURN 1

	SET @TmpUserID = @ParentUserID
END

RETURN 0
END
			*/
			#endregion

			if (actorId == -1 || userId == null || userId == 0 ||
				// check if the user requests himself
				actorId == userId)
				return true;


			// check if the user requests his owner
			var actor = Users
				.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
				.FirstOrDefault(u => u.UserId == actorId);

			if (actor != null && actor.IsPeer) actorId = actor.OwnerId ?? -1;

			if (actorId == userId) return true;

			var id = userId;
			do // check owners chain
			{
				var user = Users
					.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
					.FirstOrDefault(u => u.UserId == id);
				if (user == null || user.OwnerId == null) return false;
				else
				{
					id = user.OwnerId.Value;
					if (id == actorId) return true;
				}
			} while (true);
		}

		public DataSet GetUserThemeSettings(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserSettings]
(
	@ActorID int,
	@UserID int,
	@SettingsName nvarchar(50)
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

-- find which parent package has overriden NS
DECLARE @ParentUserID int, @TmpUserID int
SET @TmpUserID = @UserID

WHILE 10 = 10
BEGIN

	IF EXISTS
	(
		SELECT PropertyName FROM UserSettings
		WHERE SettingsName = @SettingsName AND UserID = @TmpUserID
	)
	BEGIN
		SELECT
			UserID,
			PropertyName,
			PropertyValue
		FROM
			UserSettings
		WHERE
			UserID = @TmpUserID AND
			SettingsName = @SettingsName

		BREAK
	END

	SET @ParentUserID = NULL --reset var

	-- get owner
	SELECT
		@ParentUserID = OwnerID
	FROM Users
	WHERE UserID = @TmpUserID

	IF @ParentUserID IS NULL -- the last parent
	BREAK

	SET @TmpUserID = @ParentUserID
END

RETURN
				*/
				#endregion

				const string SettingsName = "Theme";
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var id = userId;
				var settings = UserSettings
					.Where(s => s.UserId == id && s.SettingsName == SettingsName)
					.Select(ts => new
					{
						ts.UserId,
						ts.PropertyName,
						ts.PropertyValue
					});
				while (!settings.Any())
				{
					var user = Users
						.Select(u => new { u.UserId, u.OwnerId })
						.FirstOrDefault(u => u.UserId == id);
					if (user != null && user.OwnerId != null)
					{
						id = user.OwnerId.Value;
						settings = UserSettings
							.Where(s => s.UserId == id && s.SettingsName == SettingsName)
							.Select(ts => new
							{
								ts.UserId,
								ts.PropertyName,
								ts.PropertyValue
							});
					}
					else break;
				}
				return EntityDataSet(settings);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserSettings",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@SettingsName", "Theme"));
			}
		}

		public void UpdateUserThemeSetting(int actorId, int userId, string PropertyName, string PropertyValue)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateUserThemeSetting]
(
	@ActorID int,
	@UserID int,
	@PropertyName NVARCHAR(255),
	@PropertyValue NVARCHAR(255)
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

BEGIN
-- Update if present
IF EXISTS ( SELECT * FROM UserSettings 
						WHERE UserID = @UserID
						AND SettingsName = N'Theme'
						AND PropertyName = @PropertyName)
		BEGIN
			UPDATE UserSettings SET	PropertyValue = @PropertyValue
				WHERE UserID = @UserID
				AND SettingsName = N'Theme'
				AND PropertyName = @PropertyName
			Return
		END
	ELSE
		BEGIN
			INSERT UserSettings (UserID, SettingsName, PropertyName, PropertyValue) VALUES (@UserID, N'Theme', @PropertyName, @PropertyValue)
		END
END
				*/
				#endregion

				const string SettingsName = "Theme";

				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var setting = UserSettings
					.FirstOrDefault(s => s.UserId == userId &&
						s.SettingsName == SettingsName &&
						s.PropertyName == PropertyName);
				if (setting != null)
				{
					setting.PropertyValue = PropertyValue;
				}
				else
				{
					setting = new Data.Entities.UserSetting()
					{
						UserId = userId,
						SettingsName = SettingsName,
						PropertyName = PropertyName,
						PropertyValue = PropertyValue
					};
					UserSettings.Add(setting);
				}
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "UpdateUserThemeSetting",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@PropertyName", PropertyName),
					 new SqlParameter("@PropertyValue", PropertyValue));
			}
		}

		public void DeleteUserThemeSetting(int actorId, int userId, string PropertyName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteUserThemeSetting]
(
	@ActorID int,
	@UserID int,
	@PropertyName NVARCHAR(255)
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

DELETE FROM UserSettings
WHERE UserID = @UserID
AND SettingsName = N'Theme'
AND PropertyName = @PropertyName

RETURN
				*/
				#endregion

				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				UserSettings
					.Where(s => s.UserId == userId &&
						s.SettingsName == "Theme" && s.PropertyName == PropertyName)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "DeleteUserThemeSetting",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@PropertyName", PropertyName));
			}
		}

		#endregion

		#region Users
		public bool CheckUserExists(string username)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckUserExists]
(
	@Exists bit OUTPUT,
	@Username nvarchar(100)
)
AS

SET @Exists = 0

IF EXISTS (SELECT UserID FROM Users
WHERE Username = @Username)
SET @Exists = 1

RETURN
				*/
				#endregion

				return Users.Any(u => u.Username == username);
			}
			else
			{
				SqlParameter prmExists = new SqlParameter("@Exists", SqlDbType.Bit);
				prmExists.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "CheckUserExists",
					 prmExists,
					 new SqlParameter("@username", username));

				return Convert.ToBoolean(prmExists.Value);
			}
		}

		public IEnumerable<int> UserParents(int actorId, int userId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[UserParents]
(
	@ActorID int,
	@UserID int
)
RETURNS @T TABLE (UserOrder int IDENTITY(1,1), UserID int)
AS
BEGIN
	-- insert current user
	INSERT @T VALUES (@UserID)

	DECLARE @TopUserID int
	IF @ActorID = -1
	BEGIN
		SELECT @TopUserID = UserID FROM Users WHERE OwnerID IS NULL
	END
	ELSE
	BEGIN
		SET @TopUserID = @ActorID

		IF EXISTS (SELECT UserID FROM Users WHERE UserID = @ActorID AND IsPeer = 1)
		SELECT @TopUserID = OwnerID FROM Users WHERE UserID = @ActorID AND IsPeer = 1
	END

	-- owner
	DECLARE @OwnerID int, @TmpUserID int

	SET @TmpUserID = @UserID

	WHILE (@TmpUserID <> @TopUserID)
	BEGIN

		SET @OwnerID = NULL
		SELECT @OwnerID = OwnerID FROM Users WHERE UserID = @TmpUserID

		IF @OwnerID IS NOT NULL
		BEGIN
			INSERT @T VALUES (@OwnerID)
			SET @TmpUserID = @OwnerID
		END
	END

RETURN
END
			*/
			#endregion

			var user = Users
				.Select(u => new { u.UserId, u.OwnerId })
				.FirstOrDefault(u => u.UserId == userId);
			while (user != null)
			{
				yield return userId;
				if (user.OwnerId.HasValue)
				{
					userId = user.OwnerId.Value;
					user = Users
						.Select(u => new { u.UserId, u.OwnerId })
						.FirstOrDefault(u => u.UserId == userId);
				}
				else break;
			}
		}

		public TempIdSet UserChildren(int ownerId, bool recursive = true)
		{

			var set = new TempIdSet(this);
			set.Add(ownerId);

			var owner = Users
				.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
				.FirstOrDefault(u => u.UserId == ownerId);
			if (owner != null && owner.IsPeer && owner.OwnerId.HasValue)
			{
				ownerId = owner.OwnerId.Value;
				set.Add(ownerId);
			}

			SaveChanges();

			if (recursive)
			{
				int level = 1;
				var children = Users
					.Where(u => u.OwnerId == ownerId)
					.Select(u => u.UserId);
				while (set.AddRange(children, level) > 0)
				{
					children = Users
						.Join(set.OfLevel(level), u => u.OwnerId, child => child, (u, child) => u.UserId);
					level++;
				}
			}
			else SaveChanges();

			return set;
		}

		public bool CheckUserParent(int ownerId, int? userId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CheckUserParent]
(
	@OwnerID int,
	@UserID int
)
RETURNS bit
AS
BEGIN

-- check if the user requests himself
IF @OwnerID = @UserID
BEGIN
	RETURN 1
END

-- check if the owner is peer
DECLARE @IsPeer int, @TmpOwnerID int
SELECT @IsPeer = IsPeer, @TmpOwnerID = OwnerID FROM Users
WHERE UserID = @OwnerID

IF @IsPeer = 1
SET @OwnerID = @TmpOwnerID

-- check if the user requests himself
IF @OwnerID = @UserID
BEGIN
	RETURN 1
END

DECLARE @ParentUserID int, @TmpUserID int
SET @TmpUserID = @UserID

WHILE 10 = 10
BEGIN

	SET @ParentUserID = NULL --reset var

	-- get owner
	SELECT
		@ParentUserID = OwnerID
	FROM Users
	WHERE UserID = @TmpUserID

	IF @ParentUserID IS NULL -- the last parent
		BREAK

	IF @ParentUserID = @OwnerID
	RETURN 1

	SET @TmpUserID = @ParentUserID
END

RETURN 0
END
			*/
			#endregion

			if (ownerId == userId) return true;

			var owner = Users
				.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
				.FirstOrDefault(u => u.UserId == ownerId);
			if (owner != null && owner.IsPeer && owner.OwnerId.HasValue) ownerId = owner.OwnerId.Value;

			if (ownerId == userId) return true;

			var id = userId;
			var user = Users
				.Select(u => new { u.UserId, u.OwnerId })
				.FirstOrDefault(u => u.UserId == id);
			while (user != null && user.OwnerId.HasValue && user.OwnerId.Value != ownerId)
			{
				id = user.OwnerId.Value;
				user = Users
					.Select(u => new { u.UserId, u.OwnerId })
					.FirstOrDefault(u => u.UserId == id);
			}

			return user != null && user.OwnerId.HasValue && user.OwnerId.Value == ownerId;
		}

		public string GetItemComments(int itemId, string itemTypeId, int actorId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[GetItemComments]
(
	@ItemID int,
	@ItemTypeID varchar(50),
	@ActorID int
)
RETURNS nvarchar(3000)
AS
BEGIN
DECLARE @text nvarchar(3000)
SET @text = ''

SELECT @text = @text + U.Username + ' - ' + CONVERT(nvarchar(50), C.CreatedDate) + '
' + CommentText + '
--------------------------------------
' FROM Comments AS C
INNER JOIN UsersDetailed AS U ON C.UserID = U.UserID
WHERE
	ItemID = @ItemID
	AND ItemTypeID = @ItemTypeID
	AND dbo.CheckUserParent(@ActorID, C.UserID) = 1
ORDER BY C.CreatedDate DESC

RETURN @text
END
			*/
			#endregion

			var comments = Comments
				.Join(Users, c => c.UserId, u => u.UserId, (com, user) => new
				{
					com.UserId,
					com.ItemId,
					com.ItemTypeId,
					com.CreatedDate,
					com.CommentText,
					user.Username
				})
				//.Where(c => c.ItemId == itemId && c.ItemTypeId == itemTypeId &&
				//	CheckUserParent(actorId, c.UserId));
				.Where(c => c.ItemId == itemId && c.ItemTypeId == itemTypeId)
				.AsEnumerable()
				.Where(c => Local.CheckUserParent(actorId, c.UserId));

			var sb = new StringBuilder();
			foreach (var comment in comments)
			{
				sb.Append(comment.Username);
				sb.Append(" - ");
				sb.AppendLine(comment.CreatedDate.ToShortDateString());
				sb.AppendLine(comment.CommentText);
				sb.AppendLine("--------------------------------------");
			}
			return sb.ToString();
		}

		public DataSet GetUsersPaged(int actorId, int userId, string filterColumn, string filterValue,
			 int statusId, int roleId, string sortColumn, int startRow, int maximumRows, bool recursive)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUsersPaged]
(
	@ActorID int,
	@UserID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@StatusID int,
	@RoleID int,
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int,
	@Recursive bit
)
AS
-- build query and run it to the temporary table
DECLARE @sql nvarchar(2000)

SET @sql = '

DECLARE @HasUserRights bit
SET @HasUserRights = dbo.CheckActorUserRights(@ActorID, @UserID)

DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows
DECLARE @Users TABLE
(
	ItemPosition int IDENTITY(0,1),
	UserID int
)
INSERT INTO @Users (UserID)
SELECT
	U.UserID
FROM UsersDetailed AS U
WHERE 
	U.UserID <> @UserID AND U.IsPeer = 0 AND
	(
		(@Recursive = 0 AND OwnerID = @UserID) OR
		(@Recursive = 1 AND dbo.CheckUserParent(@UserID, U.UserID) = 1)
	)
	AND ((@StatusID = 0) OR (@StatusID > 0 AND U.StatusID = @StatusID))
	AND ((@RoleID = 0) OR (@RoleID > 0 AND U.RoleID = @RoleID))
	AND @HasUserRights = 1 '

IF @FilterValue <> ''
BEGIN
	IF @FilterColumn <> ''
		SET @sql = @sql + ' AND ' + @FilterColumn + ' LIKE @FilterValue '
	ELSE
		SET @sql = @sql + '
			AND (Username LIKE @FilterValue
			OR FullName LIKE @FilterValue
			OR Email LIKE @FilterValue) '
END

IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + ' SELECT COUNT(UserID) FROM @Users;
SELECT
	U.UserID,
	U.RoleID,
	U.StatusID,
	U.SubscriberNumber,
	U.LoginStatusId,
	U.FailedLogins,
	U.OwnerID,
	U.Created,
	U.Changed,
	U.IsDemo,
	dbo.GetItemComments(U.UserID, ''USER'', @ActorID) AS Comments,
	U.IsPeer,
	U.Username,
	U.FirstName,
	U.LastName,
	U.Email,
	U.FullName,
	U.OwnerUsername,
	U.OwnerFirstName,
	U.OwnerLastName,
	U.OwnerRoleID,
	U.OwnerFullName,
	U.OwnerEmail,
	U.PackagesNumber,
	U.CompanyName,
	U.EcommerceEnabled
FROM @Users AS TU
INNER JOIN UsersDetailed AS U ON TU.UserID = U.UserID
WHERE TU.ItemPosition BETWEEN @StartRow AND @EndRow'

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int, @UserID int, @FilterValue nvarchar(50), @ActorID int, @Recursive bit, @StatusID int, @RoleID int',
@StartRow, @MaximumRows, @UserID, @FilterValue, @ActorID, @Recursive, @StatusID, @RoleID

RETURN
				*/
				#endregion

				var hasRights = CheckActorUserRights(actorId, userId);
				TempIdSet childUsers = null;
				if (recursive) childUsers = UserChildren(userId, recursive);
				else
				{
					childUsers = new TempIdSet(this, new[] { userId });
				}
				using (childUsers)
				{
					var users = UsersDetailed;
					if (hasRights)
					{
						users = users
							.Where(u => u.UserId != userId && !u.IsPeer &&
								(statusId == 0 || statusId > 0 && statusId == u.StatusId) &&
								(roleId == 0 || roleId > 0 && roleId == u.RoleId));
						if (recursive)
						{
							users = users
								.Join(childUsers, u => u.UserId, ch => ch, (u, ch) => u);
						}
						else
						{
							users = users
								.Join(childUsers, u => u.OwnerId, ch => ch, (u, ch) => u);
						}
					} else
					{
						users = users.Where(u => false);
					}

					if (!string.IsNullOrEmpty(filterValue))
					{
						if (!string.IsNullOrEmpty(filterColumn))
						{
							users = users.Where(DynamicFunctions.ColumnLike(users, filterColumn, filterValue));
						}
						else
						{
							users = users.Where(u => u.Username == filterValue ||
								u.FullName == filterValue ||
								u.Email == filterValue);
						}
					}

					if (!string.IsNullOrEmpty(sortColumn))
					{
						users = users.OrderBy(sortColumn);
					}

					var count = users.Count();

					users = users.Skip(startRow).Take(maximumRows);
					
					var usersSelected = users
						.AsEnumerable()
						.Select(u => new
						{
							u.UserId,
							u.RoleId,
							u.StatusId,
							u.SubscriberNumber,
							u.LoginStatusId,
							u.FailedLogins,
							u.OwnerId,
							u.Created,
							u.Changed,
							u.IsDemo,
							Comments = Local.GetItemComments(u.UserId, "USER", actorId),
							u.IsPeer,
							u.Username,
							u.FirstName,
							u.LastName,
							u.Email,
							u.FullName,
							u.OwnerUsername,
							u.OwnerFirstName,
							u.OwnerLastName,
							u.OwnerRoleId,
							u.OwnerFullName,
							u.OwnerEmail,
							u.PackagesNumber,
							u.CompanyName,
							u.EcommerceEnabled
						});

					return EntityDataSet(count, usersSelected);
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUsersPaged",
					 new SqlParameter("@actorId", actorId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					 new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					 new SqlParameter("@statusId", statusId),
					 new SqlParameter("@roleId", roleId),
					 new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					 new SqlParameter("@startRow", startRow),
					 new SqlParameter("@maximumRows", maximumRows),
					 new SqlParameter("@recursive", recursive));
			}
		}

		//TODO START
		public DataSet GetSearchObject(int actorId, int userId, string filterColumn, string filterValue,
			int statusId, int roleId, string sortColumn, int startRow, int maximumRows, string colType, string fullType,
			bool recursive, bool onlyFind)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSearchObject]
(
	@ActorID int,
	@UserID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@StatusID int,
	@RoleID int,
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int = 0,
	@Recursive bit,
	@ColType nvarchar(500) = '',
	@FullType nvarchar(50) = '',
	@OnlyFind bit
)
AS

IF @ColType IS NULL
	SET @ColType = ''

DECLARE @HasUserRights bit
SET @HasUserRights = dbo.CheckActorUserRights(@ActorID, @UserID)

IF @HasUserRights = 0
RAISERROR('You are not allowed to access this account', 16, 1)

DECLARE @curAll CURSOR
DECLARE @curUsers CURSOR
DECLARE @ItemID int
DECLARE @TextSearch nvarchar(500)
DECLARE @ColumnType nvarchar(50)
DECLARE @FullTypeAll nvarchar(50)
DECLARE @PackageID int
DECLARE @AccountID int
DECLARE @Username nvarchar(50)
DECLARE @Fullname nvarchar(50)
DECLARE @ItemsAll TABLE
 (
  ItemID int,
  TextSearch nvarchar(500),
  ColumnType nvarchar(50),
  FullType nvarchar(50),
  PackageID int,
  AccountID int,
  Username nvarchar(100),
  Fullname nvarchar(100)
 )
DECLARE @sql nvarchar(max)

/*------------------------------------------------Users---------------------------------------------------------------*//*
DECLARE @columnUsername nvarchar(20)
SET @columnUsername = 'Username'

DECLARE @columnEmail nvarchar(20)
SET @columnEmail = 'Email'

DECLARE @columnCompanyName nvarchar(20)
SET @columnCompanyName = 'CompanyName'

DECLARE @columnFullName nvarchar(20)
SET @columnFullName = 'FullName'

IF @FilterColumn = '' AND @FilterValue<> ''
SET @FilterColumn = 'TextSearch'

SET @sql = '
DECLARE @Users TABLE
(
 ItemPosition int IDENTITY(0, 1),
 UserID int,
 Username nvarchar(100),
 Fullname nvarchar(100)
)
INSERT INTO @Users(UserID, Username, Fullname)
SELECT
 U.UserID,
 U.Username,
 U.FirstName + '' '' + U.LastName as Fullname
FROM UsersDetailed AS U
WHERE
 U.UserID<> @UserID AND U.IsPeer = 0 AND
 (
  (@Recursive = 0 AND OwnerID = @UserID) OR
  (@Recursive = 1 AND dbo.CheckUserParent(@UserID, U.UserID) = 1)
 )
 AND((@StatusID = 0) OR(@StatusID > 0 AND U.StatusID = @StatusID))
 AND((@RoleID = 0) OR(@RoleID > 0 AND U.RoleID = @RoleID))
 AND ' + CAST((@HasUserRights) AS varchar(12)) + ' = 1
 SET @curValue = cursor local for
SELECT '

IF @OnlyFind = 1
	SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + 'U.ItemID,
 U.TextSearch,
 U.ColumnType,
 ''AccountHome'' as FullType,
 0 as PackageID,
 0 as AccountID,
 TU.Username,
 TU.Fullname
FROM @Users AS TU
INNER JOIN
(
SELECT ItemID, TextSearch, ColumnType
FROM(
SELECT U0.UserID as ItemID, U0.Username as TextSearch, @columnUsername as ColumnType
FROM dbo.Users AS U0
UNION
SELECT U1.UserID as ItemID, U1.Email as TextSearch, @columnEmail as ColumnType
FROM dbo.Users AS U1
UNION
SELECT U2.UserID as ItemID, U2.CompanyName as TextSearch, @columnCompanyName as ColumnType
FROM dbo.Users AS U2
UNION
SELECT U3.UserID as ItemID, U3.FirstName + '' '' + U3.LastName as TextSearch, @columnFullName as ColumnType
FROM dbo.Users AS U3) as U
WHERE TextSearch<>'' '' OR ISNULL(TextSearch, 0) > 0
)
 AS U ON TU.UserID = U.ItemID'
IF @FilterValue<> ''
 SET @sql = @sql + ' WHERE TextSearch LIKE ''' + @FilterValue + ''''
SET @sql = @sql + ' ORDER BY TextSearch'

SET @sql = @sql + ';open @curValue'

exec sp_executesql @sql, N'@UserID int, @FilterValue nvarchar(50), @Recursive bit, @StatusID int, @RoleID int, @columnUsername nvarchar(20), @columnEmail nvarchar(20), @columnCompanyName nvarchar(20), @columnFullName nvarchar(20), @curValue cursor output',
@UserID, @FilterValue, @Recursive, @StatusID, @RoleID, @columnUsername, @columnEmail, @columnCompanyName, @columnFullName, @curUsers output

/*--------------------------------------------Space----------------------------------------------------------*//*
DECLARE @sqlNameAccountType nvarchar(4000)
SET @sqlNameAccountType = '
WHEN 1 THEN ''Mailbox''
WHEN 2 THEN ''Contact''
WHEN 3 THEN ''DistributionList''
WHEN 4 THEN ''PublicFolder''
WHEN 5 THEN ''Room''
WHEN 6 THEN ''Equipment''
WHEN 7 THEN ''User''
WHEN 8 THEN ''SecurityGroup''
WHEN 9 THEN ''DefaultSecurityGroup''
WHEN 10 THEN ''SharedMailbox''
WHEN 11 THEN ''DeletedUser''
WHEN 12 THEN ''JournalingMailbox''
'

SET @sql = '
 DECLARE @ItemsService TABLE
 (
  ItemID int,
  ItemTypeID int,
  Username nvarchar(100),
  Fullname nvarchar(100)
 )
 INSERT INTO @ItemsService(ItemID, ItemTypeID, Username, Fullname)
 SELECT
  SI.ItemID,
  SI.ItemTypeID,
  U.Username,
  U.FirstName + '' '' + U.LastName as Fullname
 FROM ServiceItems AS SI
 INNER JOIN Packages AS P ON P.PackageID = SI.PackageID
 INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
 WHERE
  dbo.CheckUserParent(@UserID, P.UserID) = 1
 DECLARE @ItemsDomain TABLE
 (
  ItemID int,
  Username nvarchar(100),
  Fullname nvarchar(100)
 )
 INSERT INTO @ItemsDomain(ItemID, Username, Fullname)
 SELECT
  D.DomainID,
  U.Username,
  U.FirstName + '' '' + U.LastName as Fullname
 FROM Domains AS D
 INNER JOIN Packages AS P ON P.PackageID = D.PackageID
 INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
 WHERE
  dbo.CheckUserParent(@UserID, P.UserID) = 1

 SET @curValue = cursor local for
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  SI.ItemID as ItemID,
  SI.ItemName as TextSearch,
  STYPE.DisplayName as ColumnType,
  STYPE.DisplayName as FullType,
  SI.PackageID as PackageID,
  0 as AccountID,
  I.Username,
  I.Fullname
 FROM @ItemsService AS I
 INNER JOIN ServiceItems AS SI ON I.ItemID = SI.ItemID
 INNER JOIN ServiceItemTypes AS STYPE ON SI.ItemTypeID = STYPE.ItemTypeID
 WHERE(STYPE.Searchable = 1
 AND STYPE.ItemTypeID<> 200 AND STYPE.ItemTypeID<> 201)'
IF @FilterValue<> ''
 SET @sql = @sql + ' AND (SI.ItemName LIKE ''' + @FilterValue + ''')'
SET @sql = @sql + '
 UNION(
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  D.DomainID AS ItemID,
  D.DomainName as TextSearch,
  ''Domain'' as ColumnType,
  ''Domains'' as FullType,
  D.PackageID as PackageID,
  0 as AccountID,
  I.Username,
  I.Fullname
 FROM @ItemsDomain AS I
 INNER JOIN Domains AS D ON I.ItemID = D.DomainID
 WHERE(D.IsDomainPointer = 0)'
IF @FilterValue<> ''
 SET @sql = @sql + ' AND (D.DomainName LIKE ''' + @FilterValue + ''')'
SET @sql = @sql + '
 UNION
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  EA.ItemID AS ItemID,
  EA.DisplayName as TextSearch,
  ''ExchangeAccount'' as ColumnType,
  FullType = CASE EA.AccountType ' + @sqlNameAccountType + ' ELSE CAST(EA.AccountType AS varchar(12)) END,
  SI2.PackageID as PackageID,
  EA.AccountID as AccountID,
  I2.Username,
  I2.Fullname
 FROM @ItemsService AS I2
 INNER JOIN ServiceItems AS SI2 ON I2.ItemID = SI2.ItemID
 INNER JOIN ExchangeAccounts AS EA ON I2.ItemID = EA.ItemID'
IF @FilterValue<> ''
 SET @sql = @sql + ' WHERE (EA.DisplayName LIKE ''' + @FilterValue + ''')'
SET @sql = @sql + '
 UNION
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  EA4.ItemID AS ItemID,
  EA4.PrimaryEmailAddress as TextSearch,
  ''ExchangeAccount'' as ColumnType,
  FullType = CASE EA4.AccountType ' + @sqlNameAccountType + ' ELSE CAST(EA4.AccountType AS varchar(12)) END,
  SI4.PackageID as PackageID,
  EA4.AccountID as AccountID,
  I4.Username,
  I4.Fullname
 FROM @ItemsService AS I4
 INNER JOIN ServiceItems AS SI4 ON I4.ItemID = SI4.ItemID
 INNER JOIN ExchangeAccounts AS EA4 ON I4.ItemID = EA4.ItemID'
IF @FilterValue<> ''
 SET @sql = @sql + ' WHERE (EA4.PrimaryEmailAddress LIKE ''' + @FilterValue + ''')'
SET @sql = @sql + '
 UNION
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  I3.ItemID AS ItemID,
  EAEA.EmailAddress as TextSearch,
  ''ExchangeAccount'' as ColumnType,
  FullType = CASE EA.AccountType ' + @sqlNameAccountType + ' ELSE CAST(EA.AccountType AS varchar(12)) END,
  SI3.PackageID as PackageID,
  EAEA.AccountID as AccountID,
  I3.Username,
  I3.Fullname
 FROM @ItemsService AS I3
 INNER JOIN ServiceItems AS SI3 ON I3.ItemID = SI3.ItemID
 INNER JOIN ExchangeAccounts AS EA ON I3.ItemID = EA.ItemID
 INNER JOIN ExchangeAccountEmailAddresses AS EAEA ON EA.AccountID = EAEA.AccountID
 WHERE I3.ItemTypeID = 29'
IF @FilterValue<> ''
 SET @sql = @sql + ' AND (EAEA.EmailAddress LIKE ''' + @FilterValue + ''')'
 SET @sql = @sql + ')'
IF @OnlyFind = 1
	SET @sql = @sql + ' ORDER BY TextSearch';

SET @sql = @sql + ';open @curValue'

exec sp_executesql @sql, N'@UserID int, @FilterValue nvarchar(50), @curValue cursor output',
@UserID, @FilterValue, @curAll output

FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
WHILE @@FETCH_STATUS = 0
BEGIN
INSERT INTO @ItemsAll(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
VALUES(@ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname)
FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
END

/*-------------------------------------------Lync-----------------------------------------------------*//*
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SET @sql = '
SET @curValue = cursor local for
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  SI.ItemID as ItemID,
  ea.AccountName as TextSearch,
  ''LyncAccount'' as ColumnType,
  ''LyncUsers'' as FullType,
  SI.PackageID as PackageID,
  ea.AccountID as AccountID,
  U.Username,
  U.FirstName + '' '' + U.LastName as Fullname
 FROM
  ExchangeAccounts as ea
 INNER JOIN
  LyncUsers as LU
 INNER JOIN
  LyncUserPlans as lp
  ON
  LU.LyncUserPlanId = lp.LyncUserPlanId
 ON
  ea.AccountID = LU.AccountID
 INNER JOIN
  ServiceItems AS SI ON ea.ItemID = SI.ItemID
 INNER JOIN
  Packages AS P ON SI.PackageID = P.PackageID
 INNER JOIN
  Users AS U ON U.UserID = P.UserID
WHERE ' + CAST((@HasUserRights) AS varchar(12)) + ' = 1
  AND(' + CAST((@IsAdmin) AS varchar(12)) + ' = 1 OR P.UserID = @UserID)'
IF @FilterValue<> ''
 SET @sql = @sql + ' AND ea.AccountName LIKE ''' + @FilterValue + ''''
IF @OnlyFind = 1
	SET @sql = @sql + ' ORDER BY TextSearch'
SET @sql = @sql + ' ;open @curValue'

CLOSE @curAll
DEALLOCATE @curAll
exec sp_executesql @sql, N'@UserID int, @curValue cursor output', @UserID, @curAll output

FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
WHILE @@FETCH_STATUS = 0
BEGIN
INSERT INTO @ItemsAll(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
VALUES(@ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname)
FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
END

/*-------------------------------------------SfB-----------------------------------------------------*//*

SET @sql = '
SET @curValue = cursor local for
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  SI.ItemID as ItemID,
  ea.AccountName as TextSearch,
  ''SfBAccount'' as ColumnType,
  ''SfBUsers'' as FullType,
  SI.PackageID as PackageID,
  ea.AccountID as AccountID,
  U.Username,
  U.FirstName + '' '' + U.LastName as Fullname
 FROM
  ExchangeAccounts as ea
 INNER JOIN
  SfBUsers as LU
 INNER JOIN
  SfBUserPlans as lp
  ON
  LU.SfBUserPlanId = lp.SfBUserPlanId
 ON
  ea.AccountID = LU.AccountID
 INNER JOIN
  ServiceItems AS SI ON ea.ItemID = SI.ItemID
 INNER JOIN
  Packages AS P ON SI.PackageID = P.PackageID
 INNER JOIN
  Users AS U ON U.UserID = P.UserID
WHERE ' + CAST((@HasUserRights) AS varchar(12)) + ' = 1
  AND(' + CAST((@IsAdmin) AS varchar(12)) + ' = 1 OR P.UserID = @UserID)'
IF @FilterValue<> ''
 SET @sql = @sql + ' AND ea.AccountName LIKE ''' + @FilterValue + ''''
IF @OnlyFind = 1
	SET @sql = @sql + ' ORDER BY TextSearch'
SET @sql = @sql + ' ;open @curValue'

CLOSE @curAll
DEALLOCATE @curAll
exec sp_executesql @sql, N'@UserID int, @curValue cursor output', @UserID, @curAll output

FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
WHILE @@FETCH_STATUS = 0
BEGIN
INSERT INTO @ItemsAll(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
VALUES(@ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname)
FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
END

/*------------------------------------RDS------------------------------------------------*//*
IF @IsAdmin = 1
BEGIN
	SET @sql = '
	SET @curValue = cursor local for
	 SELECT '

	IF @OnlyFind = 1
	SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

	SET @sql = @sql + '
	  RDSCol.ItemID as ItemID,
	  RDSCol.Name as TextSearch,
	  ''RDSCollection'' as ColumnType,
	  ''RDSCollections'' as FullType,
	  P.PackageID as PackageID,
	  RDSCol.ID as AccountID,
	  U.Username,
	  U.FirstName + '' '' + U.LastName as Fullname
	 FROM
	  RDSCollections AS RDSCol
	 INNER JOIN
	  ServiceItems AS SI ON RDSCol.ItemID = SI.ItemID
	 INNER JOIN
	  Packages AS P ON SI.PackageID = P.PackageID
	 INNER JOIN
	  Users AS U ON U.UserID = P.UserID
	 WHERE ' + CAST((@HasUserRights) AS varchar(12)) + ' = 1
	 AND(' + CAST((@IsAdmin) AS varchar(12)) + ' = 1 OR P.UserID = @UserID)'
	IF @FilterValue<> ''
		SET @sql = @sql + ' AND RDSCol.Name LIKE ''' + @FilterValue + ''''
	IF @OnlyFind = 1
		SET @sql = @sql + ' ORDER BY TextSearch'
	SET @sql = @sql + ' ;open @curValue'

	CLOSE @curAll
	DEALLOCATE @curAll
	exec sp_executesql @sql, N'@UserID int, @curValue cursor output', @UserID, @curAll output

	FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
	WHILE @@FETCH_STATUS = 0
	BEGIN
	INSERT INTO @ItemsAll(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
	VALUES(@ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname)
	FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
	END
END

/*------------------------------------CRM------------------------------------------------*//*
SET @sql = '
SET @curValue = cursor local for
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  @UserID as ItemID,
  ea.AccountName as TextSearch,
  ''CRMSite'' as ColumnType,
  ''CRMSites'' as FullType,
  SI.PackageID as PackageID,
  ea.AccountID as AccountID,
  U.Username,
  U.FirstName + '' '' + U.LastName as Fullname
 FROM
  ExchangeAccounts as ea
 INNER JOIN
  CRMUsers AS CRMU ON ea.AccountID = CRMU.AccountID
 INNER JOIN
  ServiceItems AS SI ON ea.ItemID = SI.ItemID
 INNER JOIN
  Packages AS P ON SI.PackageID = P.PackageID
 INNER JOIN
  Users AS U ON U.UserID = P.UserID
 WHERE ' + CAST((@HasUserRights) AS varchar(12)) + ' = 1
  AND(' + CAST((@IsAdmin) AS varchar(12)) + ' = 1 OR P.UserID = @UserID)'
IF @FilterValue<> ''
	SET @sql = @sql + ' AND ea.AccountName LIKE ''' + @FilterValue + ''''
IF @OnlyFind = 1
	SET @sql = @sql + ' ORDER BY TextSearch'
SET @sql = @sql + ' ;open @curValue'

CLOSE @curAll
DEALLOCATE @curAll
exec sp_executesql @sql, N'@UserID int, @curValue cursor output', @UserID, @curAll output

FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
WHILE @@FETCH_STATUS = 0
BEGIN
INSERT INTO @ItemsAll(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
VALUES(@ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname)
FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
END

/*------------------------------------VirtualServer------------------------------------------------*//*
IF @IsAdmin = 1
BEGIN
	SET @sql = '
	SET @curValue = cursor local for
	 SELECT '

	IF @OnlyFind = 1
	SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

	SET @sql = @sql + '
	  @UserID as ItemID,
	  S.ServerName as TextSearch,
	  ''VirtualServer'' as ColumnType,
	  ''VirtualServers'' as FullType,
	  (SELECT MIN(PackageID) FROM Packages WHERE UserID = @UserID) as PackageID,
	  0 as AccountID,
	  U.Username,
	  U.FirstName + '' '' + U.LastName as Fullname
	 FROM
	  Servers AS S
	 INNER JOIN

	  Packages AS P ON P.ServerID = S.ServerID

	 INNER JOIN

	  Users AS U ON U.UserID = P.UserID
	 WHERE
	  VirtualServer = 1'
	IF @FilterValue<> ''
		SET @sql = @sql + ' AND S.ServerName LIKE ''' + @FilterValue + ''''
	IF @OnlyFind = 1
		SET @sql = @sql + ' ORDER BY TextSearch'
	SET @sql = @sql + ' ;open @curValue'

	CLOSE @curAll
	DEALLOCATE @curAll
	exec sp_executesql @sql, N'@UserID int, @curValue cursor output', @UserID, @curAll output

	FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
	WHILE @@FETCH_STATUS = 0
	BEGIN
	INSERT INTO @ItemsAll(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
	VALUES(@ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname)
	FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
	END
END

/*------------------------------------WebDAVFolder------------------------------------------------*//*
SET @sql = '
SET @curValue = cursor local for
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  EF.ItemID as ItemID,
  EF.FolderName as TextSearch,
  ''WebDAVFolder'' as ColumnType,
  ''Folders'' as FullType,
  P.PackageID as PackageID,
  EF.EnterpriseFolderID as AccountID,
  U.Username,
  U.FirstName + '' '' + U.LastName as Fullname
 FROM
  EnterpriseFolders as EF
 INNER JOIN
  ServiceItems AS SI ON EF.ItemID = SI.ItemID
 INNER JOIN
  Packages AS P ON SI.PackageID = P.PackageID
 INNER JOIN
  Users AS U ON U.UserID = P.UserID
 WHERE ' + CAST((@HasUserRights) AS varchar(12)) + ' = 1
  AND(' + CAST((@IsAdmin) AS varchar(12)) + ' = 1 OR P.UserID = @UserID)'
IF @FilterValue<> ''
	SET @sql = @sql + ' AND EF.FolderName LIKE ''' + @FilterValue + ''''
IF @OnlyFind = 1
	SET @sql = @sql + ' ORDER BY TextSearch'
SET @sql = @sql + ';open @curValue'

CLOSE @curAll
DEALLOCATE @curAll
exec sp_executesql @sql, N'@UserID int, @curValue cursor output', @UserID, @curAll output

FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
WHILE @@FETCH_STATUS = 0
BEGIN
INSERT INTO @ItemsAll(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
VALUES(@ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname)
FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
END

/*------------------------------------VPS-IP------------------------------------------------*//*
SET @sql = '
SET @curValue = cursor local for
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  SI.ItemID as ItemID,
  SI.ItemName as TextSearch,
  SIT.DisplayName as ColumnType,
  SIT.DisplayName as FullType,
  P.PackageID as PackageID,
  0 as AccountID,
  U.Username,
  U.FirstName + '' '' + U.LastName as Fullname
 FROM ServiceItems AS SI
 INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
 INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
 INNER JOIN Users AS U ON U.UserID = P.UserID
 LEFT JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID
 LEFT JOIN PackageIPAddresses AS PACIP ON PACIP.ItemID = SI.ItemID
 LEFT JOIN IPAddresses AS IPS ON IPS.AddressID = PACIP.AddressID
 WHERE SIT.DisplayName = ''VirtualMachine''
  AND ' + CAST((@HasUserRights) AS varchar(12)) + ' = 1
  AND dbo.CheckUserParent(@UserID, P.UserID) = 1
  AND(''' + @FilterValue + ''' LIKE '' %.% '' OR ''' + @FilterValue + ''' LIKE '' %:% '')
  AND(PIP.IPAddress LIKE ''' + @FilterValue + ''' OR IPS.ExternalIP LIKE ''' + @FilterValue + ''')'
IF @OnlyFind = 1
	SET @sql = @sql + ' ORDER BY TextSearch'
SET @sql = @sql + ';open @curValue'

CLOSE @curAll
DEALLOCATE @curAll
exec sp_executesql @sql, N'@UserID int, @curValue cursor output', @UserID, @curAll output

FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
WHILE @@FETCH_STATUS = 0
BEGIN
INSERT INTO @ItemsAll(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
VALUES(@ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname)
FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
END

/*------------------------------------SharePoint------------------------------------------------*//*
SET @sql = '
SET @curValue = cursor local for
 SELECT '

IF @OnlyFind = 1
SET @sql = @sql + 'TOP ' + CAST(@MaximumRows AS varchar(12)) + ' '

SET @sql = @sql + '
  SIP.PropertyValue as ItemID,
  T.PropertyValue as TextSearch,
  SIT.DisplayName as ColumnType,
  ''SharePointSiteCollections'' as FullType,
  P.PackageID as PackageID,
  SI.ItemID as AccountID,
  U.Username,
  U.FirstName + '' '' + U.LastName as Fullname
FROM ServiceItems AS SI
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Users AS U ON U.UserID = P.UserID
INNER JOIN ServiceItemProperties AS SIP ON SIP.ItemID = SI.ItemID
RIGHT JOIN ServiceItemProperties AS T ON T.ItemID = SIP.ItemID
WHERE ' + CAST((@HasUserRights) AS varchar(12)) + ' = 1
AND(' + CAST((@IsAdmin) AS varchar(12)) + ' = 1 OR P.UserID = @UserID)
AND(SIT.DisplayName = ''SharePointFoundationSiteCollection''
	OR SIT.DisplayName = ''SharePointEnterpriseSiteCollection'')
AND SIP.PropertyName = ''OrganizationId''
AND T.PropertyName = ''PhysicalAddress'''
IF @FilterValue<> ''
	SET @sql = @sql + ' AND T.PropertyValue LIKE ''' + @FilterValue + ''''
IF @OnlyFind = 1
	SET @sql = @sql + ' ORDER BY TextSearch'
SET @sql = @sql + ';open @curValue'

CLOSE @curAll
DEALLOCATE @curAll
exec sp_executesql @sql, N'@UserID int, @curValue cursor output', @UserID, @curAll output

FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
WHILE @@FETCH_STATUS = 0
BEGIN
INSERT INTO @ItemsAll(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
VALUES(@ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname)
FETCH NEXT FROM @curAll INTO @ItemID, @TextSearch, @ColumnType, @FullTypeAll, @PackageID, @AccountID, @Username, @Fullname
END

/*-------------------------------------------@curAll-------------------------------------------------------*//*
CLOSE @curAll
DEALLOCATE @curAll
SET @curAll = CURSOR LOCAL FOR
 SELECT
	ItemID,
	TextSearch,
	ColumnType,
	FullType,
	PackageID,
	AccountID,
	Username,
	Fullname
 FROM @ItemsAll
OPEN @curAll

/*-------------------------------------------Return-------------------------------------------------------*//*
IF @SortColumn = ''
	SET @SortColumn = 'TextSearch'

SET @sql = '
DECLARE @ItemID int
DECLARE @TextSearch nvarchar(500)
DECLARE @ColumnType nvarchar(50)
DECLARE @FullType nvarchar(50)
DECLARE @PackageID int
DECLARE @AccountID int
DECLARE @EndRow int
DECLARE @Username nvarchar(100)
DECLARE @Fullname nvarchar(100)
SET @EndRow = @StartRow + @MaximumRows'

IF(@ColType = '' OR @ColType IN('AccountHome'))
BEGIN
	SET @sql = @sql + '
	DECLARE @ItemsUser TABLE
	(
		ItemID int,
		TextSearch nvarchar(500),
		ColumnType nvarchar(50),
		FullType nvarchar(50),
		PackageID int,
		AccountID int,
		Username nvarchar(100),
		Fullname nvarchar(100)
	)

	FETCH NEXT FROM @curUsersValue INTO @ItemID, @TextSearch, @ColumnType, @FullType, @PackageID, @AccountID, @Username, @Fullname
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF(1 = 1)'

	IF @FullType<> ''
		SET @sql = @sql + ' AND @FullType = ''' + @FullType + '''';

	SET @sql = @sql + '
		BEGIN
			INSERT INTO @ItemsUser(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
			VALUES(@ItemID, @TextSearch, @ColumnType, @FullType, @PackageID, @AccountID, @Username, @Fullname)
		END
		FETCH NEXT FROM @curUsersValue INTO @ItemID, @TextSearch, @ColumnType, @FullType, @PackageID, @AccountID, @Username, @Fullname
	END'
END

SET @sql = @sql + '
DECLARE @ItemsFilter TABLE
 (
  ItemID int,
  TextSearch nvarchar(500),
  ColumnType nvarchar(50),
  FullType nvarchar(50),
  PackageID int,
  AccountID int,
  Username nvarchar(100),
  Fullname nvarchar(100)
 )

FETCH NEXT FROM @curAllValue INTO @ItemID, @TextSearch, @ColumnType, @FullType, @PackageID, @AccountID, @Username, @Fullname
WHILE @@FETCH_STATUS = 0
BEGIN
	IF(1 = 1)'

IF @ColType<> ''
SET @sql = @sql + ' AND @ColumnType in ( ' + @ColType + ' ) ';

				IF @FullType<> ''
SET @sql = @sql + ' AND @FullType = ''' + @FullType + '''';

				SET @sql = @sql + '
	BEGIN
		INSERT INTO @ItemsFilter(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
		VALUES(@ItemID, @TextSearch, @ColumnType, @FullType, @PackageID, @AccountID, @Username, @Fullname)
	END
	FETCH NEXT FROM @curAllValue INTO @ItemID, @TextSearch, @ColumnType, @FullType, @PackageID, @AccountID, @Username, @Fullname
END

DECLARE @ItemsReturn TABLE
 (
  ItemPosition int IDENTITY(1, 1),
  ItemID int,
  TextSearch nvarchar(500),
  ColumnType nvarchar(50),
  FullType nvarchar(50),
  PackageID int,
  AccountID int,
  Username nvarchar(100),
  Fullname nvarchar(100)
 )'

IF(@ColType = '' OR @ColType IN('AccountHome'))
BEGIN
	SET @sql = @sql + '
		INSERT INTO '
	IF @SortColumn = 'TextSearch'
		SET @sql = @sql + '@ItemsReturn'
	ELSE
		SET @sql = @sql + '@ItemsFilter'
	SET @sql = @sql + ' (ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
		SELECT ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname
		FROM @ItemsUser'
END

SET @sql = @sql + '
INSERT INTO @ItemsReturn(ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname)
SELECT
	ItemID,
	TextSearch,
	ColumnType,
	FullType,
	PackageID,
	AccountID,
	Username,
	Fullname
FROM @ItemsFilter'
SET @sql = @sql + ' ORDER BY ' + @SortColumn

SET @sql = @sql + ';
SELECT COUNT(ItemID) FROM @ItemsReturn;
				SELECT DISTINCT(ColumnType) FROM @ItemsReturn';
IF @FullType<> ''
	SET @sql = @sql + ' WHERE FullType = ''' + @FullType + '''';

				SET @sql = @sql + ';
SELECT ItemPosition, ItemID, TextSearch, ColumnType, FullType, PackageID, AccountID, Username, Fullname
FROM @ItemsReturn AS IR'

IF @MaximumRows > 0
	SET @sql = @sql + ' WHERE IR.ItemPosition BETWEEN @StartRow AND @EndRow';

				exec sp_executesql @sql, N'@StartRow int, @MaximumRows int, @FilterValue nvarchar(50), @curUsersValue cursor, @curAllValue cursor',
	@StartRow, @MaximumRows, @FilterValue, @curUsers, @curAll

CLOSE @curAll
DEALLOCATE @curAll

RETURN
				*/
				#endregion

				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				if (colType == null) colType = "";

				if (string.IsNullOrEmpty(filterColumn) && !string.IsNullOrEmpty(filterValue)) filterColumn = "TextSearch";

				//TODO not yet implemented

				throw new NotImplementedException();

			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetSearchObject",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					 new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					 new SqlParameter("@StatusId", statusId),
					 new SqlParameter("@RoleId", roleId),
					 new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					 new SqlParameter("@StartRow", startRow),
					 new SqlParameter("@MaximumRows", maximumRows),
					 new SqlParameter("@Recursive", recursive),
					 new SqlParameter("@ColType", colType),
					 new SqlParameter("@FullType", fullType),
					 new SqlParameter("@OnlyFind", onlyFind));
			}
		}

		public DataSet GetSearchTableByColumns(string PagedStored, string FilterValue, int MaximumRows,
			 bool Recursive, int PoolID, int ServerID, int ActorID, int StatusID, int PlanID, int OrgID,
			 string ItemTypeName, string GroupName, int PackageID, string VPSType, int RoleID, int UserID,
			 string FilterColumns)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSearchTableByColumns]
(
	@PagedStored nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@MaximumRows int,

	@Recursive bit,
	@PoolID int,
	@ServerID int,
	@ActorID int,
	@StatusID int,
	@PlanID int,
	@OrgID int,
	@ItemTypeName nvarchar(200),
	@GroupName nvarchar(100) = NULL,
	@PackageID int,
	@VPSType nvarchar(100) = NULL,
	@UserID int,
	@RoleID int,
	@FilterColumns nvarchar(200)
)
AS

DECLARE @VPSTypeID int
IF @VPSType <> '' AND @VPSType IS NOT NULL
BEGIN
	SET @VPSTypeID = CASE @VPSType
		WHEN 'VPS' THEN 33
		WHEN 'VPS2012' THEN 41
		WHEN 'Proxmox' THEN 143
		WHEN 'VPSForPC' THEN 35
		ELSE 33
		END
END

DECLARE @sql nvarchar(3000)
SET @sql = CASE @PagedStored
WHEN 'Domains' THEN '
	DECLARE @Domains TABLE
	(
		DomainID int,
		DomainName nvarchar(100),
		Username nvarchar(100),
		FullName nvarchar(100),
		Email nvarchar(100)
	)
	INSERT INTO @Domains (DomainID, DomainName, Username, FullName, Email)
	SELECT
		D.DomainID,
		D.DomainName,
		U.Username,
		U.FullName,
		U.Email
	FROM Domains AS D
	INNER JOIN Packages AS P ON D.PackageID = P.PackageID
	INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
	LEFT OUTER JOIN ServiceItems AS Z ON D.ZoneItemID = Z.ItemID
	LEFT OUTER JOIN Services AS S ON Z.ServiceID = S.ServiceID
	LEFT OUTER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
	WHERE
		(D.IsPreviewDomain = 0 AND D.IsDomainPointer = 0)
		AND ((@Recursive = 0 AND D.PackageID = @PackageID)
		OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, D.PackageID) = 1))
		AND (@ServerID = 0 OR (@ServerID > 0 AND S.ServerID = @ServerID))
	'
WHEN 'IPAddresses' THEN '
	DECLARE @IPAddresses TABLE
	(
		AddressesID int,
		ExternalIP nvarchar(100),
		InternalIP nvarchar(100),
		DefaultGateway nvarchar(100),
		ServerName nvarchar(100),
		UserName nvarchar(100),
		ItemName nvarchar(100)
	)
	DECLARE @IsAdmin bit
	SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)
	INSERT INTO @IPAddresses (AddressesID, ExternalIP, InternalIP, DefaultGateway, ServerName, UserName, ItemName)
	SELECT
		IP.AddressID,
		IP.ExternalIP,
		IP.InternalIP,
		IP.DefaultGateway,
		S.ServerName,
		U.UserName,
		SI.ItemName
	FROM dbo.IPAddresses AS IP
	LEFT JOIN Servers AS S ON IP.ServerID = S.ServerID
	LEFT JOIN PackageIPAddresses AS PA ON IP.AddressID = PA.AddressID
	LEFT JOIN ServiceItems SI ON PA.ItemId = SI.ItemID
	LEFT JOIN dbo.Packages P ON PA.PackageID = P.PackageID
	LEFT JOIN dbo.Users U ON P.UserID = U.UserID
	WHERE
		@IsAdmin = 1
		AND (@PoolID = 0 OR @PoolID <> 0 AND IP.PoolID = @PoolID)
		AND (@ServerID = 0 OR @ServerID <> 0 AND IP.ServerID = @ServerID)
	'
WHEN 'Schedules' THEN '
	DECLARE @Schedules TABLE
	(
		ScheduleID int,
		ScheduleName nvarchar(100),
		Username nvarchar(100),
		FullName nvarchar(100),
		Email nvarchar(100)
	)
	INSERT INTO @Schedules (ScheduleID, ScheduleName, Username, FullName, Email)
	SELECT
		S.ScheduleID,
		S.ScheduleName,
		U.Username,
		U.FullName,
		U.Email
	FROM Schedule AS S
	INNER JOIN Packages AS P ON S.PackageID = P.PackageID
	INNER JOIN PackagesTree(@PackageID, @Recursive) AS PT ON S.PackageID = PT.PackageID
	INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
	'
WHEN 'NestedPackages' THEN '
	DECLARE @NestedPackages TABLE
	(
		PackageID int,
		PackageName nvarchar(100),
		Username nvarchar(100),
		FullName nvarchar(100),
		Email nvarchar(100)
	)
	INSERT INTO @NestedPackages (PackageID, PackageName, Username, FullName, Email)
	SELECT
		P.PackageID,
		P.PackageName,
		U.Username,
		U.FullName,
		U.Email
	FROM Packages AS P
	INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
	INNER JOIN Servers AS S ON P.ServerID = S.ServerID
	INNER JOIN HostingPlans AS HP ON P.PlanID = HP.PlanID
	WHERE
		P.ParentPackageID = @PackageID
		AND ((@StatusID = 0) OR (@StatusID > 0 AND P.StatusID = @StatusID))
		AND ((@PlanID = 0) OR (@PlanID > 0 AND P.PlanID = @PlanID))
		AND ((@ServerID = 0) OR (@ServerID > 0 AND P.ServerID = @ServerID))
	'
WHEN 'PackageIPAddresses' THEN '
	DECLARE @PackageIPAddresses TABLE
	(
		PackageAddressID int,
		ExternalIP nvarchar(100),
		InternalIP nvarchar(100),
		DefaultGateway nvarchar(100),
		ItemName nvarchar(100),
		UserName nvarchar(100)
	)
	INSERT INTO @PackageIPAddresses (PackageAddressID, ExternalIP, InternalIP, DefaultGateway, ItemName, UserName)
	SELECT
		PA.PackageAddressID,
		IP.ExternalIP,
		IP.InternalIP,
		IP.DefaultGateway,
		SI.ItemName,
		U.UserName
	FROM dbo.PackageIPAddresses PA
	INNER JOIN dbo.IPAddresses AS IP ON PA.AddressID = IP.AddressID
	INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
	INNER JOIN dbo.Users U ON U.UserID = P.UserID
	LEFT JOIN ServiceItems SI ON PA.ItemId = SI.ItemID
	WHERE
		((@Recursive = 0 AND PA.PackageID = @PackageID)
		OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, PA.PackageID) = 1))
		AND (@PoolID = 0 OR @PoolID <> 0 AND IP.PoolID = @PoolID)
		AND (@OrgID = 0 OR @OrgID <> 0 AND PA.OrgID = @OrgID)
	'
WHEN 'ServiceItems' THEN '
	IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
	RAISERROR(''You are not allowed to access this package'', 16, 1)
	DECLARE @ServiceItems TABLE
	(
		ItemID int,
		ItemName nvarchar(100),
		Username nvarchar(100),
		FullName nvarchar(100),
		Email nvarchar(100)
	)
	DECLARE @GroupID int
	SELECT @GroupID = GroupID FROM ResourceGroups
	WHERE GroupName = @GroupName
	DECLARE @ItemTypeID int
	SELECT @ItemTypeID = ItemTypeID FROM ServiceItemTypes
	WHERE TypeName = @ItemTypeName
	AND ((@GroupID IS NULL) OR (@GroupID IS NOT NULL AND GroupID = @GroupID))
	INSERT INTO @ServiceItems (ItemID, ItemName, Username, FullName, Email)
	SELECT
		SI.ItemID,
		SI.ItemName,
		U.Username,
		U.FirstName,
		U.Email
	FROM Packages AS P
	INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
	INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
	INNER JOIN ServiceItemTypes AS IT ON SI.ItemTypeID = IT.ItemTypeID
	INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
	INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
	WHERE
		SI.ItemTypeID = @ItemTypeID
		AND ((@Recursive = 0 AND P.PackageID = @PackageID)
			OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, P.PackageID) = 1))
		AND ((@GroupID IS NULL) OR (@GroupID IS NOT NULL AND IT.GroupID = @GroupID))
		AND (@ServerID = 0 OR (@ServerID > 0 AND S.ServerID = @ServerID))
	'
WHEN 'Users' THEN '
	DECLARE @Users TABLE
	(
		UserID int,
		Username nvarchar(100),
		FullName nvarchar(100),
		Email nvarchar(100),
		CompanyName nvarchar(100)
	)
	DECLARE @HasUserRights bit
	SET @HasUserRights = dbo.CheckActorUserRights(@ActorID, @UserID)
	INSERT INTO @Users (UserID, Username, FullName, Email, CompanyName)
	SELECT
		U.UserID,
		U.Username,
		U.FullName,
		U.Email,
		U.CompanyName
	FROM UsersDetailed AS U
	WHERE 
		U.UserID <> @UserID AND U.IsPeer = 0 AND
		(
			(@Recursive = 0 AND OwnerID = @UserID) OR
			(@Recursive = 1 AND dbo.CheckUserParent(@UserID, U.UserID) = 1)
		)
		AND ((@StatusID = 0) OR (@StatusID > 0 AND U.StatusID = @StatusID))
		AND ((@RoleID = 0) OR (@RoleID > 0 AND U.RoleID = @RoleID))
		AND @HasUserRights = 1 
	'
WHEN 'VirtualMachines' THEN '
	IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
	RAISERROR(''You are not allowed to access this package'', 16, 1)
	DECLARE @VirtualMachines TABLE
	(
		ItemID int,
		ItemName nvarchar(100),
		Username nvarchar(100),
		ExternalIP nvarchar(100),
		IPAddress nvarchar(100)
	)
	INSERT INTO @VirtualMachines (ItemID, ItemName, Username, ExternalIP, IPAddress)
	SELECT
		SI.ItemID,
		SI.ItemName,
		U.Username,
		EIP.ExternalIP,
		PIP.IPAddress
	FROM Packages AS P
	INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
	INNER JOIN Users AS U ON P.UserID = U.UserID
	LEFT OUTER JOIN (
		SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
		INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
		WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
	) AS EIP ON SI.ItemID = EIP.ItemID
	LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
	WHERE
		SI.ItemTypeID = ' + CAST(@VPSTypeID AS nvarchar(12)) + '
		AND ((@Recursive = 0 AND P.PackageID = @PackageID)
		OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, P.PackageID) = 1))
	'
WHEN 'PackagePrivateIPAddresses' THEN '
	DECLARE @PackagePrivateIPAddresses TABLE
	(
		PrivateAddressID int,
		IPAddress nvarchar(100),
		ItemName nvarchar(100)
	)
	INSERT INTO @PackagePrivateIPAddresses (PrivateAddressID, IPAddress, ItemName)
	SELECT
		PA.PrivateAddressID,
		PA.IPAddress,
		SI.ItemName
	FROM dbo.PrivateIPAddresses AS PA
	INNER JOIN dbo.ServiceItems AS SI ON PA.ItemID = SI.ItemID
	WHERE SI.PackageID = @PackageID
	'
ELSE ''
END + 'SELECT TOP ' + CAST(@MaximumRows AS nvarchar(12)) + ' MIN(ItemID) as [ItemID], TextSearch, ColumnType, COUNT(*) AS [Count]' + CASE @PagedStored
WHEN 'Domains' THEN '
	FROM(
	SELECT D0.DomainID AS ItemID, D0.DomainName AS TextSearch, ''DomainName'' AS ColumnType
	FROM @Domains AS D0
	UNION
	SELECT D1.DomainID AS ItemID, D1.Username AS TextSearch, ''Username'' AS ColumnType
	FROM @Domains AS D1
	UNION
	SELECT D2.DomainID as ItemID, D2.FullName AS TextSearch, ''FullName'' AS ColumnType
	FROM @Domains AS D2
	UNION
	SELECT D3.DomainID as ItemID, D3.Email AS TextSearch, ''Email'' AS ColumnType
	FROM @Domains AS D3) AS D'
WHEN 'IPAddresses' THEN '
	FROM(
	SELECT D0.AddressesID AS ItemID, D0.ExternalIP AS TextSearch, ''ExternalIP'' AS ColumnType
	FROM @IPAddresses AS D0
	UNION
	SELECT D1.AddressesID AS ItemID, D1.InternalIP AS TextSearch, ''InternalIP'' AS ColumnType
	FROM @IPAddresses AS D1
	UNION
	SELECT D2.AddressesID AS ItemID, D2.DefaultGateway AS TextSearch, ''DefaultGateway'' AS ColumnType
	FROM @IPAddresses AS D2
	UNION
	SELECT D3.AddressesID AS ItemID, D3.ServerName AS TextSearch, ''ServerName'' AS ColumnType
	FROM @IPAddresses AS D3
	UNION
	SELECT D4.AddressesID AS ItemID, D4.UserName AS TextSearch, ''UserName'' AS ColumnType
	FROM @IPAddresses AS D4
	UNION
	SELECT D6.AddressesID AS ItemID, D6.ItemName AS TextSearch, ''ItemName'' AS ColumnType
	FROM @IPAddresses AS D6) AS D'
WHEN 'Schedules' THEN '
	FROM(
	SELECT D0.ScheduleID AS ItemID, D0.ScheduleName AS TextSearch, ''ScheduleName'' AS ColumnType
	FROM @Schedules AS D0
	UNION
	SELECT D1.ScheduleID AS ItemID, D1.Username AS TextSearch, ''Username'' AS ColumnType
	FROM @Schedules AS D1
	UNION
	SELECT D2.ScheduleID AS ItemID, D2.FullName AS TextSearch, ''FullName'' AS ColumnType
	FROM @Schedules AS D2
	UNION
	SELECT D3.ScheduleID AS ItemID, D3.Email AS TextSearch, ''Email'' AS ColumnType
	FROM @Schedules AS D3) AS D'
WHEN 'NestedPackages' THEN '
	FROM(
	SELECT D0.PackageID AS ItemID, D0.PackageName AS TextSearch, ''PackageName'' AS ColumnType
	FROM @NestedPackages AS D0
	UNION
	SELECT D1.PackageID AS ItemID, D1.Username AS TextSearch, ''Username'' AS ColumnType
	FROM @NestedPackages AS D1
	UNION
	SELECT D2.PackageID as ItemID, D2.FullName AS TextSearch, ''FullName'' AS ColumnType
	FROM @NestedPackages AS D2
	UNION
	SELECT D3.PackageID as ItemID, D3.Email AS TextSearch, ''Email'' AS ColumnType
	FROM @NestedPackages AS D3) AS D'
WHEN 'PackageIPAddresses' THEN '
	FROM(
	SELECT D0.PackageAddressID AS ItemID, D0.ExternalIP AS TextSearch, ''ExternalIP'' AS ColumnType
	FROM @PackageIPAddresses AS D0
	UNION
	SELECT D1.PackageAddressID AS ItemID, D1.InternalIP AS TextSearch, ''InternalIP'' AS ColumnType
	FROM @PackageIPAddresses AS D1
	UNION
	SELECT D2.PackageAddressID as ItemID, D2.DefaultGateway AS TextSearch, ''DefaultGateway'' AS ColumnType
	FROM @PackageIPAddresses AS D2
	UNION
	SELECT D3.PackageAddressID as ItemID, D3.ItemName AS TextSearch, ''ItemName'' AS ColumnType
	FROM @PackageIPAddresses AS D3
	UNION
	SELECT D5.PackageAddressID as ItemID, D5.UserName AS TextSearch, ''UserName'' AS ColumnType
	FROM @PackageIPAddresses AS D5) AS D'
WHEN 'ServiceItems' THEN '
	FROM(
	SELECT D0.ItemID AS ItemID, D0.ItemName AS TextSearch, ''ItemName'' AS ColumnType
	FROM @ServiceItems AS D0
	UNION
	SELECT D1.ItemID AS ItemID, D1.Username AS TextSearch, ''Username'' AS ColumnType
	FROM @ServiceItems AS D1
	UNION
	SELECT D2.ItemID as ItemID, D2.FullName AS TextSearch, ''FullName'' AS ColumnType
	FROM @ServiceItems AS D2
	UNION
	SELECT D3.ItemID as ItemID, D3.Email AS TextSearch, ''Email'' AS ColumnType
	FROM @ServiceItems AS D3) AS D'
WHEN 'Users' THEN '
	FROM(
	SELECT D0.UserID AS ItemID, D0.Username AS TextSearch, ''Username'' AS ColumnType
	FROM @Users AS D0
	UNION
	SELECT D1.UserID AS ItemID, D1.FullName AS TextSearch, ''FullName'' AS ColumnType
	FROM @Users AS D1
	UNION
	SELECT D2.UserID as ItemID, D2.Email AS TextSearch, ''Email'' AS ColumnType
	FROM @Users AS D2
	UNION
	SELECT D3.UserID as ItemID, D3.CompanyName AS TextSearch, ''CompanyName'' AS ColumnType
	FROM @Users AS D3) AS D'
WHEN 'VirtualMachines' THEN '
	FROM(
	SELECT D0.ItemID AS ItemID, D0.ItemName AS TextSearch, ''ItemName'' AS ColumnType
	FROM @VirtualMachines AS D0
	UNION
	SELECT D1.ItemID AS ItemID, D1.ExternalIP AS TextSearch, ''ExternalIP'' AS ColumnType
	FROM @VirtualMachines AS D1
	UNION
	SELECT D2.ItemID as ItemID, D2.Username AS TextSearch, ''Username'' AS ColumnType
	FROM @VirtualMachines AS D2
	UNION
	SELECT D3.ItemID as ItemID, D3.IPAddress AS TextSearch, ''IPAddress'' AS ColumnType
	FROM @VirtualMachines AS D3) AS D'
WHEN 'PackagePrivateIPAddresses' THEN '
	FROM(
	SELECT D0.PrivateAddressID AS ItemID, D0.IPAddress AS TextSearch, ''IPAddress'' AS ColumnType
	FROM @PackagePrivateIPAddresses AS D0
	UNION
	SELECT D1.PrivateAddressID AS ItemID, D1.ItemName AS TextSearch, ''ItemName'' AS ColumnType
	FROM @PackagePrivateIPAddresses AS D1) AS D'
END + '
	WHERE (TextSearch LIKE @FilterValue)'
IF @FilterColumns <> '' AND @FilterColumns IS NOT NULL
	SET @sql = @sql + '
		AND (ColumnType IN (' + @FilterColumns + '))'
SET @sql = @sql + '
	GROUP BY TextSearch, ColumnType
	ORDER BY TextSearch'

exec sp_executesql @sql, N'@FilterValue nvarchar(50), @Recursive bit, @PoolID int, @ServerID int, @ActorID int, @StatusID int, @PlanID int, @OrgID int, @ItemTypeName nvarchar(200), @GroupName nvarchar(100), @PackageID int, @VPSTypeID int, @UserID int, @RoleID int', 
@FilterValue, @Recursive, @PoolID, @ServerID, @ActorID, @StatusID, @PlanID, @OrgID, @ItemTypeName, @GroupName, @PackageID, @VPSTypeID, @UserID, @RoleID

RETURN
				*/
				#endregion

				throw new NotImplementedException();
			}
			else
			{

				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetSearchTableByColumns",
					 new SqlParameter("@PagedStored", PagedStored),
					 new SqlParameter("@FilterValue", FilterValue),
					 new SqlParameter("@MaximumRows", MaximumRows),
					 new SqlParameter("@Recursive", Recursive),
					 new SqlParameter("@PoolID", PoolID),
					 new SqlParameter("@ServerID", ServerID),
					 new SqlParameter("@ActorID", ActorID),
					 new SqlParameter("@StatusID", StatusID),
					 new SqlParameter("@PlanID", PlanID),
					 new SqlParameter("@OrgID", OrgID),
					 new SqlParameter("@ItemTypeName", ItemTypeName),
					 new SqlParameter("@GroupName", GroupName),
					 new SqlParameter("@PackageID", PackageID),
					 new SqlParameter("@VPSType", VPSType),
					 new SqlParameter("@RoleID", RoleID),
					 new SqlParameter("@UserID", UserID),
					 new SqlParameter("@FilterColumns", FilterColumns));
			}
		}

		//TODO END
		public DataSet GetUsersSummary(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUsersSummary]
(
	@ActorID int,
	@UserID int
)
AS
-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

-- ALL users
SELECT COUNT(UserID) AS UsersNumber FROM Users
WHERE OwnerID = @UserID AND IsPeer = 0

-- BY STATUS users
SELECT StatusID, COUNT(UserID) AS UsersNumber FROM Users
WHERE OwnerID = @UserID AND IsPeer = 0
GROUP BY StatusID
ORDER BY StatusID

-- BY ROLE users
SELECT RoleID, COUNT(UserID) AS UsersNumber FROM Users
WHERE OwnerID = @UserID AND IsPeer = 0
GROUP BY RoleID
ORDER BY RoleID DESC

RETURN
				*/
				#endregion

				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var users = Users.Where(u => u.OwnerId == userId && !u.IsPeer);
				var nofUsers = new { UsersNumber = users.Count() };
				var usersByStatus = users
					.GroupBy(u => u.StatusId)
					.Select(g => new { StatusId = g.Key, UsersNumber = g.Count() })
					.OrderBy(g => g.StatusId);
				var usersByRole = users
					.GroupBy(u => u.RoleId)
					.Select(g => new { RoleId = g.Key, UsersNumber = g.Count() })
					.OrderByDescending(g => g.RoleId);

				var set = new DataSet();
				set.Tables.Add(EntityDataTable(new object[] { nofUsers }));
				set.Tables.Add(EntityDataTable(usersByStatus));
				set.Tables.Add(EntityDataTable(usersByRole));

				return set;
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUsersSummary",
					 new SqlParameter("@actorId", actorId),
					 new SqlParameter("@UserID", userId));
			}
		}

		public TempIdSet UsersTree(int ownerId, bool recursive)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[UsersTree]
(
	@OwnerID int,
	@Recursive bit = 0
)
RETURNS @T TABLE (UserID int)
AS
BEGIN

	IF @Recursive = 1
	BEGIN
		-- insert ""root"" user
		INSERT @T VALUES(@OwnerID)

		-- get all children recursively
		WHILE @@ROWCOUNT > 0
		BEGIN
			INSERT @T SELECT UserID
			FROM Users
			WHERE OwnerID IN(SELECT UserID from @T) AND UserID NOT IN(SELECT UserID FROM @T)
		END
	END
	ELSE
	BEGIN
		INSERT @T VALUES(@OwnerID)
	END

RETURN
END
			*/
			#endregion

			var tree = new TempIdSet(this);
			tree.Add(ownerId);
			SaveChanges();

			if (recursive)
			{
				int level = 0;
				var children = Users
					.Where(u => u.OwnerId == ownerId)
					.Select(u => u.UserId);
				while (tree.AddRange(children, ++level) > 0)
				{
					children = Users
						.Join(tree.OfLevel(level), u => u.OwnerId, ch => ch, (u, ch) => u.UserId);
				}
			}

			return tree;
		}
		public DataSet GetUserDomainsPaged(int actorId, int userId, string filterColumn, string filterValue,
			 string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserDomainsPaged]
(
	@ActorID int,
	@UserID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS
-- build query and run it to the temporary table
DECLARE @sql nvarchar(2000)

SET @sql = '
DECLARE @HasUserRights bit
SET @HasUserRights = dbo.CheckActorUserRights(@ActorID, @UserID)

DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows
DECLARE @Users TABLE
(
	ItemPosition int IDENTITY(1,1),
	UserID int,
	DomainID int
)
INSERT INTO @Users (UserID, DomainID)
SELECT
	U.UserID,
	D.DomainID
FROM Users AS U
INNER JOIN UsersTree(@UserID, 1) AS UT ON U.UserID = UT.UserID
LEFT OUTER JOIN Packages AS P ON U.UserID = P.UserID
LEFT OUTER JOIN Domains AS D ON P.PackageID = D.PackageID
WHERE
	U.UserID <> @UserID AND U.IsPeer = 0
	AND @HasUserRights = 1 '

IF @FilterColumn <> '' AND @FilterValue <> ''
SET @sql = @sql + ' AND ' + @FilterColumn + ' LIKE @FilterValue '

IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + ' SELECT COUNT(UserID) FROM @Users;
SELECT
	U.UserID,
	U.RoleID,
	U.StatusID,
	U.SubscriberNumber,
	U.LoginStatusId,
	U.FailedLogins,
	U.OwnerID,
	U.Created,
	U.Changed,
	U.IsDemo,
	U.Comments,
	U.IsPeer,
	U.Username,
	U.FirstName,
	U.LastName,
	U.Email,
	D.DomainName
FROM @Users AS TU
INNER JOIN Users AS U ON TU.UserID = U.UserID
LEFT OUTER JOIN Domains AS D ON TU.DomainID = D.DomainID
WHERE TU.ItemPosition BETWEEN @StartRow AND @EndRow'

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int, @UserID int, @FilterValue nvarchar(50), @ActorID int',
@StartRow, @MaximumRows, @UserID, @FilterValue, @ActorID

RETURN
				*/
				#endregion

				var hasRights = CheckActorUserRights(actorId, userId);

				using (var tree = UsersTree(userId, true))
				{
					var users = Users
						.Join(tree, u => u.UserId, ut => ut, (user, ut) => user)
						.Join(Packages, u => u.UserId, p => p.UserId, (user, package) => new { User = user, PackageId = package.PackageId })
						.Join(Domains, up => up.PackageId, d => d.PackageId, (user, domain) => new
						{
							user.User.UserId,
							user.User.RoleId,
							user.User.StatusId,
							user.User.SubscriberNumber,
							user.User.LoginStatusId,
							user.User.FailedLogins,
							user.User.OwnerId,
							user.User.Created,
							user.User.Changed,
							user.User.IsDemo,
							user.User.Comments,
							user.User.IsPeer,
							user.User.Username,
							user.User.FirstName,
							user.User.LastName,
							user.User.Email,
							domain.DomainName
						})
						.Where(u => u.UserId != userId && !u.IsPeer && hasRights);

					if (!string.IsNullOrEmpty(filterColumn) && !string.IsNullOrEmpty(filterValue))
					{
						users = users.Where(DynamicFunctions.ColumnLike(users, filterColumn, filterValue));
					}

					var count = users.Count();

					if (!string.IsNullOrEmpty(sortColumn))
					{
						users = users.OrderBy(sortColumn);
					}

					return EntityDataSet(count, users);
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserDomainsPaged",
					 new SqlParameter("@actorId", actorId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@filterColumn", VerifyColumnName(filterColumn)),
					 new SqlParameter("@filterValue", VerifyColumnValue(filterValue)),
					 new SqlParameter("@sortColumn", VerifyColumnName(sortColumn)),
					 new SqlParameter("@startRow", startRow),
					 new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public bool CanGetUserDetails(int actorId, int userId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CanGetUserDetails]
(
	@ActorID int,
	@UserID int
)
RETURNS bit
AS
BEGIN

IF @ActorID = -1
RETURN 1

-- check if the user requests himself
IF @ActorID = @UserID
BEGIN
	RETURN 1
END

DECLARE @IsPeer bit
DECLARE @OwnerID int

SELECT @IsPeer = IsPeer, @OwnerID = OwnerID FROM Users
WHERE UserID = @ActorID

IF @IsPeer = 1
SET @ActorID = @OwnerID

-- get user's owner
SELECT @OwnerID = OwnerID FROM Users
WHERE UserID = @ActorID

IF @UserID = @OwnerID
RETURN 1 -- user can get the details of his owner

-- check if the user requests himself
IF @ActorID = @UserID
BEGIN
	RETURN 1
END

DECLARE @ParentUserID int, @TmpUserID int
SET @TmpUserID = @UserID

WHILE 10 = 10
BEGIN

	SET @ParentUserID = NULL --reset var

	-- get owner
	SELECT
		@ParentUserID = OwnerID
	FROM Users
	WHERE UserID = @TmpUserID

	IF @ParentUserID IS NULL -- the last parent
		BREAK

	IF @ParentUserID = @ActorID
	RETURN 1

	SET @TmpUserID = @ParentUserID
END

RETURN 0
END
			*/
			#endregion

			if (actorId == -1 || actorId == userId) return true;

			var actor = Users
				.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
				.FirstOrDefault(u => u.UserId == actorId);
			if (actor != null && actor.IsPeer && actor.OwnerId.HasValue)
			{
				actorId = actor.OwnerId.Value;
				actor = Users
					.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
					.FirstOrDefault(u => u.UserId == actorId);
			}

			if (actor != null && actor.OwnerId.HasValue && userId == actor.OwnerId.Value) return true;

			var id = userId;
			var user = Users
				.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
				.FirstOrDefault(u => u.UserId == id);
			while (user != null && user.OwnerId.HasValue && user.OwnerId != actorId)
			{
				id = user.OwnerId.Value;
				user = Users
					.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
					.FirstOrDefault(u => u.UserId == id);
			}

			return user != null && user.OwnerId.HasValue && user.OwnerId == actorId;
		}
		public DataSet GetUsers(int actorId, int ownerId, bool recursive)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUsers]
(
	@ActorID int,
	@OwnerID int,
	@Recursive bit = 0
)
AS

DECLARE @CanGetDetails bit
SET @CanGetDetails = dbo.CanGetUserDetails(@ActorID, @OwnerID)

SELECT
	U.UserID,
	U.RoleID,
	U.StatusID,
	U.SubscriberNumber,
	U.LoginStatusId,
	U.FailedLogins,
	U.OwnerID,
	U.Created,
	U.Changed,
	U.IsDemo,
	U.Comments,
	U.IsPeer,
	U.Username,
	U.FirstName,
	U.LastName,
	U.Email,
	U.FullName,
	U.OwnerUsername,
	U.OwnerFirstName,
	U.OwnerLastName,
	U.OwnerRoleID,
	U.OwnerFullName,
	U.PackagesNumber,
	U.CompanyName,
	U.EcommerceEnabled
FROM UsersDetailed AS U
WHERE U.UserID <> @OwnerID AND
((@Recursive = 1 AND dbo.CheckUserParent(@OwnerID, U.UserID) = 1) OR
(@Recursive = 0 AND U.OwnerID = @OwnerID))
AND U.IsPeer = 0
AND @CanGetDetails = 1 -- actor user rights

RETURN
				*/
				#endregion

				var canGetDetails = CanGetUserDetails(actorId, ownerId);

				using (var childUsers = UserChildren(ownerId, recursive))
				{
					var users = UsersDetailed
						.Where(u => canGetDetails && u.UserId != ownerId && !u.IsPeer)
						.Join(childUsers, u => u.UserId, ch => ch, (u, ch) => new
						{
							u.UserId,
							u.RoleId,
							u.StatusId,
							u.SubscriberNumber,
							u.LoginStatusId,
							u.FailedLogins,
							u.OwnerId,
							u.Created,
							u.Changed,
							u.IsDemo,
							u.Comments,
							u.IsPeer,
							u.Username,
							u.FirstName,
							u.LastName,
							u.Email,
							u.FullName,
							u.OwnerUsername,
							u.OwnerFirstName,
							u.OwnerLastName,
							u.OwnerRoleId,
							u.OwnerFullName,
							u.PackagesNumber,
							u.CompanyName,
							u.EcommerceEnabled
						});

					return EntityDataSet(users);
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUsers",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@OwnerID", ownerId),
					 new SqlParameter("@Recursive", recursive));
			}
		}

		public DataSet GetUserParents(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserParents]
(
	@ActorID int,
	@UserID int
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

SELECT
	U.UserID,
	U.RoleID,
	U.StatusID,
	U.SubscriberNumber,
	U.LoginStatusId,
	U.FailedLogins,
	U.OwnerID,
	U.Created,
	U.Changed,
	U.IsDemo,
	U.Comments,
	U.IsPeer,
	U.Username,
	U.FirstName,
	U.LastName,
	U.Email,
	U.CompanyName,
	U.EcommerceEnabled
FROM UserParents(@ActorID, @UserID) AS UP
INNER JOIN Users AS U ON UP.UserID = U.UserID
ORDER BY UP.UserOrder DESC
RETURN
				*/
				#endregion

				if (!CheckActorUserRights(actorId, userId)) throw new AccessViolationException("You are not allowed to access this account");

				using (var parents = UserParents(actorId, userId).ToTempIdSet(this))
				{
					var users = Users
						.Join(parents.TempIds(), u => u.UserId, p => p.Id, (user, parent) => new { User = user, Order = parent.Key })
						.OrderByDescending(u => u.Order)
						.Select(u => new
						{
							u.User.UserId,
							u.User.RoleId,
							u.User.StatusId,
							u.User.SubscriberNumber,
							u.User.LoginStatusId,
							u.User.FailedLogins,
							u.User.OwnerId,
							u.User.Created,
							u.User.Changed,
							u.User.IsDemo,
							u.User.Comments,
							u.User.IsPeer,
							u.User.Username,
							u.User.FirstName,
							u.User.LastName,
							u.User.Email,
							u.User.CompanyName,
							u.User.EcommerceEnabled
						});
					return EntityDataSet(users);
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserParents",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId));
			}
		}

		public DataSet GetUserPeers(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserPeers]
(
	@ActorID int,
	@UserID int
)
AS

DECLARE @CanGetDetails bit
SET @CanGetDetails = dbo.CanGetUserDetails(@ActorID, @UserID)

SELECT
	U.UserID,
	U.RoleID,
	U.StatusID,
	U.LoginStatusId,
	U.FailedLogins,
	U.OwnerID,
	U.Created,
	U.Changed,
	U.IsDemo,
	U.Comments,
	U.IsPeer,
	U.Username,
	U.FirstName,
	U.LastName,
	U.Email,
	U.FullName,
	(U.FirstName + ' ' + U.LastName) AS FullName,
	U.CompanyName,
	U.EcommerceEnabled
FROM UsersDetailed AS U
WHERE U.OwnerID = @UserID AND IsPeer = 1
AND @CanGetDetails = 1 -- actor rights

RETURN
				*/
				#endregion

				var canGetDetails = CanGetUserDetails(actorId, userId);

				var userPeers = Users
					.Where(u => canGetDetails && u.OwnerId == userId && u.IsPeer)
					.Select(u => new
					{
						u.UserId,
						u.RoleId,
						u.StatusId,
						u.LoginStatusId,
						u.FailedLogins,
						u.OwnerId,
						u.Created,
						u.Changed,
						u.IsDemo,
						u.Comments,
						u.IsPeer,
						u.Username,
						u.FirstName,
						u.LastName,
						u.Email,
						FullName = u.FirstName + " " + u.LastName,
						u.CompanyName,
						u.EcommerceEnabled
					});
				return EntityDataSet(userPeers);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserPeers",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@userId", userId));
			}
		}

		public IDataReader GetUserByExchangeOrganizationIdInternally(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserByExchangeOrganizationIdInternally]
(
	@ItemID int
)
AS
	SELECT
		U.UserID,
		U.RoleID,
		U.StatusID,
		U.SubscriberNumber,
		U.LoginStatusId,
		U.FailedLogins,
		U.OwnerID,
		U.Created,
		U.Changed,
		U.IsDemo,
		U.Comments,
		U.IsPeer,
		U.Username,
		U.Password,
		U.FirstName,
		U.LastName,
		U.Email,
		U.SecondaryEmail,
		U.Address,
		U.City,
		U.State,
		U.Country,
		U.Zip,
		U.PrimaryPhone,
		U.SecondaryPhone,
		U.Fax,
		U.InstantMessenger,
		U.HtmlMail,
		U.CompanyName,
		U.EcommerceEnabled,
		U.[AdditionalParams]
	FROM Users AS U
	WHERE U.UserID IN (SELECT UserID FROM Packages WHERE PackageID IN (
	SELECT PackageID FROM ServiceItems WHERE ItemID = @ItemID))

RETURN
				*/
				#endregion

				var users = Users
					.Join(Packages, u => u.UserId, p => p.UserId, (user, package) => new { User = user, package.PackageId })
					.Join(ServiceItems, u => u.PackageId, s => s.PackageId, (user, serviceItem) => new { user.User, serviceItem.ItemId })
					.Where(u => u.ItemId == itemId)
					.Select(u => new
					{
						u.User.RoleId,
						u.User.StatusId,
						u.User.SubscriberNumber,
						u.User.LoginStatusId,
						u.User.FailedLogins,
						u.User.OwnerId,
						u.User.Created,
						u.User.Changed,
						u.User.IsDemo,
						u.User.Comments,
						u.User.IsPeer,
						u.User.Username,
						u.User.Password,
						u.User.FirstName,
						u.User.LastName,
						u.User.Email,
						u.User.SecondaryEmail,
						u.User.Address,
						u.User.City,
						u.User.State,
						u.User.Country,
						u.User.Zip,
						u.User.PrimaryPhone,
						u.User.SecondaryPhone,
						u.User.Fax,
						u.User.InstantMessenger,
						u.User.HtmlMail,
						u.User.CompanyName,
						u.User.EcommerceEnabled,
						u.User.AdditionalParams
					});
				return EntityDataReader(users);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserByExchangeOrganizationIdInternally",
					 new SqlParameter("@ItemID", itemId));
			}
		}



		public IDataReader GetUserByIdInternally(int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserByIdInternally]
(
	@UserID int
)
AS
	SELECT
		U.UserID,
		U.RoleID,
		U.StatusID,
		U.SubscriberNumber,
		U.LoginStatusId,
		U.FailedLogins,
		U.OwnerID,
		U.Created,
		U.Changed,
		U.IsDemo,
		U.Comments,
		U.IsPeer,
		U.Username,
		U.Password,
		U.FirstName,
		U.LastName,
		U.Email,
		U.SecondaryEmail,
		U.Address,
		U.City,
		U.State,
		U.Country,
		U.Zip,
		U.PrimaryPhone,
		U.SecondaryPhone,
		U.Fax,
		U.InstantMessenger,
		U.HtmlMail,
		U.CompanyName,
		U.EcommerceEnabled,
		U.[AdditionalParams],
		U.OneTimePasswordState,
		U.MfaMode,
		U.PinSecret
	FROM Users AS U
	WHERE U.UserID = @UserID

	RETURN
				*/
				#endregion

				var users = Users
					.Where(u => u.UserId == userId)
					.Select(u => new
					{
						u.UserId,
						u.RoleId,
						u.StatusId,
						u.SubscriberNumber,
						u.LoginStatusId,
						u.FailedLogins,
						u.OwnerId,
						u.Created,
						u.Changed,
						u.IsDemo,
						u.Comments,
						u.IsPeer,
						u.Username,
						u.Password,
						u.FirstName,
						u.LastName,
						u.Email,
						u.SecondaryEmail,
						u.Address,
						u.City,
						u.State,
						u.Country,
						u.Zip,
						u.PrimaryPhone,
						u.SecondaryPhone,
						u.Fax,
						u.InstantMessenger,
						u.HtmlMail,
						u.CompanyName,
						u.EcommerceEnabled,
						u.AdditionalParams,
						u.OneTimePasswordState,
						u.MfaMode,
						u.PinSecret
					});
				return EntityDataReader(users);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserByIdInternally",
					 new SqlParameter("@UserID", userId));
			}
		}

		public IDataReader GetUserByUsernameInternally(string username)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserByUsernameInternally]
(
	@Username nvarchar(50)
)
AS
	SELECT
		U.UserID,
		U.RoleID,
		U.StatusID,
		U.SubscriberNumber,
		U.LoginStatusId,
		U.FailedLogins,
		U.OwnerID,
		U.Created,
		U.Changed,
		U.IsDemo,
		U.Comments,
		U.IsPeer,
		U.Username,
		U.Password,
		U.FirstName,
		U.LastName,
		U.Email,
		U.SecondaryEmail,
		U.Address,
		U.City,
		U.State,
		U.Country,
		U.Zip,
		U.PrimaryPhone,
		U.SecondaryPhone,
		U.Fax,
		U.InstantMessenger,
		U.HtmlMail,
		U.CompanyName,
		U.EcommerceEnabled,
		U.[AdditionalParams],
		U.OneTimePasswordState,
		U.MfaMode,
		U.PinSecret
	FROM Users AS U
	WHERE U.Username = @Username

	RETURN
				*/
				#endregion

				var users = Users
					.Where(u => u.Username == username)
					.Select(u => new
					{
						u.UserId,
						u.RoleId,
						u.StatusId,
						u.SubscriberNumber,
						u.LoginStatusId,
						u.FailedLogins,
						u.OwnerId,
						u.Created,
						u.Changed,
						u.IsDemo,
						u.Comments,
						u.IsPeer,
						u.Username,
						u.Password,
						u.FirstName,
						u.LastName,
						u.Email,
						u.SecondaryEmail,
						u.Address,
						u.City,
						u.State,
						u.Country,
						u.Zip,
						u.PrimaryPhone,
						u.SecondaryPhone,
						u.Fax,
						u.InstantMessenger,
						u.HtmlMail,
						u.CompanyName,
						u.EcommerceEnabled,
						u.AdditionalParams,
						u.OneTimePasswordState,
						u.MfaMode,
						u.PinSecret
					});
				return EntityDataReader(users);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserByUsernameInternally",
					 new SqlParameter("@Username", username));
			}
		}

		public bool CanGetUserPassword(int actorId, int userId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CanGetUserPassword]
(
	@ActorID int,
	@UserID int
)
RETURNS bit
AS
BEGIN

IF @ActorID = -1
RETURN 1 -- unauthenticated mode

-- check if the user requests himself
IF @ActorID = @UserID
BEGIN
	RETURN 1
END

DECLARE @IsPeer bit
DECLARE @OwnerID int

SELECT @IsPeer = IsPeer, @OwnerID = OwnerID FROM Users
WHERE UserID = @ActorID

IF @IsPeer = 1
BEGIN
	-- peer can't get the password of his peers
	-- and his owner
	IF @UserID = @OwnerID
	RETURN 0

	IF EXISTS (
		SELECT UserID FROM Users
		WHERE IsPeer = 1 AND OwnerID = @OwnerID AND UserID = @UserID
	) RETURN 0

	-- set actor to his owner
	SET @ActorID = @OwnerID
END

-- get user's owner
SELECT @OwnerID = OwnerID FROM Users
WHERE UserID = @ActorID

IF @UserID = @OwnerID
RETURN 0 -- user can't get the password of his owner

DECLARE @ParentUserID int, @TmpUserID int
SET @TmpUserID = @UserID

WHILE 10 = 10
BEGIN

	SET @ParentUserID = NULL --reset var

	-- get owner
	SELECT
		@ParentUserID = OwnerID
	FROM Users
	WHERE UserID = @TmpUserID

	IF @ParentUserID IS NULL -- the last parent
		BREAK

	IF @ParentUserID = @ActorID
	RETURN 1

	SET @TmpUserID = @ParentUserID
END

RETURN 0
END
			*/
			#endregion

			if (actorId == -1 || actorId == userId) return true;

			var actor = Users
				.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
				.FirstOrDefault(u => u.UserId == actorId);
			if (actor != null && actor.IsPeer)
			{
				// peer can't get the password of his peers and his owner
				if (actor.OwnerId == userId ||
					Users.Any(u => u.IsPeer && u.OwnerId == actor.OwnerId && u.UserId == userId)) return false;

				// set actor to his owner
				actorId = actor.OwnerId ?? -1;
			}

			// get users owner
			var owner = Users
				.Select(u => new { u.UserId, u.OwnerId })
				.FirstOrDefault(u => u.UserId == actorId);
			if (owner != null && owner.OwnerId == userId) return false; // user can't get the password of his owner

			var id = userId;
			var user = Users
				.Select(u => new { u.UserId, u.OwnerId })
				.FirstOrDefault(u => u.UserId == id);
			while (user != null && user.OwnerId.HasValue && user.OwnerId != actorId)
			{
				id = user.OwnerId.Value;
				user = Users
					.Select(u => new { u.UserId, u.OwnerId })
					.FirstOrDefault(u => u.UserId == id);
			}
			return user != null && user.OwnerId == actorId; // actor is owner of user
		}
		public IDataReader GetUserById(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserById]
(
	@ActorID int,
	@UserID int
)
AS
	-- user can retrieve his own account, his users accounts
	-- and his reseller account (without password)
	SELECT
		U.UserID,
		U.RoleID,
		U.StatusID,
		U.SubscriberNumber,
		U.LoginStatusId,
		U.FailedLogins,
		U.OwnerID,
		U.Created,
		U.Changed,
		U.IsDemo,
		U.Comments,
		U.IsPeer,
		U.Username,
		CASE WHEN dbo.CanGetUserPassword(@ActorID, @UserID) = 1 THEN U.Password
		ELSE '' END AS Password,
		U.FirstName,
		U.LastName,
		U.Email,
		U.SecondaryEmail,
		U.Address,
		U.City,
		U.State,
		U.Country,
		U.Zip,
		U.PrimaryPhone,
		U.SecondaryPhone,
		U.Fax,
		U.InstantMessenger,
		U.HtmlMail,
		U.CompanyName,
		U.EcommerceEnabled,
		U.[AdditionalParams],
		U.MfaMode,
		CASE WHEN dbo.CanGetUserPassword(@ActorID, @UserID) = 1 THEN U.PinSecret
		ELSE '' END AS PinSecret
	FROM Users AS U
	WHERE U.UserID = @UserID
	AND dbo.CanGetUserDetails(@ActorID, @UserID) = 1 -- actor user rights

	RETURN
				*/
				#endregion

				var canGetUserDetails = CanGetUserDetails(actorId, userId);
				var canGetUserPassword = CanGetUserPassword(actorId, userId);
				var user = Users
					.Where(u => u.UserId == userId && canGetUserDetails)
					.Select(u => new UserInfoInternal()
					{
						UserId = u.UserId,
						RoleId = u.RoleId,
						StatusId = u.StatusId,
						SubscriberNumber = u.SubscriberNumber,
						LoginStatusId = u.LoginStatusId ?? 0,
						FailedLogins = u.FailedLogins ?? 0,
						OwnerId = u.OwnerId ?? 0,
						Created = u.Created ?? default(DateTime),
						Changed = u.Changed ?? default(DateTime),
						IsDemo = u.IsDemo,
						Comments = u.Comments,
						IsPeer = u.IsPeer,
						Username = u.Username,
						Password = canGetUserPassword ? u.Password : "",
						FirstName = u.FirstName,
						LastName = u.LastName,
						Email = u.Email,
						SecondaryEmail = u.SecondaryEmail,
						Address = u.Address,
						City = u.City,
						State = u.State,
						Country = u.Country,
						Zip = u.Zip,
						PrimaryPhone = u.PrimaryPhone,
						SecondaryPhone = u.SecondaryPhone,
						Fax = u.Fax,
						InstantMessenger = u.InstantMessenger,
						HtmlMail = u.HtmlMail ?? false,
						CompanyName = u.CompanyName,
						EcommerceEnabled = u.EcommerceEnabled ?? false,
						AdditionalParams = u.AdditionalParams,
						MfaMode = u.MfaMode,
						PinSecret = canGetUserPassword ? u.PinSecret : ""
					});

				return EntityDataReader(user);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserById",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId));
			}
		}

		public IDataReader GetUserByUsername(int actorId, string username)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserByUsername]
(
	@ActorID int,
	@Username nvarchar(50)
)
AS

	SELECT
		U.UserID,
		U.RoleID,
		U.StatusID,
		U.SubscriberNumber,
		U.LoginStatusId,
		U.FailedLogins,
		U.OwnerID,
		U.Created,
		U.Changed,
		U.IsDemo,
		U.Comments,
		U.IsPeer,
		U.Username,
		CASE WHEN dbo.CanGetUserPassword(@ActorID, UserID) = 1 THEN U.Password
		ELSE '' END AS Password,
		U.FirstName,
		U.LastName,
		U.Email,
		U.SecondaryEmail,
		U.Address,
		U.City,
		U.State,
		U.Country,
		U.Zip,
		U.PrimaryPhone,
		U.SecondaryPhone,
		U.Fax,
		U.InstantMessenger,
		U.HtmlMail,
		U.CompanyName,
		U.EcommerceEnabled,
		U.[AdditionalParams],
		U.MfaMode,
		CASE WHEN dbo.CanGetUserPassword(@ActorID, UserID) = 1 THEN U.PinSecret
		ELSE '' END AS PinSecret
	FROM Users AS U
	WHERE U.Username = @Username
	AND dbo.CanGetUserDetails(@ActorID, UserID) = 1 -- actor user rights

	RETURN
				*/
				#endregion

				var user = Users
					.Where(u => u.Username == username)
					.AsEnumerable()
					.Select(u => new UserInfoInternal()
					{
						UserId = u.UserId,
						RoleId = u.RoleId,
						StatusId = u.StatusId,
						SubscriberNumber = u.SubscriberNumber,
						LoginStatusId = u.LoginStatusId ?? 0,
						FailedLogins = u.FailedLogins ?? 0,
						OwnerId = u.OwnerId ?? 0,
						Created = u.Created ?? default(DateTime),
						Changed = u.Changed ?? default(DateTime),
						IsDemo = u.IsDemo,
						Comments = u.Comments,
						IsPeer = u.IsPeer,
						Username = u.Username,
						Password = CanGetUserPassword(actorId, u.UserId) ? u.Password : "",
						FirstName = u.FirstName,
						LastName = u.LastName,
						Email = u.Email,
						SecondaryEmail = u.SecondaryEmail,
						Address = u.Address,
						City = u.City,
						State = u.State,
						Country = u.Country,
						Zip = u.Zip,
						PrimaryPhone = u.PrimaryPhone,
						SecondaryPhone = u.SecondaryPhone,
						Fax = u.Fax,
						InstantMessenger = u.InstantMessenger,
						HtmlMail = u.HtmlMail ?? false,
						CompanyName = u.CompanyName,
						EcommerceEnabled = u.EcommerceEnabled ?? false,
						AdditionalParams = u.AdditionalParams,
						MfaMode = u.MfaMode,
						PinSecret = CanGetUserPassword(actorId, u.UserId) ? u.PinSecret : ""
					})
					.Where(u => Local.CanGetUserDetails(actorId, u.UserId));

				return EntityDataReader(user);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserByUsername",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@Username", username));
			}
		}

		public bool CanCreateUser(int actorId, int ownerId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CanCreateUser]
(
	@ActorID int,
	@UserID int
)
RETURNS bit
AS
BEGIN

IF @ActorID = -1
RETURN 1

-- check if the user requests himself
IF @ActorID = @UserID
RETURN 1

DECLARE @IsPeer bit
DECLARE @OwnerID int

SELECT @IsPeer = IsPeer, @OwnerID = OwnerID FROM Users
WHERE UserID = @ActorID

IF @IsPeer = 1
BEGIN
	SET @ActorID = @OwnerID
END

IF @ActorID = @UserID
RETURN 1

DECLARE @ParentUserID int, @TmpUserID int
SET @TmpUserID = @UserID

WHILE 10 = 10
BEGIN

	SET @ParentUserID = NULL --reset var

	-- get owner
	SELECT
		@ParentUserID = OwnerID
	FROM Users
	WHERE UserID = @TmpUserID

	IF @ParentUserID IS NULL -- the last parent
		BREAK

	IF @ParentUserID = @ActorID
	RETURN 1

	SET @TmpUserID = @ParentUserID
END

RETURN 0
END
			*/
			#endregion

			if (actorId == -1 || actorId == ownerId) return true;

			var actor = Users
				.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
				.FirstOrDefault(u => u.UserId == actorId);
			if (actor != null && actor.IsPeer && actor.OwnerId.HasValue) actorId = actor.OwnerId.Value;
			if (actorId == ownerId) return true;

			var id = ownerId;
			var user = Users
				.Select(u => new { u.UserId, u.OwnerId })
				.FirstOrDefault(u => u.UserId == id);
			while (user != null && user.OwnerId.HasValue && user.OwnerId != actorId)
			{
				id = user.OwnerId.Value;
				user = Users
					.Select(u => new { u.UserId, u.OwnerId })
					.FirstOrDefault(u => u.UserId == id);
			}
			return user != null && user.OwnerId == actorId;
		}

		public int AddUser(int actorId, int ownerId, int roleId, int statusId, string subscriberNumber, int loginStatusId, bool isDemo,
			 bool isPeer, string comments, string username, string password,
			 string firstName, string lastName, string email, string secondaryEmail,
			 string address, string city, string country, string state, string zip,
			 string primaryPhone, string secondaryPhone, string fax, string instantMessenger, bool htmlMail,
			 string companyName, bool ecommerceEnabled)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddUser]
(
	@ActorID int,
	@UserID int OUTPUT,
	@OwnerID int,
	@RoleID int,
	@StatusID int,
	@SubscriberNumber nvarchar(32),
	@LoginStatusID int,
	@IsDemo bit,
	@IsPeer bit,
	@Comments ntext,
	@Username nvarchar(50),
	@Password nvarchar(200),
	@FirstName nvarchar(50),
	@LastName nvarchar(50),
	@Email nvarchar(255),
	@SecondaryEmail nvarchar(255),
	@Address nvarchar(200),
	@City nvarchar(50),
	@State nvarchar(50),
	@Country nvarchar(50),
	@Zip varchar(20),
	@PrimaryPhone varchar(30),
	@SecondaryPhone varchar(30),
	@Fax varchar(30),
	@InstantMessenger nvarchar(200),
	@HtmlMail bit,
	@CompanyName nvarchar(100),
	@EcommerceEnabled bit
)
AS

-- check if the user already exists
IF EXISTS(SELECT UserID FROM Users WHERE Username = @Username)
BEGIN
	SET @UserID = -1
	RETURN
END

-- check actor rights
IF dbo.CanCreateUser(@ActorID, @OwnerID) = 0
BEGIN
	SET @UserID = -2
	RETURN
END

INSERT INTO Users
(
	OwnerID,
	RoleID,
	StatusID,
	SubscriberNumber,
	LoginStatusID,
	Created,
	Changed,
	IsDemo,
	IsPeer,
	Comments,
	Username,
	Password,
	FirstName,
	LastName,
	Email,
	SecondaryEmail,
	Address,
	City,
	State,
	Country,
	Zip,
	PrimaryPhone,
	SecondaryPhone,
	Fax,
	InstantMessenger,
	HtmlMail,
	CompanyName,
	EcommerceEnabled
)
VALUES
(
	@OwnerID,
	@RoleID,
	@StatusID,
	@SubscriberNumber,
	@LoginStatusID,
	GetDate(),
	GetDate(),
	@IsDemo,
	@IsPeer,
	@Comments,
	@Username,
	@Password,
	@FirstName,
	@LastName,
	@Email,
	@SecondaryEmail,
	@Address,
	@City,
	@State,
	@Country,
	@Zip,
	@PrimaryPhone,
	@SecondaryPhone,
	@Fax,
	@InstantMessenger,
	@HtmlMail,
	@CompanyName,
	@EcommerceEnabled
)

SET @UserID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				if (Users.Any(u => u.Username == username)) return -1;
				if (!CanCreateUser(actorId, ownerId)) return -2;
				var user = new Data.Entities.User()
				{
					OwnerId = ownerId,
					RoleId = roleId,
					StatusId = statusId,
					SubscriberNumber = subscriberNumber,
					LoginStatusId = loginStatusId,
					Created = DateTime.Now,
					Changed = DateTime.Now,
					IsDemo = isDemo,
					IsPeer = isPeer,
					Comments = comments,
					Username = username,
					Password = password,
					FirstName = firstName,
					LastName = lastName,
					Email = email,
					SecondaryEmail = secondaryEmail,
					Address = address,
					City = city,
					Country = country,
					State = state,
					Zip = zip,
					PrimaryPhone = primaryPhone,
					SecondaryPhone = secondaryPhone,
					Fax = fax,
					InstantMessenger = instantMessenger,
					HtmlMail = htmlMail,
					CompanyName = companyName,
					EcommerceEnabled = ecommerceEnabled
				};
				Users.Add(user);
				SaveChanges();

				return user.UserId;
			}
			else
			{
				SqlParameter prmUserId = new SqlParameter("@UserID", SqlDbType.Int);
				prmUserId.Direction = ParameterDirection.Output;

				// add user to SolidCP Users table
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "AddUser",
					 prmUserId,
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@OwnerID", ownerId),
					 new SqlParameter("@RoleID", roleId),
					 new SqlParameter("@StatusId", statusId),
					 new SqlParameter("@SubscriberNumber", subscriberNumber),
					 new SqlParameter("@LoginStatusId", loginStatusId),
					 new SqlParameter("@IsDemo", isDemo),
					 new SqlParameter("@IsPeer", isPeer),
					 new SqlParameter("@Comments", comments),
					 new SqlParameter("@username", username),
					 new SqlParameter("@password", password),
					 new SqlParameter("@firstName", firstName),
					 new SqlParameter("@lastName", lastName),
					 new SqlParameter("@email", email),
					 new SqlParameter("@secondaryEmail", secondaryEmail),
					 new SqlParameter("@address", address),
					 new SqlParameter("@city", city),
					 new SqlParameter("@country", country),
					 new SqlParameter("@state", state),
					 new SqlParameter("@zip", zip),
					 new SqlParameter("@primaryPhone", primaryPhone),
					 new SqlParameter("@secondaryPhone", secondaryPhone),
					 new SqlParameter("@fax", fax),
					 new SqlParameter("@instantMessenger", instantMessenger),
					 new SqlParameter("@htmlMail", htmlMail),
					 new SqlParameter("@CompanyName", companyName),
					 new SqlParameter("@EcommerceEnabled", ecommerceEnabled));

				return Convert.ToInt32(prmUserId.Value);
			}
		}

		public bool CanUpdateUserDetails(int actorId, int userId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CanUpdateUserDetails]
(
	@ActorID int,
	@UserID int
)
RETURNS bit
AS
BEGIN

IF @ActorID = -1
RETURN 1

-- check if the user requests himself
IF @ActorID = @UserID
BEGIN
	RETURN 1
END

DECLARE @IsPeer bit
DECLARE @OwnerID int

SELECT @IsPeer = IsPeer, @OwnerID = OwnerID FROM Users
WHERE UserID = @ActorID

IF @IsPeer = 1
BEGIN
	-- check if the peer is trying to update his owner
	IF @UserID = @OwnerID
	RETURN 0

	-- check if the peer is trying to update his peers
	IF EXISTS (SELECT UserID FROM Users
	WHERE IsPeer = 1 AND OwnerID = @OwnerID AND UserID = @UserID)
	RETURN 0

	SET @ActorID = @OwnerID
END

DECLARE @ParentUserID int, @TmpUserID int
SET @TmpUserID = @UserID

WHILE 10 = 10
BEGIN

	SET @ParentUserID = NULL --reset var

	-- get owner
	SELECT
		@ParentUserID = OwnerID
	FROM Users
	WHERE UserID = @TmpUserID

	IF @ParentUserID IS NULL -- the last parent
		BREAK

	IF @ParentUserID = @ActorID
	RETURN 1

	SET @TmpUserID = @ParentUserID
END

RETURN 0
END
			*/
			#endregion

			if (actorId == -1 || actorId == userId) return true;

			var actor = Users
				.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
				.FirstOrDefault(u => u.UserId == actorId);
			if (actor != null && actor.IsPeer && actor.OwnerId.HasValue)
			{
				// check if the peer is trying to update his owner
				if (actor.OwnerId == userId) return false;

				// check if the peer is trying to update his peers
				if (Users.Any(u => u.IsPeer && u.OwnerId == actor.OwnerId && u.UserId == userId)) return false;

				actorId = actor.OwnerId.Value;
			}

			var id = userId;
			var user = Users
				.Select(u => new { u.UserId, u.OwnerId })
				.FirstOrDefault(u => u.UserId == id);
			while (user != null && user.OwnerId.HasValue && user.OwnerId != actorId)
			{
				id = user.OwnerId.Value;
				user = Users
					.Select(u => new { u.UserId, u.OwnerId })
					.FirstOrDefault(u => u.UserId == id);
			}
			return user != null && user.OwnerId == actorId;
		}

		public void UpdateUser(int actorId, int userId, int roleId, int statusId, string subscriberNumber, int loginStatusId, bool isDemo,
			 bool isPeer, string comments, string firstName, string lastName, string email, string secondaryEmail,
			 string address, string city, string country, string state, string zip,
			 string primaryPhone, string secondaryPhone, string fax, string instantMessenger, bool htmlMail,
			 string companyName, bool ecommerceEnabled, string additionalParams)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateUser]
(
	@ActorID int,
	@UserID int,
	@RoleID int,
	@StatusID int,
	@SubscriberNumber nvarchar(32),
	@LoginStatusId int,
	@IsDemo bit,
	@IsPeer bit,
	@Comments ntext,
	@FirstName nvarchar(50),
	@LastName nvarchar(50),
	@Email nvarchar(255),
	@SecondaryEmail nvarchar(255),
	@Address nvarchar(200),
	@City nvarchar(50),
	@State nvarchar(50),
	@Country nvarchar(50),
	@Zip varchar(20),
	@PrimaryPhone varchar(30),
	@SecondaryPhone varchar(30),
	@Fax varchar(30),
	@InstantMessenger nvarchar(200),
	@HtmlMail bit,
	@CompanyName nvarchar(100),
	@EcommerceEnabled BIT,
	@AdditionalParams NVARCHAR(max)
)
AS

	-- check actor rights
	IF dbo.CanUpdateUserDetails(@ActorID, @UserID) = 0
	BEGIN
		RETURN
	END

	IF @LoginStatusId = 0
	BEGIN
		UPDATE Users SET
			FailedLogins = 0
		WHERE UserID = @UserID
	END

	UPDATE Users SET
		RoleID = @RoleID,
		StatusID = @StatusID,
		SubscriberNumber = @SubscriberNumber,
		LoginStatusId = @LoginStatusId,
		Changed = GetDate(),
		IsDemo = @IsDemo,
		IsPeer = @IsPeer,
		Comments = @Comments,
		FirstName = @FirstName,
		LastName = @LastName,
		Email = @Email,
		SecondaryEmail = @SecondaryEmail,
		Address = @Address,
		City = @City,
		State = @State,
		Country = @Country,
		Zip = @Zip,
		PrimaryPhone = @PrimaryPhone,
		SecondaryPhone = @SecondaryPhone,
		Fax = @Fax,
		InstantMessenger = @InstantMessenger,
		HtmlMail = @HtmlMail,
		CompanyName = @CompanyName,
		EcommerceEnabled = @EcommerceEnabled,
		[AdditionalParams] = @AdditionalParams
	WHERE UserID = @UserID

	RETURN
				*/
				#endregion

				if (CanUpdateUserDetails(actorId, userId))
				{
					var user = Users.FirstOrDefault(u => u.UserId == userId);
					if (user != null)
					{
						if (loginStatusId == 0) user.FailedLogins = 0;
						user.RoleId = roleId;
						user.StatusId = statusId;
						user.SubscriberNumber = subscriberNumber;
						user.LoginStatusId = loginStatusId;
						user.IsDemo = isDemo;
						user.IsPeer = isPeer;
						user.Comments = comments;
						user.FirstName = firstName;
						user.LastName = lastName;
						user.Email = email;
						user.SecondaryEmail = secondaryEmail;
						user.Address = address;
						user.City = city;
						user.Country = country;
						user.State = state;
						user.Zip = zip;
						user.PrimaryPhone = primaryPhone;
						user.SecondaryPhone = secondaryPhone;
						user.Fax = fax;
						user.InstantMessenger = instantMessenger;
						user.HtmlMail = htmlMail;
						user.CompanyName = companyName;
						user.EcommerceEnabled = ecommerceEnabled;
						user.AdditionalParams = additionalParams;

						SaveChanges();
					}
				}
			}
			else
			{
				// update user
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "UpdateUser",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@RoleID", roleId),
					 new SqlParameter("@StatusId", statusId),
					 new SqlParameter("@SubscriberNumber", subscriberNumber),
					 new SqlParameter("@LoginStatusId", loginStatusId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@IsDemo", isDemo),
					 new SqlParameter("@IsPeer", isPeer),
					 new SqlParameter("@Comments", comments),
					 new SqlParameter("@firstName", firstName),
					 new SqlParameter("@lastName", lastName),
					 new SqlParameter("@email", email),
					 new SqlParameter("@secondaryEmail", secondaryEmail),
					 new SqlParameter("@address", address),
					 new SqlParameter("@city", city),
					 new SqlParameter("@country", country),
					 new SqlParameter("@state", state),
					 new SqlParameter("@zip", zip),
					 new SqlParameter("@primaryPhone", primaryPhone),
					 new SqlParameter("@secondaryPhone", secondaryPhone),
					 new SqlParameter("@fax", fax),
					 new SqlParameter("@instantMessenger", instantMessenger),
					 new SqlParameter("@htmlMail", htmlMail),
					 new SqlParameter("@CompanyName", companyName),
					 new SqlParameter("@EcommerceEnabled", ecommerceEnabled),
					 new SqlParameter("@AdditionalParams", additionalParams));
			}
		}

		public void UpdateUserFailedLoginAttempt(int userId, int lockOut, bool reset)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateUserFailedLoginAttempt]
(
	@UserID int,
	@LockOut int,
	@Reset int
)
AS

IF (@Reset = 1)
BEGIN
	UPDATE Users SET FailedLogins = 0 WHERE UserID = @UserID
END
ELSE
BEGIN
	IF (@LockOut <= (SELECT FailedLogins FROM USERS WHERE UserID = @UserID))
	BEGIN
		UPDATE Users SET LoginStatusId = 2 WHERE UserID = @UserID
	END
	ELSE
	BEGIN
		IF ((SELECT FailedLogins FROM Users WHERE UserID = @UserID) IS NULL)
		BEGIN
			UPDATE Users SET FailedLogins = 1 WHERE UserID = @UserID
		END
		ELSE
			UPDATE Users SET FailedLogins = FailedLogins + 1 WHERE UserID = @UserID
	END
END
				*/
				#endregion

				var user = Users.FirstOrDefault(u => u.UserId == userId);
				if (user == null) return;

				if (reset) user.FailedLogins = 0;
				else if (lockOut <= (user.FailedLogins ?? 0)) user.LoginStatusId = 2;
				else user.FailedLogins = (user.FailedLogins ?? 0) + 1;

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "UpdateUserFailedLoginAttempt",
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@LockOut", lockOut),
					 new SqlParameter("@Reset", reset));
			}
		}

		public void DeleteUser(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteUser]
(
	@ActorID int,
	@UserID int
)
AS

-- check actor rights
IF dbo.CanUpdateUserDetails(@ActorID, @UserID) = 0
RETURN

BEGIN TRAN
-- delete user comments
DELETE FROM Comments
WHERE ItemID = @UserID AND ItemTypeID = 'USER'

IF (@@ERROR <> 0 )
      BEGIN
            ROLLBACK TRANSACTION
            RETURN -1
      END

--delete reseller addon
DELETE FROM HostingPlans WHERE UserID = @UserID AND IsAddon = 'True'

IF (@@ERROR <> 0 )
      BEGIN
            ROLLBACK TRANSACTION
            RETURN -1
      END

-- delete user peers
DELETE FROM Users
WHERE IsPeer = 1 AND OwnerID = @UserID

IF (@@ERROR <> 0 )
      BEGIN
            ROLLBACK TRANSACTION
            RETURN -1
      END

-- delete user
DELETE FROM Users
WHERE UserID = @UserID

IF (@@ERROR <> 0 )
      BEGIN
            ROLLBACK TRANSACTION
            RETURN -1
      END

COMMIT TRAN

RETURN
				*/
				#endregion

				if (!CanUpdateUserDetails(actorId, userId)) return;

				using (var transaction = Database.BeginTransaction())
				{
					// delete user comments
					Comments.Where(c => c.ItemId == userId && c.ItemTypeId == "USER").ExecuteDelete();
					// delete reseller addon
					HostingPlans.Where(h => h.UserId == userId && h.IsAddon == true).ExecuteDelete();
					// delete user peers
					Users.Where(u => u.IsPeer && u.OwnerId == userId).ExecuteDelete();
					// delete user
					Users.Where(u => u.UserId == userId).ExecuteDelete();

					transaction.Commit();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "DeleteUser",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId));
			}
		}

		public void ChangeUserPassword(int actorId, int userId, string password)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[ChangeUserPassword]
(
	@ActorID int,
	@UserID int,
	@Password nvarchar(200)
)
AS

-- check actor rights
IF dbo.CanUpdateUserDetails(@ActorID, @UserID) = 0
RETURN

UPDATE Users
SET Password = @Password, OneTimePasswordState = 0
WHERE UserID = @UserID

RETURN 
				*/
				#endregion

				if (!CanUpdateUserDetails(actorId, userId)) return;

				var user = Users.FirstOrDefault(u => u.UserId == userId);
				if (user == null) return;

				user.Password = password;
				user.OneTimePasswordState = 0;

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "ChangeUserPassword",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@password", password));
			}
		}

		public void SetUserOneTimePassword(int userId, string password, int auths)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetUserOneTimePassword]
(
	@UserID int,
	@Password nvarchar(200),
	@OneTimePasswordState int
)
AS
UPDATE Users
SET Password = @Password, OneTimePasswordState = @OneTimePasswordState
WHERE UserID = @UserID
RETURN 
				*/
				#endregion

				var user = Users.FirstOrDefault(u => u.UserId == userId);
				if (user == null) return;

				user.Password = password;
				user.OneTimePasswordState = auths;

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "SetUserOneTimePassword",
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@Password", password),
					 new SqlParameter("@OneTimePasswordState", auths));
			}
		}

		public void UpdateUserPinSecret(int actorId, int userId, string pinSecret)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateUserPinSecret]
(
	@ActorID int,
	@UserID int,
	@PinSecret NVARCHAR(255)
)
AS
	-- check actor rights
	IF dbo.CanUpdateUserDetails(@ActorID, @UserID) = 0
	BEGIN
		RETURN
	END
	UPDATE Users SET
		PinSecret = @PinSecret 
	WHERE UserID = @UserID

	RETURN
				*/
				#endregion
				if (!CanUpdateUserDetails(actorId, userId)) return;

				var user = Users.FirstOrDefault(u => u.UserId == userId);
				if (user == null) return;

				user.PinSecret = pinSecret;

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "UpdateUserPinSecret",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@PinSecret", pinSecret)
					 );
			}
		}

		public void UpdateUserMfaMode(int actorId, int userId, int mfaMode)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateUserMfaMode]
(
	@ActorID int,
	@UserID int,
	@MfaMode int
)
AS
	-- check actor rights
	IF dbo.CanUpdateUserDetails(@ActorID, @UserID) = 0
	BEGIN
		RETURN
	END
	UPDATE Users SET
		MfaMode = @MfaMode 
	WHERE UserID = @UserID

	RETURN
				*/
				#endregion

				if (!CanUpdateUserDetails(actorId, userId)) return;

				var user = Users.FirstOrDefault(u => u.UserId == userId);
				if (user == null) return;

				user.MfaMode = mfaMode;

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "UpdateUserMfaMode",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@MfaMode", mfaMode));
			}
		}

		public bool CanUserChangeMfa(int callerId, int changeUserId, bool canPeerChangeMfa)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE FUNCTION [dbo].[CanChangeMfaFunc]
(
	@CallerID int,
	@ChangeUserID int,
	@CanPeerChangeMfa bit
)
RETURNS bit
AS
BEGIN

DECLARE @IsPeer int, @OwnerID int, @Result int,  @UserId int, @GenerationNumber int
SET @Result = 0;
SET @GenerationNumber = 0;
-- get data for user
SELECT @IsPeer = IsPeer, @OwnerID = OwnerID, @UserId = UserID FROM Users
WHERE UserID = @CallerID;

-- userif not found
IF(@UserId IS NULL)
BEGIN
	RETURN 0
END

-- is rootuser serveradmin
IF (@OwnerID IS NULL)
BEGIN
	RETURN 1
END

-- check if the user requests himself
IF (@CallerID = @ChangeUserID AND @IsPeer > 0 AND @CanPeerChangeMfa <> 0)
BEGIN
	RETURN 1
END

IF (@CallerID = @ChangeUserID AND @IsPeer = 0)
BEGIN
	RETURN 1
END

IF (@IsPeer = 1)
BEGIN
	SET @UserID = @OwnerID
	SET @GenerationNumber = 1;
END;

WITH generation AS (
    SELECT UserID,
           Username,
		   OwnerID,
		   IsPeer,
           0 AS generation_number
    FROM Users
	where UserID = @UserID
UNION ALL
    SELECT child.UserID,
         child.Username,
         child.OwnerId,
		 child.IsPeer,
		 generation_number + 1 AS generation_number
    FROM Users child
    JOIN generation g
      ON g.UserID = child.OwnerId
)

Select @Result = count(*)
FROM generation g
JOIN Users parent
ON g.OwnerID = parent.UserID
where (g.generation_number > @GenerationNumber or g.IsPeer <> 1) and g.UserID = @ChangeUserID;

if(@Result > 0)
BEGIN
	RETURN 1
END
ELSE
BEGIN
	RETURN 0
END

RETURN 0
END
			
CREATE PROCEDURE [dbo].[CanChangeMfa]
(
	@CallerID int,
	@ChangeUserID int,
	@CanPeerChangeMfa bit,
	@Result bit OUTPUT
)
AS
	SET @Result = dbo.CanChangeMfaFunc(@CallerID, @ChangeUserID, @CanPeerChangeMfa)
	RETURN
				 */
				#endregion

				var user = Users
					.Select(u => new { u.UserId, u.OwnerId, u.IsPeer })
					.FirstOrDefault(u => u.UserId == callerId);
				if (user == null) return false;

				if (user.OwnerId == null) return true; // serveradmin user

				// check if the user requests himself
				if (callerId == changeUserId && user.IsPeer && canPeerChangeMfa) return true;

				if (callerId == changeUserId && !user.IsPeer) return true;

				int generationNumber = 0, userId = user.UserId;
				if (user.IsPeer)
				{
					userId = user.OwnerId.Value;
					generationNumber = 1;
				}

				var generation = Users
					.Where(u => u.UserId == userId)
					.Select(u => new
					{
						u.UserId,
						u.Username,
						u.OwnerId,
						u.IsPeer,
						GenerationNumber = 0
					});
				var nextGeneration = Users.Join(generation, u => u.OwnerId, g => g.UserId, (usr, gen) => new
				{
					usr.UserId,
					usr.Username,
					usr.OwnerId,
					usr.IsPeer,
					GenerationNumber = gen.GenerationNumber + 1
				});
				while (nextGeneration.Any())
				{
					generation = generation.Concat(nextGeneration);
				}

				return generation.Join(Users, g => g.OwnerId, u => u.UserId, (gen, usr) => gen)
					.Any(g => (g.GenerationNumber > generationNumber || !g.IsPeer) &&
						g.UserId == changeUserId);
			}
			else
			{
				SqlParameter prmResult = new SqlParameter("@Result", SqlDbType.Bit);
				prmResult.Direction = ParameterDirection.Output;
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "CanChangeMfa",
					 new SqlParameter("@CallerID", callerId),
					 new SqlParameter("@ChangeUserID", changeUserId),
					 new SqlParameter("@CanPeerChangeMfa", canPeerChangeMfa ? 1 : 0),
					 prmResult
					 );

				return Convert.ToBoolean(prmResult.Value);
			}
		}

		public IDataReader GetUserPackagesServerUrls(int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserPackagesServerUrls]
(
	@UserId INT
)
AS
	SELECT DISTINCT Servers.ServerUrl
	FROM Servers
	INNER JOIN Packages
	ON Servers.ServerId = Packages.ServerId
	WHERE Packages.UserID = @UserId
	RETURN
				*/
				#endregion

				var serverUrls = Servers.Join(Packages, s => s.ServerId, p => p.ServerId, (server, package) => new
				{
					server.ServerUrl,
					package.UserId
				})
				.Where(s => s.UserId == userId)
				.Select(s => new { s.ServerUrl });

				return EntityDataReader(serverUrls);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserPackagesServerUrls",
					 new SqlParameter("@UserId", userId));
			}
		}

		#endregion

		#region User Settings
		public IDataReader GetUserSettings(int actorId, int userId, string settingsName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserSettings]
(
	@ActorID int,
	@UserID int,
	@SettingsName nvarchar(50)
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

-- find which parent package has overriden NS
DECLARE @ParentUserID int, @TmpUserID int
SET @TmpUserID = @UserID

WHILE 10 = 10
BEGIN

	IF EXISTS
	(
		SELECT PropertyName FROM UserSettings
		WHERE SettingsName = @SettingsName AND UserID = @TmpUserID
	)
	BEGIN
		SELECT
			UserID,
			PropertyName,
			PropertyValue
		FROM
			UserSettings
		WHERE
			UserID = @TmpUserID AND
			SettingsName = @SettingsName

		BREAK
	END

	SET @ParentUserID = NULL --reset var

	-- get owner
	SELECT
		@ParentUserID = OwnerID
	FROM Users
	WHERE UserID = @TmpUserID

	IF @ParentUserID IS NULL -- the last parent
	BREAK

	SET @TmpUserID = @ParentUserID
END

RETURN
				*/
				#endregion

				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var id = userId;
				var setting = UserSettings.FirstOrDefault(s => s.UserId == id);
				while (setting == null)
				{
					var user = Users
						.Select(u => new { u.UserId, u.OwnerId })
						.FirstOrDefault(u => u.UserId == id);
					if (user != null && user.OwnerId.HasValue) id = user.OwnerId.Value;
					setting = UserSettings.FirstOrDefault(s => s.UserId == id);
				}

				return EntityDataReader(new Data.Entities.UserSetting[] { setting });
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetUserSettings",
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@SettingsName", settingsName));
			}
		}
		public void UpdateUserSettings(int actorId, int userId, string settingsName, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
	CREATE PROCEDURE [dbo].[UpdateUserSettings]
(
	@ActorID int,
	@UserID int,
	@SettingsName nvarchar(50),
	@Xml ntext
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

-- delete old properties
BEGIN TRAN
DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

-- Execute a SELECT statement that uses the OPENXML rowset provider.
DELETE FROM UserSettings
WHERE UserID = @UserID AND SettingsName = @SettingsName

INSERT INTO UserSettings
(
	UserID,
	SettingsName,
	PropertyName,
	PropertyValue
)
SELECT
	@UserID,
	@SettingsName,
	PropertyName,
	PropertyValue
FROM OPENXML(@idoc, '/properties/property',1) WITH
(
	PropertyName nvarchar(50) '@name',
	PropertyValue ntext '@value'
) as PV

-- remove document
exec sp_xml_removedocument @idoc

COMMIT TRAN

RETURN
				*/
				#endregion

				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				UserSettings.RemoveRange(UserSettings
					.Where(s => s.UserId == userId && s.SettingsName == settingsName));

				var properties = XElement.Parse(xml);
				foreach (var property in properties.Elements())
				{
					var setting = new Data.Entities.UserSetting()
					{
						UserId = userId,
						SettingsName = settingsName,
						PropertyName = (string)property.Attribute("name"),
						PropertyValue = (string)property.Attribute("value")
					};
					UserSettings.Add(setting);
				}

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "UpdateUserSettings",
					 new SqlParameter("@UserID", userId),
					 new SqlParameter("@ActorId", actorId),
					 new SqlParameter("@SettingsName", settingsName),
					 new SqlParameter("@Xml", xml));
			}
		}
		#endregion

		#region Servers
		public bool CheckIsUserAdmin(int userId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CheckIsUserAdmin]
(
	@UserID int
)
RETURNS bit
AS
BEGIN

IF @UserID = -1
RETURN 1

IF EXISTS (SELECT UserID FROM Users
WHERE UserID = @UserID AND RoleID = 1) -- administrator
RETURN 1

RETURN 0
END
			*/
			#endregion

			return userId == -1 || Users.Any(u => u.UserId == userId && u.RoleId == 1);
		}
		public DataSet GetAllServers(int actorId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetAllServers]
(
	@ActorID int
)
AS

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
	S.ServerID,
	S.ServerName,
	S.ServerUrl,
	(SELECT COUNT(SRV.ServiceID) FROM VirtualServices AS SRV WHERE S.ServerID = SRV.ServerID) AS ServicesNumber,
	S.Comments
FROM Servers AS S
WHERE @IsAdmin = 1
ORDER BY S.VirtualServer, S.ServerName
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var servers = Servers
					.Where(s => isAdmin)
					.OrderBy(s => s.VirtualServer)
					.ThenBy(s => s.ServerName)
					.Select(s => new
					{
						s.ServerId,
						s.ServerName,
						s.ServerUrl,
						ServicesNumber = VirtualServices.Count(v => v.ServerId == s.ServerId),
						s.Comments
					});

				var serversTable = EntityDataTable(servers);

				var services = Services
					.Join(Providers, s => s.ProviderId, p => p.ProviderId, (srvc, p) => new { Service = srvc, ProviderGroupId = p.GroupId })
					.Join(ResourceGroups, s => s.ProviderGroupId, rg => rg.GroupId, (srvc, rg) => new
					{
						Service = srvc.Service,
						GroupOrder = rg.GroupOrder
					})
					.Where(s => isAdmin)
					.OrderBy(s => s.GroupOrder)
					.Select(s => new
					{
						s.Service.ServiceId,
						s.Service.ServerId,
						s.Service.ProviderId,
						s.Service.ServiceName,
						s.Service.Comments
					});

				var servicesTable = EntityDataTable(services);

				return EntityDataSet(serversTable, servicesTable);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetAllServers",
					 new SqlParameter("@actorId", actorId));
			}
		}
		public DataSet GetServers(int actorId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServers]
(
	@ActorID int
)
AS
-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
	S.ServerID,
	S.ServerName,
	S.ServerUrl,
	(SELECT COUNT(SRV.ServiceID) FROM Services AS SRV WHERE S.ServerID = SRV.ServerID) AS ServicesNumber,
	S.Comments,
	PrimaryGroupID,
	S.ADEnabled
FROM Servers AS S
WHERE VirtualServer = 0
AND @IsAdmin = 1
ORDER BY S.ServerName

-- services
SELECT
	S.ServiceID,
	S.ServerID,
	S.ProviderID,
	S.ServiceName,
	S.Comments
FROM Services AS S
INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
INNER JOIN ResourceGroups AS RG ON P.GroupID = RG.GroupID
WHERE @IsAdmin = 1
ORDER BY RG.GroupOrder

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var servers = Servers
					.Where(s => isAdmin && !s.VirtualServer)
					.OrderBy(s => s.ServerName)
					.Select(s => new
					{
						s.ServerId,
						s.ServerName,
						s.ServerUrl,
						ServicesNumber = Services.Where(sc => sc.ServerId == s.ServerId).Count(),
						s.Comments,
						s.PrimaryGroupId,
						s.ADEnabled
					});

				var services = Services
					.Where(s => isAdmin)
					.Join(Providers, srvc => srvc.ProviderId, p => p.ProviderId, (srvc, prov) => new
					{
						Service = srvc,
						prov.GroupId
					})
					.Join(ResourceGroups, srvc => srvc.GroupId, rg => rg.GroupId, (srvc, rg) => new
					{
						srvc.Service,
						rg.GroupOrder
					})
					.OrderBy(s => s.GroupOrder)
					.Select(s => new
					{
						s.Service.ServiceId,
						s.Service.ServerId,
						s.Service.ProviderId,
						s.Service.ServiceName,
						s.Service.Comments
					});

				var set = new DataSet();
				set.Tables.Add(EntityDataTable(servers));
				set.Tables.Add(EntityDataTable(services));

				return set;
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetServers",
					 new SqlParameter("@actorId", actorId));
			}
		}

		public IDataReader GetServer(int actorId, int serverId, bool forAutodiscover)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServer]
(
	@ActorID int,
	@ServerID int,
	@forAutodiscover bit
)
AS
-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
	ServerID,
	ServerName,
	ServerUrl,
	Password,
	Comments,
	VirtualServer,
	InstantDomainAlias,
	PrimaryGroupID,
	ADEnabled,
	ADRootDomain,
	ADUsername,
	ADPassword,
	ADAuthenticationType,
	ADParentDomain,
	ADParentDomainController,
	OSPlatform,
	IsCore,
	PasswordIsSHA256

FROM Servers
WHERE
	ServerID = @ServerID
	AND (@IsAdmin = 1 OR @forAutodiscover = 1)

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var server = Servers
					.Where(s => s.ServerId == serverId && (isAdmin || forAutodiscover))
					.Select(s => new
					{
						s.ServerId,
						s.ServerName,
						s.ServerUrl,
						s.Password,
						s.Comments,
						s.VirtualServer,
						s.InstantDomainAlias,
						s.PrimaryGroupId,
						s.ADEnabled,
						s.ADRootDomain,
						s.ADUsername,
						s.ADPassword,
						s.ADAuthenticationType,
						s.ADParentDomain,
						s.ADParentDomainController,
						s.OSPlatform,
						s.IsCore,
						s.PasswordIsSHA256
					});

				return EntityDataReader(server);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetServer",
					 new SqlParameter("@actorId", actorId),
					 new SqlParameter("@ServerID", serverId),
					 new SqlParameter("@forAutodiscover", forAutodiscover));
			}
		}

		public IDataReader GetServerShortDetails(int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServerShortDetails]
(
	@ServerID int
)
AS

SELECT
	ServerID,
	ServerName,
	Comments,
	VirtualServer,
	InstantDomainAlias
FROM Servers
WHERE
	ServerID = @ServerID

RETURN
				*/
				#endregion

				var server = Servers
					.Where(s => s.ServerId == serverId)
					.Select(s => new
					{
						s.ServerId,
						s.ServerName,
						s.Comments,
						s.VirtualServer,
						s.InstantDomainAlias
					});

				return EntityDataReader(server);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetServerShortDetails",
					 new SqlParameter("@ServerID", serverId));
			}
		}

		public IDataReader GetServerByName(int actorId, string serverName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServerByName]
(
	@ActorID int,
	@ServerName nvarchar(100)
)
AS
-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
	ServerID,
	ServerName,
	ServerUrl,
	Password,
	Comments,
	VirtualServer,
	InstantDomainAlias,
	PrimaryGroupID,
	ADRootDomain,
	ADUsername,
	ADPassword,
	ADAuthenticationType,
	ADParentDomain,
	ADParentDomainController,
	OSPlatform,
	IsCore,
	PasswordIsSHA256
FROM Servers
WHERE
	ServerName = @ServerName
	AND @IsAdmin = 1

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var server = Servers
					.Where(s => isAdmin && s.ServerName == serverName)
					.Select(s => new
					{
						s.ServerId,
						s.ServerName,
						s.ServerUrl,
						s.Password,
						s.Comments,
						s.VirtualServer,
						s.InstantDomainAlias,
						s.PrimaryGroupId,
						s.ADRootDomain,
						s.ADUsername,
						s.ADPassword,
						s.ADAuthenticationType,
						s.ADParentDomain,
						s.ADParentDomainController,
						s.OSPlatform,
						s.IsCore,
						s.PasswordIsSHA256
					});

				return EntityDataReader(server);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetServerByName",
					 new SqlParameter("@actorId", actorId),
					 new SqlParameter("@ServerName", serverName));
			}
		}

		public IDataReader GetServerInternal(int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServerInternal]
(
	@ServerID int
)
AS
SELECT
	ServerID,
	ServerName,
	ServerUrl,
	Password,
	Comments,
	VirtualServer,
	InstantDomainAlias,
	PrimaryGroupID,
	ADEnabled,
	ADRootDomain,
	ADUsername,
	ADPassword,
	ADAuthenticationType,
	ADParentDomain,
	ADParentDomainController,
	OSPlatform,
	IsCore,
	PasswordIsSHA256
FROM Servers
WHERE
	ServerID = @ServerID

RETURN
				*/
				#endregion

				var server = Servers
					.Where(s => s.ServerId == serverId)
					.Select(s => new
					{
						s.ServerId,
						s.ServerName,
						s.ServerUrl,
						s.Password,
						s.Comments,
						s.VirtualServer,
						s.InstantDomainAlias,
						s.PrimaryGroupId,
						s.ADEnabled,
						s.ADRootDomain,
						s.ADUsername,
						s.ADPassword,
						s.ADAuthenticationType,
						s.ADParentDomain,
						s.ADParentDomainController,
						s.OSPlatform,
						s.IsCore,
						s.PasswordIsSHA256
					});

				return EntityDataReader(server);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetServerInternal",
					 new SqlParameter("@ServerID", serverId));
			}
		}

		public int AddServer(string serverName, string serverUrl,
			 string password, string comments, bool virtualServer, string instantDomainAlias,
			 int primaryGroupId, bool adEnabled, string adRootDomain, string adUsername, string adPassword,
			 string adAuthenticationType, OSPlatform osPlatform, bool? isCore, bool PasswordIsSHA256)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddServer]
(
	@ServerID int OUTPUT,
	@ServerName nvarchar(100),
	@ServerUrl nvarchar(255),
	@Password nvarchar(100),
	@Comments ntext,
	@VirtualServer bit,
	@InstantDomainAlias nvarchar(200),
	@PrimaryGroupID int,
	@ADEnabled bit,
	@ADRootDomain nvarchar(200),
	@ADUsername nvarchar(100),
	@ADPassword nvarchar(100),
	@ADAuthenticationType varchar(50),
	@OSPlatform int,
	@IsCore bit,
	@PasswordIsSHA256 bit
)
AS

IF @PrimaryGroupID = 0

SET @PrimaryGroupID = NULL

INSERT INTO Servers
(
	ServerName,
	ServerUrl,
	Password,
	Comments,
	VirtualServer,
	InstantDomainAlias,
	PrimaryGroupID,
	ADEnabled,
	ADRootDomain,
	ADUsername,
	ADPassword,
	ADAuthenticationType,
	OSPlatform,
	IsCore,
	PasswordIsSHA256
)
VALUES
(
	@ServerName,
	@ServerUrl,
	@Password,
	@Comments,
	@VirtualServer,
	@InstantDomainAlias,
	@PrimaryGroupID,
	@ADEnabled,
	@ADRootDomain,
	@ADUsername,
	@ADPassword,
	@ADAuthenticationType,
	@OSPlatform,
	@IsCore,
	@PasswordIsSHA256
)

SET @ServerID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var server = new Data.Entities.Server()
				{
					ServerName = serverName,
					ServerUrl = serverUrl,
					Password = password,
					Comments = comments,
					VirtualServer = virtualServer,
					InstantDomainAlias = instantDomainAlias,
					PrimaryGroupId = primaryGroupId != 0 ? primaryGroupId : null,
					ADEnabled = adEnabled,
					ADRootDomain = adRootDomain,
					ADUsername = adUsername,
					ADPassword = adPassword,
					ADAuthenticationType = adAuthenticationType,
					OSPlatform = osPlatform,
					IsCore = isCore,
					PasswordIsSHA256 = PasswordIsSHA256
				};
				Servers.Add(server);

				SaveChanges();

				return server.ServerId;
			}
			else
			{
				SqlParameter prmServerId = new SqlParameter("@ServerID", SqlDbType.Int);
				prmServerId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "AddServer",
					 prmServerId,
					 new SqlParameter("@ServerName", serverName),
					 new SqlParameter("@ServerUrl", serverUrl),
					 new SqlParameter("@Password", password),
					 new SqlParameter("@Comments", comments),
					 new SqlParameter("@VirtualServer", virtualServer),
					 new SqlParameter("@InstantDomainAlias", instantDomainAlias),
					 new SqlParameter("@PrimaryGroupId", primaryGroupId),
					 new SqlParameter("@AdEnabled", adEnabled),
					 new SqlParameter("@AdRootDomain", adRootDomain),
					 new SqlParameter("@AdUsername", adUsername),
					 new SqlParameter("@AdPassword", adPassword),
					 new SqlParameter("@AdAuthenticationType", adAuthenticationType),
					 new SqlParameter("@OSPlatform", osPlatform),
					 new SqlParameter("@IsCore", isCore),
					 new SqlParameter("@PasswordIsSHA256", PasswordIsSHA256));

				return Convert.ToInt32(prmServerId.Value);
			}
		}

		public void UpdateServer(int serverId, string serverName, string serverUrl,
			 string password, string comments, string instantDomainAlias,
			 int primaryGroupId, bool adEnabled, string adRootDomain, string adUsername, string adPassword,
			 string adAuthenticationType, string adParentDomain, String adParentDomainController,
			 OSPlatform osPlatform, bool? isCore, bool PasswordIsSHA256)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateServer]
(
	@ServerID int,
	@ServerName nvarchar(100),
	@ServerUrl nvarchar(255),
	@Password nvarchar(100),
	@Comments ntext,
	@InstantDomainAlias nvarchar(200),
	@PrimaryGroupID int,
	@ADEnabled bit,
	@ADRootDomain nvarchar(200),
	@ADUsername nvarchar(100),
	@ADPassword nvarchar(100),
	@ADAuthenticationType varchar(50),
	@ADParentDomain nvarchar(200),
	@ADParentDomainController nvarchar(200),
	@OSPlatform int,
	@IsCore bit,
	@PasswordIsSHA256 bit
)
AS

IF @PrimaryGroupID = 0
SET @PrimaryGroupID = NULL

UPDATE Servers SET
	ServerName = @ServerName,
	ServerUrl = @ServerUrl,
	Password = @Password,
	Comments = @Comments,
	InstantDomainAlias = @InstantDomainAlias,
	PrimaryGroupID = @PrimaryGroupID,
	ADEnabled = @ADEnabled,
	ADRootDomain = @ADRootDomain,
	ADUsername = @ADUsername,
	ADPassword = @ADPassword,
	ADAuthenticationType = @ADAuthenticationType,
	ADParentDomain = @ADParentDomain,
	ADParentDomainController = @ADParentDomainController,
	OSPlatform = @OSPlatform,
	IsCore = @IsCore,
	PasswordIsSHA256 = @PasswordIsSHA256
WHERE ServerID = @ServerID
RETURN
				*/
				#endregion

				var server = Servers.FirstOrDefault(s => s.ServerId == serverId);
				if (server == null) return;

				server.ServerName = serverName;
				server.ServerUrl = serverUrl;
				server.Password = password;
				server.Comments = comments;
				server.InstantDomainAlias = instantDomainAlias;
				server.PrimaryGroupId = primaryGroupId != 0 ? primaryGroupId : null;
				server.ADEnabled = adEnabled;
				server.ADRootDomain = adRootDomain;
				server.ADUsername = adUsername;
				server.ADPassword = adPassword;
				server.ADAuthenticationType = adAuthenticationType;
				server.ADParentDomain = adParentDomain;
				server.ADParentDomainController = adParentDomainController;
				server.OSPlatform = osPlatform;
				server.IsCore = isCore;
				server.PasswordIsSHA256 = PasswordIsSHA256;

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "UpdateServer",
					 new SqlParameter("@ServerID", serverId),
					 new SqlParameter("@ServerName", serverName),
					 new SqlParameter("@ServerUrl", serverUrl),
					 new SqlParameter("@Password", password),
					 new SqlParameter("@Comments", comments),
					 new SqlParameter("@InstantDomainAlias", instantDomainAlias),
					 new SqlParameter("@PrimaryGroupId", primaryGroupId),
					 new SqlParameter("@AdEnabled", adEnabled),
					 new SqlParameter("@AdRootDomain", adRootDomain),
					 new SqlParameter("@AdUsername", adUsername),
					 new SqlParameter("@AdPassword", adPassword),
					 new SqlParameter("@AdAuthenticationType", adAuthenticationType),
					 new SqlParameter("@AdParentDomain", adParentDomain),
					 new SqlParameter("@AdParentDomainController", adParentDomainController),
					 new SqlParameter("@OSPlatform", osPlatform),
					 new SqlParameter("@IsCore", isCore),
					 new SqlParameter("@PasswordIsSHA256", PasswordIsSHA256));
			}
		}

		public int DeleteServer(int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteServer]
(
	@ServerID int,
	@Result int OUTPUT
)
AS
SET @Result = 0

-- check related services
IF EXISTS (SELECT ServiceID FROM Services WHERE ServerID = @ServerID)
BEGIN
	SET @Result = -1
	RETURN
END

-- check related packages
IF EXISTS (SELECT PackageID FROM Packages WHERE ServerID = @ServerID)
BEGIN
	SET @Result = -2
	RETURN
END

-- check related hosting plans
IF EXISTS (SELECT PlanID FROM HostingPlans WHERE ServerID = @ServerID)
BEGIN
	SET @Result = -3
	RETURN
END

BEGIN TRAN

-- delete IP addresses
DELETE FROM IPAddresses
WHERE ServerID = @ServerID

-- delete global DNS records
DELETE FROM GlobalDnsRecords
WHERE ServerID = @ServerID

-- delete server
DELETE FROM Servers
WHERE ServerID = @ServerID

-- delete virtual services if any
DELETE FROM VirtualServices
WHERE ServerID = @ServerID
COMMIT TRAN

RETURN
				*/
				#endregion
				// check related services
				if (Services.Any(svc => svc.ServerId == serverId)) return -1;

				// check related packages
				if (Packages.Any(p => p.ServerId == serverId)) return -2;

				// check related hosting plans
				if (HostingPlans.Any(p => p.ServerId == serverId)) return -3;

				using (var transaction = Database.BeginTransaction())
				{
					// delete IP addresses
					IpAddresses.Where(ip => ip.ServerId == serverId).ExecuteDelete();

					// delete global DNS records
					GlobalDnsRecords.Where(r => r.ServerId == serverId).ExecuteDelete();

					// delete server
					Servers.Where(s => s.ServerId == serverId).ExecuteDelete();

					// delete virtual services if any
					VirtualServices.Where(vs => vs.ServerId == serverId).ExecuteDelete();

					transaction.Commit();
				}
				return 0;
			}
			else
			{
				SqlParameter prmResult = new SqlParameter("@Result", SqlDbType.Int);
				prmResult.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "DeleteServer",
					 prmResult,
					 new SqlParameter("@ServerID", serverId));

				return Convert.ToInt32(prmResult.Value);
			}
		}
		#endregion

		#region Virtual Servers
		public DataSet GetVirtualServers(int actorId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetVirtualServers]
(
	@ActorID int
)
AS

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
	S.ServerID,
	S.ServerName,
	S.ServerUrl,
	(SELECT COUNT(SRV.ServiceID) FROM VirtualServices AS SRV WHERE S.ServerID = SRV.ServerID) AS ServicesNumber,
	S.Comments,
	PrimaryGroupID
FROM Servers AS S
WHERE
	VirtualServer = 1
	AND @IsAdmin = 1
ORDER BY S.ServerName

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var servers = Servers
					.Where(s => isAdmin && s.VirtualServer)
					.OrderBy(s => s.ServerName)
					.Select(s => new
					{
						s.ServerId,
						s.ServerName,
						s.ServerUrl,
						ServicesNumber = VirtualServices.Where(v => v.ServerId == s.ServerId).Count(),
						s.Comments,
						s.PrimaryGroupId
					});

				return EntityDataSet(servers);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetVirtualServers",
					 new SqlParameter("@actorId", actorId));
			}
		}

		public DataSet GetAvailableVirtualServices(int actorId, int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetAvailableVirtualServices]
(
	@ActorID int,
	@ServerID int
)
AS

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
	S.ServerID,
	S.ServerName,
	S.Comments
FROM Servers AS S
WHERE
	VirtualServer = 0 -- get only physical servers
	AND @IsAdmin = 1

-- services
SELECT
	ServiceID,
	ServerID,
	ProviderID,
	ServiceName,
	Comments
FROM Services
WHERE
	ServiceID NOT IN (SELECT ServiceID FROM VirtualServices WHERE ServerID = @ServerID)
	AND @IsAdmin = 1

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var servers = Servers
					.Where(s => isAdmin && !s.VirtualServer) // get only physical servers
					.Select(s => new
					{
						s.ServerId,
						s.ServerName,
						s.Comments
					});

				var virtualServiceIds = VirtualServices
					.Where(v => v.ServerId == serverId)
					.Select(v => v.ServiceId)
					.ToArray();
				var services = Services
					.Where(s => isAdmin && !virtualServiceIds.Any(id => id == s.ServiceId))
					.Select(s => new
					{
						s.ServiceId,
						s.ServerId,
						s.ProviderId,
						s.ServiceName,
						s.Comments
					});

				var set = new DataSet();
				set.Tables.Add(EntityDataTable(servers));
				set.Tables.Add(EntityDataTable(services));

				return set;
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetAvailableVirtualServices",
					 new SqlParameter("@actorId", actorId),
					 new SqlParameter("@ServerID", serverId));
			}
		}

		public DataSet GetVirtualServices(int actorId, int serverId, bool forAutodiscover)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetVirtualServices]
(
	@ActorID int,
	@ServerID int,
	@forAutodiscover bit
)
AS

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

-- virtual groups
SELECT
	VRG.VirtualGroupID,
	RG.GroupID,
	RG.GroupName,
	ISNULL(VRG.DistributionType, 1) AS DistributionType,
	ISNULL(VRG.BindDistributionToPrimary, 1) AS BindDistributionToPrimary
FROM ResourceGroups AS RG
LEFT OUTER JOIN VirtualGroups AS VRG ON RG.GroupID = VRG.GroupID AND VRG.ServerID = @ServerID
WHERE
	(@IsAdmin = 1 OR @forAutodiscover = 1) AND (ShowGroup = 1)
ORDER BY RG.GroupOrder

-- services
SELECT
	VS.ServiceID,
	S.ServiceName,
	S.Comments,
	P.GroupID,
	P.DisplayName,
	SRV.ServerName
FROM VirtualServices AS VS
INNER JOIN Services AS S ON VS.ServiceID = S.ServiceID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
WHERE
	VS.ServerID = @ServerID
	AND (@IsAdmin = 1 OR @forAutodiscover = 1)

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				// virtual groups
				var virtGroups = ResourceGroups
					.Where(g => (isAdmin || forAutodiscover) && g.ShowGroup == true)
					.OrderBy(g => g.GroupOrder)
					.SelectMany(g => g.VirtualGroups
						.Where(vg => vg.ServerId == serverId)
						.DefaultIfEmpty(),
						(g, vg) => new
					{
						VirtualGroupId = (int?)(vg != null ? vg.VirtualGroupId : null),
						g.GroupId,
						g.GroupName,
						DistributionType = (vg != null ? vg.DistributionType : null) ?? 1,
						BindDistributionToPrimary = (vg != null ? vg.BindDistributionToPrimary : null) ?? true
					});

				var services = VirtualServices
					.Where(vs => vs.ServerId == serverId && (isAdmin || forAutodiscover))
					.Select(s => new
					{
						s.ServerId,
						s.Service.ServiceName,
						s.Service.Comments,
						s.Service.Provider.GroupId,
						s.Service.Provider.DisplayName,
						s.Server.ServerName
					});
				return EntityDataSet(virtGroups, services);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetVirtualServices",
					 new SqlParameter("@actorId", actorId),
					 new SqlParameter("@ServerID", serverId),
					 new SqlParameter("@forAutodiscover", forAutodiscover));
			}
		}

		public void AddVirtualServices(int serverId, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddVirtualServices]
(
	@ServerID int,
	@Xml ntext
)
AS

/*
XML Format:

<services>
	<service id=""16"" />
</services>

*//*

				BEGIN TRAN
DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

-- update HP resources
INSERT INTO VirtualServices
(
	ServerID,
	ServiceID
)
SELECT
	@ServerID,
	ServiceID
FROM OPENXML(@idoc, '/services/service',1) WITH
(
	ServiceID int '@id'
) as XS
WHERE XS.ServiceID NOT IN(SELECT ServiceID FROM VirtualServices WHERE ServerID = @ServerID)

-- remove document
exec sp_xml_removedocument @idoc

COMMIT TRAN
RETURN
				*/
				#endregion

				/* XML Format:
				<services>
					<service id="16" />
				</services> */

				var services = XElement.Parse(xml);

				var existingServices = VirtualServices
					.Where(v => v.ServerId == serverId)
					.Select(v => v.ServiceId)
					.ToHashSet();

				bool addedAny = false;
				foreach (var service in services.Elements())
				{
					var serviceId = (int)service.Attribute("id");
					if (!existingServices.Contains(serviceId))
					{
						var virtualService = new Data.Entities.VirtualService()
						{
							ServerId = serverId,
							ServiceId = serviceId
						};
						VirtualServices.Add(virtualService);
						addedAny = true;
					}
				}

				if (addedAny) SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "AddVirtualServices",
					 new SqlParameter("@ServerID", serverId),
					 new SqlParameter("@xml", xml));
			}
		}

		public void DeleteVirtualServices(int serverId, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteVirtualServices]
(
	@ServerID int,
	@Xml ntext
)
AS

/*
XML Format:

<services>
	<service id=""16"" />
</services>
*//*

				BEGIN TRAN
DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

-- update HP resources
DELETE FROM VirtualServices
WHERE ServiceID IN(
SELECT
	ServiceID
FROM OPENXML(@idoc, '/services/service',1) WITH
(
	ServiceID int '@id'
) as XS)
AND ServerID = @ServerID

-- remove document
EXEC sp_xml_removedocument @idoc

COMMIT TRAN
RETURN
				*/
				#endregion

				/* XML Format:
				<services>
					<service id=""16"" />
				</services> */

				var services = XElement.Parse(xml);
				var serviceIds = services.Elements()
					.Select(service => (int)service.Attribute("id"))
					.ToArray();
				var toDelete = VirtualServices
					.Where(vs => vs.ServerId == serverId)
					.Join(serviceIds, vs => vs.ServiceId, sid => sid, (vs, sid) => vs);
				VirtualServices.RemoveRange(toDelete);

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "DeleteVirtualServices",
					 new SqlParameter("@ServerID", serverId),
					 new SqlParameter("@xml", xml));
			}
		}

		public void UpdateVirtualGroups(int serverId, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateVirtualGroups]
(
	@ServerID int,
	@Xml ntext
)
AS

/*
XML Format:
<groups>
	<group id="16" distributionType="1" bindDistributionToPrimary="1"/>
</groups>
*//*

				BEGIN TRAN
DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

-- delete old virtual groups
DELETE FROM VirtualGroups
WHERE ServerID = @ServerID

-- update HP resources
INSERT INTO VirtualGroups
(
	ServerID,
	GroupID,
	DistributionType,
	BindDistributionToPrimary
)
SELECT
	@ServerID,
	GroupID,
	DistributionType,
	BindDistributionToPrimary
FROM OPENXML(@idoc, '/groups/group',1) WITH
(
	GroupID int '@id',
	DistributionType int '@distributionType',
	BindDistributionToPrimary bit '@bindDistributionToPrimary'
) as XRG

-- remove document
exec sp_xml_removedocument @idoc

COMMIT TRAN
RETURN
				*/
				#endregion

				/* XML Format:
				<groups>
					<group id="16" distributionType="1" bindDistributionToPrimary="1"/>
				</groups> */

				var groupsXml = XElement.Parse(xml);
				var groups = groupsXml.Elements()
					.Select(group => new Data.Entities.VirtualGroup
					{
						ServerId = serverId,
						GroupId = (int)group.Attribute("id"),
						DistributionType = (int?)group.Attribute("distributionType"),
						BindDistributionToPrimary = ((int?)group.Attribute("bindDistributionToPrimary") ?? 1) == 1
					});

				// delete existing groups
				VirtualGroups.RemoveRange(VirtualGroups.Where(vg => vg.ServerId == serverId));

				VirtualGroups.AddRange(groups);

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "UpdateVirtualGroups",
					 new SqlParameter("@ServerID", serverId),
					 new SqlParameter("@xml", xml));
			}
		}
		#endregion

		#region Providers

		// Providers methods

		public DataSet GetProviders()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetProviders]
AS
SELECT
	PROV.ProviderID,
	PROV.GroupID,
	PROV.ProviderName,
	PROV.EditorControl,
	PROV.DisplayName,
	PROV.ProviderType,
	RG.GroupName + ' - ' + PROV.DisplayName AS ProviderName,
	PROV.DisableAutoDiscovery
FROM Providers AS PROV
INNER JOIN ResourceGroups AS RG ON PROV.GroupID = RG.GroupID
ORDER BY RG.GroupOrder, PROV.DisplayName
RETURN
				*/
				#endregion

				// TODO ProviderName was duplicate in the Stored Procedure. Resolve correctly. I've changed
				// the duplicate ProviderName to ProviderGroupedName
				var providers = Providers
					.Join(ResourceGroups, p => p.GroupId, rg => rg.GroupId, (p, rg) => new
					{
						Provider = p,
						ResourceGroup = rg
					})
					.OrderBy(j => j.ResourceGroup.GroupOrder)
					.ThenBy(j => j.Provider.DisplayName)
					.Select(j => new
					{
						j.Provider.ProviderId,
						j.Provider.GroupId,
						j.Provider.ProviderName,
						j.Provider.EditorControl,
						j.Provider.DisplayName,
						j.Provider.ProviderType,
						ProviderGroupedName = j.ResourceGroup.GroupName + " - " + j.Provider.DisplayName,
						j.Provider.DisableAutoDiscovery
					});

				return EntityDataSet(providers);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetProviders");
			}
		}

		public DataSet GetGroupProviders(int groupId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetGroupProviders]
(
	@GroupID int
)
AS
SELECT
	PROV.ProviderID,
	PROV.GroupID,
	PROV.ProviderName,
	PROV.DisplayName,
	PROV.ProviderType,
	RG.GroupName + ' - ' + PROV.DisplayName AS ProviderName
FROM Providers AS PROV
INNER JOIN ResourceGroups AS RG ON PROV.GroupID = RG.GroupID
WHERE RG.GroupID = @GroupId
ORDER BY RG.GroupOrder, PROV.DisplayName
RETURN
				*/
				#endregion

				// TODO ProviderName was duplicate in the Stored Procedure. Resolve correctly. I've changed
				// the duplicate ProviderName to ProviderGroupedName
				var providers = Providers
					.Where(p => p.GroupId == groupId)
					.Join(ResourceGroups, p => p.GroupId, rg => rg.GroupId, (p, rg) => new
					{
						Provider = p,
						ResourceGroup = rg
					})
					.OrderBy(j => j.ResourceGroup.GroupOrder)
					.ThenBy(j => j.Provider.DisplayName)
					.Select(j => new
					{
						j.Provider.ProviderId,
						j.Provider.GroupId,
						j.Provider.ProviderName,
						j.Provider.DisplayName,
						j.Provider.ProviderType,
						ProviderGroupedName = j.ResourceGroup.GroupName + " - " + j.Provider.DisplayName,
					});

				return EntityDataSet(providers);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetGroupProviders",
					 new SqlParameter("@groupId", groupId));
			}
		}

		public IDataReader GetProvider(int providerId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetProvider]
(
	@ProviderID int
)
AS
SELECT
	ProviderID,
	GroupID,
	ProviderName,
	EditorControl,
	DisplayName,
	ProviderType
FROM Providers
WHERE
	ProviderID = @ProviderID

RETURN
				*/
				#endregion

				var provider = Providers
					.Where(p => p.ProviderId == providerId)
					.Select(p => new
					{
						p.ProviderId,
						p.GroupId,
						p.ProviderName,
						p.EditorControl,
						p.DisplayName,
						p.ProviderType
					});

				return EntityDataReader(provider);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetProvider",
					 new SqlParameter("@ProviderID", providerId));
			}
		}

		public IDataReader GetProviderByServiceID(int serviceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetProviderByServiceID]
(
	@ServiceID int
)
AS
SELECT
	P.ProviderID,
	P.GroupID,
	P.DisplayName,
	P.EditorControl,
	P.ProviderType
FROM Services AS S
INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
WHERE
	S.ServiceID = @ServiceID

RETURN
				*/
				#endregion

				var provider = Services
					.Where(s => s.ServiceId == serviceId)
					.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => new
					{
						p.ProviderId,
						p.GroupId,
						p.DisplayName,
						p.EditorControl,
						p.ProviderType
					});

				return EntityDataReader(provider);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetProviderByServiceID",
					 new SqlParameter("@ServiceID", serviceId));
			}
		}

		#endregion

		#region Private Network VLANs
		public int AddPrivateNetworkVLAN(int serverId, int vlan, string comments)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddPrivateNetworkVlan]
(
 @VlanID int OUTPUT,
 @Vlan int,
 @ServerID int,
 @Comments ntext
)
AS
BEGIN
 IF @ServerID = 0
 SET @ServerID = NULL

 INSERT INTO PrivateNetworkVLANs(Vlan, ServerID, Comments)
 VALUES (@Vlan, @ServerID, @Comments)

 SET @VlanID = SCOPE_IDENTITY()

 RETURN
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[AddRDSCertificate]
(
	@RDSCertificateId INT OUTPUT,
	@ServiceId INT,
	@Content NTEXT,
	@Hash NVARCHAR(255),
	@FileName NVARCHAR(255),
	@ValidFrom DATETIME,
	@ExpiryDate DATETIME
)
AS
INSERT INTO RDSCertificates
(
	ServiceId,
	Content,
	Hash,
	FileName,
	ValidFrom,
	ExpiryDate	
)
VALUES
(
	@ServiceId,
	@Content,
	@Hash,
	@FileName,
	@ValidFrom,
	@ExpiryDate
)

SET @RDSCertificateId = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var vlanEntity = new Data.Entities.PrivateNetworkVlan()
				{
					ServerId = serverId != 0 ? serverId : null,
					Vlan = vlan,
					Comments = comments
				};
				PrivateNetworkVlans.Add(vlanEntity);

				SaveChanges();

				return vlanEntity.VlanId;
			}
			else
			{
				SqlParameter prmAddresId = new SqlParameter("@VlanID", SqlDbType.Int);
				prmAddresId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "AddPrivateNetworkVlan",
					 prmAddresId,
					 new SqlParameter("@Vlan", vlan),
					 new SqlParameter("@ServerID", serverId),
					 new SqlParameter("@Comments", comments));

				return Convert.ToInt32(prmAddresId.Value);
			}
		}

		public int DeletePrivateNetworkVLAN(int vlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeletePrivateNetworkVLAN]
(
	@VlanID int,
	@Result int OUTPUT
)
AS

SET @Result = 0
IF EXISTS(SELECT VlanID FROM PackageVLANs WHERE VlanID = @VlanID)
BEGIN
	SET @Result = -2
	RETURN
END

DELETE FROM PrivateNetworkVLANs
WHERE VlanID = @VlanID
RETURN
				*/
				#endregion

				if (PackageVlans.Any(vlan => vlan.VlanId == vlanId)) return -2;

				PrivateNetworkVlans.Where(vlan => vlan.VlanId == vlanId).ExecuteDelete();

				return 0;
			}
			else
			{
				SqlParameter prmResult = new SqlParameter("@Result", SqlDbType.Int);
				prmResult.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "DeletePrivateNetworkVLAN",
					 prmResult,
					 new SqlParameter("@VlanID", vlanId));

				return Convert.ToInt32(prmResult.Value);
			}
		}

		public IDataReader GetPrivateNetworkVLANsPaged(int actorId, int serverId,
			 string filterColumn, string filterValue,
			 string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPrivateNetworVLANsPaged]
(
 @ActorID int,
 @ServerID int,
 @FilterColumn nvarchar(50) = '',
 @FilterValue nvarchar(50) = '',
 @SortColumn nvarchar(50),
 @StartRow int,
 @MaximumRows int
)
AS
BEGIN

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
@IsAdmin = 1
AND (@ServerID = 0 OR @ServerID <> 0 AND V.ServerID = @ServerID)
'

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
 IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
  SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
 ELSE
  SET @condition = @condition + '
   AND (Vlan LIKE ''' + @FilterValue + '''
   OR ServerName LIKE ''' + @FilterValue + '''
   OR Username LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'V.Vlan ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(V.VlanID)
FROM dbo.PrivateNetworkVLANs AS V
LEFT JOIN Servers AS S ON V.ServerID = S.ServerID
LEFT JOIN PackageVLANs AS PA ON V.VlanID = PA.VlanID
LEFT JOIN dbo.Packages P ON PA.PackageID = P.PackageID
LEFT JOIN dbo.Users U ON P.UserID = U.UserID
WHERE ' + @condition + '

DECLARE @VLANs AS TABLE
(
 VlanID int
);

WITH TempItems AS (
 SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
  V.VlanID
 FROM dbo.PrivateNetworkVLANs AS V
 LEFT JOIN Servers AS S ON V.ServerID = S.ServerID
 LEFT JOIN PackageVLANs AS PA ON V.VlanID = PA.VlanID
 LEFT JOIN dbo.Packages P ON PA.PackageID = P.PackageID
 LEFT JOIN dbo.Users U ON U.UserID = P.UserID
 WHERE ' + @condition + '
)

INSERT INTO @VLANs
SELECT VlanID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
 V.VlanID,
 V.Vlan,
 V.Comments,
 V.ServerID,
 S.ServerName,
 PA.PackageID,
 P.PackageName,
 P.UserID,
 U.UserName
FROM @VLANs AS TA
INNER JOIN dbo.PrivateNetworkVLANs AS V ON TA.VlanID = V.VlanID
LEFT JOIN Servers AS S ON V.ServerID = S.ServerID
LEFT JOIN PackageVLANs AS PA ON V.VlanID = PA.VlanID
LEFT JOIN dbo.Packages P ON PA.PackageID = P.PackageID
LEFT JOIN dbo.Users U ON U.UserID = P.UserID
'

exec sp_executesql @sql, N'@IsAdmin bit, @ServerID int, @StartRow int, @MaximumRows int',
@IsAdmin, @ServerID, @StartRow, @MaximumRows

END
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var vlans = PrivateNetworkVlans
					.Where(vlan => isAdmin && (serverId == 0 || serverId != 0 && serverId == vlan.ServerId))
					.Join(Servers, v => v.ServerId, s => s.ServerId, (v, s) => new
					{
						Vlan = v,
						Server = s
					})
					.Join(PackageVlans, j => j.Vlan.VlanId, pv => pv.VlanId, (j, pv) => new
					{
						j.Vlan,
						j.Server,
						PackageVlan = pv
					})
					.Join(Packages, j => j.PackageVlan.PackageId, p => p.PackageId, (j, p) => new
					{
						j.Vlan,
						j.Server,
						j.PackageVlan,
						Package = p
					})
					.Join(Users, j => j.Package.UserId, u => u.UserId, (j, u) => new
					{
						j.Vlan.VlanId,
						j.Vlan.Vlan,
						j.Vlan.Comments,
						j.Vlan.ServerId,
						j.Server.ServerName,
						j.PackageVlan.PackageId,
						j.Package.PackageName,
						j.Package.UserId,
						u.Username
					});

				if (!string.IsNullOrEmpty(filterValue))
				{
					if (!string.IsNullOrEmpty(filterColumn))
					{
						vlans = vlans.Where(DynamicFunctions.ColumnLike(vlans, filterColumn, filterValue));
					}
					else
					{
						vlans = vlans.Where(v => v.Vlan.ToString() == filterValue || v.ServerName == filterValue ||
							v.Username == filterValue);
					}
				}

				if (string.IsNullOrEmpty(sortColumn)) sortColumn = "Vlan";

				var count = vlans.Count();

				vlans = vlans.OrderBy(sortColumn);

				vlans = vlans.Skip(startRow).Take(maximumRows);

				return EntityDataReader(count, vlans);
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
												 "GetPrivateNetworVLANsPaged",
													 new SqlParameter("@ActorId", actorId),
													 new SqlParameter("@ServerId", serverId),
													 new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
													 new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
													 new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
													 new SqlParameter("@startRow", startRow),
													 new SqlParameter("@maximumRows", maximumRows));
				return reader;
			}
		}

		public IDataReader GetPrivateNetworVLAN(int vlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPrivateNetworVLAN]
(
 @VlanID int
)
AS
BEGIN
 -- select
 SELECT
  VlanID,
  Vlan,
  ServerID,
  Comments
 FROM PrivateNetworkVLANs
 WHERE
  VlanID = @VlanID
 RETURN
END
				*/
				#endregion

				var vlan = PrivateNetworkVlans
					.Where(v => v.VlanId == vlanId);

				return EntityDataReader(vlan);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "GetPrivateNetworVLAN",
					 new SqlParameter("@VlanID", vlanId));
			}
		}

		public void UpdatePrivateNetworVLAN(int vlanId, int serverId, int vlan, string comments)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdatePrivateNetworVLAN]
(
 @VlanID int,
 @ServerID int,
 @Vlan int,
 @Comments ntext
)
AS
BEGIN
 IF @ServerID = 0
 SET @ServerID = NULL

 UPDATE PrivateNetworkVLANs SET
  Vlan = @Vlan,
  ServerID = @ServerID,
  Comments = @Comments
 WHERE VlanID = @VlanID
 RETURN
END
				*/
				#endregion

				var vl = PrivateNetworkVlans.FirstOrDefault(v => v.VlanId == vlanId);
				if (vl == null) return;

				vl.ServerId = serverId != 0 ? serverId : null;
				vl.Vlan = vlan;
				vl.Comments = comments;

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "UpdatePrivateNetworVLAN",
					 new SqlParameter("@VlanID", vlanId),
					 new SqlParameter("@ServerID", serverId),
					 new SqlParameter("@Vlan", vlan),
					 new SqlParameter("@Comments", comments));
			}
		}

		public bool CheckPackageParent(int parentPackageId, int packageId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CheckPackageParent]
(
	@ParentPackageID int,
	@PackageID int
)
RETURNS bit
AS
BEGIN

-- check if the user requests hiself
IF @ParentPackageID = @PackageID
BEGIN
	RETURN 1
END

DECLARE @TmpParentPackageID int, @TmpPackageID int
SET @TmpPackageID = @PackageID

WHILE 10 = 10
BEGIN

	SET @TmpParentPackageID = NULL --reset var

	-- get owner
	SELECT
		@TmpParentPackageID = ParentPackageID
	FROM Packages
	WHERE PackageID = @TmpPackageID

	IF @TmpParentPackageID IS NULL -- the last parent package
		BREAK

	IF @TmpParentPackageID = @ParentPackageID
	RETURN 1

	SET @TmpPackageID = @TmpParentPackageID
END

RETURN 0
END
			*/
			#endregion

			// check if the user requests hiself
			if (parentPackageId == packageId) return true;

			var id = packageId;
			var package = Packages
				.Select(p => new { p.PackageId, p.ParentPackageId })
				.FirstOrDefault(p => p.PackageId == id);
			while (package != null && package.ParentPackageId.HasValue && package.ParentPackageId != parentPackageId)
			{
				id = package.ParentPackageId.Value;
				package = Packages
					.Select(p => new { p.PackageId, p.ParentPackageId })
					.FirstOrDefault(p => p.PackageId == id);
			}
			return package != null && package.ParentPackageId == parentPackageId;
		}

		public IDataReader GetPackagePrivateNetworkVLANs(int packageId, string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackagePrivateNetworkVLANs]
(
 @PackageID int,
 @SortColumn nvarchar(50),
 @StartRow int,
 @MaximumRows int
)
AS
BEGIN
-- start
DECLARE @condition nvarchar(700)
SET @condition = '
dbo.CheckPackageParent(@PackageID, PA.PackageID) = 1
AND PA.IsDmz = 0
'

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'V.Vlan ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(PA.PackageVlanID)
FROM dbo.PackageVLANs PA
INNER JOIN dbo.PrivateNetworkVLANs AS V ON PA.VlanID = V.VlanID
INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
INNER JOIN dbo.Users U ON U.UserID = P.UserID
WHERE ' + @condition + '

DECLARE @VLANs AS TABLE
(
 PackageVlanID int
);

WITH TempItems AS (
 SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
  PA.PackageVlanID
 FROM dbo.PackageVLANs PA
 INNER JOIN dbo.PrivateNetworkVLANs AS V ON PA.VlanID = V.VlanID
 INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
 INNER JOIN dbo.Users U ON U.UserID = P.UserID
 WHERE ' + @condition + '
)

INSERT INTO @VLANs
SELECT PackageVlanID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
 PA.PackageVlanID,
 PA.VlanID,
 V.Vlan,
 PA.PackageID,
 P.PackageName,
 P.UserID,
 U.UserName
FROM @VLANs AS TA
INNER JOIN dbo.PackageVLANs AS PA ON TA.PackageVlanID = PA.PackageVlanID
INNER JOIN dbo.PrivateNetworkVLANs AS V ON PA.VlanID = V.VlanID
INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
INNER JOIN dbo.Users U ON U.UserID = P.UserID
'

print @sql

exec sp_executesql @sql, N'@PackageID int, @StartRow int, @MaximumRows int',
@PackageID, @StartRow, @MaximumRows

END
GO
				*/
				#endregion

				using (var packages = PackagesTree(packageId, true))
				{
					var vlans = PackageVlans
						//.Where(pv => CheckPackageParent(packageId, pv.PackageId) && !pv.IsDmz)
						.Where(pv => !pv.IsDmz)
						.Join(packages, pv => pv.PackageId, p => p, (pv, p) => pv)
						.Join(PrivateNetworkVlans, p => p.VlanId, v => v.VlanId, (pv, vl) => new
						{
							PackageVlan = pv,
							Vlan = vl
						})
						.Join(Packages, j => j.PackageVlan.PackageId, p => p.PackageId, (j, p) => new
						{
							j.PackageVlan,
							j.Vlan,
							Package = p
						})
						.Join(Users, j => j.Package.UserId, u => u.UserId, (j, u) => new
						{
							j.PackageVlan.PackageVlanId,
							j.PackageVlan.VlanId,
							j.Vlan.Vlan,
							j.PackageVlan.PackageId,
							j.Package.PackageName,
							j.Package.UserId,
							u.Username
						});

					if (!string.IsNullOrEmpty(sortColumn)) vlans = vlans.OrderBy(sortColumn);
					else vlans = vlans.OrderBy(v => v.Vlan);

					vlans = vlans.Skip(startRow).Take(maximumRows);

					return EntityDataReader(vlans);
				}
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
												 "GetPackagePrivateNetworkVLANs",
													 new SqlParameter("@PackageID", packageId),
													 new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
													 new SqlParameter("@startRow", startRow),
													 new SqlParameter("@maximumRows", maximumRows));
				return reader;
			}
		}

		public void DeallocatePackageVLAN(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeallocatePackageVLAN]
	@PackageVlanID int
AS
BEGIN

	SET NOCOUNT ON;

	-- check parent package
	DECLARE @ParentPackageID int

	SELECT @ParentPackageID = P.ParentPackageID
	FROM PackageVLANs AS PV
	INNER JOIN Packages AS P ON PV.PackageID = P.PackageId
	WHERE PV.PackageVlanID = @PackageVlanID

	IF (@ParentPackageID = 1) -- ""System"" space
	BEGIN
		DELETE FROM dbo.PackageVLANs
		WHERE PackageVlanID = @PackageVlanID
	END
	ELSE -- 2rd level space and below
	BEGIN
		UPDATE PackageVLANs
		SET PackageID = @ParentPackageID
		WHERE PackageVlanID = @PackageVlanID
	END

END
				*/
				#endregion

				var packageVlan = PackageVlans
					.Where(pv => pv.PackageVlanId == id)
					.Include(pv => pv.Package)
					.Single();

				if (packageVlan.Package.ParentPackageId == 1) // System space
				{
					PackageVlans.Where(pv => pv.PackageVlanId == id).ExecuteDelete();
				}
				else // 2nd level space and below
				{
					packageVlan.PackageId = id;

					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure, "DeallocatePackageVLAN",
												  new SqlParameter("@PackageVlanID", id));
			}
		}

		public IDataReader GetUnallottedVLANs(int packageId, int serviceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUnallottedVLANs]
 @PackageID int,
 @ServiceID int
AS
BEGIN
 DECLARE @ParentPackageID int
 DECLARE @ServerID int
IF (@PackageID = -1) -- NO PackageID defined, use ServerID from ServiceID (VPS Import)
BEGIN
 SELECT
  @ServerID = ServerID,
  @ParentPackageID = 1
 FROM Services
 WHERE ServiceID = @ServiceID
END
ELSE
BEGIN
 SELECT
  @ParentPackageID = ParentPackageID,
  @ServerID = ServerID
 FROM Packages
 WHERE PackageID = @PackageId
END

IF @ParentPackageID = 1 -- ""System"" space
BEGIN
  -- check if server is physical
  IF EXISTS(SELECT * FROM Servers WHERE ServerID = @ServerID AND VirtualServer = 0)
  BEGIN
   -- physical server
   SELECT
    V.VlanID,
    V.Vlan,
    V.ServerID
   FROM dbo.PrivateNetworkVLANs AS V
   WHERE
    (V.ServerID = @ServerID OR V.ServerID IS NULL)
    AND V.VlanID NOT IN (SELECT PV.VlanID FROM dbo.PackageVLANs AS PV)
   ORDER BY V.ServerID DESC, V.Vlan
  END
  ELSE
  BEGIN
   -- virtual server
   -- get resource group by service
   DECLARE @GroupID int
   SELECT @GroupID = P.GroupID FROM Services AS S
   INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
   WHERE S.ServiceID = @ServiceID
   SELECT
    V.VlanID,
    V.Vlan,
    V.ServerID
   FROM dbo.PrivateNetworkVLANs AS V
   WHERE
    (V.ServerID IN (
     SELECT SVC.ServerID FROM [dbo].[Services] AS SVC
     INNER JOIN [dbo].[Providers] AS P ON SVC.ProviderID = P.ProviderID
     WHERE [SVC].[ServiceID] = @ServiceId AND P.GroupID = @GroupID
    ) OR V.ServerID IS NULL)
    AND V.VlanID NOT IN (SELECT PV.VlanID FROM dbo.PackageVLANs AS PV)
   ORDER BY V.ServerID DESC, V.Vlan
  END
 END
 ELSE -- 2rd level space and below
 BEGIN
  -- get service location
  SELECT @ServerID = S.ServerID FROM Services AS S
  WHERE S.ServiceID = @ServiceID
  SELECT
   V.VlanID,
   V.Vlan,
   V.ServerID
  FROM dbo.PackageVLANs AS PV
  INNER JOIN PrivateNetworkVLANs AS V ON PV.VlanID = V.VlanID
  WHERE
   PV.PackageID = @ParentPackageID
   AND (V.ServerID = @ServerID OR V.ServerID IS NULL)
  ORDER BY V.ServerID DESC, V.Vlan
 END
END
				*/
				#endregion

				int parentPackageId = -1;
				int serverId = -1;

				if (packageId == -1)
				{ // No PackageID defined, use ServerID from ServiceID (VPS Import)
					serverId = Services
						.Where(service => service.ServiceId == serviceId)
						.Select(service => service.ServerId)
						.FirstOrDefault();
					parentPackageId = 1;
				}
				else
				{
					var package = Packages
						.Where(p => p.PackageId == packageId)
						.Select(p => new { p.ServerId, p.ParentPackageId })
						.FirstOrDefault();
					if (package != null)
					{
						parentPackageId = package.ParentPackageId ?? 1;
						serverId = package.ServerId ?? -1;
					}
				}

				if (parentPackageId == 1) // "System" space
				{
					// check if server is physical
					if (Servers.Any(s => s.ServerId == serverId && !s.VirtualServer))
					{
						// physical server
						var vlans = PrivateNetworkVlans
							.SelectMany(v => v.PackageVlans.DefaultIfEmpty(), (v, ps) => new
							{
								Vlan = v,
								HasPackage = ps != null,
							})
							.Where(v => !v.HasPackage && (v.Vlan.ServerId == serverId || v.Vlan.ServerId == null))
							.Select(v => new
							{
								v.Vlan.VlanId,
								v.Vlan.Vlan,
								v.Vlan.ServerId
							});
						return EntityDataReader(vlans);
					}
					else
					{ // virtual server, get resource group by service
						var groupId = Services
							.Where(s => s.ServiceId == serviceId)
							.Select(s => s.Provider.GroupId)
							.FirstOrDefault();
						var vlans = PrivateNetworkVlans
							.SelectMany(v => v.Server.Services, (v, s) => new
							{
								Vlan = v,
								Service = s,
								s.Provider
							})
							.Where(v => (v.Service.ServiceId == serviceId && v.Provider.GroupId == groupId) ||
								v.Vlan.ServerId == null)
							.SelectMany(v => v.Vlan.PackageVlans.DefaultIfEmpty(), (v, ps) => new
							{
								v.Vlan,
								HasPackages = ps != null,
							})
							.Where(v => !v.HasPackages)
							.Select(v => new
							{
								v.Vlan.VlanId,
								v.Vlan.Vlan,
								v.Vlan.ServerId,
							})
							.OrderByDescending(v => v.ServerId)
							.ThenBy(v => v.Vlan);
						return EntityDataReader(vlans);
					}
				}
				else
				{ // 2nd level space and below, get service location
					serverId = Services
						.Where(s => s.ServiceId == serviceId)
						.Select(s => s.ServerId)
						.Single();
					var vlans = PrivateNetworkVlans
						.SelectMany(v => v.PackageVlans, (v, pv) => new
						{
							Vlan = v,
							Package = pv,
						})
						.Where(g => g.Package.PackageId == packageId &&
							(g.Vlan.ServerId == serverId || g.Vlan.ServerId == null))
						.Select(g => new
						{
							g.Vlan.ServerId,
							g.Vlan.Vlan,
							g.Vlan.VlanId
						})
						.OrderByDescending(g => g.ServerId)
						.ThenBy(g => g.Vlan);
					return EntityDataReader(vlans);
				}
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
												 "GetUnallottedVLANs",
													 new SqlParameter("@PackageId", packageId),
													 new SqlParameter("@ServiceId", serviceId));
			}
		}

		public void AllocatePackageVLANs(int packageId, bool isDmz, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AllocatePackageVLANs]
(
	@PackageID int,
	@IsDmz bit,
	@xml ntext
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @idoc int
	--Create an internal representation of the XML document.
	EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

	-- delete
	DELETE FROM PackageVLANs
	FROM PackageVLANs AS PV
	INNER JOIN OPENXML(@idoc, '/items/item', 1) WITH 
	(
		VlanID int '@id'
	) as PX ON PV.VlanID = PX.VlanID


	-- insert
	INSERT INTO dbo.PackageVLANs
	(		
		PackageID,
		VlanID,
		IsDmz
	)
	SELECT		
		@PackageID,
		VlanID,
		@IsDmz

	FROM OPENXML(@idoc, '/items/item', 1) WITH 
	(
		VlanID int '@id'
	) as PX

	-- remove document
	exec sp_xml_removedocument @idoc

END
GO
				*/
				#endregion

				var items = XElement.Parse(xml);
				using (var ids = items
					.Elements()
					.Select(e => (int)e.Attribute("id"))
					.ToTempIdSet(this))
				{
					// delete
					var toDelete = PackageVlans
						.Join(ids, p => p.VlanId, id => id, (p, id) => p);
					PackageVlans.RemoveRange(toDelete);

					// insert
					PackageVlans.AddRange(
						ids.Select(id => new Data.Entities.PackageVlan
						{
							PackageId = packageId,
							VlanId = id,
							IsDmz = isDmz
						}));

					SaveChanges();
				}
			}
			else
			{
				SqlParameter[] param = new[] {
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@IsDmz", isDmz),                  
					new SqlParameter("@xml", xml)
				};

				ExecuteLongNonQuery("AllocatePackageVLANs", param);
			}
		}

        public IDataReader GetPackageDmzNetworkVLANs(int packageId, string sortColumn, int startRow, int maximumRows)
        {
			if (UseEntityFramework)  {
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageDmzNetworkVLANs]
(
 @PackageID int,
 @SortColumn nvarchar(50),
 @StartRow int,
 @MaximumRows int
)
AS
BEGIN
-- start
DECLARE @condition nvarchar(700)
SET @condition = '
dbo.CheckPackageParent(@PackageID, PA.PackageID) = 1
AND PA.IsDmz = 1
'

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'V.Vlan ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(PA.PackageVlanID)
FROM dbo.PackageVLANs PA
INNER JOIN dbo.PrivateNetworkVLANs AS V ON PA.VlanID = V.VlanID
INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
INNER JOIN dbo.Users U ON U.UserID = P.UserID
WHERE ' + @condition + '

DECLARE @VLANs AS TABLE
(
 PackageVlanID int
);

WITH TempItems AS (
 SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
  PA.PackageVlanID
 FROM dbo.PackageVLANs PA
 INNER JOIN dbo.PrivateNetworkVLANs AS V ON PA.VlanID = V.VlanID
 INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
 INNER JOIN dbo.Users U ON U.UserID = P.UserID
 WHERE ' + @condition + '
)

INSERT INTO @VLANs
SELECT PackageVlanID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
 PA.PackageVlanID,
 PA.VlanID,
 V.Vlan,
 PA.PackageID,
 P.PackageName,
 P.UserID,
 U.UserName
FROM @VLANs AS TA
INNER JOIN dbo.PackageVLANs AS PA ON TA.PackageVlanID = PA.PackageVlanID
INNER JOIN dbo.PrivateNetworkVLANs AS V ON PA.VlanID = V.VlanID
INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
INNER JOIN dbo.Users U ON U.UserID = P.UserID
'

print @sql

exec sp_executesql @sql, N'@PackageID int, @StartRow int, @MaximumRows int',
@PackageID, @StartRow, @MaximumRows

END
				*/
				#endregion

				using (var packages = PackagesTree(packageId, true))
				{
					var vlans = PackageVlans
						//.Where(pv => CheckPackageParent(packageId, pv.PackageId) && pv.IsDmz)
						.Where(pv => pv.IsDmz)
						.Join(packages, pv => pv.PackageId, p => p, (pv, p) => pv)
						.Join(PrivateNetworkVlans, p => p.VlanId, v => v.VlanId, (pv, vl) => new
						{
							PackageVlan = pv,
							Vlan = vl
						})
						.Join(Packages, j => j.PackageVlan.PackageId, p => p.PackageId, (j, p) => new
						{
							j.PackageVlan,
							j.Vlan,
							Package = p
						})
						.Join(Users, j => j.Package.UserId, u => u.UserId, (j, u) => new
						{
							j.PackageVlan.PackageVlanId,
							j.PackageVlan.VlanId,
							j.Vlan.Vlan,
							j.PackageVlan.PackageId,
							j.Package.PackageName,
							j.Package.UserId,
							u.Username
						});

					if (!string.IsNullOrEmpty(sortColumn)) vlans = vlans.OrderBy(sortColumn);
					else vlans = vlans.OrderBy(v => v.Vlan);

					vlans = vlans.Skip(startRow).Take(maximumRows);

					return EntityDataReader(vlans);
				}
			} else {
            	IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
                                	     "GetPackageDmzNetworkVLANs",
                            	            new SqlParameter("@PackageID", packageId),
                        	                new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
                    	                    new SqlParameter("@startRow", startRow),
                	                        new SqlParameter("@maximumRows", maximumRows));
            	return reader;
        	}
		}
		#endregion

		#region IPAddresses
		public IDataReader GetIPAddress(int ipAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetIPAddress]
(
 @AddressID int
)
AS
BEGIN
 -- select
 SELECT
  AddressID,
  ServerID,
  ExternalIP,
  InternalIP,
  PoolID,
  SubnetMask,
  DefaultGateway,
  Comments,
  VLAN
 FROM IPAddresses
 WHERE
  AddressID = @AddressID
 RETURN
END
				*/
				#endregion

				var address = IpAddresses
					.Where(ip => ip.AddressId == ipAddressId)
					.Select(ip => new
					{
						ip.AddressId,
						ip.ServerId,
						ip.ExternalIp,
						ip.InternalIp,
						ip.PoolId,
						ip.SubnetMask,
						ip.DefaultGateway,
						ip.Comments,
						ip.Vlan
					});
				return EntityDataReader(address);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetIPAddress",
					new SqlParameter("@AddressID", ipAddressId));
			}
		}

		public IDataReader GetIPAddresses(int actorId, int poolId, int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetIPAddresses]
(
 @ActorID int,
 @PoolID int,
 @ServerID int
)
AS
BEGIN

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
 IP.AddressID,
 IP.PoolID,
 IP.ExternalIP,
 IP.InternalIP,
 IP.SubnetMask,
 IP.DefaultGateway,
 IP.Comments,
 IP.VLAN,
 IP.ServerID,
 S.ServerName,
 PA.ItemID,
 SI.ItemName,
 PA.PackageID,
 P.PackageName,
 P.UserID,
 U.UserName
FROM dbo.IPAddresses AS IP
LEFT JOIN Servers AS S ON IP.ServerID = S.ServerID
LEFT JOIN PackageIPAddresses AS PA ON IP.AddressID = PA.AddressID
LEFT JOIN ServiceItems SI ON PA.ItemId = SI.ItemID
LEFT JOIN dbo.Packages P ON PA.PackageID = P.PackageID
LEFT JOIN dbo.Users U ON U.UserID = P.UserID
WHERE @IsAdmin = 1
AND (@PoolID = 0 OR @PoolID <> 0 AND IP.PoolID = @PoolID)
AND (@ServerID = 0 OR @ServerID <> 0 AND IP.ServerID = @ServerID)
END
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var addresses = IpAddresses
					.Where(ip => isAdmin &&
						(poolId == 0 || (poolId != 0 && poolId == ip.PoolId)) &&
						(serverId == 0 || (serverId != 0 && serverId == ip.ServerId)))
					.Join(Servers, ip => ip.ServerId, s => s.ServerId, (ip, s) => new { Ip = ip, Server = s })
					.Join(PackageIpAddresses, g => g.Ip.AddressId, p => p.AddressId, (g, p) => new
					{
						g.Ip,
						g.Server,
						PackageIp = p
					})
					.Join(ServiceItems, g => g.PackageIp.ItemId, s => s.ItemId, (g, s) => new
					{
						g.Ip,
						g.Server,
						g.PackageIp,
						Item = s
					})
					.Join(Packages, g => g.PackageIp.PackageId, p => p.PackageId, (g, p) => new
					{
						g.Ip,
						g.Server,
						g.PackageIp,
						g.Item,
						Package = p
					})
					.Join(Users, g => g.Package.UserId, u => u.UserId, (g, u) => new
					{
						g.Ip.AddressId,
						g.Ip.PoolId,
						g.Ip.ExternalIp,
						g.Ip.InternalIp,
						g.Ip.SubnetMask,
						g.Ip.DefaultGateway,
						g.Ip.Comments,
						g.Ip.Vlan,
						g.Ip.ServerId,
						g.Server.ServerName,
						g.PackageIp.ItemId,
						g.Item.ItemName,
						g.PackageIp.PackageId,
						g.Package.PackageName,
						g.Package.UserId,
						u.Username
					});

				return EntityDataReader(addresses);
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetIPAddresses",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PoolId", poolId),
					new SqlParameter("@ServerId", serverId));
				return reader;
			}
		}

		public IDataReader GetIPAddressesPaged(int actorId, int poolId, int serverId,
			string filterColumn, string filterValue,
			string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetIPAddressesPaged]
(
 @ActorID int,
 @PoolID int,
 @ServerID int,
 @FilterColumn nvarchar(50) = '',
 @FilterValue nvarchar(50) = '',
 @SortColumn nvarchar(50),
 @StartRow int,
 @MaximumRows int
)
AS
BEGIN

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
@IsAdmin = 1
AND (@PoolID = 0 OR @PoolID <> 0 AND IP.PoolID = @PoolID)
AND (@ServerID = 0 OR @ServerID <> 0 AND IP.ServerID = @ServerID)
'

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
 IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
  SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
 ELSE
  SET @condition = @condition + '
   AND (ExternalIP LIKE ''' + @FilterValue + '''
   OR InternalIP LIKE ''' + @FilterValue + '''
   OR DefaultGateway LIKE ''' + @FilterValue + '''
   OR ServerName LIKE ''' + @FilterValue + '''
   OR ItemName LIKE ''' + @FilterValue + '''
   OR Username LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'IP.ExternalIP ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(IP.AddressID)
FROM dbo.IPAddresses AS IP
LEFT JOIN Servers AS S ON IP.ServerID = S.ServerID
LEFT JOIN PackageIPAddresses AS PA ON IP.AddressID = PA.AddressID
LEFT JOIN ServiceItems SI ON PA.ItemId = SI.ItemID
LEFT JOIN dbo.Packages P ON PA.PackageID = P.PackageID
LEFT JOIN dbo.Users U ON P.UserID = U.UserID
WHERE ' + @condition + '

DECLARE @Addresses AS TABLE
(
 AddressID int
);

WITH TempItems AS (
 SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
  IP.AddressID
 FROM dbo.IPAddresses AS IP
 LEFT JOIN Servers AS S ON IP.ServerID = S.ServerID
 LEFT JOIN PackageIPAddresses AS PA ON IP.AddressID = PA.AddressID
 LEFT JOIN ServiceItems SI ON PA.ItemId = SI.ItemID
 LEFT JOIN dbo.Packages P ON PA.PackageID = P.PackageID
 LEFT JOIN dbo.Users U ON U.UserID = P.UserID
 WHERE ' + @condition + '
)

INSERT INTO @Addresses
SELECT AddressID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
 IP.AddressID,
 IP.PoolID,
 IP.ExternalIP,
 IP.InternalIP,
 IP.SubnetMask,
 IP.DefaultGateway,
 IP.Comments,
 IP.VLAN,
 IP.ServerID,
 S.ServerName,
 PA.ItemID,
 SI.ItemName,
 PA.PackageID,
 P.PackageName,
 P.UserID,
 U.UserName
FROM @Addresses AS TA
INNER JOIN dbo.IPAddresses AS IP ON TA.AddressID = IP.AddressID
LEFT JOIN Servers AS S ON IP.ServerID = S.ServerID
LEFT JOIN PackageIPAddresses AS PA ON IP.AddressID = PA.AddressID
LEFT JOIN ServiceItems SI ON PA.ItemId = SI.ItemID
LEFT JOIN dbo.Packages P ON PA.PackageID = P.PackageID
LEFT JOIN dbo.Users U ON U.UserID = P.UserID
'

exec sp_executesql @sql, N'@IsAdmin bit, @PoolID int, @ServerID int, @StartRow int, @MaximumRows int',
@IsAdmin, @PoolID, @ServerID, @StartRow, @MaximumRows

END
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var addresses = IpAddresses
					.Where(ip => isAdmin &&
						(poolId == 0 || (poolId != 0 && poolId == ip.PoolId)) &&
						(serverId == 0 || (serverId != 0 && serverId == ip.ServerId)))
					.Join(Servers, ip => ip.ServerId, s => s.ServerId, (ip, s) => new { Ip = ip, Server = s })
					.Join(PackageIpAddresses, g => g.Ip.AddressId, p => p.AddressId, (g, p) => new
					{
						g.Ip,
						g.Server,
						PackageIp = p
					})
					.Join(ServiceItems, g => g.PackageIp.ItemId, s => s.ItemId, (g, s) => new
					{
						g.Ip,
						g.Server,
						g.PackageIp,
						Item = s
					})
					.Join(Packages, g => g.PackageIp.PackageId, p => p.PackageId, (g, p) => new
					{
						g.Ip,
						g.Server,
						g.PackageIp,
						g.Item,
						Package = p
					})
					.Join(Users, g => g.Package.UserId, u => u.UserId, (g, u) => new
					{
						g.Ip.AddressId,
						g.Ip.PoolId,
						g.Ip.ExternalIp,
						g.Ip.InternalIp,
						g.Ip.SubnetMask,
						g.Ip.DefaultGateway,
						g.Ip.Comments,
						g.Ip.Vlan,
						g.Ip.ServerId,
						g.Server.ServerName,
						g.PackageIp.ItemId,
						g.Item.ItemName,
						g.PackageIp.PackageId,
						g.Package.PackageName,
						g.Package.UserId,
						u.Username
					});

				if (!string.IsNullOrEmpty(filterValue))
				{
					if (!string.IsNullOrEmpty(filterColumn))
					{
						addresses = addresses.Where(DynamicFunctions.ColumnLike(addresses, filterColumn, filterValue));
					}
					else
					{
#if NETFRAMEWORK
						addresses = addresses.Where(a => DbFunctions.Like(a.ExternalIp, filterValue) ||
							DbFunctions.Like(a.InternalIp, filterValue) ||
							DbFunctions.Like(a.DefaultGateway, filterValue) ||
							DbFunctions.Like(a.ServerName, filterValue) ||
							DbFunctions.Like(a.ItemName, filterValue) ||
							DbFunctions.Like(a.Username, filterValue));
#else
						addresses = addresses.Where(a => EF.Functions.Like(a.ExternalIp, filterValue) ||
							EF.Functions.Like(a.InternalIp, filterValue) ||
							EF.Functions.Like(a.DefaultGateway, filterValue) ||
							EF.Functions.Like(a.ServerName, filterValue) ||
							EF.Functions.Like(a.ItemName, filterValue) ||
							EF.Functions.Like(a.Username, filterValue));
#endif
					}
				}

				var count = addresses.Count();

				if (string.IsNullOrEmpty(sortColumn)) addresses = addresses.OrderBy(a => a.ExternalIp);
				else addresses = addresses.OrderBy(sortColumn);

				addresses = addresses.Skip(startRow).Take(maximumRows);

				return EntityDataReader(count, addresses);
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetIPAddressesPaged",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PoolId", poolId),
					new SqlParameter("@ServerId", serverId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
				return reader;
			}
		}

		public int AddIPAddress(int poolId, int serverId, string externalIP, string internalIP,
			 string subnetMask, string defaultGateway, string comments, int VLAN)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddIPAddress]
(
 @AddressID int OUTPUT,
 @ServerID int,
 @ExternalIP varchar(24),
 @InternalIP varchar(24),
 @PoolID int,
 @SubnetMask varchar(15),
 @DefaultGateway varchar(15),
 @Comments ntext,
 @VLAN int
)
AS
BEGIN
 IF @ServerID = 0
 SET @ServerID = NULL

 INSERT INTO IPAddresses (ServerID, ExternalIP, InternalIP, PoolID, SubnetMask, DefaultGateway, Comments, VLAN)
 VALUES (@ServerID, @ExternalIP, @InternalIP, @PoolID, @SubnetMask, @DefaultGateway, @Comments, @VLAN)

 SET @AddressID = SCOPE_IDENTITY()

 RETURN
END
				*/
				#endregion

				var address = new Data.Entities.IpAddress()
				{
					PoolId = poolId,
					ServerId = serverId != 0 ? serverId : null,
					ExternalIp = externalIP,
					InternalIp = internalIP,
					SubnetMask = subnetMask,
					DefaultGateway = defaultGateway,
					Comments = comments,
					Vlan = VLAN
				};

				IpAddresses.Add(address);

				SaveChanges();

				return address.AddressId;
			}
			else
			{
				SqlParameter prmAddresId = new SqlParameter("@AddressID", SqlDbType.Int);
				prmAddresId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "AddIPAddress",
					 prmAddresId,
					 new SqlParameter("@ServerID", serverId),
					 new SqlParameter("@externalIP", externalIP),
					 new SqlParameter("@internalIP", internalIP),
					 new SqlParameter("@PoolId", poolId),
					 new SqlParameter("@SubnetMask", subnetMask),
					 new SqlParameter("@DefaultGateway", defaultGateway),
					 new SqlParameter("@Comments", comments),
					 new SqlParameter("@VLAN", VLAN));

				return Convert.ToInt32(prmAddresId.Value);
			}
		}

		public void UpdateIPAddress(int addressId, int poolId, int serverId,
			 string externalIP, string internalIP, string subnetMask, string defaultGateway, string comments, int VLAN)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateIPAddress]
(
 @AddressID int,
 @ServerID int,
 @ExternalIP varchar(24),
 @InternalIP varchar(24),
 @PoolID int,
 @SubnetMask varchar(15),
 @DefaultGateway varchar(15),
 @Comments ntext,
 @VLAN int
)
AS
BEGIN
 IF @ServerID = 0
 SET @ServerID = NULL

 UPDATE IPAddresses SET
  ExternalIP = @ExternalIP,
  InternalIP = @InternalIP,
  ServerID = @ServerID,
  PoolID = @PoolID,
  SubnetMask = @SubnetMask,
  DefaultGateway = @DefaultGateway,
  Comments = @Comments,
  VLAN = @VLAN
 WHERE AddressID = @AddressID
 RETURN
END
				*/
				#endregion

				var address = IpAddresses.FirstOrDefault(ip => ip.AddressId == addressId);

				if (address != null)
				{
					address.PoolId = poolId;
					address.ServerId = serverId > 0 ? serverId : null;
					address.ExternalIp = externalIP;
					address.InternalIp = internalIP;
					address.SubnetMask = subnetMask;
					address.DefaultGateway = defaultGateway;
					address.Comments = comments;
					address.Vlan = VLAN;

					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
				 ObjectQualifier + "UpdateIPAddress",
				 new SqlParameter("@AddressID", addressId),
				 new SqlParameter("@externalIP", externalIP),
				 new SqlParameter("@internalIP", internalIP),
				 new SqlParameter("@ServerID", serverId),
				 new SqlParameter("@PoolId", poolId),
				 new SqlParameter("@SubnetMask", subnetMask),
				 new SqlParameter("@DefaultGateway", defaultGateway),
				 new SqlParameter("@Comments", comments),
				 new SqlParameter("@VLAN", VLAN));
			}
		}

		public void UpdateIPAddresses(string xmlIds, int poolId, int serverId,
			 string subnetMask, string defaultGateway, string comments, int VLAN)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateIPAddresses]
(
 @xml ntext,
 @PoolID int,
 @ServerID int,
 @SubnetMask varchar(15),
 @DefaultGateway varchar(15),
 @Comments ntext,
 @VLAN int
)
AS
BEGIN
 SET NOCOUNT ON;
 IF @ServerID = 0
 SET @ServerID = NULL
 DECLARE @idoc int
 --Create an internal representation of the XML document.
 EXEC sp_xml_preparedocument @idoc OUTPUT, @xml
 -- update
 UPDATE IPAddresses SET
  ServerID = @ServerID,
  PoolID = @PoolID,
  SubnetMask = @SubnetMask,
  DefaultGateway = @DefaultGateway,
  Comments = @Comments,
  VLAN = @VLAN
 FROM IPAddresses AS IP
 INNER JOIN OPENXML(@idoc, '/items/item', 1) WITH
 (
  AddressID int '@id'
 ) as PV ON IP.AddressID = PV.AddressID
 -- remove document
 exec sp_xml_removedocument @idoc
END
				*/
				#endregion

				var items = XElement.Parse(xmlIds);
				var addressIds = items
					.Elements()
					.Select(e => (int)e.Attribute("id"))
					.ToArray();

				var addresses = IpAddresses
					.Join(addressIds, ip => ip.AddressId, id => id, (ip, id) => ip)
					.ToArray();

				foreach (var ip in addresses)
				{
					ip.PoolId = poolId;
					ip.ServerId = serverId;
					ip.SubnetMask = subnetMask;
					ip.DefaultGateway = defaultGateway;
					ip.Comments = comments;
					ip.Vlan = VLAN;
				}

				if (addresses.Any()) SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
				 ObjectQualifier + "UpdateIPAddresses",
				 new SqlParameter("@Xml", xmlIds),
				 new SqlParameter("@ServerID", serverId),
				 new SqlParameter("@PoolId", poolId),
				 new SqlParameter("@SubnetMask", subnetMask),
				 new SqlParameter("@DefaultGateway", defaultGateway),
				 new SqlParameter("@Comments", comments),
				 new SqlParameter("@VLAN", VLAN));
			}
		}

		public int DeleteIPAddress(int ipAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteIPAddress]
(
	@AddressID int,
	@Result int OUTPUT
)
AS

SET @Result = 0

IF EXISTS(SELECT RecordID FROM GlobalDnsRecords WHERE IPAddressID = @AddressID)
BEGIN
	SET @Result = -1
	RETURN
END

IF EXISTS(SELECT AddressID FROM PackageIPAddresses WHERE AddressID = @AddressID AND ItemID IS NOT NULL)
BEGIN
	SET @Result = -2

	RETURN
END

-- delete package-IP relation
DELETE FROM PackageIPAddresses
WHERE AddressID = @AddressID

-- delete IP address
DELETE FROM IPAddresses
WHERE AddressID = @AddressID

RETURN
				*/
				#endregion

				if (GlobalDnsRecords.Any(r => r.IpAddressId == ipAddressId)) return -1;
				if (PackageIpAddresses.Any(p => p.AddressId == ipAddressId && p.ItemId != null)) return -2;

				using (var transaction = Database.BeginTransaction())
				{
					// delete package-IP relation
					PackageIpAddresses.Where(p => p.AddressId == ipAddressId).ExecuteDelete();

					// delete IP address
					IpAddresses.Where(a => a.AddressId == ipAddressId).ExecuteDelete();

					transaction.Commit();
				}

				return 0;
			}
			else
			{
				SqlParameter prmResult = new SqlParameter("@Result", SqlDbType.Int);
				prmResult.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "DeleteIPAddress",
					 prmResult,
					 new SqlParameter("@AddressID", ipAddressId));

				return Convert.ToInt32(prmResult.Value);
			}
		}
#endregion

		#region Clusters
		public IDataReader GetClusters(int actorId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetClusters]
(
	@ActorID int
)
AS

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

-- get the list
SELECT
	ClusterID,
	ClusterName
FROM Clusters
WHERE @IsAdmin = 1

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var clusters = Clusters.Where(c => isAdmin);

				return EntityDataReader(clusters);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
				 ObjectQualifier + "GetClusters",
				 new SqlParameter("@actorId", actorId));
			}
		}

		public int AddCluster(string clusterName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddCluster]
(
	@ClusterID int OUTPUT,
	@ClusterName nvarchar(100)
)
AS
INSERT INTO Clusters
(
	ClusterName
)
VALUES
(
	@ClusterName
)

SET @ClusterID = SCOPE_IDENTITY()
RETURN
				*/
				#endregion

				var cluster = new Data.Entities.Cluster() { ClusterName = clusterName };

				Clusters.Add(cluster);
				SaveChanges();

				return cluster.ClusterId;
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@ClusterID", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					 ObjectQualifier + "AddCluster",
					 prmId,
					 new SqlParameter("@ClusterName", clusterName));

				return Convert.ToInt32(prmId.Value);
			}
		}

		public void DeleteCluster(int clusterId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteCluster]
(
	@ClusterID int
)
AS

-- reset cluster in services
UPDATE Services
SET ClusterID = NULL
WHERE ClusterID = @ClusterID

-- delete cluster
DELETE FROM Clusters
WHERE ClusterID = @ClusterID
RETURN
				*/
				#endregion

				using (var transaction = Database.BeginTransaction())
				{
					// reset cluster in services
					Services
						.Where(s => s.ClusterId == clusterId)
						.ExecuteUpdate(s => new Data.Entities.Service { ClusterId = null });
					// delete cluster
					Clusters
						.Where(c => c.ClusterId == clusterId)
						.ExecuteDelete();

					transaction.Commit();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
				 ObjectQualifier + "DeleteCluster",
				 new SqlParameter("@ClusterId", clusterId));
			}
		}

		#endregion

		#region Global DNS records

		public string GetFullIPAddress(string externalIp, string internalIp)
		{
			var ip = string.Empty;

			if (!string.IsNullOrEmpty(externalIp)) ip = externalIp;

			if (!string.IsNullOrEmpty(internalIp))
			{
				if (ip == string.Empty) ip = internalIp;
				else ip = $"{ip} ({internalIp})";
			}

			return ip;
		}

		public DataSet GetDnsRecordsByService(int actorId, int serviceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDnsRecordsByService]
(
	@ActorID int,
	@ServiceID int
)
AS

SELECT
	NR.RecordID,
	NR.ServiceID,
	NR.ServerID,
	NR.PackageID,
	NR.RecordType,
	NR.RecordName,
	CASE
		WHEN NR.RecordType = 'A' AND NR.RecordData = '' THEN dbo.GetFullIPAddress(IP.ExternalIP, IP.InternalIP)
		WHEN NR.RecordType = 'MX' THEN CONVERT(varchar(3), NR.MXPriority) + ', ' + NR.RecordData
		WHEN NR.RecordType = 'SRV' THEN CONVERT(varchar(3), NR.SrvPort) + ', ' + NR.RecordData
		ELSE NR.RecordData
	END AS FullRecordData,
	NR.RecordData,
	NR.MXPriority,
	NR.SrvPriority,
	NR.SrvWeight,
	NR.SrvPort,
	NR.IPAddressID,
	dbo.GetFullIPAddress(IP.ExternalIP, IP.InternalIP) AS IPAddress,
	IP.ExternalIP,
	IP.InternalIP
FROM
	GlobalDnsRecords AS NR
LEFT OUTER JOIN IPAddresses AS IP ON NR.IPAddressID = IP.AddressID
WHERE
	NR.ServiceID = @ServiceID
RETURN
				*/
				#endregion

				var records = GlobalDnsRecords
					.Where(r => r.ServiceId == serviceId)
					.Select(r => new
					{
						r.RecordId,
						r.ServiceId,
						r.ServerId,
						r.PackageId,
						r.RecordType,
						r.RecordName,
						r.RecordData,
						r.MXPriority,
						r.SrvPriority,
						r.SrvWeight,
						r.SrvPort,
						r.IpAddressId,
						ExternalIp = r.IpAddress != null ? r.IpAddress.ExternalIp : null,
						InternalIp = r.IpAddress != null ? r.IpAddress.InternalIp : null
					})
					.AsEnumerable()
					.Select(r => new
					{
						r.RecordId,
						r.ServiceId,
						r.ServerId,
						r.PackageId,
						r.RecordType,
						r.RecordName,
						FullRecordData = r.RecordType == "A" && string.IsNullOrEmpty(r.RecordData) ?
							GetFullIPAddress(r.ExternalIp, r.InternalIp) :
							(r.RecordType == "MX" ?
								$"{r.MXPriority}, {r.RecordData}" :
								(r.RecordType == "SRV" ? $"{r.SrvPort}, {r.RecordData}" :
									r.RecordData)),
						r.RecordData,
						r.MXPriority,
						r.SrvPriority,
						r.SrvWeight,
						r.SrvPort,
						r.IpAddressId,
						IPAddress = GetFullIPAddress(r.ExternalIp, r.InternalIp),
						r.ExternalIp,
						r.InternalIp
					});
				return EntityDataSet(records);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
				 ObjectQualifier + "GetDnsRecordsByService",
				 new SqlParameter("@actorId", actorId),
				 new SqlParameter("@ServiceId", serviceId));
			}
		}

		public DataSet GetDnsRecordsByServer(int actorId, int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDnsRecordsByServer]
(
	@ActorID int,
	@ServerID int
)
AS

SELECT
	NR.RecordID,
	NR.ServiceID,
	NR.ServerID,
	NR.PackageID,
	NR.RecordType,
	NR.RecordName,
	NR.RecordData,
	CASE
		WHEN NR.RecordType = 'A' AND NR.RecordData = '' THEN dbo.GetFullIPAddress(IP.ExternalIP, IP.InternalIP)
		WHEN NR.RecordType = 'MX' THEN CONVERT(varchar(3), NR.MXPriority) + ', ' + NR.RecordData
		WHEN NR.RecordType = 'SRV' THEN CONVERT(varchar(3), NR.SrvPort) + ', ' + NR.RecordData
		ELSE NR.RecordData
	END AS FullRecordData,
	NR.MXPriority,
	NR.SrvPriority,
	NR.SrvWeight,
	NR.SrvPort,
	NR.IPAddressID,
	dbo.GetFullIPAddress(IP.ExternalIP, IP.InternalIP) AS IPAddress,
	IP.ExternalIP,
	IP.InternalIP
FROM
	GlobalDnsRecords AS NR
LEFT OUTER JOIN IPAddresses AS IP ON NR.IPAddressID = IP.AddressID
WHERE
	NR.ServerID = @ServerID
RETURN
				*/
				#endregion

				var records = GlobalDnsRecords
					.Where(r => r.ServerId == serverId)
					.Select(r => new
					{
						r.RecordId,
						r.ServiceId,
						r.ServerId,
						r.PackageId,
						r.RecordType,
						r.RecordName,
						r.RecordData,
						r.MXPriority,
						r.SrvPriority,
						r.SrvWeight,
						r.SrvPort,
						r.IpAddressId,
						ExternalIp = r.IpAddress != null ? r.IpAddress.ExternalIp : null,
						InternalIp = r.IpAddress != null ? r.IpAddress.InternalIp : null
					})
					.AsEnumerable()
					.Select(r => new
					{
						r.RecordId,
						r.ServiceId,
						r.ServerId,
						r.PackageId,
						r.RecordType,
						r.RecordName,
						FullRecordData = r.RecordType == "A" && string.IsNullOrEmpty(r.RecordData) ?
							GetFullIPAddress(r.ExternalIp, r.InternalIp) :
							(r.RecordType == "MX" ?
								$"{r.MXPriority}, {r.RecordData}" :
								(r.RecordType == "SRV" ? $"{r.SrvPort}, {r.RecordData}" :
									r.RecordData)),
						r.RecordData,
						r.MXPriority,
						r.SrvPriority,
						r.SrvWeight,
						r.SrvPort,
						r.IpAddressId,
						IPAddress = GetFullIPAddress(r.ExternalIp, r.InternalIp),
						r.ExternalIp,
						r.InternalIp
					});
				return EntityDataSet(records);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
				 ObjectQualifier + "GetDnsRecordsByServer",
				 new SqlParameter("@actorId", actorId),
				 new SqlParameter("@ServerId", serverId));
			}
		}

		public bool CheckActorPackageRights(int actorId, int? packageId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CheckActorPackageRights]
(
	@ActorID int,
	@PackageID int
)
RETURNS bit
AS
BEGIN

IF @ActorID = -1 OR @PackageID IS NULL
RETURN 1

-- check if this is a 'system' package
IF @PackageID < 2 AND @PackageID > -1 AND dbo.CheckIsUserAdmin(@ActorID) = 0
RETURN 0

-- get package owner
DECLARE @UserID int
SELECT @UserID = UserID FROM Packages
WHERE PackageID = @PackageID

IF @UserID IS NULL
RETURN 1 -- unexisting package

-- check user
RETURN dbo.CheckActorUserRights(@ActorID, @UserID)

RETURN 0
END
			*/
			#endregion

			if (actorId == -1 || packageId == null) return true;

			// check if this is a 'system' package
			if (packageId >= 0 && packageId <= 1 && !CheckIsUserAdmin(actorId)) return false;

			// get package owner
			var ownerId = Packages
				.Where(p => p.PackageId == packageId)
				.Select(p => (int?)p.UserId)
				.FirstOrDefault();

			if (ownerId == null) return true; // unexisting package

			return CheckActorUserRights(actorId, ownerId.Value);
		}

		public DataSet GetDnsRecordsByPackage(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDnsRecordsByPackage]
(
	@ActorID int,
	@PackageID int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SELECT
	NR.RecordID,
	NR.ServiceID,
	NR.ServerID,
	NR.PackageID,
	NR.RecordType,
	NR.RecordName,
	NR.RecordData,
	NR.MXPriority,
	NR.SrvPriority,
	NR.SrvWeight,
	NR.SrvPort,
	NR.IPAddressID,
	CASE
		WHEN NR.RecordType = 'A' AND NR.RecordData = '' THEN dbo.GetFullIPAddress(IP.ExternalIP, IP.InternalIP)
		WHEN NR.RecordType = 'MX' THEN CONVERT(varchar(3), NR.MXPriority) + ', ' + NR.RecordData
		WHEN NR.RecordType = 'SRV' THEN CONVERT(varchar(3), NR.SrvPort) + ', ' + NR.RecordData
		ELSE NR.RecordData
	END AS FullRecordData,
	dbo.GetFullIPAddress(IP.ExternalIP, IP.InternalIP) AS IPAddress,
	IP.ExternalIP,
	IP.InternalIP
FROM
	GlobalDnsRecords AS NR
LEFT OUTER JOIN IPAddresses AS IP ON NR.IPAddressID = IP.AddressID
WHERE NR.PackageID = @PackageID
RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId)) throw new AccessViolationException("You are not allowed to access this package");

				var records = GlobalDnsRecords
					.Where(r => r.PackageId == packageId)
					.Select(r => new
					{
						r.RecordId,
						r.ServiceId,
						r.ServerId,
						r.PackageId,
						r.RecordType,
						r.RecordName,
						r.RecordData,
						r.MXPriority,
						r.SrvPriority,
						r.SrvWeight,
						r.SrvPort,
						r.IpAddressId,
						ExternalIp = r.IpAddress != null ? r.IpAddress.ExternalIp : null,
						InternalIp = r.IpAddress != null ? r.IpAddress.InternalIp : null
					})
					.AsEnumerable()
					.Select(r => new
					 {
						 r.RecordId,
						 r.ServiceId,
						 r.ServerId,
						 r.PackageId,
						 r.RecordType,
						 r.RecordName,
						 FullRecordData = r.RecordType == "A" && string.IsNullOrEmpty(r.RecordData) ?
							GetFullIPAddress(r.ExternalIp, r.InternalIp) :
							(r.RecordType == "MX" ?
								$"{r.MXPriority}, {r.RecordData}" :
								(r.RecordType == "SRV" ? $"{r.SrvPort}, {r.RecordData}" :
									r.RecordData)),
						 r.RecordData,
						 r.MXPriority,
						 r.SrvPriority,
						 r.SrvWeight,
						 r.SrvPort,
						 r.IpAddressId,
						 IPAddress = GetFullIPAddress(r.ExternalIp, r.InternalIp),
						 r.ExternalIp,
						 r.InternalIp
					 });
				return EntityDataSet(records);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
				 ObjectQualifier + "GetDnsRecordsByPackage",
				 new SqlParameter("@actorId", actorId),
				 new SqlParameter("@PackageId", packageId));
			}
		}

		public DataSet GetDnsRecordsByGroup(int groupId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDnsRecordsByGroup]
(
	@GroupID int
)
AS
SELECT
	RGR.RecordID,
	RGR.RecordOrder,
	RGR.GroupID,
	RGR.RecordType,
	RGR.RecordName,
	RGR.RecordData,
	RGR.MXPriority
FROM
	ResourceGroupDnsRecords AS RGR
WHERE RGR.GroupID = @GroupID
ORDER BY RGR.RecordOrder
RETURN
				*/
				#endregion

				var records = ResourceGroupDnsRecords
					.Where(r => r.GroupId == groupId)
					.OrderBy(r => r.RecordOrder)
					.Select(r => new
					{
						r.RecordId,
						r.RecordOrder,
						r.GroupId,
						r.RecordType,
						r.RecordName,
						r.RecordData,
						r.MXPriority
					});

				return EntityDataSet(records);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
				 ObjectQualifier + "GetDnsRecordsByGroup",
				 new SqlParameter("@GroupId", groupId));
			}
		}
		public DataSet GetDnsRecordsTotal(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDnsRecordsTotal]
(
	@ActorID int,
	@PackageID int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- create temp table for DNS records
DECLARE @Records TABLE
(
	RecordID int,
	RecordType nvarchar(10),
	RecordName nvarchar(50)
)

-- select PACKAGES DNS records
DECLARE @ParentPackageID int, @TmpPackageID int
SET @TmpPackageID = @PackageID

WHILE 10 = 10
BEGIN

	-- get DNS records for the current package
	INSERT INTO @Records (RecordID, RecordType, RecordName)
	SELECT
		GR.RecordID,
		GR.RecordType,
		GR.RecordName
	FROM GlobalDNSRecords AS GR
	WHERE GR.PackageID = @TmpPackageID
	AND GR.RecordType + GR.RecordName NOT IN (SELECT RecordType + RecordName FROM @Records)

	SET @ParentPackageID = NULL

	-- get parent package
	SELECT
		@ParentPackageID = ParentPackageID
	FROM Packages
	WHERE PackageID = @TmpPackageID

	IF @ParentPackageID IS NULL -- the last parent
	BREAK

	SET @TmpPackageID = @ParentPackageID
END

-- select VIRTUAL SERVER DNS records
DECLARE @ServerID int
SELECT @ServerID = ServerID FROM Packages
WHERE PackageID = @PackageID

INSERT INTO @Records (RecordID, RecordType, RecordName)
SELECT
	GR.RecordID,
	GR.RecordType,
	GR.RecordName
FROM GlobalDNSRecords AS GR
WHERE GR.ServerID = @ServerID
AND GR.RecordType + GR.RecordName NOT IN (SELECT RecordType + RecordName FROM @Records)

-- select SERVER DNS records
INSERT INTO @Records (RecordID, RecordType, RecordName)
SELECT
	GR.RecordID,
	GR.RecordType,
	GR.RecordName
FROM GlobalDNSRecords AS GR
WHERE GR.ServerID IN (SELECT
	SRV.ServerID
FROM VirtualServices AS VS
INNER JOIN Services AS S ON VS.ServiceID = S.ServiceID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
WHERE VS.ServerID = @ServerID)
AND GR.RecordType + GR.RecordName NOT IN (SELECT RecordType + RecordName FROM @Records)

-- select SERVICES DNS records
-- re-distribute package services
EXEC DistributePackageServices @ActorID, @PackageID

--INSERT INTO @Records (RecordID, RecordType, RecordName)
--SELECT
--	GR.RecordID,
--	GR.RecordType,
	-- GR.RecordName
-- FROM GlobalDNSRecords AS GR
-- WHERE GR.ServiceID IN (SELECT ServiceID FROM PackageServices WHERE PackageID = @PackageID)
-- AND GR.RecordType + GR.RecordName NOT IN (SELECT RecordType + RecordName FROM @Records)

SELECT
	NR.RecordID,
	NR.ServiceID,
	NR.ServerID,
	NR.PackageID,
	NR.RecordType,
	NR.RecordName,
	NR.RecordData,
	NR.MXPriority,
	NR.SrvPriority,
	NR.SrvWeight,
	NR.SrvPort,
	NR.IPAddressID,
	ISNULL(IP.ExternalIP, '') AS ExternalIP,
	ISNULL(IP.InternalIP, '') AS InternalIP,
	CASE
		WHEN NR.RecordType = 'A' AND NR.RecordData = '' THEN dbo.GetFullIPAddress(IP.ExternalIP, IP.InternalIP)
		WHEN NR.RecordType = 'MX' THEN CONVERT(varchar(3), NR.MXPriority) + ', ' + NR.RecordData
		WHEN NR.RecordType = 'SRV' THEN CONVERT(varchar(3), NR.SrvPort) + ', ' + NR.RecordData
		ELSE NR.RecordData
	END AS FullRecordData,
	dbo.GetFullIPAddress(IP.ExternalIP, IP.InternalIP) AS IPAddress
FROM @Records AS TR
INNER JOIN GlobalDnsRecords AS NR ON TR.RecordID = NR.RecordID
LEFT OUTER JOIN IPAddresses AS IP ON NR.IPAddressID = IP.AddressID

RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId)) throw new AccessViolationException("You are not allowed to access this package");

				// select PACKAGES DNS records
				var pid = (int?)packageId;

				IQueryable<Data.Entities.GlobalDnsRecord> records = GlobalDnsRecords
					.Where(r => r.PackageId == pid);
				pid = Packages
					.Where(p => p.PackageId == pid)
					.Select(p => p.ParentPackageId)
					.FirstOrDefault();
				while (pid != null)
				{
					records = records
						.Concat(GlobalDnsRecords
							.Where(r => r.PackageId == pid));
					pid = Packages
						.Where(p => p.PackageId == pid)
						.Select(p => p.ParentPackageId)
						.FirstOrDefault();
				}

				// select VIRTUAL SERVER DNS records
				var serverId = Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => p.ServerId)
					.FirstOrDefault();

				records = records
					.Concat(GlobalDnsRecords
						.Where(r => r.ServerId == serverId));

				// select SERVER DNS records
				records = records
					.Concat(GlobalDnsRecords
						.Where(r => r.ServerId == serverId)
						.Join(Services, r => r.ServerId, s => s.ServerId, (r, s) => new
						{
							Record = r,
							Service = s
						})
						.Join(VirtualServices, r => r.Service.ServiceId, vs => vs.ServiceId, (r, vs) => new
						{
							r.Record,
							vs.ServerId
						})
						.Where(r => r.ServerId == serverId)
						.Select(r => r.Record));

				// select SERVICES DNS records

				// re-distribute package services
				DistributePackageServices(actorId, packageId);

				// TODO uncomment this?
				/* records = records
					.Concat(GlobalDnsRecords
					.Join(PackageServices.Where(p => p.PackageId == packageId),
						r => r.ServiceId, p => p.ServiceId, (r, p) => r)); */

#if NETCOREAPP
				records = records.DistinctBy(r => r.RecordType + r.RecordName);
#else
				records = records.GroupBy(r => new { r.RecordType, r.RecordName })
					.Select(g => g.First());
#endif
				var recordsSelected = records
					.Select(r => new
					{
						r.RecordId,
						r.ServiceId,
						r.ServerId,
						r.PackageId,
						r.RecordType,
						r.RecordName,
						r.RecordData,
						r.MXPriority,
						r.SrvPriority,
						r.SrvWeight,
						r.SrvPort,
						r.IpAddressId,
						ExternalIp = r.IpAddress != null ? r.IpAddress.ExternalIp : null,
						InternalIp = r.IpAddress != null ? r.IpAddress.InternalIp : null
					})
					.AsEnumerable()
					.Select(r => new
					{
						r.RecordId,
						r.ServiceId,
						r.ServerId,
						r.PackageId,
						r.RecordType,
						r.RecordName,
						r.RecordData,
						r.MXPriority,
						r.SrvPriority,
						r.SrvWeight,
						r.SrvPort,
						r.IpAddressId,
						ExternalIp = r.ExternalIp ?? "",
						InternalIp = r.InternalIp ?? "",
						FullRecordData = r.RecordType == "A" && string.IsNullOrEmpty(r.RecordData) ?
							GetFullIPAddress(r.ExternalIp, r.InternalIp) :
							(r.RecordType == "MX" ?
								$"{r.MXPriority}, {r.RecordData}" :
								(r.RecordType == "SRV" ? $"{r.SrvPort}, {r.RecordData}" :
									r.RecordData)),
						IPAddress = GetFullIPAddress(r.ExternalIp, r.InternalIp)
					});
				return EntityDataSet(recordsSelected);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetDnsRecordsTotal",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@packageId", packageId));
			}
		}

		public IDataReader GetDnsRecord(int actorId, int recordId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDnsRecord]
(
	@ActorID int,
	@RecordID int
)
AS

-- check rights
DECLARE @ServiceID int, @ServerID int, @PackageID int
SELECT
	@ServiceID = ServiceID,
	@ServerID = ServerID,
	@PackageID = PackageID
FROM GlobalDnsRecords
WHERE
	RecordID = @RecordID

IF (@ServiceID > 0 OR @ServerID > 0) AND dbo.CheckIsUserAdmin(@ActorID) = 0
RAISERROR('You are not allowed to perform this operation', 16, 1)

IF (@PackageID > 0) AND dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SELECT
	NR.RecordID,
	NR.ServiceID,
	NR.ServerID,
	NR.PackageID,
	NR.RecordType,
	NR.RecordName,
	NR.RecordData,
	NR.MXPriority,
	NR.SrvPriority,
	NR.SrvWeight,
	NR.SrvPort,
	NR.IPAddressID
FROM
	GlobalDnsRecords AS NR
WHERE NR.RecordID = @RecordID
RETURN
				*/
				#endregion

				// check rights
				var records = GlobalDnsRecords
					.Where(r => r.RecordId == recordId)
					.Select(r => new
					{
						r.RecordId,
						r.ServiceId,
						r.ServerId,
						r.PackageId,
						r.RecordType,
						r.RecordName,
						r.RecordData,
						r.MXPriority,
						r.SrvPriority,
						r.SrvWeight,
						r.SrvPort,
						r.IpAddressId
					})
					.ToArray();
				var record = records
					.SingleOrDefault();

				if (record != null && (record.ServiceId > 0 || record.ServerId > 0) && !CheckIsUserAdmin(actorId))
					throw new AccessViolationException("You are not allowed to perform this operation");

				if (record != null && record.PackageId > 0 && !CheckActorPackageRights(actorId, record.PackageId))
					throw new AccessViolationException("You are not allowed to access this package");

				return EntityDataReader(records);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetDnsRecord",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@RecordId", recordId));
			}
		}

		public void AddDnsRecord(int actorId, int serviceId, int serverId, int packageId, string recordType,
			 string recordName, string recordData, int mxPriority, int SrvPriority, int SrvWeight, int SrvPort, int ipAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddDnsRecord]
(
	@ActorID int,
	@ServiceID int,
	@ServerID int,
	@PackageID int,
	@RecordType nvarchar(10),
	@RecordName nvarchar(50),
	@RecordData nvarchar(500),
	@MXPriority int,
	@SrvPriority int,
	@SrvWeight int,
	@SrvPort int,
	@IPAddressID int
)
AS

IF (@ServiceID > 0 OR @ServerID > 0) AND dbo.CheckIsUserAdmin(@ActorID) = 0
RAISERROR('You should have administrator role to perform such operation', 16, 1)

IF (@PackageID > 0) AND dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

IF @ServiceID = 0 SET @ServiceID = NULL
IF @ServerID = 0 SET @ServerID = NULL
IF @PackageID = 0 SET @PackageID = NULL
IF @IPAddressID = 0 SET @IPAddressID = NULL

IF EXISTS
(
	SELECT RecordID FROM GlobalDnsRecords WHERE
	ServiceID = @ServiceID AND ServerID = @ServerID AND PackageID = @PackageID
	AND RecordName = @RecordName AND RecordType = @RecordType
)

	UPDATE GlobalDnsRecords
	SET
		RecordData = RecordData,
		MXPriority = MXPriority,
		SrvPriority = SrvPriority,
		SrvWeight = SrvWeight,
		SrvPort = SrvPort,

		IPAddressID = @IPAddressID
	WHERE
		ServiceID = @ServiceID AND ServerID = @ServerID AND PackageID = @PackageID
ELSE
	INSERT INTO GlobalDnsRecords
	(
		ServiceID,
		ServerID,
		PackageID,
		RecordType,
		RecordName,
		RecordData,
		MXPriority,
		SrvPriority,
		SrvWeight,
		SrvPort,
		IPAddressID
	)
	VALUES
	(
		@ServiceID,
		@ServerID,
		@PackageID,
		@RecordType,
		@RecordName,
		@RecordData,
		@MXPriority,
		@SrvPriority,
		@SrvWeight,
		@SrvPort,
		@IPAddressID
	)

RETURN
				*/
				#endregion

				if ((serviceId > 0 || serverId > 0) && !CheckIsUserAdmin(actorId))
					throw new AccessViolationException("You should have administrator role to perform such operation");

				if (packageId > 0 && !CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				int? serverIdOrNull = serverId != 0 ? serverId : null;
				int? serviceIdOrNull = serviceId != 0 ? serviceId : null;
				int? packageIdOrNull = packageId != 0 ? packageId : null;
				int? ipAddressIdOrNull = ipAddressId != 0 ? ipAddressId : null;

				var record = GlobalDnsRecords
					.FirstOrDefault(r => r.ServiceId == serviceIdOrNull &&
						r.ServerId == serverIdOrNull && r.PackageId == packageIdOrNull &&
						r.RecordName == recordName && r.RecordType == recordType);

				if (record == null)
				{
					record = new Data.Entities.GlobalDnsRecord()
					{
						RecordType = recordType,
						RecordName = recordName,
						ServiceId = serviceIdOrNull,
						ServerId = serverIdOrNull,
						PackageId = packageIdOrNull
					};
					GlobalDnsRecords.Add(record);
				}

				record.RecordData = recordData;
				record.MXPriority = mxPriority;
				record.SrvPriority = SrvPriority;
				record.SrvWeight = SrvWeight;
				record.SrvPort = SrvPort;
				record.IpAddressId = ipAddressIdOrNull;

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddDnsRecord",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@ServiceId", serviceId),
					new SqlParameter("@ServerId", serverId),
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@RecordType", recordType),
					new SqlParameter("@RecordName", recordName),
					new SqlParameter("@RecordData", recordData),
					new SqlParameter("@MXPriority", mxPriority),
					new SqlParameter("@SrvPriority", SrvPriority),
					new SqlParameter("@SrvWeight", SrvWeight),
					new SqlParameter("@SrvPort", SrvPort),
					new SqlParameter("@IpAddressId", ipAddressId));
			}
		}
		public void UpdateDnsRecord(int actorId, int recordId, string recordType,
			 string recordName, string recordData, int mxPriority, int SrvPriority, int SrvWeight, int SrvPort, int ipAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateDnsRecord]
(
	@ActorID int,
	@RecordID int,
	@RecordType nvarchar(10),
	@RecordName nvarchar(50),
	@RecordData nvarchar(500),
	@MXPriority int,
	@SrvPriority int,
	@SrvWeight int,
	@SrvPort int,
	@IPAddressID int
)
AS

IF @IPAddressID = 0 SET @IPAddressID = NULL

-- check rights
DECLARE @ServiceID int, @ServerID int, @PackageID int
SELECT
	@ServiceID = ServiceID,
	@ServerID = ServerID,
	@PackageID = PackageID
FROM GlobalDnsRecords
WHERE
	RecordID = @RecordID

IF (@ServiceID > 0 OR @ServerID > 0) AND dbo.CheckIsUserAdmin(@ActorID) = 0
RAISERROR('You are not allowed to perform this operation', 16, 1)

IF (@PackageID > 0) AND dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- update record
UPDATE GlobalDnsRecords
SET
	RecordType = @RecordType,
	RecordName = @RecordName,
	RecordData = @RecordData,
	MXPriority = @MXPriority,
	SrvPriority = @SrvPriority,
	SrvWeight = @SrvWeight,
	SrvPort = @SrvPort,
	IPAddressID = @IPAddressID
WHERE
	RecordID = @RecordID
RETURN
				*/
				#endregion

				int? ipAddressIdOrNull = ipAddressId != 0 ? ipAddressId : null;

				var record = GlobalDnsRecords
					.FirstOrDefault(r => r.RecordId == recordId);

				if (record != null)
				{
					// check rights
					if ((record.ServiceId > 0 || record.ServerId > 0) && !CheckIsUserAdmin(actorId))
						throw new AccessViolationException("You are not allowed to perform this operation");

					if (record.PackageId > 0 && !CheckActorPackageRights(actorId, record.PackageId))
						throw new AccessViolationException("You are not allowed to access this package");

					record.RecordType = recordType;
					record.RecordName = recordName;
					record.RecordData = recordData;
					record.MXPriority = mxPriority;
					record.SrvPriority = SrvPriority;
					record.SrvWeight = SrvWeight;
					record.SrvPort = SrvPort;
					record.IpAddressId = ipAddressIdOrNull;

					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateDnsRecord",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@RecordId", recordId),
					new SqlParameter("@RecordType", recordType),
					new SqlParameter("@RecordName", recordName),
					new SqlParameter("@RecordData", recordData),
					new SqlParameter("@MXPriority", mxPriority),
					new SqlParameter("@SrvPriority", SrvPriority),
					new SqlParameter("@SrvWeight", SrvWeight),
					new SqlParameter("@SrvPort", SrvPort),
					new SqlParameter("@IpAddressId", ipAddressId));
			}
		}


		public void DeleteDnsRecord(int actorId, int recordId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteDnsRecord]
(
	@ActorID int,
	@RecordID int
)
AS

-- check rights
DECLARE @ServiceID int, @ServerID int, @PackageID int
SELECT
	@ServiceID = ServiceID,
	@ServerID = ServerID,
	@PackageID = PackageID
FROM GlobalDnsRecords
WHERE
	RecordID = @RecordID

IF (@ServiceID > 0 OR @ServerID > 0) AND dbo.CheckIsUserAdmin(@ActorID) = 0
RETURN

IF (@PackageID > 0) AND dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RETURN

-- delete record
DELETE FROM GlobalDnsRecords
WHERE RecordID = @RecordID

RETURN
				*/
				#endregion

				var record = GlobalDnsRecords
					.FirstOrDefault(r => r.RecordId == recordId);

				if (record != null)
				{
					// check rights
					if ((record.ServerId > 0 || record.ServiceId > 0) && !CheckIsUserAdmin(actorId) ||
						record.PackageId > 0 && !CheckActorPackageRights(actorId, record.PackageId))
						return;

					GlobalDnsRecords.Remove(record);

					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteDnsRecord",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@RecordId", recordId));
			}
		}
		#endregion

		#region Domains

		public TempIdSet PackagesTree(int packageId, bool recursive = false)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[PackagesTree]
(
	@PackageID int,
	@Recursive bit = 0
)
RETURNS @T TABLE (PackageID int)
AS
BEGIN

INSERT INTO @T VALUES (@PackageID)

IF @Recursive = 1
BEGIN
	WITH RecursivePackages(ParentPackageID, PackageID, PackageLevel) AS
	(
		SELECT ParentPackageID, PackageID, 0 AS PackageLevel
		FROM Packages
		WHERE ParentPackageID = @PackageID
		UNION ALL
		SELECT p.ParentPackageID, p.PackageID, PackageLevel + 1
		FROM Packages p
			INNER JOIN RecursivePackages d
			ON p.ParentPackageID = d.PackageID
		WHERE @Recursive = 1
	)
	INSERT INTO @T
	SELECT PackageID
	FROM RecursivePackages
END

RETURN
END
			*/
			#endregion

			var tree = new TempIdSet(this);
			tree.Add(packageId);
			SaveChanges();

			if (recursive)
			{
				int level = 0;
				var children = Packages
					.Where(p => p.ParentPackageId == packageId)
					.Select(p => p.PackageId);
				while (tree.AddRange(children, ++level) > 0)
				{
					children = Packages
						.Join(tree.OfLevel(level), pkg => pkg.ParentPackageId, t => t, (pkg, t) => pkg.PackageId);
				}
			}

			return tree;
		}
		public DataSet GetDomains(int actorId, int packageId, bool recursive = true)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDomains]
(
	@ActorID int,
	@PackageID int,
	@Recursive bit = 1
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SELECT
	D.DomainID,
	D.PackageID,
	D.ZoneItemID,
	D.DomainItemID,
	D.DomainName,
	D.HostingAllowed,
	ISNULL(WS.ItemID, 0) AS WebSiteID,
	WS.ItemName AS WebSiteName,
	ISNULL(MD.ItemID, 0) AS MailDomainID,
	MD.ItemName AS MailDomainName,
	Z.ItemName AS ZoneName,
	D.IsSubDomain,
	D.IsPreviewDomain,
	D.CreationDate,
	D.ExpirationDate,
	D.LastUpdateDate,
	D.IsDomainPointer,
	D.RegistrarName
FROM Domains AS D
INNER JOIN PackagesTree(@PackageID, @Recursive) AS PT ON D.PackageID = PT.PackageID
LEFT OUTER JOIN ServiceItems AS WS ON D.WebSiteID = WS.ItemID
LEFT OUTER JOIN ServiceItems AS MD ON D.MailDomainID = MD.ItemID
LEFT OUTER JOIN ServiceItems AS Z ON D.ZoneItemID = Z.ItemID
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var tree = PackagesTree(packageId, recursive))
				{
					var domains = Domains
						.Join(tree, d => d.PackageId, t => t, (d, t) => d)
						.Select(d => new
						{
							d.DomainId,
							d.PackageId,
							d.ZoneItemId,
							d.DomainItemId,
							d.DomainName,
							d.HostingAllowed,
							WebSiteId = d.WebSite != null ? d.WebSite.ItemId : 0,
							WebSiteName = d.WebSite != null ? d.WebSite.ItemName : null,
							MailDomainId = d.MailDomain != null ? d.MailDomain.ItemId : 0,
							MailDomainName = d.MailDomain != null ? d.MailDomain.ItemName : null,
							ZoneName = d.Zone != null ? d.Zone.ItemName : null,
							d.IsSubDomain,
							d.IsPreviewDomain,
							d.IsDomainPointer
						});
					return EntityDataSet(domains);
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
				 ObjectQualifier + "GetDomains",
				 new SqlParameter("@ActorId", actorId),
				 new SqlParameter("@PackageId", packageId),
				 new SqlParameter("@Recursive", recursive));
			}
		}

		public DataSet GetResellerDomains(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetResellerDomains]
(
	@ActorID int,
	@PackageID int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- load parent package
DECLARE @ParentPackageID int
SELECT @ParentPackageID = ParentPackageID FROM Packages
WHERE PackageID = @PackageID

SELECT
	D.DomainID,
	D.PackageID,
	D.ZoneItemID,
	D.DomainName,
	D.HostingAllowed,
	D.WebSiteID,
	WS.ItemName,
	D.MailDomainID,
	MD.ItemName
FROM Domains AS D
INNER JOIN PackagesTree(@ParentPackageID, 0) AS PT ON D.PackageID = PT.PackageID
LEFT OUTER JOIN ServiceItems AS WS ON D.WebSiteID = WS.ItemID
LEFT OUTER JOIN ServiceItems AS MD ON D.MailDomainID = MD.ItemID
WHERE HostingAllowed = 1
RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				// load parent package
				var parentPackageId = Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => p.ParentPackageId)
					.FirstOrDefault();
				var domains = Domains
					.Where(d => d.HostingAllowed && d.PackageId == parentPackageId)
					.Select(d => new
					{
						d.DomainId,
						d.PackageId,
						d.ZoneItemId,
						d.DomainName,
						d.HostingAllowed,
						d.WebSiteId,
						WebSiteName = d.WebSite != null ? d.WebSite.ItemName : null,
						d.MailDomainId,
						MailDomainName = d.MailDomain != null ? d.MailDomain.ItemName : null
					});
				return EntityDataSet(domains);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetResellerDomains",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageId", packageId));
			}
		}

		public DataSet GetDomainsPaged(int actorId, int packageId, int serverId, bool recursive, string filterColumn, string filterValue,
			 string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored procedure
				/*
CREATE PROCEDURE [dbo].[GetDomainsPaged]
(
	@ActorID int,
	@PackageID int,
	@ServerID int,
	@Recursive bit,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS
SET NOCOUNT ON

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- build query and run it to the temporary table
DECLARE @sql nvarchar(2500)

IF @SortColumn = '' OR @SortColumn IS NULL
SET @SortColumn = 'DomainName'

SET @sql = '
DECLARE @Domains TABLE
(
	ItemPosition int IDENTITY(1,1),
	DomainID int
)
INSERT INTO @Domains (DomainID)
SELECT
	D.DomainID
FROM Domains AS D
INNER JOIN Packages AS P ON D.PackageID = P.PackageID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
LEFT OUTER JOIN ServiceItems AS Z ON D.ZoneItemID = Z.ItemID
LEFT OUTER JOIN Services AS S ON Z.ServiceID = S.ServiceID
LEFT OUTER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
WHERE (D.IsPreviewDomain = 0 AND D.IsDomainPointer = 0) AND
		((@Recursive = 0 AND D.PackageID = @PackageID)
		OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, D.PackageID) = 1))
AND (@ServerID = 0 OR (@ServerID > 0 AND S.ServerID = @ServerID))
'

IF @FilterValue <> ''
BEGIN
	IF @FilterColumn <> ''
	BEGIN
		SET @sql = @sql + ' AND ' + @FilterColumn + ' LIKE @FilterValue '
	END
	ELSE
		SET @sql = @sql + '
		AND (DomainName LIKE @FilterValue 
		OR Username LIKE @FilterValue
		OR ServerName LIKE @FilterValue
		OR PackageName LIKE @FilterValue) '
END

IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + ' SELECT COUNT(DomainID) FROM @Domains;SELECT
	D.DomainID,
	D.PackageID,
	D.ZoneItemID,
	D.DomainItemID,
	D.DomainName,
	D.HostingAllowed,
	ISNULL(WS.ItemID, 0) AS WebSiteID,
	WS.ItemName AS WebSiteName,
	ISNULL(MD.ItemID, 0) AS MailDomainID,
	MD.ItemName AS MailDomainName,
	D.IsSubDomain,
	D.IsPreviewDomain,
	D.IsDomainPointer,
	D.ExpirationDate,
	D.LastUpdateDate,
	D.RegistrarName,
	P.PackageName,
	ISNULL(SRV.ServerID, 0) AS ServerID,
	ISNULL(SRV.ServerName, '''') AS ServerName,
	ISNULL(SRV.Comments, '''') AS ServerComments,
	ISNULL(SRV.VirtualServer, 0) AS VirtualServer,
	P.UserID,
	U.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	U.RoleID,
	U.Email
FROM @Domains AS SD
INNER JOIN Domains AS D ON SD.DomainID = D.DomainID
INNER JOIN Packages AS P ON D.PackageID = P.PackageID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
LEFT OUTER JOIN ServiceItems AS WS ON D.WebSiteID = WS.ItemID
LEFT OUTER JOIN ServiceItems AS MD ON D.MailDomainID = MD.ItemID
LEFT OUTER JOIN ServiceItems AS Z ON D.ZoneItemID = Z.ItemID
LEFT OUTER JOIN Services AS S ON Z.ServiceID = S.ServiceID
LEFT OUTER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
WHERE SD.ItemPosition BETWEEN @StartRow + 1 AND @StartRow + @MaximumRows'

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int, @PackageID int, @FilterValue nvarchar(50), @ServerID int, @Recursive bit', 
@StartRow, @MaximumRows, @PackageID, @FilterValue, @ServerID, @Recursive

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				TempIdSet childPackages = null;
				try
				{
					IQueryable<Data.Entities.Domain> domainsFiltered;
					if (!recursive) domainsFiltered = Domains.Where(d => d.PackageId == packageId);
					else
					{
						childPackages = PackagesTree(packageId, true);
						domainsFiltered = Domains
							.Join(childPackages, d => d.PackageId, ch => ch, (d, ch) => d);
					}

					var domains = domainsFiltered
						.Where(d => !d.IsPreviewDomain && !d.IsDomainPointer &&
							(serverId == 0 ||
								d.Zone != null && d.Zone.Service != null &&
								d.Zone.Service.ServerId == serverId))
						.Select(d => new
						{
							d.DomainId,
							d.PackageId,
							d.ZoneItemId,
							d.DomainItemId,
							d.DomainName,
							d.HostingAllowed,
							WebSiteId = d.WebSite != null ? d.WebSite.ItemId : 0,
							WebSiteName = d.WebSite != null ? d.WebSite.ItemName : null,
							MailDomainId = d.MailDomain != null ? d.MailDomain.ItemId : 0,
							MailDomainName = d.MailDomain != null ? d.MailDomain.ItemName : null,
							d.IsSubDomain,
							d.IsPreviewDomain,
							d.IsDomainPointer,
							d.ExpirationDate,
							d.LastUpdateDate,
							d.RegistrarName,
							d.Package.PackageName,
							ServerId = serverId != 0 ? d.Zone.Service.Server.ServerId : 0,
							ServerName = serverId != 0 ? d.Zone.Service.Server.ServerName : "",
							ServerComments = serverId != 0 ? d.Zone.Service.Server.Comments : "",
							VirtualServer = serverId != 0 ?	d.Zone.Service.Server.VirtualServer : false,
							d.Package.UserId,
							d.Package.User.Username,
							d.Package.User.FirstName,
							d.Package.User.LastName,
							FullName = d.Package.User.FirstName + " " + d.Package.User.LastName,
							d.Package.User.RoleId,
							d.Package.User.Email
						});		

					if (!string.IsNullOrEmpty(filterValue))
					{
						if (!string.IsNullOrEmpty(filterColumn))
						{
							domains = domains.Where(DynamicFunctions.ColumnLike(domains, filterColumn, filterValue));
						}
						else
						{
#if NETFRAMEWORK
							domains = domains.Where(d => DbFunctions.Like(d.DomainName, filterValue) ||
								DbFunctions.Like(d.Username, filterValue) ||
								DbFunctions.Like(d.ServerName, filterValue) ||
								DbFunctions.Like(d.PackageName, filterValue));
#else
							domains = domains.Where(d => EF.Functions.Like(d.DomainName, filterValue) ||
								EF.Functions.Like(d.Username, filterValue) ||
								EF.Functions.Like(d.ServerName, filterValue) ||
								EF.Functions.Like(d.PackageName, filterValue));
#endif
						}
					}

					var count = domains.Count();

					if (!string.IsNullOrEmpty(sortColumn)) domains = domains.OrderBy(sortColumn);
					else domains = domains.OrderBy(d => d.DomainName);

					domains = domains.Skip(startRow).Take(maximumRows);

					return EntityDataSet(count, domains);
				} finally
				{
					childPackages?.Dispose();
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetDomainsPaged",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@serverId", serverId),
					new SqlParameter("@recursive", recursive),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("@MaximumRows", maximumRows));
			}
		}

		public IDataReader GetDomain(int actorId, int domainId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDomain]
(
	@ActorID int,
	@DomainID int
)
AS

SELECT
	D.DomainID,
	D.PackageID,
	D.ZoneItemID,
	D.DomainItemID,
	D.DomainName,
	D.HostingAllowed,
	ISNULL(WS.ItemID, 0) AS WebSiteID,
	WS.ItemName AS WebSiteName,
	ISNULL(MD.ItemID, 0) AS MailDomainID,
	MD.ItemName AS MailDomainName,
	Z.ItemName AS ZoneName,
	D.IsSubDomain,
	D.IsPreviewDomain,
	D.IsDomainPointer
FROM Domains AS D
INNER JOIN Packages AS P ON D.PackageID = P.PackageID
LEFT OUTER JOIN ServiceItems AS WS ON D.WebSiteID = WS.ItemID
LEFT OUTER JOIN ServiceItems AS MD ON D.MailDomainID = MD.ItemID
LEFT OUTER JOIN ServiceItems AS Z ON D.ZoneItemID = Z.ItemID
WHERE
	D.DomainID = @DomainID
	AND dbo.CheckActorPackageRights(@ActorID, P.PackageID) = 1
RETURN
				*/
				#endregion

				var domains = Domains
					.Where(d => d.DomainId == domainId)
					.Select(d => new
					{
						d.DomainId,
						d.PackageId,
						d.ZoneItemId,
						d.DomainItemId,
						d.DomainName,
						d.HostingAllowed,
						WebSiteId = d.WebSite != null ? d.WebSite.ItemId : 0,
						WebSiteName = d.WebSite != null ? d.WebSite.ItemName : null,
						MailDomainId = d.MailDomain != null ? d.MailDomain.ItemId : 0,
						MailDomainName = d.MailDomain != null ? d.MailDomain.ItemName : null,
						ZoneName = d.Zone != null ? d.Zone.ItemName : null,
						d.IsSubDomain,
						d.IsPreviewDomain,
						d.IsDomainPointer
					})
					.ToArray()
					.Where(d => CheckActorPackageRights(actorId, d.PackageId));
				return EntityDataReader(domains);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetDomain",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@domainId", domainId));
			}
		}

		public IDataReader GetDomainByName(int actorId, string domainName, bool searchOnDomainPointer, bool isDomainPointer)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDomainByName]
(
	@ActorID int,
	@DomainName nvarchar(100),
	@SearchOnDomainPointer bit,
	@IsDomainPointer bit
)
AS

IF (@SearchOnDomainPointer = 1)
BEGIN
	SELECT
		D.DomainID,
		D.PackageID,
		D.ZoneItemID,
		D.DomainItemID,
		D.DomainName,
		D.HostingAllowed,
		ISNULL(D.WebSiteID, 0) AS WebSiteID,
		WS.ItemName AS WebSiteName,
		ISNULL(D.MailDomainID, 0) AS MailDomainID,
		MD.ItemName AS MailDomainName,
		Z.ItemName AS ZoneName,
		D.IsSubDomain,
		D.IsPreviewDomain,
		D.IsDomainPointer
	FROM Domains AS D
	INNER JOIN Packages AS P ON D.PackageID = P.PackageID
	LEFT OUTER JOIN ServiceItems AS WS ON D.WebSiteID = WS.ItemID
	LEFT OUTER JOIN ServiceItems AS MD ON D.MailDomainID = MD.ItemID
	LEFT OUTER JOIN ServiceItems AS Z ON D.ZoneItemID = Z.ItemID
	WHERE
		D.DomainName = @DomainName
		AND D.IsDomainPointer = @IsDomainPointer
		AND dbo.CheckActorPackageRights(@ActorID, P.PackageID) = 1
	RETURN
END
ELSE
BEGIN
	SELECT
		D.DomainID,
		D.PackageID,
		D.ZoneItemID,
		D.DomainItemID,
		D.DomainName,
		D.HostingAllowed,
		ISNULL(D.WebSiteID, 0) AS WebSiteID,
		WS.ItemName AS WebSiteName,
		ISNULL(D.MailDomainID, 0) AS MailDomainID,
		MD.ItemName AS MailDomainName,
		Z.ItemName AS ZoneName,
		D.IsSubDomain,
		D.IsPreviewDomain,
		D.IsDomainPointer
	FROM Domains AS D
	INNER JOIN Packages AS P ON D.PackageID = P.PackageID
	LEFT OUTER JOIN ServiceItems AS WS ON D.WebSiteID = WS.ItemID
	LEFT OUTER JOIN ServiceItems AS MD ON D.MailDomainID = MD.ItemID
	LEFT OUTER JOIN ServiceItems AS Z ON D.ZoneItemID = Z.ItemID
	WHERE
		D.DomainName = @DomainName
		AND dbo.CheckActorPackageRights(@ActorID, P.PackageID) = 1
	RETURN
END
				*/
				#endregion

				var domains = Domains
					.Where(d => d.DomainName == domainName &&
						(!searchOnDomainPointer || d.IsDomainPointer == isDomainPointer))
					.Select(d => new
					{
						d.DomainId,
						d.PackageId,
						d.ZoneItemId,
						d.DomainItemId,
						d.DomainName,
						d.HostingAllowed,
						WebSiteId = d.WebSite != null ? d.WebSite.ItemId : 0,
						WebSiteName = d.WebSite != null ? d.WebSite.ItemName : null,
						MailDomainId = d.MailDomain != null ? d.MailDomain.ItemId : 0,
						MailDomainName = d.MailDomain != null ? d.MailDomain.ItemName : null,
						ZoneName = d.Zone != null ? d.Zone.ItemName : null,
						d.IsSubDomain,
						d.IsPreviewDomain,
						d.IsDomainPointer
					})
					.AsEnumerable()
					.Where(d => Local.CheckActorPackageRights(actorId, d.PackageId));
				return EntityDataReader(domains);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetDomainByName",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@domainName", domainName),
					new SqlParameter("@SearchOnDomainPointer", searchOnDomainPointer),
					new SqlParameter("@IsDomainPointer", isDomainPointer));
			}
		}


		public DataSet GetDomainsByZoneId(int actorId, int zoneId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDomainsByZoneID]
(
	@ActorID int,
	@ZoneID int
)
AS

SELECT
	D.DomainID,
	D.PackageID,
	D.ZoneItemID,
	D.DomainItemID,
	D.DomainName,
	D.HostingAllowed,
	ISNULL(D.WebSiteID, 0) AS WebSiteID,
	WS.ItemName AS WebSiteName,
	ISNULL(D.MailDomainID, 0) AS MailDomainID,
	MD.ItemName AS MailDomainName,
	Z.ItemName AS ZoneName,
	D.IsSubDomain,
	D.IsPreviewDomain,
	D.IsDomainPointer
FROM Domains AS D
INNER JOIN Packages AS P ON D.PackageID = P.PackageID
LEFT OUTER JOIN ServiceItems AS WS ON D.WebSiteID = WS.ItemID
LEFT OUTER JOIN ServiceItems AS MD ON D.MailDomainID = MD.ItemID
LEFT OUTER JOIN ServiceItems AS Z ON D.ZoneItemID = Z.ItemID
WHERE
	D.ZoneItemID = @ZoneID
	AND dbo.CheckActorPackageRights(@ActorID, P.PackageID) = 1
RETURN
				*/
				#endregion

				var domains = Domains
					.Where(d => d.ZoneItemId == zoneId)
					.Select(d => new
					{
						d.DomainId,
						d.PackageId,
						d.ZoneItemId,
						d.DomainItemId,
						d.DomainName,
						d.HostingAllowed,
						WebSiteId = d.WebSite != null ? d.WebSite.ItemId : 0,
						WebSiteName = d.WebSite != null ? d.WebSite.ItemName : null,
						MailDomainId = d.MailDomain != null ? d.MailDomain.ItemId : 0,
						MailDomainName = d.MailDomain != null ? d.MailDomain.ItemName : null,
						ZoneName = d.Zone != null ? d.Zone.ItemName : null,
						d.IsSubDomain,
						d.IsPreviewDomain,
						d.IsDomainPointer
					})
					.AsEnumerable()
					.Where(d => Local.CheckActorPackageRights(actorId, d.PackageId));
				return EntityDataSet(domains);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetDomainsByZoneID",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@ZoneID", zoneId));
			}
		}

		public DataSet GetDomainsByDomainItemId(int actorId, int domainId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDomainsByDomainItemID]
(
	@ActorID int,
	@DomainID int
)
AS

SELECT
	D.DomainID,
	D.PackageID,
	D.ZoneItemID,
	D.DomainItemID,
	D.DomainName,
	D.HostingAllowed,
	ISNULL(D.WebSiteID, 0) AS WebSiteID,
	WS.ItemName AS WebSiteName,
	ISNULL(D.MailDomainID, 0) AS MailDomainID,
	MD.ItemName AS MailDomainName,
	Z.ItemName AS ZoneName,
	D.IsSubDomain,
	D.IsPreviewDomain,
	D.IsDomainPointer
FROM Domains AS D
INNER JOIN Packages AS P ON D.PackageID = P.PackageID
LEFT OUTER JOIN ServiceItems AS WS ON D.WebSiteID = WS.ItemID
LEFT OUTER JOIN ServiceItems AS MD ON D.MailDomainID = MD.ItemID
LEFT OUTER JOIN ServiceItems AS Z ON D.ZoneItemID = Z.ItemID
WHERE
	D.DomainItemID = @DomainID
	AND dbo.CheckActorPackageRights(@ActorID, P.PackageID) = 1
RETURN
				*/
				#endregion

				var domains = Domains
					.Where(d => d.DomainItemId == domainId)
					.Select(d => new
					{
						d.DomainId,
						d.PackageId,
						d.ZoneItemId,
						d.DomainItemId,
						d.DomainName,
						d.HostingAllowed,
						WebSiteId = d.WebSite != null ? d.WebSite.ItemId : 0,
						WebSiteName = d.WebSite != null ? d.WebSite.ItemName : null,
						MailDomainId = d.MailDomain != null ? d.MailDomain.ItemId : 0,
						MailDomainName = d.MailDomain != null ? d.MailDomain.ItemName : null,
						ZoneName = d.Zone != null ? d.Zone.ItemName : null,
						d.IsSubDomain,
						d.IsPreviewDomain,
						d.IsDomainPointer
					})
					.AsEnumerable()
					.Where(d => Local.CheckActorPackageRights(actorId, d.PackageId));
				return EntityDataSet(domains);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetDomainsByDomainItemID",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@DomainID", domainId));
			}
		}



		public int CheckDomain(int packageId, string domainName, bool isDomainPointer)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckDomain]
(
	@PackageID int,
	@DomainName nvarchar(100),
	@IsDomainPointer bit,
	@Result int OUTPUT
)
AS

/*
@Result values:
	0 - OK
	-1 - already exists
	-2 - sub-domain of prohibited domain
*/ /*

SET @Result = 0 -- OK

-- check if the domain already exists
IF EXISTS(
	SELECT DomainID FROM Domains
	WHERE DomainName = @DomainName AND IsDomainPointer = @IsDomainPointer
)
BEGIN
	SET @Result = -1
	RETURN
END

--check if this is a sub - domain of other domain
-- that is not allowed for 3rd level hosting

DECLARE @UserID int
SELECT @UserID = UserID FROM Packages
WHERE PackageID = @PackageID

-- find sub - domains
DECLARE @DomainUserID int, @HostingAllowed bit
SELECT
	@DomainUserID = P.UserID,
	@HostingAllowed = D.HostingAllowed
FROM Domains AS D
INNER JOIN Packages AS P ON D.PackageID = P.PackageID
WHERE CHARINDEX('.' + DomainName, @DomainName) > 0
AND(CHARINDEX('.' + DomainName, @DomainName) + LEN('.' + DomainName)) = LEN(@DomainName) + 1
AND IsDomainPointer = 0

-- this is a domain of other user
IF @UserID<> @DomainUserID AND @HostingAllowed = 0
BEGIN
	SET @Result = -2
	RETURN
END

RETURN

				*/
				#endregion

				// check if the domain already exists
				if (Domains.Any(d => d.DomainName == domainName && d.IsDomainPointer == isDomainPointer)) return -1;

				// check if this is a sub-domain of other domain that is not allowed for 3rd level hosting
				var userId = Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => p.UserId)
					.FirstOrDefault();

				// find sub-domains
				var subdomains = Domains
					.Where(d => domainName.IndexOf("." + d.DomainName) >= 0 &&
						domainName.IndexOf("." + d.DomainName) + d.DomainName.Length + 1 == domainName.Length + 1 &&
						!d.IsDomainPointer)
					.Join(Packages, d => d.PackageId, p => p.PackageId, (d, p) => new
					{
						p.UserId,
						d.HostingAllowed
					});

				if (subdomains.Any(d => d.UserId != userId && !d.HostingAllowed)) return -2;

				return 0;
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@Result", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "CheckDomain",
					prmId,
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@domainName", domainName),
					new SqlParameter("@isDomainPointer", isDomainPointer));

				return Convert.ToInt32(prmId.Value);
			}
		}



		public int CheckDomainUsedByHostedOrganization(string domainName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckDomainUsedByHostedOrganization] 
	@DomainName nvarchar(100),
	@Result int OUTPUT
AS
	SET @Result = 0
	IF EXISTS(SELECT 1 FROM ExchangeAccounts WHERE UserPrincipalName LIKE '%@'+ @DomainName AND AccountType!=2)
	BEGIN
		SET @Result = 1
	END
	ELSE
	IF EXISTS(SELECT 1 FROM ExchangeAccountEmailAddresses WHERE EmailAddress LIKE '%@'+ @DomainName)
	BEGIN
		SET @Result = 1
	END
	ELSE
	IF EXISTS(SELECT 1 FROM LyncUsers WHERE SipAddress LIKE '%@'+ @DomainName)
	BEGIN
		SET @Result = 1
	END
	ELSE
	IF EXISTS(SELECT 1 FROM SfBUsers WHERE SipAddress LIKE '%@'+ @DomainName)
	BEGIN
		SET @Result = 1
	END

	RETURN @Result
				*/
				#endregion

				var mailDomain = $"@{domainName}";

				if (ExchangeAccounts.Any(a => a.UserPrincipalName.EndsWith(mailDomain)) ||
					ExchangeAccountEmailAddresses.Any(e => e.EmailAddress.EndsWith(mailDomain)) ||
					LyncUsers.Any(u => u.SipAddress.EndsWith(mailDomain)) ||
					SfBUsers.Any(u => u.SipAddress.EndsWith(mailDomain))) return 1;
				else return 0;

			}
			else
			{
				SqlParameter prmId = new SqlParameter("@Result", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "CheckDomainUsedByHostedOrganization",
					prmId,
					new SqlParameter("@domainName", domainName));

				return Convert.ToInt32(prmId.Value);
			}
		}


		public int AddDomain(int actorId, int packageId, int zoneItemId, string domainName,
			 bool hostingAllowed, int webSiteId, int mailDomainId, bool isSubDomain, bool isPreviewDomain, bool isDomainPointer)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddDomain]
(
	@DomainID int OUTPUT,
	@ActorID int,
	@PackageID int,
	@ZoneItemID int,
	@DomainName nvarchar(200),
	@HostingAllowed bit,
	@WebSiteID int,
	@MailDomainID int,
	@IsSubDomain bit,
	@IsPreviewDomain bit,
	@IsDomainPointer bit
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

IF @ZoneItemID = 0 SET @ZoneItemID = NULL
IF @WebSiteID = 0 SET @WebSiteID = NULL
IF @MailDomainID = 0 SET @MailDomainID = NULL

-- insert record
INSERT INTO Domains
(
	PackageID,
	ZoneItemID,
	DomainName,
	HostingAllowed,
	WebSiteID,
	MailDomainID,
	IsSubDomain,
	IsPreviewDomain,
	IsDomainPointer
)
VALUES
(
	@PackageID,
	@ZoneItemID,
	@DomainName,
	@HostingAllowed,
	@WebSiteID,
	@MailDomainID,
	@IsSubDomain,
	@IsPreviewDomain,
	@IsDomainPointer
)

SET @DomainID = SCOPE_IDENTITY()
RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var domain = new Data.Entities.Domain()
				{
					PackageId = packageId,
					ZoneItemId = zoneItemId != 0 ? zoneItemId : null,
					DomainName = domainName,
					HostingAllowed = hostingAllowed,
					WebSiteId = webSiteId != 0 ? webSiteId : null,
					MailDomainId = mailDomainId != 0 ? mailDomainId : null,
					IsSubDomain = isSubDomain,
					IsPreviewDomain = isPreviewDomain,
					IsDomainPointer = isDomainPointer
				};

				Domains.Add(domain);

				SaveChanges();

				return domain.DomainId;
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@DomainID", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddDomain",
					prmId,
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@ZoneItemId", zoneItemId),
					new SqlParameter("@DomainName", domainName),
					new SqlParameter("@HostingAllowed", hostingAllowed),
					new SqlParameter("@WebSiteId", webSiteId),
					new SqlParameter("@MailDomainId", mailDomainId),
					new SqlParameter("@IsSubDomain", isSubDomain),
					new SqlParameter("@IsPreviewDomain", isPreviewDomain),
					new SqlParameter("@IsDomainPointer", isDomainPointer));

				return Convert.ToInt32(prmId.Value);
			}
		}

		public void UpdateDomain(int actorId, int domainId, int zoneItemId,
			 bool hostingAllowed, int webSiteId, int mailDomainId, int domainItemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateDomain]
(
	@DomainID int,
	@ActorID int,
	@ZoneItemID int,
	@HostingAllowed bit,
	@WebSiteID int,
	@MailDomainID int,
	@DomainItemID int
)
AS

-- check rights
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM Domains
WHERE DomainID = @DomainID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

IF @ZoneItemID = 0 SET @ZoneItemID = NULL
IF @WebSiteID = 0 SET @WebSiteID = NULL
IF @MailDomainID = 0 SET @MailDomainID = NULL

-- update record
UPDATE Domains
SET
	ZoneItemID = @ZoneItemID,
	HostingAllowed = @HostingAllowed,
	WebSiteID = @WebSiteID,
	MailDomainID = @MailDomainID,
	DomainItemID = @DomainItemID
WHERE
	DomainID = @DomainID
	RETURN
				*/
				#endregion

				var domain = Domains.FirstOrDefault(d => d.DomainId == domainId);
				if (domain == null) return;

				if (!CheckActorPackageRights(actorId, domain.PackageId))
					throw new AccessViolationException("You are not allowed to access this package");

				domain.ZoneItemId = zoneItemId != 0 ? zoneItemId : null;
				domain.HostingAllowed = hostingAllowed;
				domain.WebSiteId = webSiteId != 0 ? webSiteId : null;
				domain.MailDomainId = mailDomainId != 0 ? mailDomainId : null;
				domain.DomainItemId = domainItemId;

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateDomain",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@DomainId", domainId),
					new SqlParameter("@ZoneItemId", zoneItemId),
					new SqlParameter("@HostingAllowed", hostingAllowed),
					new SqlParameter("@WebSiteId", webSiteId),
					new SqlParameter("@MailDomainId", mailDomainId),
					new SqlParameter("@DomainItemId", domainItemId));
			}
		}

		public void DeleteDomain(int actorId, int domainId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteDomain]
(
	@DomainID int,
	@ActorID int
)
AS

-- check rights
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM Domains
WHERE DomainID = @DomainID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)
DELETE FROM Domains
WHERE DomainID = @DomainID

RETURN
				*/
				#endregion

				var domain = Domains.FirstOrDefault(d => d.DomainId == domainId);
				if (domain == null) return;

				if (!CheckActorPackageRights(actorId, domain.PackageId))
					throw new AccessViolationException("You are not allowed to access this package");

				Domains.Remove(domain);

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteDomain",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@DomainId", domainId));
			}
		}
#endregion

		#region Services
		public IDataReader GetServicesByServerId(int actorId, int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServicesByServerID]
(
	@ActorID int,
	@ServerID int
)
AS

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
	S.ServiceID,
	S.ServerID,
	S.ServiceName,
	S.Comments,
	S.ServiceQuotaValue,
	RG.GroupName,
	S.ProviderID,
	PROV.DisplayName AS ProviderName
FROM Services AS S
INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
INNER JOIN ResourceGroups AS RG ON PROV.GroupID = RG.GroupID
WHERE
	S.ServerID = @ServerID
	AND @IsAdmin = 1
ORDER BY RG.GroupOrder

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var services = Services
					.Where(s => isAdmin && s.ServerId == serverId)
					.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => new
					{
						Service = s,
						Provider = p
					})
					.Join(ResourceGroups, s => s.Provider.GroupId, r => r.GroupId, (s, r) => new
					{
						s.Service,
						s.Provider,
						ResourceGroup = r
					})
					.OrderBy(s => s.ResourceGroup.GroupOrder)
					.Select(s => new
					{
						s.Service.ServiceId,
						s.Service.ServerId,
						s.Service.ServiceName,
						s.Service.Comments,
						s.Service.ServiceQuotaValue,
						s.ResourceGroup.GroupName,
						s.Service.ProviderId,
						ProviderName = s.Provider.DisplayName
					});

				return EntityDataReader(services);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServicesByServerID",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@ServerID", serverId));
			}
		}

		public IDataReader GetServicesByServerIdGroupName(int actorId, int serverId, string groupName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServicesByServerIDGroupName]
(
	@ActorID int,
	@ServerID int,
	@GroupName nvarchar(50)
)
AS

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
	S.ServiceID,
	S.ServerID,
	S.ServiceName,
	S.Comments,
	S.ServiceQuotaValue,
	RG.GroupName,
	PROV.DisplayName AS ProviderName
FROM Services AS S
INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
INNER JOIN ResourceGroups AS RG ON PROV.GroupID = RG.GroupID
WHERE
	S.ServerID = @ServerID AND RG.GroupName = @GroupName
	AND @IsAdmin = 1
ORDER BY RG.GroupOrder

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var services = Services
					.Where(s => isAdmin && s.ServerId == serverId)
					.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => new
					{
						Service = s,
						Provider = p
					})
					.Join(ResourceGroups, s => s.Provider.GroupId, r => r.GroupId, (s, r) => new
					{
						s.Service.ServiceId,
						s.Service.ServerId,
						s.Service.ServiceName,
						s.Service.Comments,
						s.Service.ServiceQuotaValue,
						r.GroupName,
						ProviderName = s.Provider.DisplayName
					})
					.Where(s => s.GroupName == groupName);

				return EntityDataReader(services);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServicesByServerIDGroupName",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@ServerID", serverId),
					new SqlParameter("@GroupName", groupName));
			}
		}

		public DataSet GetRawServicesByServerId(int actorId, int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRawServicesByServerID]
(
	@ActorID int,
	@ServerID int
)
AS

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

-- resource groups
SELECT
	GroupID,
	GroupName
FROM ResourceGroups
WHERE @IsAdmin = 1 AND (ShowGroup = 1)
ORDER BY GroupOrder

-- services
SELECT
	S.ServiceID,
	S.ServerID,
	S.ServiceName,
	S.Comments,
	RG.GroupID,
	PROV.DisplayName AS ProviderName
FROM Services AS S
INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
INNER JOIN ResourceGroups AS RG ON PROV.GroupID = RG.GroupID
WHERE
	S.ServerID = @ServerID
	AND @IsAdmin = 1
ORDER BY RG.GroupOrder

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var groups = ResourceGroups
					.Where(g => isAdmin && g.ShowGroup == true)
					.OrderBy(g => g.GroupOrder)
					.Select(g => new { g.GroupId, g.GroupName });

				var services = Services
					.Where(s => isAdmin && s.ServerId == serverId)
					.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => new
					{
						Service = s,
						Provider = p
					})
					.Join(ResourceGroups, s => s.Provider.GroupId, r => r.GroupId, (s, r) => new
					{
						s.Service.ServiceId,
						s.Service.ServerId,
						s.Service.ServiceName,
						s.Service.Comments,
						r.GroupId,
						ProviderName = s.Provider.DisplayName
					});

				return EntityDataSet(groups, services);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetRawServicesByServerID",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@ServerID", serverId));
			}
		}

		public DataSet GetServicesByGroupId(int actorId, int groupId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServicesByGroupID]
(
	@ActorID int,
	@GroupID int
)
AS
-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
	S.ServiceID,
	S.ServiceName,
	S.ServerID,
	S.ServiceQuotaValue,
	SRV.ServerName,
	S.ProviderID,
	S.ServiceName+' on '+SRV.ServerName AS FullServiceName
FROM Services AS S
INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
WHERE
	PROV.GroupID = @GroupID
	AND @IsAdmin = 1
RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var services = Services
					.Where(s => isAdmin)
					.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => new
					{
						Service = s,
						Provider = p
					})
					.Where(s => s.Provider.GroupId == groupId)
					.Join(Servers, s => s.Service.ServerId, s => s.ServerId, (s, t) => new
					{
						s.Service.ServiceId,
						s.Service.ServiceName,
						s.Service.ServerId,
						s.Service.ServiceQuotaValue,
						t.ServerName,
						s.Service.ProviderId,
						FullServiceName = s.Service.ServiceName + " on " + t.ServerName
					});

				return EntityDataSet(services);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServicesByGroupID",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@groupId", groupId));
			}
		}

		public DataSet GetServicesByGroupName(int actorId, string groupName, bool forAutodiscover)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServicesByGroupName]
(
	@ActorID int,
	@GroupName nvarchar(100),
	@forAutodiscover bit
)
AS
-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

SELECT
	S.ServiceID,
	S.ServiceName,
	S.ServerID,
	S.ServiceQuotaValue,
	SRV.ServerName,
	S.ProviderID,
    PROV.ProviderName,
	S.ServiceName + ' on ' + SRV.ServerName AS FullServiceName
FROM Services AS S
INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
INNER JOIN ResourceGroups AS RG ON PROV.GroupID = RG.GroupID
WHERE
	RG.GroupName = @GroupName
	AND (@IsAdmin = 1 OR @forAutodiscover = 1)
RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				var services = Services
					.Where(s => isAdmin)
					.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => new
					{
						Service = s,
						Provider = p
					})
					.Join(Servers, s => s.Service.ServerId, t => t.ServerId, (s, t) => new
					{
						s.Service,
						s.Provider,
						Server = t
					})
					.Join(ResourceGroups, s => s.Provider.GroupId, r => r.GroupId, (s, r) => new
					{
						s.Service,
						s.Provider,
						s.Server,
						ResourceGroup = r
					})
					.Where(s => s.ResourceGroup.GroupName == groupName)
					.Select(s => new
					{
						s.Service.ServiceId,
						s.Service.ServiceName,
						s.Service.ServerId,
						s.Service.ServiceQuotaValue,
						s.Server.ServerName,
						s.Service.ProviderId,
						s.Provider.ProviderName,
						FullServiceName = s.Service.ServiceName + " on " + s.Server.ServerName
					});

				return EntityDataSet(services);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServicesByGroupName",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@GroupName", groupName),
					new SqlParameter("@forAutodiscover", forAutodiscover));
			}
		}

		public IDataReader GetService(int actorId, int serviceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetService]
(
	@ActorID int,
	@ServiceID int
)
AS

SELECT
	ServiceID,
	Services.ServerID,
	ProviderID,
	ServiceName,
	ServiceQuotaValue,
	ClusterID,
	Services.Comments,
	Servers.ServerName
FROM Services INNER JOIN Servers ON Services.ServerID = Servers.ServerID
WHERE
	ServiceID = @ServiceID

RETURN
				*/
				#endregion

				var services = Services
					.Where(s => s.ServiceId == serviceId)
					.Join(Servers, s => s.ServerId, t => t.ServerId, (s, t) => new
					{
						s.ServiceId,
						s.ServerId,
						s.ProviderId,
						s.ServiceName,
						s.ServiceQuotaValue,
						s.ClusterId,
						s.Comments,
						t.ServerName
					});

				return EntityDataReader(services);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString,
					CommandType.StoredProcedure,
					ObjectQualifier + "GetService",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@ServiceID", serviceId));
			}
		}

		public int AddService(int serverId, int providerId, string serviceName, int serviceQuotaValue,
			 int clusterId, string comments)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddService]
(
	@ServiceID int OUTPUT,
	@ServerID int,
	@ProviderID int,
	@ServiceQuotaValue int,
	@ServiceName nvarchar(50),
	@ClusterID int,
	@Comments ntext
)
AS
BEGIN

BEGIN TRAN
IF @ClusterID = 0 SET @ClusterID = NULL

INSERT INTO Services
(
	ServerID,
	ProviderID,
	ServiceName,
	ServiceQuotaValue,
	ClusterID,
	Comments
)
VALUES
(
	@ServerID,
	@ProviderID,
	@ServiceName,
	@ServiceQuotaValue,
	@ClusterID,
	@Comments
)

SET @ServiceID = SCOPE_IDENTITY()

-- copy default service settings
INSERT INTO ServiceProperties (ServiceID, PropertyName, PropertyValue)
SELECT @ServiceID, PropertyName, PropertyValue
FROM ServiceDefaultProperties
WHERE ProviderID = @ProviderID

-- copy all default DNS records for the given service
DECLARE @GroupID int
SELECT @GroupID = GroupID FROM Providers
WHERE ProviderID = @ProviderID

-- default IP address for added records
DECLARE @AddressID int
SELECT TOP 1 @AddressID = AddressID FROM IPAddresses
WHERE ServerID = @ServerID

INSERT INTO GlobalDnsRecords
(
	RecordType,
	RecordName,
	RecordData,
	MXPriority,
	IPAddressID,
	ServiceID,
	ServerID,
	PackageID
)
SELECT
	RecordType,
	RecordName,
	CASE WHEN RecordData = '[ip]' THEN ''
	ELSE RecordData END,
	MXPriority,
	CASE WHEN RecordData = '[ip]' THEN @AddressID
	ELSE NULL END,
	@ServiceID,
	NULL, -- server
	NULL -- package
FROM
	ResourceGroupDnsRecords
WHERE GroupID = @GroupID
ORDER BY RecordOrder
COMMIT TRAN

END
RETURN
				*/
				#endregion

				int serviceId = 0;

				using (var transaction = Database.BeginTransaction())
				{
					var service = new Data.Entities.Service()
					{
						ServerId = serverId,
						ProviderId = providerId,
						ServiceName = serviceName,
						ServiceQuotaValue = serviceQuotaValue,
						ClusterId = clusterId != 0 ? clusterId : null,
						Comments = comments
					};
					Services.Add(service);
					SaveChanges();

					serviceId = service.ServiceId;

					// copy default service settings
					var properties = ServiceDefaultProperties
						.Where(p => p.ProviderId == providerId)
						.AsEnumerable()
						.Select(p => new Data.Entities.ServiceProperty
						{
							ServiceId = serviceId,
							PropertyName = p.PropertyName,
							PropertyValue = p.PropertyValue
						});
					ServiceProperties.AddRange(properties);

					// copy all default DNS records for the given service
					var groupId = Providers
						.Where(p => p.ProviderId == providerId)
						.Select(p => p.GroupId)
						.FirstOrDefault();

					// default IP address for added records
					var addressId = IpAddresses
						.Where(ip => ip.ServerId == serverId)
						.Select(ip => ip.AddressId)
						.FirstOrDefault();

					var dnsRecords = ResourceGroupDnsRecords
						.Where(r => r.GroupId == groupId)
						.OrderBy(r => r.RecordOrder)
						.AsEnumerable()
						.Select(r => new Data.Entities.GlobalDnsRecord
						{
							RecordType = r.RecordType,
							RecordName = r.RecordName,
							RecordData = r.RecordData == "[ip]" ? "" : r.RecordData,
							MXPriority = r.MXPriority ?? 0,
							IpAddressId = r.RecordData == "[ip]" ? addressId : null,
							ServiceId = serviceId,
							ServerId = null,
							PackageId = null
						});
					GlobalDnsRecords.AddRange(dnsRecords);
					SaveChanges();

					transaction.Commit();
				}

				return serviceId;
			}
			else
			{
				SqlParameter prmServiceId = new SqlParameter("@ServiceID", SqlDbType.Int);
				prmServiceId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddService",
					prmServiceId,
					new SqlParameter("@ServerID", serverId),
					new SqlParameter("@ProviderID", providerId),
					new SqlParameter("@ServiceName", serviceName),
					new SqlParameter("@ServiceQuotaValue", serviceQuotaValue),
					new SqlParameter("@ClusterId", clusterId),
					new SqlParameter("@comments", comments));

				UpdateServerPackageServices(serverId);

				return Convert.ToInt32(prmServiceId.Value);
			}
		}

		public void UpdateServiceFully(int serviceId, int providerId, string serviceName, int serviceQuotaValue,
			 int clusterId, string comments)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateServiceFully]
(
	@ServiceID int,
	@ProviderID int,
	@ServiceName nvarchar(50),
	@Comments ntext,
	@ServiceQuotaValue int,
	@ClusterID int
)
AS

IF @ClusterID = 0 SET @ClusterID = NULL

UPDATE Services
SET
	ProviderID = @ProviderID,
	ServiceName = @ServiceName,
	ServiceQuotaValue = @ServiceQuotaValue,
	Comments = @Comments,
	ClusterID = @ClusterID
WHERE ServiceID = @ServiceID

RETURN
				*/
				#endregion

				var service = Services
					.FirstOrDefault(s => s.ServiceId == serviceId);

				if (service != null)
				{
					service.ProviderId = providerId;
					service.ServiceName = serviceName;
					service.ServiceQuotaValue = serviceQuotaValue;
					service.Comments = comments;
					service.ClusterId = clusterId != 0 ? clusterId : null;

					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateServiceFully",
					new SqlParameter("@ProviderID", providerId),
					new SqlParameter("@ServiceName", serviceName),
					new SqlParameter("@ServiceID", serviceId),
					new SqlParameter("@ServiceQuotaValue", serviceQuotaValue),
					new SqlParameter("@ClusterId", clusterId),
					new SqlParameter("@Comments", comments));
			}
		}

		public void UpdateService(int serviceId, string serviceName, int serviceQuotaValue,
			 int clusterId, string comments)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateService]
(
	@ServiceID int,
	@ServiceName nvarchar(50),
	@Comments ntext,
	@ServiceQuotaValue int,
	@ClusterID int
)
AS

IF @ClusterID = 0 SET @ClusterID = NULL

UPDATE Services
SET
	ServiceName = @ServiceName,
	ServiceQuotaValue = @ServiceQuotaValue,
	Comments = @Comments,
	ClusterID = @ClusterID
WHERE ServiceID = @ServiceID

RETURN
				*/
				#endregion

				var service = Services
					.FirstOrDefault(s => s.ServiceId == serviceId);

				if (service != null)
				{
					service.ServiceName = serviceName;
					service.ServiceQuotaValue = serviceQuotaValue;
					service.Comments = comments;
					service.ClusterId = clusterId != 0 ? clusterId : null;

					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateService",
					new SqlParameter("@ServiceName", serviceName),
					new SqlParameter("@ServiceID", serviceId),
					new SqlParameter("@ServiceQuotaValue", serviceQuotaValue),
					new SqlParameter("@ClusterId", clusterId),
					new SqlParameter("@Comments", comments));
			}
		}

		public int DeleteService(int serviceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteService]
(
	@ServiceID int,
	@Result int OUTPUT
)
AS

SET @Result = 0

-- check related service items
IF EXISTS (SELECT ItemID FROM ServiceItems WHERE ServiceID = @ServiceID)
BEGIN
	SET @Result = -1
	RETURN
END

IF EXISTS (SELECT ServiceID FROM VirtualServices WHERE ServiceID = @ServiceID)
BEGIN
	SET @Result = -2
	RETURN
END

BEGIN TRAN
-- delete global DNS records
DELETE FROM GlobalDnsRecords
WHERE ServiceID = @ServiceID

-- delete service
DELETE FROM Services
WHERE ServiceID = @ServiceID

COMMIT TRAN

RETURN
				*/
				#endregion

				// check related service items
				if (ServiceItems.Any(s => s.ServiceId == serviceId)) return -1;
				if (VirtualServices.Any(s => s.ServiceId == serviceId)) return -2;

				using (var transaction = Database.BeginTransaction())
				{
					GlobalDnsRecords.Where(r => r.ServiceId == serviceId).ExecuteDelete();
					Services.Where(s => s.ServiceId == serviceId).ExecuteDelete();

					transaction.Commit();
					return 0;
				}
			}
			else
			{
				SqlParameter prmResult = new SqlParameter("@Result", SqlDbType.Int);
				prmResult.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteService",
					prmResult,
					new SqlParameter("@ServiceID", serviceId));

				return Convert.ToInt32(prmResult.Value);
			}
		}

		public IDataReader GetServiceProperties(int actorId, int serviceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceProperties]
(
	@ActorID int,
	@ServiceID int
)
AS

SELECT ServiceID, PropertyName, PropertyValue
FROM ServiceProperties
WHERE
	ServiceID = @ServiceID

RETURN
				*/
				#endregion

				var properties = ServiceProperties
					.Where(s => s.ServiceId == serviceId);

				return EntityDataReader(properties);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString,
					CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceProperties",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@ServiceID", serviceId));
			}
		}

		public void UpdateServiceProperties(int serviceId, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateServiceProperties]
(
	@ServiceID int,
	@Xml ntext
)
AS

-- delete old properties
BEGIN TRAN
DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

-- Execute a SELECT statement that uses the OPENXML rowset provider.
DELETE FROM ServiceProperties
WHERE ServiceID = @ServiceID 
AND PropertyName IN
(
	SELECT PropertyName
	FROM OPENXML(@idoc, '/properties/property', 1)
	WITH (PropertyName nvarchar(50) '@name')
)

INSERT INTO ServiceProperties
(
	ServiceID,
	PropertyName,
	PropertyValue
)
SELECT
	@ServiceID,
	PropertyName,
	PropertyValue
FROM OPENXML(@idoc, '/properties/property',1) WITH 
(
	PropertyName nvarchar(50) '@name',
	PropertyValue nvarchar(MAX) '@value'
) as PV

-- remove document
exec sp_xml_removedocument @idoc

COMMIT TRAN
RETURN 
				*/
				#endregion

				var properties = XElement.Parse(xml)
					.Elements()
					.Select(e => new Data.Entities.ServiceProperty
					{
						ServiceId = serviceId,
						PropertyName = (string)e.Attribute("name"),
						PropertyValue = (string)e.Attribute("value")
					})
					.ToArray();
				var propertyNames = properties
					.Select(p => p.PropertyName)
					.ToArray();

				// delete old properties
				var serviceProperties = ServiceProperties
					.Where(s => s.ServiceId == serviceId && propertyNames.Contains(s.PropertyName));
				ServiceProperties.RemoveRange(serviceProperties);

				ServiceProperties.AddRange(properties);

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateServiceProperties",
					new SqlParameter("@ServiceId", serviceId),
					new SqlParameter("@Xml", xml));
			}
		}

		public IDataReader GetResourceGroup(int groupId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetResourceGroup]
(
	@GroupID int
)
AS
SELECT
	RG.GroupID,
	RG.GroupOrder,
	RG.GroupName,
	RG.GroupController
FROM ResourceGroups AS RG
WHERE RG.GroupID = @GroupID

RETURN
				*/
				#endregion

				var groups = ResourceGroups
					.Where(g => g.GroupId == groupId)
					.Select(g => new
					{
						g.GroupId,
						g.GroupOrder,
						g.GroupName,
						g.GroupController
					});

				return EntityDataReader(groups);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString,
					CommandType.StoredProcedure,
					ObjectQualifier + "GetResourceGroup",
					new SqlParameter("@groupId", groupId));
			}
		}

		public DataSet GetResourceGroups()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetResourceGroups]
AS
SELECT
	GroupID,
	GroupName,
	GroupController
FROM ResourceGroups
ORDER BY GroupOrder
RETURN
				*/
				#endregion

				var groups = ResourceGroups
					.OrderBy(g => g.GroupOrder)
					.Select(g => new
					{
						g.GroupId,
						g.GroupName,
						g.GroupController
					});

				return EntityDataSet(groups);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString,
					CommandType.StoredProcedure,
					ObjectQualifier + "GetResourceGroups");
			}
		}

		public IDataReader GetResourceGroupByName(string groupName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetResourceGroupByName]
(
	@GroupName nvarchar(100)
)
AS
SELECT
	RG.GroupID,
	RG.GroupOrder,
	RG.GroupName,
	RG.GroupController
FROM ResourceGroups AS RG
WHERE RG.GroupName = @GroupName
				*/
				#endregion

				var group = ResourceGroups
					.Where(g => g.GroupName == groupName)
					.Select(g => new
					{
						g.GroupId,
						g.GroupOrder,
						g.GroupName,
						g.GroupController
					});
				return EntityDataReader(group);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString,
					CommandType.StoredProcedure,
					ObjectQualifier + "GetResourceGroupByName",
					new SqlParameter("@groupName", groupName));
			}
		}

		#endregion

		#region Service Items
		public DataSet GetServiceItems(int actorId, int packageId, string groupName, string itemTypeName, bool recursive)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItems]
(
	@ActorID int,
	@PackageID int,
	@ItemTypeName nvarchar(200),
	@GroupName nvarchar(100) = NULL,
	@Recursive bit
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @Items TABLE
(
	ItemID int
)

-- find service items
INSERT INTO @Items
SELECT
	SI.ItemID
FROM ServiceItems AS SI
INNER JOIN PackagesTree(@PackageID, @Recursive) AS PT ON SI.PackageID = PT.PackageID
INNER JOIN ServiceItemTypes AS IT ON SI.ItemTypeID = IT.ItemTypeID
INNER JOIN ResourceGroups AS RG ON IT.GroupID = RG.GroupID
WHERE IT.TypeName = @ItemTypeName
AND ((@GroupName IS NULL) OR (@GroupName IS NOT NULL AND RG.GroupName = @GroupName))

-- select service items
SELECT
	SI.ItemID,
	SI.ItemName,
	SI.ItemTypeID,
	SIT.TypeName,
	SI.ServiceID,
	SI.PackageID,
	P.PackageName,
	S.ServiceID,
	S.ServiceName,
	SRV.ServerID,
	SRV.ServerName,
	RG.GroupName,
	U.UserID,
	U.Username,
	(U.FirstName + U.LastName) AS UserFullName,
	SI.CreatedDate
FROM @Items AS FI
INNER JOIN ServiceItems AS SI ON FI.ItemID = SI.ItemID
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
INNER JOIN ResourceGroups AS RG ON SIT.GroupID = RG.GroupID
INNER JOIN Users AS U ON P.UserID = U.UserID

-- select item properties
-- get corresponding item properties
SELECT
	IP.ItemID,
	IP.PropertyName,
	IP.PropertyValue
FROM ServiceItemProperties AS IP
INNER JOIN @Items AS FI ON IP.ItemID = FI.ItemID

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var tree = PackagesTree(packageId, recursive))
				{
					var items = ServiceItems
						.Join(tree, s => s.PackageId, p => p, (s, p) => s)
						.Join(ServiceItemTypes, s => s.ItemTypeId, t => t.ItemTypeId, (s, t) => new
						{
							Item = s,
							Type = t
						})
						.Join(ResourceGroups, s => s.Type.GroupId, r => r.GroupId, (s, r) => new
						{
							s.Item,
							s.Type,
							ResourceGroup = r
						})
						.Where(s => s.Type.TypeName == itemTypeName &&
							(groupName == null || groupName != null && groupName == s.ResourceGroup.GroupName))
						.Select(s => s.Item.ItemId)
						.ToArray();

					// select service items
					var serviceItems = items
						.Join(ServiceItems, i => i, s => s.ItemId, (i, s) => s)
						.Join(ServiceItemTypes, s => s.ItemTypeId, t => t.ItemTypeId, (s, t) => new
						{
							Item = s,
							Type = t
						})
						.Join(Packages, s => s.Item.PackageId, p => p.PackageId, (s, p) => new
						{
							s.Item,
							s.Type,
							Package = p
						})
						.Join(Services, s => s.Item.ServiceId, s => s.ServiceId, (s, t) => new
						{
							s.Item,
							s.Type,
							s.Package,
							Service = t
						})
						.Join(Servers, s => s.Service.ServerId, t => t.ServerId, (s, t) => new
						{
							s.Item,
							s.Type,
							s.Package,
							s.Service,
							Server = t
						})
						.Join(ResourceGroups, s => s.Type.GroupId, r => r.GroupId, (s, r) => new
						{
							s.Item,
							s.Type,
							s.Package,
							s.Service,
							s.Server,
							ResourceGroup = r
						})
						.Join(Users, s => s.Package.UserId, u => u.UserId, (s, u) => new
						{
							s.Item.ItemId,
							s.Item.ItemName,
							s.Item.ItemTypeId,
							s.Type.TypeName,
							s.Item.ServiceId,
							s.Item.PackageId,
							s.Package.PackageName,
							s.Service.ServiceName,
							s.Server.ServerId,
							s.Server.ServerName,
							s.ResourceGroup.GroupName,
							u.UserId,
							u.Username,
							UserFullName = u.FirstName + " " + u.LastName,
							s.Item.CreatedDate
						});

					// select item properties
					// get corresponding item properties
					var itemProperties = ServiceItemProperties
						.Join(items, p => p.ItemId, i => i, (p, i) => new
						{
							p.ItemId,
							p.PropertyName,
							p.PropertyValue
						});

					return EntityDataSet(serviceItems, itemProperties);
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceItems",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@GroupName", groupName),
					new SqlParameter("@ItemTypeName", itemTypeName),
					new SqlParameter("@Recursive", recursive));
			}
		}

		public DataSet GetServiceItemsPaged(int actorId, int packageId, string groupName, string itemTypeName,
			int serverId, bool recursive, string filterColumn, string filterValue,
			string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItemsPaged]
(
	@ActorID int,
	@PackageID int,
	@ItemTypeName nvarchar(200),
	@GroupName nvarchar(100) = NULL,
	@ServerID int,
	@Recursive bit,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- start
DECLARE @GroupID int
SELECT @GroupID = GroupID FROM ResourceGroups
WHERE GroupName = @GroupName

DECLARE @ItemTypeID int
SELECT @ItemTypeID = ItemTypeID FROM ServiceItemTypes
WHERE TypeName = @ItemTypeName
AND ((@GroupID IS NULL) OR (@GroupID IS NOT NULL AND GroupID = @GroupID))

DECLARE @condition nvarchar(700)
SET @condition = 'SI.ItemTypeID = @ItemTypeID
AND ((@Recursive = 0 AND P.PackageID = @PackageID)
		OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, P.PackageID) = 1))
AND ((@GroupID IS NULL) OR (@GroupID IS NOT NULL AND IT.GroupID = @GroupID))
AND (@ServerID = 0 OR (@ServerID > 0 AND S.ServerID = @ServerID))
'

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
	IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
		SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
	ELSE
		SET @condition = @condition + '
			AND (ItemName LIKE ''' + @FilterValue + '''
			OR Username LIKE ''' + @FilterValue + '''
			OR FullName LIKE ''' + @FilterValue + '''
			OR Email LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'SI.ItemName ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(SI.ItemID) FROM Packages AS P
INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
INNER JOIN ServiceItemTypes AS IT ON SI.ItemTypeID = IT.ItemTypeID
INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
WHERE ' + @condition + '

DECLARE @Items AS TABLE
(
	ItemID int
);

WITH TempItems AS (
	SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
		SI.ItemID
	FROM Packages AS P
	INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
	INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
	INNER JOIN ServiceItemTypes AS IT ON SI.ItemTypeID = IT.ItemTypeID
	INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
	INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
	WHERE ' + @condition + '
)

INSERT INTO @Items
SELECT ItemID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
	SI.ItemID,
	SI.ItemName,
	SI.ItemTypeID,
	IT.TypeName,
	SI.ServiceID,
	SI.PackageID,
	SI.CreatedDate,
	RG.GroupName,

	-- packages
	P.PackageName,

	-- server
	ISNULL(SRV.ServerID, 0) AS ServerID,
	ISNULL(SRV.ServerName, '''') AS ServerName,
	ISNULL(SRV.Comments, '''') AS ServerComments,
	ISNULL(SRV.VirtualServer, 0) AS VirtualServer,

	-- user
	P.UserID,
	U.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	U.RoleID,
	U.Email
FROM @Items AS TSI
INNER JOIN ServiceItems AS SI ON TSI.ItemID = SI.ItemID
INNER JOIN ServiceItemTypes AS IT ON SI.ItemTypeID = IT.ItemTypeID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
INNER JOIN ResourceGroups AS RG ON IT.GroupID = RG.GroupID

SELECT
	IP.ItemID,
	IP.PropertyName,
	IP.PropertyValue
FROM ServiceItemProperties AS IP
INNER JOIN @Items AS TSI ON IP.ItemID = TSI.ItemID'

--print @sql

exec sp_executesql @sql, N'@ItemTypeID int, @PackageID int, @GroupID int, @StartRow int, @MaximumRows int, @Recursive bit, @ServerID int',
@ItemTypeID, @PackageID, @GroupID, @StartRow, @MaximumRows, @Recursive, @ServerID

RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var groupId = ResourceGroups
					.Where(r => r.GroupName == groupName)
					.Select(r => (int?)r.GroupId)
					.FirstOrDefault();

				var itemTypeId = ServiceItemTypes
					.Where(t => t.TypeName == itemTypeName &&
						(groupId == null || groupId != null && t.GroupId == groupId))
					.Select(t => t.ItemTypeId)
					.FirstOrDefault();

				IQueryable<Data.Entities.ServiceItem> serviceItems;
				TempIdSet childPackages = null;
				try
				{
					if (!recursive) serviceItems = ServiceItems.Where(si => si.PackageId == packageId);
					else
					{
						childPackages = PackagesTree(packageId, true);
						serviceItems = ServiceItems.Join(childPackages, si => si.PackageId, ch => ch, (p, ch) => p);
					}
					var items = serviceItems
						.Where(s => s.ItemTypeId == itemTypeId)
						// &&
						// (!recursive && s.PackageId == packageId ||
						// recursive && CheckPackageParent(packageId, s.PackageId ?? 0)))
						.Join(Packages, i => i.PackageId, p => p.PackageId, (si, p) => new
						{
							Item = si,
							Package = p
						})
						.Join(ServiceItemTypes, i => i.Item.ItemTypeId, t => t.ItemTypeId, (i, t) => new
						{
							i.Item,
							i.Package,
							Type = t
						})
						.Where(i => groupId == null || groupId != null && i.Type.GroupId == groupId)
						.Join(UsersDetailed, i => i.Package.UserId, u => u.UserId, (i, u) => new
						{
							i.Item,
							i.Package,
							i.Type,
							User = u
						})
						.Join(Services, i => i.Item.ServiceId, s => s.ServiceId, (i, s) => new
						{
							i.Item,
							i.Package,
							i.Type,
							i.User,
							Service = s
						})
						.Where(i => serverId == 0 || serverId > 0 && i.Service.ServerId == serverId)
						.Join(Servers, i => i.Service.ServerId, s => s.ServerId, (i, s) => new
						{
							i.Item,
							i.Package,
							i.Type,
							i.User,
							i.Service,
							Server = s
						})
						.Join(ResourceGroups, i => i.Type.GroupId, r => r.GroupId, (i, r) => new
						{
							i.Item.ItemId,
							i.Item.ItemName,
							i.Item.ItemTypeId,
							i.Type.TypeName,
							i.Item.ServiceId,
							i.Item.PackageId,
							i.Item.CreatedDate,
							r.GroupName,
							i.Package.PackageName,
							i.Server.ServerId,
							i.Server.ServerName,
							ServerComments = i.Server.Comments,
							i.Server.VirtualServer,
							i.Package.UserId,
							i.User.Username,
							i.User.FirstName,
							i.User.LastName,
							i.User.FullName,
							i.User.RoleId,
							i.User.Email
						});

					if (!string.IsNullOrEmpty(filterValue))
					{
						if (!string.IsNullOrEmpty(filterColumn))
						{
							items = items.Where(DynamicFunctions.ColumnLike(items, filterColumn, filterValue));
						}
						else
						{
							items = items
#if NETFRAMEWORK
								.Where(i => DbFunctions.Like(i.ItemName, filterValue) ||
									DbFunctions.Like(i.Username, filterValue) ||
									DbFunctions.Like(i.FullName, filterValue) ||
									DbFunctions.Like(i.Email, filterValue));
#else
							.Where(i => EF.Functions.Like(i.ItemName, filterValue) ||
								EF.Functions.Like(i.Username, filterValue) ||
								EF.Functions.Like(i.FullName, filterValue) ||
								EF.Functions.Like(i.Email, filterValue));
#endif
						}
					}

					var count = items.Count();

					if (!string.IsNullOrEmpty(sortColumn)) items = items.OrderBy(sortColumn);
					else items = items.OrderBy(i => i.ItemName);

					items = items.Skip(startRow).Take(maximumRows);

					var properties = ServiceItemProperties
						.Join(items, s => s.ItemId, i => i.ItemId, (s, i) => new
						{
							s.ItemId,
							s.PropertyName,
							s.PropertyValue
						});

					return EntityDataSet(count, items, properties);
				} finally
				{
					childPackages?.Dispose();
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceItemsPaged",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@groupName", groupName),
					new SqlParameter("@serverId", serverId),
					new SqlParameter("@itemTypeName", itemTypeName),
					new SqlParameter("@recursive", recursive),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public DataSet GetSearchableServiceItemTypes()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSearchableServiceItemTypes]

AS
SELECT
	ItemTypeID,
	DisplayName
FROM
	ServiceItemTypes
WHERE Searchable = 1
ORDER BY TypeOrder
RETURN
				*/
				#endregion

				var types = ServiceItemTypes
					.Where(t => t.Searchable == true)
					.OrderBy(t => t.TypeOrder)
					.Select(t => new
					{
						t.ItemTypeId,
						t.DisplayName
					});

				return EntityDataSet(types);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetSearchableServiceItemTypes");
			}
		}

		public DataSet GetServiceItemsByService(int actorId, int serviceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItemsByService]
(
	@ActorID int,
	@ServiceID int
)
AS

-- check rights
DECLARE @IsAdmin bit
SET @IsAdmin = dbo.CheckIsUserAdmin(@ActorID)

DECLARE @Items TABLE
(
	ItemID int
)

-- find service items
INSERT INTO @Items
SELECT
	SI.ItemID
FROM ServiceItems AS SI
WHERE SI.ServiceID = @ServiceID

-- select service items
SELECT
	SI.ItemID,
	SI.ItemName,
	SI.ItemTypeID,
	SIT.TypeName,
	SI.ServiceID,
	SI.PackageID,
	P.PackageName,
	S.ServiceID,
	S.ServiceName,
	SRV.ServerID,
	SRV.ServerName,
	RG.GroupName,
	U.UserID,
	U.Username,
	(U.FirstName + U.LastName) AS UserFullName,
	SI.CreatedDate
FROM @Items AS FI
INNER JOIN ServiceItems AS SI ON FI.ItemID = SI.ItemID
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
INNER JOIN ResourceGroups AS RG ON SIT.GroupID = RG.GroupID
INNER JOIN Users AS U ON P.UserID = U.UserID
WHERE @IsAdmin = 1

-- select item properties
-- get corresponding item properties
SELECT
	IP.ItemID,
	IP.PropertyName,
	IP.PropertyValue
FROM ServiceItemProperties AS IP
INNER JOIN @Items AS FI ON IP.ItemID = FI.ItemID
WHERE @IsAdmin = 1

RETURN
				*/
				#endregion

				var isAdmin = CheckIsUserAdmin(actorId);

				// select service items
				var items = ServiceItems
					.Where(s => isAdmin && s.ServiceId == serviceId)
					.Join(Packages, i => i.PackageId, p => p.PackageId, (si, p) => new
					{
						Item = si,
						Package = p
					})
					.Join(ServiceItemTypes, i => i.Item.ItemTypeId, t => t.ItemTypeId, (i, t) => new
					{
						i.Item,
						i.Package,
						Type = t
					})
					.Join(UsersDetailed, i => i.Package.UserId, u => u.UserId, (i, u) => new
					{
						i.Item,
						i.Package,
						i.Type,
						User = u
					})
					.Join(Services, i => i.Item.ServiceId, s => s.ServiceId, (i, s) => new
					{
						i.Item,
						i.Package,
						i.Type,
						i.User,
						Service = s
					})
					.Join(Servers, i => i.Service.ServerId, s => s.ServerId, (i, s) => new
					{
						i.Item,
						i.Package,
						i.Type,
						i.User,
						i.Service,
						Server = s
					})
					.Join(ResourceGroups, i => i.Type.GroupId, r => r.GroupId, (i, r) => new
					{
						i.Item.ItemId,
						i.Item.ItemName,
						i.Item.ItemTypeId,
						i.Type.TypeName,
						i.Item.ServiceId,
						i.Item.PackageId,
						i.Package.PackageName,
						i.Service.ServiceName,
						i.Server.ServerId,
						i.Server.ServerName,
						r.GroupName,
						i.User.UserId,
						i.User.Username,
						UserFullName = i.User.FirstName + " " + i.User.LastName,
						i.Item.CreatedDate
					});

				// select item properties, get corresponding item properties
				var properties = ServiceItemProperties
					.Join(items, p => p.ItemId, i => i.ItemId, (p, i) => new
					{
						p.ItemId,
						p.PropertyName,
						p.PropertyValue
					});

				return EntityDataSet(items, properties);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceItemsByService",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@ServiceID", serviceId));
			}
		}

		public int GetServiceItemsCount(string typeName, string groupName, int serviceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItemsCount]
(
	@ItemTypeName nvarchar(200),
	@GroupName nvarchar(100) = NULL,
	@ServiceID int = 0,
	@TotalNumber int OUTPUT
)
AS

SET @TotalNumber = 0

-- find service items
SELECT
	@TotalNumber = COUNT(SI.ItemID)
FROM ServiceItems AS SI
INNER JOIN ServiceItemTypes AS IT ON SI.ItemTypeID = IT.ItemTypeID
INNER JOIN ResourceGroups AS RG ON IT.GroupID = RG.GroupID
WHERE IT.TypeName = @ItemTypeName
AND ((@GroupName IS NULL) OR (@GroupName IS NOT NULL AND RG.GroupName = @GroupName))
AND ((@ServiceID = 0) OR (@ServiceID > 0 AND SI.ServiceID = @ServiceID))

RETURN
				*/
				#endregion

				return ServiceItems
					.Where(s => serviceId == 0 || serviceId > 0 && s.ServiceId == serviceId)
					.Join(ServiceItemTypes, s => s.ItemTypeId, t => t.ItemTypeId, (s, t) => new
					{
						Item = s,
						Type = t
					})
					.Where(s => s.Type.TypeName == typeName)
					.Join(ResourceGroups, s => s.Type.GroupId, r => r.GroupId, (s, r) => r)
					.Where(r => groupName == null || groupName != null && r.GroupName == groupName)
					.Count();
			}
			else
			{
				SqlParameter prmTotalNumber = new SqlParameter("@TotalNumber", SqlDbType.Int);
				prmTotalNumber.Direction = ParameterDirection.Output;

				DataSet ds = SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceItemsCount",
					prmTotalNumber,
					new SqlParameter("@itemTypeName", typeName),
					new SqlParameter("@groupName", groupName),
					new SqlParameter("@serviceId", serviceId));

				// read identity
				return Convert.ToInt32(prmTotalNumber.Value);
			}
		}

		public DataSet GetServiceItemsForStatistics(int actorId, int serviceId, int packageId,
			bool calculateDiskspace, bool calculateBandwidth, bool suspendable, bool disposable)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItemsForStatistics]
(
	@ActorID int,
	@ServiceID int,
	@PackageID int,
	@CalculateDiskspace bit,
	@CalculateBandwidth bit,
	@Suspendable bit,
	@Disposable bit
)
AS
DECLARE @Items TABLE
(
	ItemID int
)

-- find service items
INSERT INTO @Items
SELECT
	SI.ItemID
FROM ServiceItems AS SI
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
WHERE
	((@ServiceID = 0) OR (@ServiceID > 0 AND SI.ServiceID = @ServiceID))
	AND ((@PackageID = 0) OR (@PackageID > 0 AND SI.PackageID = @PackageID))
	AND ((@CalculateDiskspace = 0) OR (@CalculateDiskspace = 1 AND SIT.CalculateDiskspace = @CalculateDiskspace))
	AND ((@CalculateBandwidth = 0) OR (@CalculateBandwidth = 1 AND SIT.CalculateBandwidth = @CalculateBandwidth))
	AND ((@Suspendable = 0) OR (@Suspendable = 1 AND SIT.Suspendable = @Suspendable))
	AND ((@Disposable = 0) OR (@Disposable = 1 AND SIT.Disposable = @Disposable))

-- select service items
SELECT
	SI.ItemID,
	SI.ItemName,
	SI.ItemTypeID,
	RG.GroupName,
	SIT.TypeName,
	SI.ServiceID,
	SI.PackageID,
	SI.CreatedDate
FROM @Items AS FI
INNER JOIN ServiceItems AS SI ON FI.ItemID = SI.ItemID
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
INNER JOIN ResourceGroups AS RG ON SIT.GroupID = RG.GroupID
ORDER BY RG.GroupOrder DESC, SI.ItemName

-- select item properties
-- get corresponding item properties
SELECT
	IP.ItemID,
	IP.PropertyName,
	IP.PropertyValue
FROM ServiceItemProperties AS IP
INNER JOIN @Items AS FI ON IP.ItemID = FI.ItemID

RETURN
				*/
				#endregion

				var items = ServiceItems
					.Where(s => (serviceId == 0 || serviceId > 0 && s.ServiceId == serviceId) &&
						(packageId == 0 || packageId != 0 && s.PackageId == packageId))
					.Join(ServiceItemTypes, s => s.ItemTypeId, t => t.ItemTypeId, (s, t) => new
					{
						Item = s,
						Type = t
					})
					// TODO is this correct?
					.Where(s => (!calculateDiskspace || s.Type.CalculateDiskspace == true) &&
						(!calculateBandwidth || s.Type.CalculateBandwidth == true) &&
						(!suspendable || s.Type.Suspendable == true) &&
						(!disposable || s.Type.Disposable == true));

				var serviceItems = items
					.Join(ResourceGroups, s => s.Type.GroupId, r => r.GroupId, (s, r) => new
					{
						s.Item,
						s.Type,
						ResourceGroup = r
					})
					.OrderBy(s => s.ResourceGroup.GroupOrder)
					.Select(s => new
					{
						s.Item.ItemId,
						s.Item.ItemName,
						s.Item.ItemTypeId,
						s.ResourceGroup.GroupName,
						s.Type.TypeName,
						s.Item.ServiceId,
						s.Item.PackageId,
						s.Item.CreatedDate
					});

				var properties = ServiceItemProperties
					.Join(items, p => p.ItemId, i => i.Item.ItemId, (p, i) => new
					{
						p.ItemId,
						p.PropertyName,
						p.PropertyValue
					});

				return EntityDataSet(serviceItems, properties);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceItemsForStatistics",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ServiceID", serviceId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@calculateDiskspace", calculateDiskspace),
					new SqlParameter("@calculateBandwidth", calculateBandwidth),
					new SqlParameter("@suspendable", suspendable),
					new SqlParameter("@disposable", disposable));
			}
		}

		public DataSet GetServiceItemsByPackage(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItemsByPackage]
(
	@ActorID int,
	@PackageID int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @Items TABLE
(
	ItemID int
)

-- find service items
INSERT INTO @Items
SELECT
	SI.ItemID
FROM ServiceItems AS SI
WHERE SI.PackageID = @PackageID

-- select service items
SELECT
	SI.ItemID,
	SI.ItemName,
	SI.ItemTypeID,
	SIT.TypeName,
	SIT.DisplayName,
	SI.ServiceID,
	SI.PackageID,
	P.PackageName,
	S.ServiceID,
	S.ServiceName,
	SRV.ServerID,
	SRV.ServerName,
	RG.GroupName,
	U.UserID,
	U.Username,
	(U.FirstName + U.LastName) AS UserFullName,
	SI.CreatedDate
FROM @Items AS FI
INNER JOIN ServiceItems AS SI ON FI.ItemID = SI.ItemID
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
INNER JOIN ResourceGroups AS RG ON SIT.GroupID = RG.GroupID
INNER JOIN Users AS U ON P.UserID = U.UserID

-- select item properties
-- get corresponding item properties
SELECT
	IP.ItemID,
	IP.PropertyName,
	IP.PropertyValue
FROM ServiceItemProperties AS IP
INNER JOIN @Items AS FI ON IP.ItemID = FI.ItemID

RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				// select service items
				var items = ServiceItems
					.Where(s => s.PackageId == packageId)
					.Join(Packages, i => i.PackageId, p => p.PackageId, (si, p) => new
					{
						Item = si,
						Package = p
					})
					.Join(ServiceItemTypes, i => i.Item.ItemTypeId, t => t.ItemTypeId, (i, t) => new
					{
						i.Item,
						i.Package,
						Type = t
					})
					.Join(Users, i => i.Package.UserId, u => u.UserId, (i, u) => new
					{
						i.Item,
						i.Package,
						i.Type,
						User = u
					})
					.Join(Services, i => i.Item.ServiceId, s => s.ServiceId, (i, s) => new
					{
						i.Item,
						i.Package,
						i.Type,
						i.User,
						Service = s
					})
					.Join(Servers, i => i.Service.ServerId, s => s.ServerId, (i, s) => new
					{
						i.Item,
						i.Package,
						i.Type,
						i.User,
						i.Service,
						Server = s
					})
					.Join(ResourceGroups, i => i.Type.GroupId, r => r.GroupId, (i, r) => new
					{
						i.Item.ItemId,
						i.Item.ItemName,
						i.Item.ItemTypeId,
						i.Type.DisplayName,
						i.Item.ServiceId,
						i.Item.PackageId,
						i.Package.PackageName,
						i.Service.ServiceName,
						i.Server.ServerId,
						i.Server.ServerName,
						r.GroupName,
						i.User.UserId,
						i.User.Username,
						UserFullName = i.User.FirstName + " " + i.User.LastName,
						i.Item.CreatedDate
					});

				// select item properties, get corresponding item properties
				var properties = ServiceItemProperties
					.Join(items, p => p.ItemId, i => i.ItemId, (p, i) => new
					{
						p.ItemId,
						p.PropertyName,
						p.PropertyValue
					});

				return EntityDataSet(items, properties);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceItemsByPackage",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageID", packageId));
			}
		}

		public DataSet GetServiceItem(int actorId, int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItem]
(
	@ActorID int,
	@ItemID int
)
AS

DECLARE @Items TABLE
(
	ItemID int
)

-- find service items
INSERT INTO @Items
SELECT
	SI.ItemID
FROM ServiceItems AS SI
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
WHERE
	SI.ItemID = @ItemID
	AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1

-- select service items
SELECT
	SI.ItemID,
	SI.ItemName,
	SI.ItemTypeID,
	SIT.TypeName,
	SI.ServiceID,
	SI.PackageID,
	P.PackageName,
	S.ServiceID,
	S.ServiceName,
	SRV.ServerID,
	SRV.ServerName,
	RG.GroupName,
	U.UserID,
	U.Username,
	U.FullName AS UserFullName,
	SI.CreatedDate
FROM @Items AS FI
INNER JOIN ServiceItems AS SI ON FI.ItemID = SI.ItemID
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
INNER JOIN ResourceGroups AS RG ON PROV.GroupID = RG.GroupID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID

-- select item properties
-- get corresponding item properties
SELECT
	IP.ItemID,
	IP.PropertyName,
	IP.PropertyValue
FROM ServiceItemProperties AS IP
INNER JOIN @Items AS FI ON IP.ItemID = FI.ItemID

RETURN
				*/
				#endregion

				// select service items
				var items = ServiceItems
					.Where(s => s.ItemId == itemId)
					.Join(Packages, i => i.PackageId, p => p.PackageId, (si, p) => new
					{
						Item = si,
						Package = p
					})
					.Join(ServiceItemTypes, i => i.Item.ItemTypeId, t => t.ItemTypeId, (i, t) => new
					{
						i.Item,
						i.Package,
						Type = t
					})
					.Join(Users, i => i.Package.UserId, u => u.UserId, (i, u) => new
					{
						i.Item,
						i.Package,
						i.Type,
						User = u
					})
					.Join(Services, i => i.Item.ServiceId, s => s.ServiceId, (i, s) => new
					{
						i.Item,
						i.Package,
						i.Type,
						i.User,
						Service = s
					})
					.Join(Servers, i => i.Service.ServerId, s => s.ServerId, (i, s) => new
					{
						i.Item,
						i.Package,
						i.Type,
						i.User,
						i.Service,
						Server = s
					})
					.Join(ResourceGroups, i => i.Type.GroupId, r => r.GroupId, (i, r) => new
					{
						i.Item.ItemId,
						i.Item.ItemName,
						i.Item.ItemTypeId,
						i.Type.TypeName,
						i.Item.ServiceId,
						i.Item.PackageId,
						i.Package.PackageName,
						i.Service.ServiceName,
						i.Server.ServerId,
						i.Server.ServerName,
						r.GroupName,
						i.User.UserId,
						i.User.Username,
						UserFullName = i.User.FirstName + " " + i.User.LastName,
						i.Item.CreatedDate
					})
					.AsEnumerable()
					.Where(s => Local.CheckActorPackageRights(actorId, s.PackageId));

				// select item properties, get corresponding item properties
				var properties = ServiceItemProperties
					.Join(items, p => p.ItemId, i => i.ItemId, (p, i) => new
					{
						p.ItemId,
						p.PropertyName,
						p.PropertyValue
					});

				return EntityDataSet(items, properties);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceItem",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@actorId", actorId));
			}
		}

		public bool CheckServiceItemExists(int serviceId, string itemName, string itemTypeName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckServiceItemExistsInService]
(
	@Exists bit OUTPUT,
	@ServiceID int,
	@ItemName nvarchar(500),
	@ItemTypeName nvarchar(200)
)
AS

SET @Exists = 0

DECLARE @ItemTypeID int
SELECT @ItemTypeID = ItemTypeID FROM ServiceItemTypes
WHERE TypeName = @ItemTypeName

IF EXISTS (SELECT ItemID FROM ServiceItems
WHERE ItemName = @ItemName AND ItemTypeID = @ItemTypeID AND ServiceID = @ServiceID)
SET @Exists = 1

RETURN
				*/
				#endregion

				var itemTypeId = ServiceItemTypes
					.Where(t => t.TypeName == itemTypeName)
					.Select(t => t.ItemTypeId)
					.FirstOrDefault();

				return ServiceItems.Any(s => s.ServiceId == serviceId && s.ItemName == itemName &&
					s.ItemTypeId == itemTypeId);
			}
			else
			{
				SqlParameter prmExists = new SqlParameter("@Exists", SqlDbType.Bit);
				prmExists.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "CheckServiceItemExistsInService",
					prmExists,
					new SqlParameter("@serviceId", serviceId),
					new SqlParameter("@itemName", itemName),
					new SqlParameter("@itemTypeName", itemTypeName));

				return Convert.ToBoolean(prmExists.Value);
			}
		}

		public bool CheckServiceItemExists(string itemName, string groupName, string itemTypeName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckServiceItemExists]
(
	@Exists bit OUTPUT,
	@ItemName nvarchar(500),
	@ItemTypeName nvarchar(200),
	@GroupName nvarchar(100) = NULL
)
AS

SET @Exists = 0

DECLARE @ItemTypeID int
SELECT @ItemTypeID = ItemTypeID FROM ServiceItemTypes
WHERE TypeName = @ItemTypeName

IF EXISTS (
SELECT ItemID FROM ServiceItems AS SI
INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
INNER JOIN ResourceGroups AS RG ON PROV.GroupID = RG.GroupID
WHERE SI.ItemName = @ItemName AND SI.ItemTypeID = @ItemTypeID
AND ((@GroupName IS NULL) OR (@GroupName IS NOT NULL AND RG.GroupName = @GroupName))
)
SET @Exists = 1

RETURN
				*/
				#endregion

				var itemTypeId = ServiceItemTypes
					.Where(t => t.TypeName == itemTypeName)
					.Select(t => t.ItemTypeId)
					.FirstOrDefault();

				return ServiceItems
					.Where(s => s.ItemName == itemName && s.ItemTypeId == itemTypeId)
					.Join(Services, i => i.ServiceId, s => s.ServiceId, (i, s) => new
					{
						Item = i,
						Service = s,
					})
					.Join(Providers, i => i.Service.ProviderId, p => p.ProviderId, (i, p) => new
					{
						i.Item,
						i.Service,
						Provider = p
					})
					.Join(ResourceGroups, i => i.Provider.GroupId, r => r.GroupId, (i, r) => new
					{
						i.Item,
						i.Service,
						i.Provider,
						ResourceGroup = r
					})
					.Where(s => groupName == null || groupName != null && s.ResourceGroup.GroupName == groupName)
					.Any();
			}
			else
			{
				SqlParameter prmExists = new SqlParameter("@Exists", SqlDbType.Bit);
				prmExists.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "CheckServiceItemExists",
					prmExists,
					new SqlParameter("@itemName", itemName),
					new SqlParameter("@groupName", groupName),
					new SqlParameter("@itemTypeName", itemTypeName));

				return Convert.ToBoolean(prmExists.Value);
			}
		}

		public DataSet GetServiceItemByName(int actorId, int packageId, string groupName,
			string itemName, string itemTypeName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItemByName]
(
	@ActorID int,
	@PackageID int,
	@ItemName nvarchar(500),
	@GroupName nvarchar(100) = NULL,
	@ItemTypeName nvarchar(200)
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @Items TABLE
(
	ItemID int
)

-- find service items
INSERT INTO @Items
SELECT
	SI.ItemID
FROM ServiceItems AS SI
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
INNER JOIN ResourceGroups AS RG ON SIT.GroupID = RG.GroupID
WHERE SI.PackageID = @PackageID AND SIT.TypeName = @ItemTypeName
AND SI.ItemName = @ItemName
AND ((@GroupName IS NULL) OR (@GroupName IS NOT NULL AND RG.GroupName = @GroupName))

-- select service items
SELECT
	SI.ItemID,
	SI.ItemName,
	SI.ItemTypeID,
	SIT.TypeName,
	SI.ServiceID,
	SI.PackageID,
	P.PackageName,
	S.ServiceID,
	S.ServiceName,
	SRV.ServerID,
	SRV.ServerName,
	RG.GroupName,
	U.UserID,
	U.Username,
	U.FullName AS UserFullName,
	SI.CreatedDate
FROM @Items AS FI
INNER JOIN ServiceItems AS SI ON FI.ItemID = SI.ItemID
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
INNER JOIN ResourceGroups AS RG ON PROV.GroupID = RG.GroupID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID

-- select item properties
-- get corresponding item properties
SELECT
	IP.ItemID,
	IP.PropertyName,
	IP.PropertyValue
FROM ServiceItemProperties AS IP
INNER JOIN @Items AS FI ON IP.ItemID = FI.ItemID

RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				// select service items
				var items = ServiceItems
					.Where(s => s.PackageId == packageId && s.ItemName == itemName)
					.Join(Packages, i => i.PackageId, p => p.PackageId, (si, p) => new
					{
						Item = si,
						Package = p
					})
					.Join(ServiceItemTypes, i => i.Item.ItemTypeId, t => t.ItemTypeId, (i, t) => new
					{
						i.Item,
						i.Package,
						Type = t
					})
					.Where(s => s.Type.TypeName == itemTypeName)
					.Join(Users, i => i.Package.UserId, u => u.UserId, (i, u) => new
					{
						i.Item,
						i.Package,
						i.Type,
						User = u
					})
					.Join(Services, i => i.Item.ServiceId, s => s.ServiceId, (i, s) => new
					{
						i.Item,
						i.Package,
						i.Type,
						i.User,
						Service = s
					})
					.Join(Servers, i => i.Service.ServerId, s => s.ServerId, (i, s) => new
					{
						i.Item,
						i.Package,
						i.Type,
						i.User,
						i.Service,
						Server = s
					})
					.Join(ResourceGroups, i => i.Type.GroupId, r => r.GroupId, (i, r) => new
					{
						i.Item.ItemId,
						i.Item.ItemName,
						i.Item.ItemTypeId,
						i.Type.DisplayName,
						i.Item.ServiceId,
						i.Item.PackageId,
						i.Package.PackageName,
						i.Service.ServiceName,
						i.Server.ServerId,
						i.Server.ServerName,
						r.GroupName,
						i.User.UserId,
						i.User.Username,
						UserFullName = i.User.FirstName + " " + i.User.LastName,
						i.Item.CreatedDate
					})
					.Where(i => groupName == null || groupName != null && i.GroupName == groupName);

				// select item properties, get corresponding item properties
				var properties = ServiceItemProperties
					.Join(items, p => p.ItemId, i => i.ItemId, (p, i) => new
					{
						p.ItemId,
						p.PropertyName,
						p.PropertyValue
					});

				return EntityDataSet(items, properties);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceItemByName",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@itemName", itemName),
					new SqlParameter("@itemTypeName", itemTypeName),
					new SqlParameter("@groupName", groupName));
			}
		}

		public DataSet GetServiceItemsByName(int actorId, int packageId, string itemName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItemsByName]
(
	@ActorID int,
	@PackageID int,
	@ItemName nvarchar(500)
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @Items TABLE
(
	ItemID int
)

-- find service items
INSERT INTO @Items
SELECT
	SI.ItemID
FROM ServiceItems AS SI
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
WHERE SI.PackageID = @PackageID
AND SI.ItemName LIKE @ItemName

-- select service items
SELECT
	SI.ItemID,
	SI.ItemName,
	SI.ItemTypeID,
	SIT.TypeName,
	SI.ServiceID,
	SI.PackageID,
	P.PackageName,
	S.ServiceID,
	S.ServiceName,
	SRV.ServerID,
	SRV.ServerName,
	RG.GroupName,
	U.UserID,
	U.Username,
	U.FullName AS UserFullName,
	SI.CreatedDate
FROM @Items AS FI
INNER JOIN ServiceItems AS SI ON FI.ItemID = SI.ItemID
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
INNER JOIN Servers AS SRV ON S.ServerID = SRV.ServerID
INNER JOIN ResourceGroups AS RG ON SIT.GroupID = RG.GroupID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID

-- select item properties
-- get corresponding item properties
SELECT
	IP.ItemID,
	IP.PropertyName,
	IP.PropertyValue
FROM ServiceItemProperties AS IP
INNER JOIN @Items AS FI ON IP.ItemID = FI.ItemID

RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				// select service items
				var items = ServiceItems
					.Where(s => s.PackageId == packageId && s.ItemName == itemName)
					.Join(Packages, i => i.PackageId, p => p.PackageId, (si, p) => new
					{
						Item = si,
						Package = p
					})
					.Join(ServiceItemTypes, i => i.Item.ItemTypeId, t => t.ItemTypeId, (i, t) => new
					{
						i.Item,
						i.Package,
						Type = t
					})
					.Join(Users, i => i.Package.UserId, u => u.UserId, (i, u) => new
					{
						i.Item,
						i.Package,
						i.Type,
						User = u
					})
					.Join(Services, i => i.Item.ServiceId, s => s.ServiceId, (i, s) => new
					{
						i.Item,
						i.Package,
						i.Type,
						i.User,
						Service = s
					})
					.Join(Servers, i => i.Service.ServerId, s => s.ServerId, (i, s) => new
					{
						i.Item,
						i.Package,
						i.Type,
						i.User,
						i.Service,
						Server = s
					})
					.Join(ResourceGroups, i => i.Type.GroupId, r => r.GroupId, (i, r) => new
					{
						i.Item.ItemId,
						i.Item.ItemName,
						i.Item.ItemTypeId,
						i.Type.DisplayName,
						i.Item.ServiceId,
						i.Item.PackageId,
						i.Package.PackageName,
						i.Service.ServiceName,
						i.Server.ServerId,
						i.Server.ServerName,
						r.GroupName,
						i.User.UserId,
						i.User.Username,
						UserFullName = i.User.FirstName + " " + i.User.LastName,
						i.Item.CreatedDate
					});

				// select item properties, get corresponding item properties
				var properties = ServiceItemProperties
					.Join(items, p => p.ItemId, i => i.ItemId, (p, i) => new
					{
						p.ItemId,
						p.PropertyName,
						p.PropertyValue
					});

				return EntityDataSet(items, properties);

			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceItemsByName",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@itemName", itemName));
			}
		}

		public int GetServiceItemsCountByNameAndServiceId(int actorId, int serviceId, string groupName,
			string itemName, string itemTypeName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItemsCountByNameAndServiceId]
(
	@ActorID int,
	@ServiceId int,
	@ItemName nvarchar(500),
	@GroupName nvarchar(100) = NULL,
	@ItemTypeName nvarchar(200)
)
AS
SELECT Count(*)
FROM ServiceItems AS SI
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
INNER JOIN ResourceGroups AS RG ON SIT.GroupID = RG.GroupID
INNER JOIN Services AS S ON SI.ServiceID = S.ServiceID
WHERE S.ServiceID = @ServiceId 
AND SIT.TypeName = @ItemTypeName
AND SI.ItemName = @ItemName
AND ((@GroupName IS NULL) OR (@GroupName IS NOT NULL AND RG.GroupName = @GroupName))
RETURN 
				*/
				#endregion

				// select service items
				return ServiceItems
					.Where(s => s.ServiceId == serviceId && s.ItemName == itemName)
					.Join(ServiceItemTypes, i => i.ItemTypeId, t => t.ItemTypeId, (i, t) => new
					{
						Item = i,
						Type = t
					})
					.Where(s => s.Type.TypeName == itemTypeName)
					.Join(ResourceGroups, i => i.Type.GroupId, r => r.GroupId, (i, r) => r)
					.Where(r => groupName == null || groupName != null && r.GroupName == groupName)
					.Count();
			}
			else
			{
				int res = 0;

				object obj = SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetServiceItemsCountByNameAndServiceId",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ServiceId", serviceId),
					new SqlParameter("@ItemName", itemName),
					new SqlParameter("@GroupName", groupName),
					new SqlParameter("@ItemTypeName", itemTypeName));

				if (!int.TryParse(obj.ToString(), out res)) return -1;

				return res;
			}
		}

		public int AddServiceItem(int actorId, int serviceId, int packageId, string itemName,
			string itemTypeName, string xmlProperties)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddServiceItem]
(
	@ActorID int,
	@PackageID int,
	@ServiceID int,
	@ItemName nvarchar(500),
	@ItemTypeName nvarchar(200),
	@ItemID int OUTPUT,
	@XmlProperties ntext,
	@CreatedDate datetime
)
AS
BEGIN TRAN

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- get GroupID
DECLARE @GroupID int
SELECT
	@GroupID = PROV.GroupID
FROM Services AS S
INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
WHERE S.ServiceID = @ServiceID

DECLARE @ItemTypeID int
SELECT @ItemTypeID = ItemTypeID FROM ServiceItemTypes
WHERE TypeName = @ItemTypeName
AND ((@GroupID IS NULL) OR (@GroupID IS NOT NULL AND GroupID = @GroupID))

-- Fix to allow plans assigned to serveradmin
IF (@ItemTypeName = 'SolidCP.Providers.HostedSolution.Organization, SolidCP.Providers.Base')
BEGIN
	IF NOT EXISTS (SELECT * FROM ServiceItems WHERE PackageID = 1)
	BEGIN
		INSERT INTO ServiceItems (PackageID, ItemTypeID,ServiceID,ItemName,CreatedDate)
		VALUES(1, @ItemTypeID, @ServiceID, 'System',  @CreatedDate)

		DECLARE @TempItemID int

		SET @TempItemID = SCOPE_IDENTITY()
		INSERT INTO ExchangeOrganizations (ItemID, OrganizationID)
		VALUES(@TempItemID, 'System')
	END
END

-- add item
INSERT INTO ServiceItems
(
	PackageID,
	ServiceID,
	ItemName,
	ItemTypeID,
	CreatedDate
)
VALUES
(
	@PackageID,
	@ServiceID,
	@ItemName,
	@ItemTypeID,
	@CreatedDate
)

SET @ItemID = SCOPE_IDENTITY()

DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @XmlProperties

-- Execute a SELECT statement that uses the OPENXML rowset provider.
DELETE FROM ServiceItemProperties
WHERE ItemID = @ItemID

CREATE TABLE #TempTable(
	ItemID int,
	PropertyName nvarchar(50),
	PropertyValue  nvarchar(max))

INSERT INTO #TempTable (ItemID, PropertyName, PropertyValue)
SELECT
	@ItemID,
	PropertyName,
	PropertyValue
FROM OPENXML(@idoc, '/properties/property',1) WITH 
(
	PropertyName nvarchar(50) '@name',
	PropertyValue nvarchar(max) '@value'
) as PV

-- Move data from temp table to real table
INSERT INTO ServiceItemProperties
(
	ItemID,
	PropertyName,
	PropertyValue
)
SELECT 
	ItemID, 
	PropertyName, 
	PropertyValue
FROM #TempTable

DROP TABLE #TempTable

-- remove document
exec sp_xml_removedocument @idoc

COMMIT TRAN
RETURN 
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var groupId = Services
					.Where(s => s.ServiceId == serviceId)
					.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => (int?)p.GroupId)
					.FirstOrDefault();

				var itemTypeId = ServiceItemTypes
					.Where(t => t.TypeName == itemTypeName &&
						(groupId == null || groupId != null && t.GroupId == groupId))
					.Select(t => (int?)t.ItemTypeId)
					.FirstOrDefault();

				using (var transaction = Database.BeginTransaction())
				{
					// Fix to allow plans assigned to serveradmin
					if (itemTypeName == "SolidCP.Providers.HostedSolution.Organization, SolidCP.Providers.Base")
					{
						if (!ServiceItems.Any(s => s.PackageId == 1))
						{
							var serviceItem = new Data.Entities.ServiceItem()
							{
								PackageId = 1,
								ItemTypeId = itemTypeId,
								ServiceId = serviceId,
								ItemName = "System",
								CreatedDate = DateTime.Now
							};
							ServiceItems.Add(serviceItem);
							ExchangeOrganizations.Add(new Data.Entities.ExchangeOrganization()
							{
								Item = serviceItem,
								OrganizationId = "System"
							});
						}
					}

					// add item
					var item = new Data.Entities.ServiceItem()
					{
						PackageId = packageId,
						ItemTypeId = itemTypeId,
						ServiceId = serviceId,
						ItemName = itemName,
						CreatedDate = DateTime.Now
					};
					ServiceItems.Add(item);

					SaveChanges();

					ServiceItemProperties.Where(p => p.ItemId == item.ItemId).ExecuteDelete();

					var properties = XElement.Parse(xmlProperties)
						.Elements()
						.Select(e => new Data.Entities.ServiceItemProperty
						{
							ItemId = item.ItemId,
							PropertyName = (string)e.Attribute("name"),
							PropertyValue = (string)e.Attribute("value")
						});

					ServiceItemProperties.AddRange(properties);

					SaveChanges();

					transaction.Commit();

					return item.ItemId;
				}
			}
			else
			{
				// add item
				SqlParameter prmItemId = new SqlParameter("@ItemID", SqlDbType.Int);
				prmItemId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddServiceItem",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@ServiceID", serviceId),
					new SqlParameter("@ItemName", itemName),
					new SqlParameter("@ItemTypeName", itemTypeName),
					new SqlParameter("@xmlProperties", xmlProperties),
					new SqlParameter("@CreatedDate", DateTime.Now),
					prmItemId);

				return Convert.ToInt32(prmItemId.Value);
			}
		}

		public void UpdateServiceItem(int actorId, int itemId, string itemName, string xmlProperties)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateServiceItem]
(
	@ActorID int,
	@ItemID int,
	@ItemName nvarchar(500),
	@XmlProperties ntext
)
AS
BEGIN TRAN

-- check rights
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM ServiceItems
WHERE ItemID = @ItemID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- update item
UPDATE ServiceItems SET ItemName = @ItemName
WHERE ItemID=@ItemID

DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @XmlProperties

-- Execute a SELECT statement that uses the OPENXML rowset provider.
DELETE FROM ServiceItemProperties
WHERE ItemID = @ItemID

-- Add the xml data into a temp table for the capability and robust
IF OBJECT_ID('tempdb..#TempTable') IS NOT NULL DROP TABLE #TempTable

CREATE TABLE #TempTable(
	ItemID int,
	PropertyName nvarchar(50),
	PropertyValue  nvarchar(max))

INSERT INTO #TempTable (ItemID, PropertyName, PropertyValue)
SELECT
	@ItemID,
	PropertyName,
	PropertyValue
FROM OPENXML(@idoc, '/properties/property',1) WITH 
(
	PropertyName nvarchar(50) '@name',
	PropertyValue nvarchar(max) '@value'
) as PV

-- Move data from temp table to real table
INSERT INTO ServiceItemProperties
(
	ItemID,
	PropertyName,
	PropertyValue
)
SELECT 
	ItemID, 
	PropertyName, 
	PropertyValue
FROM #TempTable

DROP TABLE #TempTable

-- remove document
exec sp_xml_removedocument @idoc

COMMIT TRAN

RETURN
				 */
				#endregion

				var item = ServiceItems
					.FirstOrDefault(s => s.ItemId == itemId);
				var packageId = item?.PackageId;

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var transaction = Database.BeginTransaction())
				{
					// update item
					item.ItemName = itemName;

					ServiceItemProperties
						.Where(p => p.ItemId == itemId)
						.ExecuteDelete();

					var properties = XElement.Parse(xmlProperties)
						.Elements()
						.Select(e => new Data.Entities.ServiceItemProperty
						{
							ItemId = itemId,
							PropertyName = (string)e.Attribute("name"),
							PropertyValue = (string)e.Attribute("value")
						});
					ServiceItemProperties.AddRange(properties);

					SaveChanges();

					transaction.Commit();
				}
			}
			else
			{
				// update item
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateServiceItem",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@ItemName", itemName),
					new SqlParameter("@ItemId", itemId),
					new SqlParameter("@XmlProperties", xmlProperties));
			}
		}

		public void DeleteServiceItem(int actorId, int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteServiceItem]
(
	@ActorID int,
	@ItemID int
)
AS

-- check rights
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM ServiceItems
WHERE ItemID = @ItemID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

BEGIN TRAN

UPDATE Domains
SET ZoneItemID = NULL
WHERE ZoneItemID = @ItemID

DELETE FROM Domains
WHERE WebSiteID = @ItemID AND IsDomainPointer = 1

UPDATE Domains
SET WebSiteID = NULL
WHERE WebSiteID = @ItemID

UPDATE Domains
SET MailDomainID = NULL
WHERE MailDomainID = @ItemID

-- delete item comments
DELETE FROM Comments
WHERE ItemID = @ItemID AND ItemTypeID = 'SERVICE_ITEM'

-- delete item properties
DELETE FROM ServiceItemProperties
WHERE ItemID = @ItemID

-- delete external IP addresses
EXEC dbo.DeleteItemIPAddresses @ActorID, @ItemID

-- delete item
DELETE FROM ServiceItems
WHERE ItemID = @ItemID

COMMIT TRAN

RETURN
				*/
				#endregion

				var packageId = ServiceItems
					.Where(s => s.ItemId == itemId)
					.Select(s => s.PackageId)
					.FirstOrDefault();

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var transaction = Database.BeginTransaction())
				{
					Domains
						.Where(d => d.WebSiteId == itemId && d.IsDomainPointer)
						.ExecuteDelete();
					Domains
						.Where(d => d.ZoneItemId == itemId)
						.ExecuteUpdate(d => new Data.Entities.Domain { ZoneItemId = null });
					Domains
						.Where(d => d.WebSiteId == itemId)
						.ExecuteUpdate(d => new Data.Entities.Domain { WebSiteId = null }); 
					Domains
						.Where(d => d.MailDomainId == itemId)
						.ExecuteUpdate(d => new Data.Entities.Domain { MailDomainId = null });

					// delete item comments
					Comments
						.Where(c => c.ItemId == itemId && c.ItemTypeId == "SERVICE_ITEM")
						.ExecuteDelete();

					// delete item properties
					ServiceItemProperties
						.Where(p => p.ItemId == itemId)
						.ExecuteDelete();

					// delete external IP addresses
					DeleteItemIPAddresses(actorId, itemId);

					// delete item
					ServiceItems
						.Where(s => s.ItemId == itemId)
						.ExecuteDelete();

					SaveChanges();

					transaction.Commit();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteServiceItem",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@ItemID", itemId));
			}
		}

		public void MoveServiceItem(int actorId, int itemId, int destinationServiceId, bool forAutodiscover)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[MoveServiceItem]
(
	@ActorID int,
	@ItemID int,
	@DestinationServiceID int,
	@forAutodiscover bit
)
AS

-- check rights
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM ServiceItems
WHERE ItemID = @ItemID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0 AND @forAutodiscover = 0
RAISERROR('You are not allowed to access this package', 16, 1)

BEGIN TRAN

UPDATE ServiceItems
SET ServiceID = @DestinationServiceID
WHERE ItemID = @ItemID

COMMIT TRAN

RETURN
				*/
				#endregion

				var packageId = ServiceItems
					.Where(s => s.ItemId == itemId)
					.Select(s => s.PackageId)
					.FirstOrDefault();

				if (!forAutodiscover && !CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var transaction = Database.BeginTransaction())
				{
#if NETCOREAPP
					ServiceItems.Where(s => s.ItemId == itemId).ExecuteUpdate(s => s.SetProperty(p => p.ServiceId, destinationServiceId));
#else
					foreach (var item in ServiceItems.Where(s => s.ItemId == itemId)) item.ServiceId = destinationServiceId;
					SaveChanges();
#endif
					transaction.Commit();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "MoveServiceItem",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@DestinationServiceID", destinationServiceId),
					new SqlParameter("@forAutodiscover", forAutodiscover));
			}
		}

		public bool GetPackageAllocatedResource(int? packageId, int groupId, int? serverId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[GetPackageAllocatedResource]
(
	@PackageID int,
	@GroupID int,
	@ServerID int
)
RETURNS bit
AS
BEGIN

IF @PackageID IS NULL
RETURN 1

DECLARE @Result bit
SET @Result = 1 -- enabled

DECLARE @PID int, @ParentPackageID int
SET @PID = @PackageID

DECLARE @OverrideQuotas bit

IF @ServerID IS NULL OR @ServerID = 0
SELECT @ServerID = ServerID FROM Packages
WHERE PackageID = @PackageID

WHILE 1 = 1
BEGIN

	DECLARE @GroupEnabled int

	-- get package info
	SELECT
		@ParentPackageID = ParentPackageID,
		@OverrideQuotas = OverrideQuotas
	FROM Packages WHERE PackageID = @PID

	-- check if this is a root 'System' package
	SET @GroupEnabled = 1 -- enabled
	IF @ParentPackageID IS NULL
	BEGIN

		IF @ServerID = -1 OR @ServerID IS NULL
		RETURN 1

		IF EXISTS (SELECT VirtualServer FROM Servers WHERE ServerID = @ServerID AND VirtualServer = 1)
		BEGIN
			IF NOT EXISTS(
				SELECT
					DISTINCT(PROV.GroupID)
				FROM VirtualServices AS VS
				INNER JOIN Services AS S ON VS.ServiceID = S.ServiceID
				INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
				WHERE PROV.GroupID = @GroupID AND VS.ServerID = @ServerID
			)
			SET @GroupEnabled = 0
		END
		ELSE
		BEGIN
			IF NOT EXISTS(
				SELECT
					DISTINCT(PROV.GroupID)
				FROM Services AS S
				INNER JOIN Providers AS PROV ON S.ProviderID = PROV.ProviderID
				WHERE PROV.GroupID = @GroupID AND  S.ServerID = @ServerID
			)
			SET @GroupEnabled = 0
		END

		RETURN @GroupEnabled -- exit from the loop
	END
	ELSE -- parentpackage is not null
	BEGIN
		-- check the current package
		IF @OverrideQuotas = 1
		BEGIN
			IF NOT EXISTS(
				SELECT GroupID FROM PackageResources WHERE GroupID = @GroupID AND PackageID = @PID
			)
			SET @GroupEnabled = 0
		END
		ELSE
		BEGIN
			IF NOT EXISTS(
				SELECT HPR.GroupID FROM Packages AS P
				INNER JOIN HostingPlanResources AS HPR ON P.PlanID = HPR.PlanID
				WHERE HPR.GroupID = @GroupID AND P.PackageID = @PID
			)
			SET @GroupEnabled = 0
		END

		-- check addons
		IF EXISTS(
			SELECT HPR.GroupID FROM PackageAddons AS PA
			INNER JOIN HostingPlanResources AS HPR ON PA.PlanID = HPR.PlanID
			WHERE HPR.GroupID = @GroupID AND PA.PackageID = @PID
			AND PA.StatusID = 1 -- active add-on
		)
		SET @GroupEnabled = 1
	END

	IF @GroupEnabled = 0
		RETURN 0

	SET @PID = @ParentPackageID

END -- end while

RETURN @Result
END
			*/
			#endregion

			if (packageId == null) return true;

			if (serverId == null || serverId == 0)
			{
				serverId = Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => p.ServerId)
					.FirstOrDefault();
			}

			var id = packageId;
			bool groupEnabled = true;

			while (groupEnabled)
			{
				var package = Packages
					.Where(p => p.PackageId == id)
					.Select(p => new { p.ParentPackageId, p.OverrideQuotas })
					.FirstOrDefault();

				// check if this is a root 'System' package
				if (package.ParentPackageId == null)
				{
					if (serverId == -1 || serverId == null) return true;

					if (Servers.Any(s => s.ServerId == serverId && s.VirtualServer))
					{
						if (!VirtualServices
							.Where(v => v.ServerId == serverId)
							.Join(Services, v => v.ServerId, s => s.ServiceId, (v, s) => s)
							.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => p)
							.Any(p => p.GroupId == groupId))
						{
							groupEnabled = false;
						}
					}
					else
					{
						if (!Services
							.Where(s => s.ServerId == serverId)
							.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => p)
							.Any(p => p.GroupId == groupId))
						{
							groupEnabled = false;
						}
					}

					return groupEnabled;
				}
				else // parentPackageId != null
				{
					// check the current package
					if (package.OverrideQuotas)
					{
						if (!PackageResources.Any(r => r.GroupId == groupId && r.PackageId == id))
						{
							groupEnabled = false;
						}
					}
					else
					{
						if (!Packages
							.Where(p => p.PackageId == id)
							.Join(HostingPlanResources, p => p.PlanId, r => r.PlanId, (p, r) => r)
							.Any(r => r.GroupId == groupId))
						{
							groupEnabled = false;
						}
					}

					// check addons
					if (PackageAddons
						.Where(p => p.PackageId == id && p.StatusId == 1)
						.Join(HostingPlanResources, p => p.PlanId, r => r.PlanId, (p, r) => r)
						.Any(r => r.GroupId == groupId))
					{
						groupEnabled = true;
					}
				}

				id = package.ParentPackageId;
			}

			return false;
		}

		public int GetPackageServiceId(int actorId, int packageId, string groupName, bool updatePackage)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageServiceID]
(
	@ActorID int,
	@PackageID int,
	@GroupName nvarchar(100),
	@UpdatePackage bit,
	@ServiceID int OUTPUT
)
AS
BEGIN

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SET @ServiceID = 0

-- optimized run when we don't need any changes
IF @UpdatePackage = 0
BEGIN
SELECT
	@ServiceID = PS.ServiceID
FROM PackageServices AS PS
INNER JOIN Services AS S ON PS.ServiceID = S.ServiceID
INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
INNER JOIN ResourceGroups AS RG ON RG.GroupID = P.GroupID
WHERE PS.PackageID = @PackageID AND RG.GroupName = @GroupName
RETURN
END

-- load group info
DECLARE @GroupID int
SELECT @GroupID = GroupID FROM ResourceGroups
WHERE GroupName = @GroupName

-- check if user has this resource enabled
IF dbo.GetPackageAllocatedResource(@PackageID, @GroupID, NULL) = 0
BEGIN
	-- remove all resource services from the space
	DELETE FROM PackageServices FROM PackageServices AS PS
	INNER JOIN Services AS S ON PS.ServiceID = S.ServiceID
	INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
	WHERE P.GroupID = @GroupID AND PS.PackageID = @PackageID
	RETURN
END

-- check if the service is already distributed
SELECT
	@ServiceID = PS.ServiceID
FROM PackageServices AS PS
INNER JOIN Services AS S ON PS.ServiceID = S.ServiceID
INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
WHERE PS.PackageID = @PackageID AND P.GroupID = @GroupID

IF @ServiceID <> 0
RETURN

-- distribute services
EXEC DistributePackageServices @ActorID, @PackageID

-- get distributed service again
SELECT
	@ServiceID = PS.ServiceID
FROM PackageServices AS PS
INNER JOIN Services AS S ON PS.ServiceID = S.ServiceID
INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
WHERE PS.PackageID = @PackageID AND P.GroupID = @GroupID

END
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				int serviceId = 0;
				//optimized run when we don't need any changes
				if (!updatePackage) {
					serviceId = PackageServices
						.Where(ps => ps.PackageId == packageId)
						.Join(Services, ps => ps.ServiceId, s => s.ServiceId, (ps, s) => s)
						.Join(ResourceGroups.Where(rg => rg.GroupName == groupName),
							s => s.Provider.GroupId, rg => rg.GroupId, (s, rg) => s.ServiceId)
						.FirstOrDefault();
					return serviceId;
				}

				var groupId = ResourceGroups
					.Where(g => g.GroupName == groupName)
					.Select(g => g.GroupId)
					.FirstOrDefault();

				// check if user has this resource enabled
				if (!GetPackageAllocatedResource(packageId, groupId, null))
				{
					// remove all resource services from the space
					// var servicesToRemove =
					PackageServices
						.Where(ps => ps.PackageId == packageId)
						.Join(Services, ps => ps.ServiceId, s => s.ServiceId, (ps, s) => new
						{
							PackageService = ps,
							Service = s
						})
						.Join(Providers.Where(p => p.GroupId == groupId),
							ps => ps.Service.ProviderId, p => p.ProviderId, (ps, p) => new
						{
							PackageService = ps,
							Provider = p
						})
						.Select(g => g.PackageService)
						.ExecuteDelete();

					/*
					foreach (var service in servicesToRemove) package.Services.Remove(service);

					SaveChanges();
					*/
				}

				// check if the service is already distributed
				var serviceIdQuery = PackageServices
					.Where(ps => ps.PackageId == packageId)
					.Join(Services, ps => ps.ServiceId, s => s.ServiceId, (ps, s) => s)
					.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => new
					{
						Service = s,
						Provider = p
					})
					.Where(g => g.Provider.GroupId == groupId)
					.Select(g => g.Service.ServiceId);

				serviceId = serviceIdQuery
					.FirstOrDefault();

				if (serviceId != 0) return serviceId;

				// distribute services
				DistributePackageServices(actorId, packageId);

				// get distributed service again
				serviceId = serviceIdQuery
					.FirstOrDefault();

				return serviceId;
			}
			else
			{
				SqlParameter prmServiceId = new SqlParameter("@ServiceID", SqlDbType.Int);
				prmServiceId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackageServiceID",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@groupName", groupName),
	                new SqlParameter("@UpdatePackage", updatePackage),
					prmServiceId);

				return Convert.ToInt32(prmServiceId.Value);
			}
		}

		public string GetMailFilterURL(int actorId, int packageId, string groupName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetFilterURL]
(
 @ActorID int,
 @PackageID int,
 @GroupName nvarchar(100),
 @FilterUrl nvarchar(200) OUTPUT
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- load group info
DECLARE @GroupID int
SELECT @GroupID = GroupID FROM ResourceGroups
WHERE GroupName = @GroupName

--print @GroupID 

Declare @ServiceID int
SELECT @ServiceID = PS.ServiceID FROM PackageServices AS PS
INNER JOIN Services AS S ON PS.ServiceID = S.ServiceID
INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
WHERE PS.PackageID = @PackageID AND P.GroupID = @GroupID

SELECT
 @FilterUrl = PropertyValue
 FROM ServiceProperties AS SP
 WHERE @ServiceID = SP.ServiceID AND PropertyName = 'apiurl'
-- print  @FilterUrl
RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var groupId = ResourceGroups
					.Where(g => g.GroupName == groupName)
					.Select(g => g.GroupId)
					.FirstOrDefault();
				var package = Packages
					.Include(p => p.Services)
					.FirstOrDefault(p => p.PackageId == packageId);
				var serviceId = package.Services
					.Join(Providers, s => s.ProviderId, p => p.ProviderId, (s, p) => new
					{
						s.ServiceId,
						p.GroupId
					})
					.Where(s => s.GroupId == groupId)
					.Select(s => s.ServiceId)
					.FirstOrDefault();
				var filterUrl = ServiceProperties
					.Where(p => p.ServiceId == serviceId && p.PropertyName == "apiurl")
					.Select(p => p.PropertyValue)
					.FirstOrDefault();
				return filterUrl;
			}
			else
			{
				SqlParameter prmFilterUrl = new SqlParameter("@FilterUrl", SqlDbType.NVarChar, 200);
				prmFilterUrl.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetFilterURL",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@GroupName", groupName),
					prmFilterUrl);

				return Convert.ToString(prmFilterUrl.Value);
			}
		}

		public string GetMailFilterUrlByHostingPlan(int actorId, int PlanID, string groupName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetFilterURLByHostingPlan]
(
 @ActorID int,
 @PlanID int,
 @GroupName nvarchar(100),
 @FilterUrl nvarchar(200) OUTPUT
)
AS 

-- load ServerID info
DECLARE @ServerID int
select @ServerID = HostingPlans.ServerID from HostingPlans where PlanID = @PlanID
--print @ServerID 

--Check Server Type
DECLARE @IsVirtualServer int
select @IsVirtualServer = VirtualServer from Servers where ServerID = @ServerID

-- load group info
DECLARE @GroupID int
SELECT @GroupID = GroupID FROM ResourceGroups
WHERE GroupName = @GroupName
--print @GroupID 

-- load ProviderID info
DECLARE @ProviderID int
select @ProviderID = providerid from Providers 
where GroupID = @GroupID  and ProviderName = 'MailCleaner'

Declare @ServiceID int
if  (@IsVirtualServer = 1)
	select @ServiceID = Services.ServiceID from Services   
	Join VirtualServices vs on vs.ServerID = @ServerID and vs.ServiceID = Services.ServiceID
	where ProviderID = @ProviderID
ELSE
 BEGIN
	select  @ServiceID = Services.ServiceID from Services  
	Where Services.ProviderID = @ProviderID and Services.ServerID = @ServerID
END; 

SELECT
 @FilterUrl = PropertyValue
 FROM ServiceProperties AS SP
 WHERE @ServiceID = SP.ServiceID AND PropertyName = 'apiurl'
 --print @FilterUrl
RETURN
				*/
				#endregion

				// load ServerID info
				var serverId = HostingPlans
					.Where(p => p.PlanId == PlanID)
					.Select(p => p.ServerId)
					.FirstOrDefault();
				var isVirtualServer = Servers
					.Where(s => s.ServerId == serverId)
					.Select(s => s.VirtualServer)
					.FirstOrDefault();
				var providerId = ResourceGroups
					.Where(g => g.GroupName == groupName)
					.Join(Providers, r => r.GroupId, p => p.GroupId, (r, p) => p)
					.Where(p => p.ProviderName == "MailCleaner")
					.Select(p => p.ProviderId)
					.FirstOrDefault();
				int serviceId;
				if (isVirtualServer)
				{
					serviceId = Services
						.Join(VirtualServices, s => s.ServiceId, v => v.ServiceId, (s, v) => new
						{
							Service = s,
							VirtualService = v
						})
						.Where(s => s.VirtualService.ServerId == serverId && s.Service.ProviderId == providerId)
						.Select(s => s.Service.ServiceId)
						.FirstOrDefault();
				}
				else
				{
					serviceId = Services
						.Where(s => s.ServerId == serverId && s.ProviderId == providerId)
						.Select(s => s.ServiceId)
						.FirstOrDefault();
				}
				var filterUrl = ServiceProperties
					.Where(p => p.ServiceId == serviceId && p.PropertyName == "apiurl")
					.Select(p => p.PropertyValue)
					.FirstOrDefault();
				return filterUrl;
			}
			else
			{
				SqlParameter prmFilterUrl = new SqlParameter("@FilterUrl", SqlDbType.NVarChar, 200);
				prmFilterUrl.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetFilterURLByHostingPlan",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@PlanID", PlanID),
					new SqlParameter("@GroupName", groupName),
					prmFilterUrl);

				return Convert.ToString(prmFilterUrl.Value);
			}
		}


		public void UpdatePackageDiskSpace(int packageId, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdatePackageDiskSpace]
(
	@PackageID int,
	@xml ntext
)
AS
DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @xml
-- Execute a SELECT statement that uses the OPENXML rowset provider.

DECLARE @Items TABLE
(
	ItemID int,
	Bytes bigint
)

INSERT INTO @Items (ItemID, Bytes)
SELECT ItemID, DiskSpace FROM OPENXML (@idoc, '/items/item',1)
WITH
(
	ItemID int '@id',
	DiskSpace bigint '@bytes'
) as XSI

-- remove current diskspace
DELETE FROM PackagesDiskspace
WHERE PackageID = @PackageID

-- update package diskspace
INSERT INTO PackagesDiskspace (PackageID, GroupID, Diskspace)
SELECT
	@PackageID,
	SIT.GroupID,
	SUM(I.Bytes)
FROM @Items AS I
INNER JOIN ServiceItems AS SI ON I.ItemID = SI.ItemID
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
GROUP BY SIT.GroupID

-- remove document
exec sp_xml_removedocument @idoc

RETURN
				*/
				#endregion

				// remove current diskspace
				PackagesDiskspaces.Where(d => d.PackageId == packageId).ExecuteDelete();

				var items = XElement.Parse(xml)
					.Elements()
					.Select(e => new
					{
						ItemId = (int)e.Attribute("id"),
						Bytes = (long)e.Attribute("bytes")
					})
					.ToArray();
				using (var tempIds = items.Select(item => item.ItemId).ToTempIdSet(this))
				{
					var diskspace = tempIds
						.Join(ServiceItems, id => id, s => s.ItemId, (it, s) => s)
						.Join(ServiceItemTypes, s => s.ItemTypeId, t => t.ItemTypeId, (s, t) => new
						{
							s.ItemId,
							t.GroupId
						})
						.Where(s => s.GroupId != null)
						.AsEnumerable()
						.Join(items, s => s.ItemId, item => item.ItemId, (s, item) => new
						{
							GroupId = s.GroupId.Value,
							item.Bytes
						})
						.GroupBy(s => s.GroupId)
						.Select(g => new Data.Entities.PackagesDiskspace
						{
							PackageId = packageId,
							GroupId = g.Key,
							DiskSpace = g.Sum(s => s.Bytes)
						});
					PackagesDiskspaces.AddRange(diskspace);
					SaveChanges();
				}
			}
			else
			{
				ExecuteLongNonQuery(
					ObjectQualifier + "UpdatePackageDiskSpace",
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@xml", xml));
			}
		}

		public void UpdatePackageBandwidth(int packageId, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdatePackageBandwidth]
(
	@PackageID int,
	@xml ntext
)
AS
DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

DECLARE @Items TABLE
(
	ItemID int,
	LogDate datetime,
	BytesSent bigint,
	BytesReceived bigint
)

INSERT INTO @Items
(
	ItemID,
	LogDate,
	BytesSent,
	BytesReceived
)
SELECT
	ItemID,
	CONVERT(datetime, LogDate, 101),
	BytesSent,
	BytesReceived
FROM OPENXML(@idoc, '/items/item',1) WITH
(
	ItemID int '@id',
	LogDate nvarchar(10) '@date',
    BytesSent bigint '@sent',
    BytesReceived bigint '@received'
)

-- delete current statistics
DELETE FROM PackagesBandwidth
FROM PackagesBandwidth AS PB
INNER JOIN (
	SELECT
		SIT.GroupID,
		I.LogDate
	FROM @Items AS I
	INNER JOIN ServiceItems AS SI ON I.ItemID = SI.ItemID
	INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
	GROUP BY I.LogDate, SIT.GroupID
) AS STAT ON PB.LogDate = STAT.LogDate AND PB.GroupID = STAT.GroupID
WHERE PB.PackageID = @PackageID

-- insert new statistics
INSERT INTO PackagesBandwidth (PackageID, GroupID, LogDate, BytesSent, BytesReceived)
SELECT
	@PackageID,
	SIT.GroupID,
	I.LogDate,
	SUM(I.BytesSent),
	SUM(I.BytesReceived)
FROM @Items AS I
INNER JOIN ServiceItems AS SI ON I.ItemID = SI.ItemID
INNER JOIN ServiceItemTypes AS SIT ON SI.ItemTypeID = SIT.ItemTypeID
GROUP BY I.LogDate, SIT.GroupID

-- remove document
exec sp_xml_removedocument @idoc

RETURN
				*/
				#endregion

				var items = XElement.Parse(xml)
					.Elements()
					.Select(e => new
					{
						ItemId = (int)e.Attribute("id"),
						LogDate = DateTime.Parse((string)e.Attribute("date")),
						BytesSent = (long)e.Attribute("sent"),
						BytesReceived = (long)e.Attribute("received")
					})
					.ToArray();

				using (var itemIds = items.Select(item => item.ItemId).ToTempIdSet(this))
				{
					// delete current statistics
					var groupedItems = itemIds
						.Join(ServiceItems, i => i, s => s.ItemId, (i, s) => s)
						.Join(ServiceItemTypes, i => i.ItemTypeId, t => t.ItemTypeId, (i, t) => new
						{
							ItemId = i.ItemId,
							GroupId = t.GroupId
						})
						.Where(s => s.GroupId != null)
						.AsEnumerable()
						.Join(items, s => s.ItemId, i => i.ItemId, (s, i) => new
						{
							GroupId = s.GroupId.Value,
							i.LogDate,
							i.BytesSent,
							i.BytesReceived
						})
						.GroupBy(i => new DatedId { Date = i.LogDate, Id = i.GroupId });

					using (var tempKeys = groupedItems.Select(g => g.Key).ToTempDatedIdSet(this))
					{
						var bandwidthsToDelete = PackagesBandwidths
							.Where(pb => pb.PackageId == packageId)
							.Join(tempKeys,
								pb => new DatedId { Date = pb.LogDate, Id = pb.GroupId }, k => k, (pb, k) => pb);

						using (var transaction = Database.BeginTransaction())
						{
							bandwidthsToDelete.ExecuteDelete();

							// insert new statistics
							var newBandwiths = groupedItems
								.Select(item => new Data.Entities.PackagesBandwidth
								{
									PackageId = packageId,
									GroupId = item.Key.Id,
									LogDate = item.Key.Date,
									BytesSent = item.Sum(x => x.BytesSent),
									BytesReceived = item.Sum(x => x.BytesReceived)
								});
							PackagesBandwidths.AddRange(newBandwiths);

							SaveChanges();

							transaction.Commit();
						}
					}
				}
			}
			else
			{
				ExecuteLongNonQuery(
					ObjectQualifier + "UpdatePackageBandwidth",
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@xml", xml));
			}
		}

		public DateTime GetPackageBandwidthUpdate(int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageBandwidthUpdate]
(
	@PackageID int,
	@UpdateDate datetime OUTPUT
)
AS
	SELECT @UpdateDate = BandwidthUpdated FROM Packages
	WHERE PackageID = @PackageID
RETURN
				*/
				#endregion

				return Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => p.BandwidthUpdated)
					.FirstOrDefault() ??
					default(DateTime);
			}
			else
			{
				SqlParameter prmUpdateDate = new SqlParameter("@UpdateDate", SqlDbType.DateTime);
				prmUpdateDate.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackageBandwidthUpdate",
					prmUpdateDate,
					new SqlParameter("@packageId", packageId));

				return (prmUpdateDate.Value != DBNull.Value) ? Convert.ToDateTime(prmUpdateDate.Value) : DateTime.MinValue;
			}
		}

		public void UpdatePackageBandwidthUpdate(int packageId, DateTime updateDate)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdatePackageBandwidthUpdate]
(
	@PackageID int,
	@UpdateDate datetime
)
AS

UPDATE Packages SET BandwidthUpdated = @UpdateDate
WHERE PackageID = @PackageID

RETURN
				*/
				#endregion

#if NETCOREAPP
				Packages.Where(p => p.PackageId == packageId).ExecuteUpdate(set => set.SetProperty(p => p.BandwidthUpdated, updateDate));
#else
				foreach (var package in Packages.Where(p => p.PackageId == packageId)) package.BandwidthUpdated = updateDate;
				SaveChanges();
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdatePackageBandwidthUpdate",
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@updateDate", updateDate));
			}
		}

		public IDataReader GetServiceItemType(int itemTypeId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItemType]
(
	@ItemTypeID int
)
AS
SELECT
	[ItemTypeID],
	[GroupID],
	[DisplayName],
	[TypeName],
	[TypeOrder],
	[CalculateDiskspace],
	[CalculateBandwidth],
	[Suspendable],
	[Disposable],
	[Searchable],
	[Importable],
	[Backupable]
FROM
	[ServiceItemTypes]
WHERE
	[ItemTypeID] = @ItemTypeID
				*/
				#endregion

				var type = ServiceItemTypes
					.Where(t => t.ItemTypeId == itemTypeId);
				return EntityDataReader(type);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetServiceItemType",
					new SqlParameter("@ItemTypeID", itemTypeId));
			}
		}

		public IDataReader GetServiceItemTypes()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetServiceItemTypes]
AS
SELECT
	[ItemTypeID],
	[GroupID],
	[DisplayName],
	[TypeName],
	[TypeOrder],
	[CalculateDiskspace],
	[CalculateBandwidth],
	[Suspendable],
	[Disposable],
	[Searchable],
	[Importable],
	[Backupable]
FROM
	[ServiceItemTypes]
ORDER BY TypeOrder
				*/
				#endregion

				var types = ServiceItemTypes
					.OrderBy(t => t.TypeOrder);
				return EntityDataReader(types);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetServiceItemTypes");
			}
		}
#endregion

		#region Plans
		// Plans methods
		public DataSet GetHostingPlans(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetHostingPlans]
(
	@ActorID int,
	@UserID int
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

SELECT
	HP.PlanID,
	HP.UserID,
	HP.PackageID,
	HP.PlanName,
	HP.PlanDescription,
	HP.Available,
	HP.SetupPrice,
	HP.RecurringPrice,
	HP.RecurrenceLength,
	HP.RecurrenceUnit,
	HP.IsAddon,

	(SELECT COUNT(P.PackageID) FROM Packages AS P WHERE P.PlanID = HP.PlanID) AS PackagesNumber,

	-- server
	ISNULL(HP.ServerID, 0) AS ServerID,
	ISNULL(S.ServerName, 'None') AS ServerName,
	ISNULL(S.Comments, '') AS ServerComments,
	ISNULL(S.VirtualServer, 1) AS VirtualServer,

	-- package
	ISNULL(HP.PackageID, 0) AS PackageID,
	ISNULL(P.PackageName, 'None') AS PackageName

FROM HostingPlans AS HP
LEFT OUTER JOIN Servers AS S ON HP.ServerID = S.ServerID
LEFT OUTER JOIN Packages AS P ON HP.PackageID = P.PackageID
WHERE
	HP.UserID = @UserID
	AND HP.IsAddon = 0
ORDER BY HP.PlanName
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var plans = HostingPlans
					.Where(pl => pl.UserId == userId && pl.IsAddon == false)
					.OrderBy(pl => pl.PlanName)
					// we have to do a GroupJoin here since hp.Packages is not related to hp.PackageId
					.GroupJoin(Packages, hp => hp.PackageId, p => p.PackageId, (hp, ps) => new
					{
						Plan = hp,
						Packages = ps
					})
					.SelectMany(pl => pl.Packages.DefaultIfEmpty(), (pl, p) => new
					{
						pl.Plan.PlanId,
						pl.Plan.UserId,
						pl.Plan.PackageId,
						pl.Plan.PlanName,
						pl.Plan.PlanDescription,
						pl.Plan.Available,
						pl.Plan.SetupPrice,
						pl.Plan.RecurringPrice,
						pl.Plan.RecurrenceLength,
						pl.Plan.RecurrenceUnit,
						pl.Plan.IsAddon,
						PackagesNumber = pl.Plan.Packages.Count(),
						// server
						ServerId = pl.Plan.ServerId != null ? pl.Plan.ServerId : 0,
						ServerName = pl.Plan.Server != null ? pl.Plan.Server.ServerName : "None",
						ServerComments = pl.Plan.Server != null ? pl.Plan.Server.Comments : "",
						VirtualServer = pl.Plan.Server != null ? pl.Plan.Server.VirtualServer : true,
						// package
						PackageName = p != null ? p.PackageName : "None"

					});
				return EntityDataSet(plans);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
				ObjectQualifier + "GetHostingPlans",
				new SqlParameter("@actorId", actorId),
				new SqlParameter("@userId", userId));
			}
		}

		public DataSet GetHostingAddons(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetHostingAddons]
(
	@ActorID int,
	@UserID int
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

SELECT
	PlanID,
	UserID,
	PackageID,
	PlanName,
	PlanDescription,
	Available,
	SetupPrice,
	RecurringPrice,
	RecurrenceLength,
	RecurrenceUnit,
	IsAddon,
	(SELECT COUNT(P.PackageID) FROM PackageAddons AS P WHERE P.PlanID = HP.PlanID) AS PackagesNumber
FROM
	HostingPlans AS HP
WHERE
	UserID = @UserID
	AND IsAddon = 1
ORDER BY PlanName
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var plans = HostingPlans
					.Where(pl => pl.UserId == userId && pl.IsAddon == true)
					.OrderBy(pl => pl.PlanName)
					.Select(pl => new
					{
						pl.PlanId,
						pl.UserId,
						pl.PackageId,
						pl.PlanName,
						pl.PlanDescription,
						pl.Available,
						pl.SetupPrice,
						pl.RecurringPrice,
						pl.RecurrenceLength,
						pl.RecurrenceUnit,
						pl.IsAddon,
						PackagesNumber = pl.Packages.Count(),
					});
				return EntityDataSet(plans);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetHostingAddons",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@userId", userId));
			}
		}

		public DataSet GetUserAvailableHostingPlans(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserAvailableHostingPlans]
(
	@ActorID int,
	@UserID int
)
AS

-- user should see the plans only of his reseller
-- also user can create packages based on his own plans (admins and resellers)

DECLARE @Plans TABLE
(
	PlanID int
)

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

DECLARE @OwnerID int
SELECT @OwnerID = OwnerID FROM Users
WHERE UserID = @UserID

SELECT
	HP.PlanID,
	HP.PackageID,
	HP.PlanName,
	HP.PlanDescription,
	HP.Available,
	HP.ServerID,
	HP.SetupPrice,
	HP.RecurringPrice,
	HP.RecurrenceLength,
	HP.RecurrenceUnit,
	HP.IsAddon
FROM
	HostingPlans AS HP
WHERE HP.UserID = @OwnerID
AND HP.IsAddon = 0
ORDER BY PlanName
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var ownerId = Users
					.Where(u => u.UserId == userId)
					.Select(u => u.OwnerId)
					.FirstOrDefault();

				var plans = HostingPlans
					.Where(pl => pl.UserId == ownerId && pl.IsAddon == false)
					.OrderBy(pl => pl.PlanName)
					.Select(pl => new
					{
						pl.PlanId,
						pl.PackageId,
						pl.PlanName,
						pl.PlanDescription,
						pl.Available,
						pl.ServerId,
						pl.SetupPrice,
						pl.RecurringPrice,
						pl.RecurrenceLength,
						pl.RecurrenceUnit,
						pl.IsAddon
					});
				return EntityDataSet(plans);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetUserAvailableHostingPlans",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@userId", userId));
			}
		}

		public DataSet GetUserAvailableHostingAddons(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserAvailableHostingAddons]
(
	@ActorID int,
	@UserID int
)
AS

-- user should see the plans only of his reseller
-- also user can create packages based on his own plans (admins and resellers)

DECLARE @Plans TABLE
(
	PlanID int
)

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

DECLARE @OwnerID int
SELECT @OwnerID = OwnerID FROM Users
WHERE UserID = @UserID

SELECT
	HP.PlanID,
	HP.PackageID,
	HP.PlanName,
	HP.PlanDescription,
	HP.Available,
	HP.ServerID,
	HP.SetupPrice,
	HP.RecurringPrice,
	HP.RecurrenceLength,
	HP.RecurrenceUnit,
	HP.IsAddon
FROM
	HostingPlans AS HP
WHERE HP.UserID = @OwnerID
AND HP.IsAddon = 1
ORDER BY PlanName
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var ownerId = Users
					.Where(u => u.UserId == userId)
					.Select(u => u.OwnerId)
					.FirstOrDefault();

				var plans = HostingPlans
					.Where(pl => pl.UserId == ownerId && pl.IsAddon == true)
					.OrderBy(pl => pl.PlanName)
					.Select(pl => new
					{
						pl.PlanId,
						pl.PackageId,
						pl.PlanName,
						pl.PlanDescription,
						pl.Available,
						pl.ServerId,
						pl.SetupPrice,
						pl.RecurringPrice,
						pl.RecurrenceLength,
						pl.RecurrenceUnit,
						pl.IsAddon
					});
				return EntityDataSet(plans);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetUserAvailableHostingAddons",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@userId", userId));
			}
		}

		public IDataReader GetHostingPlan(int actorId, int planId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetHostingPlan]
(
	@ActorID int,
	@PlanID int
)
AS

SELECT
	PlanID,
	UserID,
	PackageID,
	ServerID,
	PlanName,
	PlanDescription,
	Available,
	SetupPrice,
	RecurringPrice,
	RecurrenceLength,
	RecurrenceUnit,
	IsAddon
FROM HostingPlans AS HP
WHERE HP.PlanID = @PlanID

RETURN				
				*/
				#endregion

				var plans = HostingPlans
					.Where(p => p.PlanId == planId)
					.Select(p => new
					{
						p.PlanId,
						p.UserId,
						p.PackageId,
						p.ServerId,
						p.PlanName,
						p.PlanDescription,
						p.Available,
						p.SetupPrice,
						p.RecurringPrice,
						p.RecurrenceLength,
						p.RecurrenceUnit,
						p.IsAddon
					});
				return EntityDataReader(plans);
			}
			else
			{
				return (IDataReader)SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetHostingPlan",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PlanId", planId));
			}
		}

		public bool CheckActorParentPackageRights(int actorId, int? packageId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CheckActorParentPackageRights]
(
	@ActorID int,
	@PackageID int
)
RETURNS bit
AS
BEGIN

IF @ActorID = -1 OR @PackageID IS NULL
RETURN 1

-- get package owner
DECLARE @UserID int
SELECT @UserID = UserID FROM Packages
WHERE PackageID = @PackageID

IF @UserID IS NULL
RETURN 1 -- unexisting package

-- check user
RETURN dbo.CanGetUserDetails(@ActorID, @UserID)

RETURN 0
END
			*/
			#endregion

			if (actorId == -1 || packageId == null) return true;

			// get package owner
			var userId = Packages
				.Where(p => p.PackageId == packageId)
				.Select(p => (int?)p.UserId)
				.FirstOrDefault();
			if (userId == null) return true;

			// check user
			return CanGetUserDetails(actorId, userId ?? -1);
		}

		public bool GetPackageServiceLevelResource(int? packageId, int groupId, int? serverId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[GetPackageServiceLevelResource]
(
	@PackageID int,
	@GroupID int,
	@ServerID int
)
RETURNS bit
AS
BEGIN

IF NOT EXISTS (SELECT * FROM dbo.ResourceGroups WHERE GroupID = @GroupID AND GroupName = 'Service Levels')
RETURN 0

IF @PackageID IS NULL
RETURN 1

DECLARE @Result bit
SET @Result = 1 -- enabled

DECLARE @PID int, @ParentPackageID int
SET @PID = @PackageID

DECLARE @OverrideQuotas bit

IF @ServerID IS NULL OR @ServerID = 0
SELECT @ServerID = ServerID FROM Packages
WHERE PackageID = @PackageID

WHILE 1 = 1
BEGIN

	DECLARE @GroupEnabled int

	-- get package info
	SELECT
		@ParentPackageID = ParentPackageID,
		@OverrideQuotas = OverrideQuotas
	FROM Packages WHERE PackageID = @PID

	-- check if this is a root 'System' package
	SET @GroupEnabled = 1 -- enabled
	IF @ParentPackageID IS NULL
	BEGIN

		IF @ServerID = 0
		RETURN 0
		ELSE IF @PID = -1
		RETURN 1
		ELSE IF @ServerID IS NULL
		RETURN 1
		ELSE IF @ServerID > 0
		RETURN 1
		ELSE RETURN 0
	END
	ELSE -- parentpackage is not null
	BEGIN
		-- check the current package
		IF @OverrideQuotas = 1
		BEGIN
			IF NOT EXISTS(
				SELECT GroupID FROM PackageResources WHERE GroupID = @GroupID AND PackageID = @PID
			)
			SET @GroupEnabled = 0
		END
		ELSE
		BEGIN
			IF NOT EXISTS(
				SELECT HPR.GroupID FROM Packages AS P
				INNER JOIN HostingPlanResources AS HPR ON P.PlanID = HPR.PlanID
				WHERE HPR.GroupID = @GroupID AND P.PackageID = @PID
			)
			SET @GroupEnabled = 0
		END

		-- check addons
		IF EXISTS(
			SELECT HPR.GroupID FROM PackageAddons AS PA
			INNER JOIN HostingPlanResources AS HPR ON PA.PlanID = HPR.PlanID
			WHERE HPR.GroupID = @GroupID AND PA.PackageID = @PID
			AND PA.StatusID = 1 -- active add-on
		)
		SET @GroupEnabled = 1
	END

	IF @GroupEnabled = 0
		RETURN 0

	SET @PID = @ParentPackageID

END -- end while

RETURN @Result
END
			*/
			#endregion

			if (!ResourceGroups.Any(g => g.GroupId == groupId && g.GroupName == "Service Levels")) return false;

			if (packageId == null) return true;

			int? pid = packageId;
			var package = Packages
				.Where(p => p.PackageId == pid)
				.Select(p => new
				{
					p.ServerId,
					p.ParentPackageId,
					p.OverrideQuotas
				})
				.FirstOrDefault();

			if (serverId == null || serverId == 0) serverId = package?.ServerId;

			bool groupEnabled = true;
			while (groupEnabled)
			{
				// check if this is a root "System" package
				if (package.ParentPackageId == null)
				{
					return serverId != 0 && (pid == -1 || serverId == null || serverId > 0);
				}
				else
				{
					// check the current package
					if (package.OverrideQuotas)
					{
						if (!PackageResources.Any(r => r.GroupId == groupId && r.PackageId == pid))
						{
							groupEnabled = false;
						}
					}
					else
					{
						if (!Packages
							.Where(p => p.PackageId == pid)
							.Join(HostingPlanResources, p => p.PlanId, hr => hr.PlanId, (p, hr) => hr)
							.Any(hr => hr.GroupId == groupId))
						{
							groupEnabled = false;
						}
					}

					// check addons
					if (PackageAddons
						.Where(a => a.PackageId == pid && a.StatusId == 1)
						.Join(HostingPlanResources, a => a.PlanId, hr => hr.PlanId, (a, hr) => hr)
						.Any(hr => hr.GroupId == groupId))
					{
						groupEnabled = true;
					}
				}

				pid = package.ParentPackageId;
				package = Packages
					.Where(p => p.PackageId == pid)
					.Select(p => new
					{
						p.ServerId,
						p.ParentPackageId,
						p.OverrideQuotas
					})
					.FirstOrDefault();
			}

			return false;
		}

		public int GetPackageAllocatedQuota(int? packageId, int quotaId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[GetPackageAllocatedQuota]
(
	@PackageID int,
	@QuotaID int
)
RETURNS int
AS
BEGIN

DECLARE @Result int

DECLARE @QuotaTypeID int
SELECT @QuotaTypeID = QuotaTypeID FROM Quotas
WHERE QuotaID = @QuotaID

IF @QuotaTypeID = 1
	SET @Result = 1 -- enabled
ELSE
	SET @Result = -1 -- unlimited

DECLARE @PID int, @ParentPackageID int
SET @PID = @PackageID

DECLARE @OverrideQuotas bit

WHILE 1 = 1
BEGIN

	DECLARE @QuotaValue int

	-- get package info
	SELECT
		@ParentPackageID = ParentPackageID,
		@OverrideQuotas = OverrideQuotas
	FROM Packages WHERE PackageID = @PID

	SET @QuotaValue = NULL

	-- check if this is a root 'System' package
	IF @ParentPackageID IS NULL
	BEGIN
		IF @QuotaTypeID = 1 -- boolean
			SET @QuotaValue = 1 -- enabled
		ELSE IF @QuotaTypeID > 1 -- numeric
			SET @QuotaValue = -1 -- unlimited
	END
	ELSE
	BEGIN
		-- check the current package
		IF @OverrideQuotas = 1
			SELECT @QuotaValue = QuotaValue FROM PackageQuotas WHERE QuotaID = @QuotaID AND PackageID = @PID
		ELSE
			SELECT @QuotaValue = HPQ.QuotaValue FROM Packages AS P
			INNER JOIN HostingPlanQuotas AS HPQ ON P.PlanID = HPQ.PlanID
			WHERE HPQ.QuotaID = @QuotaID AND P.PackageID = @PID

		IF @QuotaValue IS NULL
		SET @QuotaValue = 0

		-- check package addons
		DECLARE @QuotaAddonValue int
		SELECT
			@QuotaAddonValue = SUM(HPQ.QuotaValue * PA.Quantity)
		FROM PackageAddons AS PA
		INNER JOIN HostingPlanQuotas AS HPQ ON PA.PlanID = HPQ.PlanID
		WHERE PA.PackageID = @PID AND HPQ.QuotaID = @QuotaID AND PA.StatusID = 1 -- active

		-- process bool quota
		IF @QuotaAddonValue IS NOT NULL
		BEGIN
			IF @QuotaTypeID = 1
			BEGIN
				IF @QuotaAddonValue > 0 AND @QuotaValue = 0 -- enabled
				SET @QuotaValue = 1
			END
			ELSE
			BEGIN -- numeric quota
				IF @QuotaAddonValue < 0 -- unlimited
					SET @QuotaValue = -1
				ELSE
					SET @QuotaValue = @QuotaValue + @QuotaAddonValue
			END
		END
	END

	-- process bool quota
	IF @QuotaTypeID = 1
	BEGIN
		IF @QuotaValue = 0 OR @QuotaValue IS NULL -- disabled
		RETURN 0
	END
	ELSE
	BEGIN -- numeric quota
		IF @QuotaValue = 0 OR @QuotaValue IS NULL -- zero quantity
		RETURN 0

		IF (@QuotaValue <> -1 AND @Result = -1) OR (@QuotaValue < @Result AND @QuotaValue <> -1)
			SET @Result = @QuotaValue
	END

	IF @ParentPackageID IS NULL
	RETURN @Result -- exit from the loop

	SET @PID = @ParentPackageID

END -- end while

RETURN @Result
END
			*/
			#endregion

			int result;

			var quotaTypeId = Quotas
				.Where(q => q.QuotaId == quotaId)
				.Select(q => q.QuotaTypeId)
				.FirstOrDefault();

			if (quotaTypeId == 1) result = 1; // enabled
			else result = -1; // unlimited

			int? pid = packageId;

			while (pid != null)
			{
				var package = Packages
					.Where(p => p.PackageId == pid)
					.Select(p => new
					{
						p.ParentPackageId,
						p.OverrideQuotas
					})
					.FirstOrDefault();

				int? quotaValue = null;

				// check if this is a root 'System' package
				if (package.ParentPackageId == null)
				{
					if (quotaTypeId == 1) // boolean
						quotaValue = 1; // enabled
					else if (quotaTypeId > 1) // numeric
						quotaValue = -1; // unlimited
				}
				else
				{
					// check the current package
					if (package.OverrideQuotas)
					{
						quotaValue = PackageQuotas
							.Where(q => q.QuotaId == quotaId && q.PackageId == pid)
							.Select(q => q.QuotaValue)
							.FirstOrDefault();
					}
					else
					{
						quotaValue = Packages
							.Where(p => p.PackageId == pid)
							.Join(HostingPlanQuotas, p => p.PlanId, hq => hq.PlanId, (p, hq) => hq)
							.Where(q => q.QuotaId == quotaId)
							.Select(q => q.QuotaValue)
							.FirstOrDefault();
					}

					if (quotaValue == null) quotaValue = 0;

					// check package addons
					int? quotaAddonValue = null;
					quotaAddonValue = PackageAddons
						.Where(p => p.PackageId == pid && p.StatusId == 1 /* active */)
						.Join(HostingPlanQuotas, a => a.PlanId, hq => hq.PlanId, (a, hq) => new
						{
							Addon = a,
							Quota = hq
						})
						.Where(q => q.Quota.QuotaId == quotaId)
						.Sum(q => (int?)(q.Quota.QuotaValue * q.Addon.Quantity ?? 0));

					// process bool quota
					if (quotaAddonValue != null)
					{
						if (quotaTypeId == 1)
						{
							if (quotaAddonValue > 0 && quotaValue == 0 /* enabled */) quotaValue = 1;
						}
						else // numeric quota
						{
							if (quotaAddonValue < 0) // unlimited
							{
								quotaValue = -1;
							}
							else
							{
								quotaValue += quotaAddonValue;
							}
						}
					}
				}

				// process bool quota
				if (quotaTypeId == 1)
				{
					if (quotaValue == 0 || quotaValue == null) return 0; // disabled
				}
				else // numeric quota
				{
					if (quotaValue == 0 || quotaValue == null) return 0; // zero quantity

					if (quotaValue != -1 && (result == -1 || quotaValue < result)) result = quotaValue.Value;
				}

				pid = package.ParentPackageId;
			}

			return result;
		}

		public DataSet GetHostingPlanQuotas(int actorId, int packageId, int planId, int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetHostingPlanQuotas]
(
	@ActorID int,
	@PlanID int,
	@PackageID int,
	@ServerID int
)
AS

-- check rights
IF dbo.CheckActorParentPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @IsAddon bit

IF @ServerID = 0
SELECT @ServerID = ServerID FROM Packages
WHERE PackageID = @PackageID

-- get resource groups
SELECT
	RG.GroupID,
	RG.GroupName,
	CASE
		WHEN HPR.CalculateDiskSpace IS NULL THEN CAST(0 as bit)
		ELSE CAST(1 as bit)
	END AS Enabled,
	--dbo.GetPackageAllocatedResource(@PackageID, RG.GroupID, @ServerID) AS ParentEnabled,
	CASE
		WHEN RG.GroupName = 'Service Levels' THEN dbo.GetPackageServiceLevelResource(@PackageID, RG.GroupID, @ServerID)
		ELSE dbo.GetPackageAllocatedResource(@PackageID, RG.GroupID, @ServerID)
	END AS ParentEnabled,
	ISNULL(HPR.CalculateDiskSpace, 1) AS CalculateDiskSpace,
	ISNULL(HPR.CalculateBandwidth, 1) AS CalculateBandwidth
FROM ResourceGroups AS RG 
LEFT OUTER JOIN HostingPlanResources AS HPR ON RG.GroupID = HPR.GroupID AND HPR.PlanID = @PlanID
WHERE (RG.ShowGroup = 1)
ORDER BY RG.GroupOrder

-- get quotas by groups
SELECT
	Q.QuotaID,
	Q.GroupID,
	Q.QuotaName,
	Q.QuotaDescription,
	Q.QuotaTypeID,
	ISNULL(HPQ.QuotaValue, 0) AS QuotaValue,
	dbo.GetPackageAllocatedQuota(@PackageID, Q.QuotaID) AS ParentQuotaValue
FROM Quotas AS Q
LEFT OUTER JOIN HostingPlanQuotas AS HPQ ON Q.QuotaID = HPQ.QuotaID AND HPQ.PlanID = @PlanID
WHERE Q.HideQuota IS NULL OR Q.HideQuota = 0
ORDER BY Q.QuotaOrder
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorParentPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				if (serverId == 0)
				{
					serverId = Packages
						.Where(p => p.PackageId == packageId)
						.Select(p => p.ServerId)
						.FirstOrDefault() ?? 0;
				}

				// get resource groups
				var groups = ResourceGroups
					.Where(r => r.ShowGroup == true)
					.OrderBy(r => r.GroupOrder)
					.GroupJoin(HostingPlanResources,
						g => new { g.GroupId, PlanId = planId },
						hr => new { hr.GroupId, hr.PlanId }, (g, hr) => new
						{
							Group = g,
							HostingPlans = hr
						})
					.SelectMany(g => g.HostingPlans.DefaultIfEmpty(), (g, plan) => new
					{
						g.Group.GroupId,
						g.Group.GroupName,
						Enabled = plan != null,
						CalculateDiskSpace = plan != null ? plan.CalculateDiskSpace : true,
						CalculateBandwidth = plan != null ? plan.CalculateBandwidth : true
					})
					.AsEnumerable()
					.Select(g => new
					{
						g.GroupId,
						g.GroupName,
						g.Enabled,
						ParentEnabled = g.GroupName == "Service Levels" ?
							Local.GetPackageServiceLevelResource(packageId, g.GroupId, serverId) :
							Local.GetPackageAllocatedResource(packageId, g.GroupId, serverId),
						g.CalculateDiskSpace,
						g.CalculateBandwidth
					});

				// get quotas by groups
				var quotas = Quotas
					.Where(q => q.HideQuota != true)
					.OrderBy(q => q.QuotaOrder)
					.GroupJoin(HostingPlanQuotas,
						q => new { q.QuotaId, PlanId = planId },
						hq => new { hq.QuotaId, hq.PlanId }, (q, hq) => new
						{
							Quota = q,
							HostingPlanQuotas = hq
						})
					.SelectMany(q => q.HostingPlanQuotas.DefaultIfEmpty(), (q, hq) => new
					{
						q.Quota.QuotaId,
						q.Quota.GroupId,
						q.Quota.QuotaName,
						q.Quota.QuotaDescription,
						q.Quota.QuotaTypeId,
						QuotaValue = hq != null ? hq.QuotaValue : 0
					})
					.AsEnumerable()
					.Select(q => new
					{
						q.QuotaId,
						q.GroupId,
						q.QuotaName,
						q.QuotaDescription,
						q.QuotaTypeId,
						q.QuotaValue,
						ParentQuotaValue = Local.GetPackageAllocatedQuota(packageId, q.QuotaId),
					});	

				return EntityDataSet(groups, quotas);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetHostingPlanQuotas",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@planId", planId),
					new SqlParameter("@serverId", serverId));
			}
		}

		public void UpdateHostingPlanQuotas(int actorId, int planId, string quotasXml)
		{
			#region Stored Procedure
			/*
CREATE PROCEDURE [dbo].[UpdateHostingPlanQuotas]
(
	@ActorID int,
	@PlanID int,
	@Xml ntext
)
AS

/*
XML Format:
<plan>
	<groups>
		<group id=""16"" enabled=""1"" calculateDiskSpace=""1"" calculateBandwidth=""1""/>
	</groups>
	<quotas>
		<quota id=""2"" value=""2""/>
	</quotas>
</plan>
*//*

-- check rights
DECLARE @UserID int
SELECT @UserID = UserID FROM HostingPlans
WHERE PlanID = @PlanID

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

-- delete old HP resources
DELETE FROM HostingPlanResources
WHERE PlanID = @PlanID

-- delete old HP quotas
DELETE FROM HostingPlanQuotas
WHERE PlanID = @PlanID

-- update HP resources
INSERT INTO HostingPlanResources
(
	PlanID,
	GroupID,
	CalculateDiskSpace,
	CalculateBandwidth
)
SELECT
	@PlanID,
	GroupID,
	CalculateDiskSpace,
	CalculateBandwidth
FROM OPENXML(@idoc, '/plan/groups/group',1) WITH
(
	GroupID int '@id',
	CalculateDiskSpace bit '@calculateDiskSpace',
	CalculateBandwidth bit '@calculateBandwidth'
) as XRG

-- update HP quotas
INSERT INTO HostingPlanQuotas
(
	PlanID,
	QuotaID,
	QuotaValue
)
SELECT
	@PlanID,
	QuotaID,
	QuotaValue
FROM OPENXML(@idoc, '/plan/quotas/quota',1) WITH
(
	QuotaID int '@id',
	QuotaValue int '@value'
) as PV

-- remove document
exec sp_xml_removedocument @idoc

RETURN
			*/
			#endregion

			var userId = HostingPlans
				.Where(p => p.PlanId == planId)
				.Select(p => p.UserId)
				.FirstOrDefault();

			// check rights
			if (!CheckActorUserRights(actorId, userId))
				throw new AccessViolationException("You are not allowed to access this account");

			var xml = XElement.Parse(quotasXml);
			var groups = xml.Element("groups")
				.Elements()
				.Select(e => new Data.Entities.HostingPlanResource
				{
					PlanId = planId,
					GroupId = (int)e.Attribute("id"),
					CalculateDiskSpace = (int)e.Attribute("calculateDiskSpace") == 1,
					CalculateBandwidth = (int)e.Attribute("calculateBandwith") == 1
				});
			var quotas = xml.Element("quotas")
				.Elements()
				.Select(e => new Data.Entities.HostingPlanQuota
				{
					PlanId = planId,
					QuotaId = (int)e.Attribute("id"),
					QuotaValue = (int)e.Attribute("value")
				});

			// delete old HP resources
			HostingPlanResources.Where(r => r.PlanId == planId).ExecuteDelete();

			// delete old HP quotas
			HostingPlanQuotas.Where(q => q.PlanId == planId).ExecuteDelete();

			HostingPlanResources.AddRange(groups);
			HostingPlanQuotas.AddRange(quotas);

			SaveChanges();
		}
		public int AddHostingPlan(int actorId, int userId, int packageId, string planName,
			string planDescription, bool available, int serverId, decimal setupPrice, decimal recurringPrice,
			int recurrenceUnit, int recurrenceLength, bool isAddon, string quotasXml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddHostingPlan]
(
	@ActorID int,
	@PlanID int OUTPUT,
	@UserID int,
	@PackageID int,
	@PlanName nvarchar(200),
	@PlanDescription ntext,
	@Available bit,
	@ServerID int,
	@SetupPrice money,
	@RecurringPrice money,
	@RecurrenceLength int,
	@RecurrenceUnit int,
	@IsAddon bit,
	@QuotasXml ntext
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

BEGIN TRAN

IF @ServerID = 0
SELECT @ServerID = ServerID FROM Packages
WHERE PackageID = @PackageID

IF @IsAddon = 1
SET @ServerID = NULL

IF @PackageID = 0 SET @PackageID = NULL

INSERT INTO HostingPlans
(
	UserID,
	PackageID,
	PlanName,
	PlanDescription,
	Available,
	ServerID,
	SetupPrice,
	RecurringPrice,
	RecurrenceLength,
	RecurrenceUnit,
	IsAddon
)
VALUES
(
	@UserID,
	@PackageID,
	@PlanName,
	@PlanDescription,
	@Available,
	@ServerID,
	@SetupPrice,
	@RecurringPrice,
	@RecurrenceLength,
	@RecurrenceUnit,
	@IsAddon
)

SET @PlanID = SCOPE_IDENTITY()

-- save quotas
EXEC UpdateHostingPlanQuotas @ActorID, @PlanID, @QuotasXml

COMMIT TRAN
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				if (serverId == 0)
				{
					serverId = Packages
						.Where(p => p.PackageId == packageId)
						.Select(p => p.ServerId)
						.FirstOrDefault() ?? 0;
				}

				using (var transaction = Database.BeginTransaction())
				{
					var plan = new Data.Entities.HostingPlan()
					{
						UserId = userId,
						PackageId = packageId != 0 ? packageId : null,
						PlanName = planName,
						PlanDescription = planDescription,
						Available = available,
						ServerId = serverId != 0 && !isAddon ? serverId : null,
						SetupPrice = setupPrice,
						RecurringPrice = recurringPrice,
						RecurrenceLength = recurrenceLength,
						RecurrenceUnit = recurrenceUnit,
						IsAddon = isAddon
					};
					HostingPlans.Add(plan);
					SaveChanges();

					// save quotas
					UpdateHostingPlanQuotas(actorId, plan.PlanId, quotasXml);

					transaction.Commit();

					return plan.PlanId;
				}
			}
			else
			{
				SqlParameter prmPlanId = new SqlParameter("@PlanID", SqlDbType.Int);
				prmPlanId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddHostingPlan",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@userId", userId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@planName", planName),
					new SqlParameter("@planDescription", planDescription),
					new SqlParameter("@available", available),
					new SqlParameter("@serverId", serverId),
					new SqlParameter("@setupPrice", setupPrice),
					new SqlParameter("@recurringPrice", recurringPrice),
					new SqlParameter("@recurrenceUnit", recurrenceUnit),
					new SqlParameter("@recurrenceLength", recurrenceLength),
					new SqlParameter("@isAddon", isAddon),
					new SqlParameter("@quotasXml", quotasXml),
					prmPlanId);

				// read identity
				return Convert.ToInt32(prmPlanId.Value);
			}
		}

		public int CheckExceedingQuota(int? packageId, int quotaId, int quotaTypeId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CheckExceedingQuota]
(
	@PackageID int,
	@QuotaID int,
	@QuotaTypeID int
)
RETURNS int
AS
BEGIN

DECLARE @ExceedValue int
SET @ExceedValue = 0

DECLARE @PackageQuotaValue int
SET @PackageQuotaValue = dbo.GetPackageAllocatedQuota(@PackageID, @QuotaID)

-- check boolean quota
IF @QuotaTypeID = 1-- AND @PackageQuotaValue > 0 -- enabled
RETURN 0 -- can exceed

-- check numeric quota
IF @QuotaTypeID = 2 AND @PackageQuotaValue = -1 -- unlimited
RETURN 0 -- can exceed

-- get summary usage for the numeric quota
DECLARE @UsedQuantity int
DECLARE @UsedPlans int
DECLARE @UsedOverrides int
DECLARE @UsedAddons int

	-- limited by hosting plans
	SELECT @UsedPlans = SUM(HPQ.QuotaValue) FROM Packages AS P
	INNER JOIN HostingPlanQuotas AS HPQ ON P.PlanID = HPQ.PlanID
	WHERE HPQ.QuotaID = @QuotaID
		AND P.ParentPackageID = @PackageID
		AND P.OverrideQuotas = 0

	-- overrides
	SELECT @UsedOverrides = SUM(PQ.QuotaValue) FROM Packages AS P
	INNER JOIN PackageQuotas AS PQ ON P.PackageID = PQ.PackageID AND PQ.QuotaID = @QuotaID
	WHERE P.ParentPackageID = @PackageID
		AND P.OverrideQuotas = 1

	-- addons
	SELECT @UsedAddons = SUM(HPQ.QuotaValue * PA.Quantity)
	FROM Packages AS P
	INNER JOIN PackageAddons AS PA ON P.PackageID = PA.PackageID
	INNER JOIN HostingPlanQuotas AS HPQ ON PA.PlanID = HPQ.PlanID
	WHERE P.ParentPackageID = @PackageID AND HPQ.QuotaID = @QuotaID AND PA.StatusID = 1 -- active

--SET @UsedQuantity = (SELECT SUM(dbo.GetPackageAllocatedQuota(PackageID, @QuotaID)) FROM Packages WHERE ParentPackageID = @PackageID)

SET @UsedQuantity = @UsedPlans + @UsedOverrides + @UsedAddons

IF @UsedQuantity IS NULL
RETURN 0 -- can exceed

SET @ExceedValue = @UsedQuantity - @PackageQuotaValue

RETURN @ExceedValue
END
			*/
			#endregion

			if (packageId == null) return 0;

			var packageQuotaValue = GetPackageAllocatedQuota(packageId, quotaId);

			// check boolean quota
			if (quotaTypeId == 1) return 0; // && packageQuotaValue > 0 // enabled, can exceed

			// check numeric quota
			if (quotaTypeId == 2 && packageQuotaValue == -1) return 0; // unlimited, can exceed

			int usedQuantity, usedPlans, usedOverrides, usedAddons;

			// limited by hosting plans
			usedPlans = Packages
				.Where(p => p.ParentPackageId == packageId && !p.OverrideQuotas)
				.Join(HostingPlanQuotas, p => p.PlanId, hq => hq.PlanId, (p, hq) => hq)
				.Where(hq => hq.QuotaId == quotaId)
				.Sum(hq => (int?)hq.QuotaValue) ?? 0;

			// overrides
			usedOverrides = Packages
				.Where(p => p.ParentPackageId == packageId && p.OverrideQuotas)
				.Join(PackageQuotas.Where(pq => pq.QuotaId == quotaId), p => p.PackageId, pq => pq.PackageId, (p, pq) => pq)
				.Sum(pq => (int?)pq.QuotaValue) ?? 0;

			// addons
			usedAddons = Packages
				.Where(p => p.ParentPackageId == packageId)
				.Join(PackageAddons, p => p.PackageId, pa => pa.PackageId, (p, pa) => new
				{
					Package = p,
					Addon = pa
				})
				.Join(HostingPlanQuotas, p => p.Addon.PlanId, hq => hq.PlanId, (p, hq) => new
				{
					hq.QuotaId,
					p.Addon.StatusId,
					hq.QuotaValue,
					p.Addon.Quantity
				})
				.Where(p => p.QuotaId == quotaId && p.StatusId == 1 /* active */)
				.Sum(p => (int?)(p.QuotaValue * p.Quantity)) ?? 0;

			/*
			usedQuantity = Packages
				.Where(p => p.ParentPackageId == packageId)
				.Sum(p => (int?)GetPackageAllocatedQuota(p.PackageId, quotaId)) ?? 0;
			*/

			usedQuantity = usedPlans + usedOverrides + usedAddons;

			if (usedQuantity == 0) return 0; // can exceed

			return usedQuantity - packageQuotaValue;
		}

		public class ExceedingQuota
		{
			public int QuotaId { get; set; }
			public string QuotaName { get; set; }
			public int QuotaValue { get; set; }
		}

		public IEnumerable<ExceedingQuota> GetPackageExceedingQuotas(int? packageId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[GetPackageExceedingQuotas]
(
	@PackageID int
)
RETURNS @quotas TABLE (QuotaID int, QuotaName nvarchar(50), QuotaValue int)
AS
BEGIN

DECLARE @ParentPackageID int
DECLARE @PlanID int
DECLARE @OverrideQuotas bit

SELECT
	@ParentPackageID = ParentPackageID,
	@PlanID = PlanID,
	@OverrideQuotas = OverrideQuotas
FROM Packages WHERE PackageID = @PackageID

IF @ParentPackageID IS NOT NULL -- not root package
BEGIN

	IF @OverrideQuotas = 0 -- hosting plan quotas
		BEGIN
			INSERT INTO @quotas (QuotaID, QuotaName, QuotaValue)
			SELECT
				Q.QuotaID,
				Q.QuotaName,
				dbo.CheckExceedingQuota(@PackageID, Q.QuotaID, Q.QuotaTypeID) AS QuotaValue
			FROM HostingPlanQuotas AS HPQ
			INNER JOIN Quotas AS Q ON HPQ.QuotaID = Q.QuotaID
			WHERE HPQ.PlanID = @PlanID AND Q.QuotaTypeID <> 3
		END
	ELSE -- overriden quotas
		BEGIN
			INSERT INTO @quotas (QuotaID, QuotaName, QuotaValue)
			SELECT
				Q.QuotaID,
				Q.QuotaName,
				dbo.CheckExceedingQuota(@PackageID, Q.QuotaID, Q.QuotaTypeID) AS QuotaValue
			FROM PackageQuotas AS PQ
			INNER JOIN Quotas AS Q ON PQ.QuotaID = Q.QuotaID
			WHERE PQ.PackageID = @PackageID AND Q.QuotaTypeID <> 3
		END
END -- if 'root' package

RETURN
END
			*/
			#endregion

			var package = Packages
				.Where(p => p.PackageId == packageId)
				.Select(p => new { p.PlanId, p.ParentPackageId, p.OverrideQuotas })
				.FirstOrDefault();
			if (package?.ParentPackageId != null) // not root package
			{
				if (!package.OverrideQuotas) // hosting plan quotas
				{
					return HostingPlanQuotas
						.Where(q => q.PlanId == package.PlanId)
						.Join(Quotas.Where(q => q.QuotaTypeId != 3), hq => hq.QuotaId, q => q.QuotaId, (hq, q) => q)
						.AsEnumerable()
						.Select(q => new ExceedingQuota
						{
							QuotaId = q.QuotaId,
							QuotaName = q.QuotaName,
							QuotaValue = Local.CheckExceedingQuota(packageId, q.QuotaId, q.QuotaTypeId)
						});
				}
				else // overriden quotas
				{
					return PackageQuotas
						.Where(q => q.PackageId == packageId)
						.Join(Quotas.Where(q => q.QuotaTypeId != 3), hq => hq.QuotaId, q => q.QuotaId, (hq, q) => q)
						.AsEnumerable()
						.Select(q => new ExceedingQuota
						{
							QuotaId = q.QuotaId,
							QuotaName = q.QuotaName,
							QuotaValue = Local.CheckExceedingQuota(packageId, q.QuotaId, q.QuotaTypeId)
						});
				}
			}
			return new ExceedingQuota[0];
		}

		public DataSet UpdateHostingPlan(int actorId, int planId, int packageId, int serverId, string planName,
			string planDescription, bool available, decimal setupPrice, decimal recurringPrice,
			int recurrenceUnit, int recurrenceLength, string quotasXml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateHostingPlan]
(
	@ActorID int,
	@PlanID int,
	@PackageID int,
	@ServerID int,
	@PlanName nvarchar(200),
	@PlanDescription ntext,
	@Available bit,
	@SetupPrice money,
	@RecurringPrice money,
	@RecurrenceLength int,
	@RecurrenceUnit int,
	@QuotasXml ntext
)
AS

-- check rights
DECLARE @UserID int
SELECT @UserID = UserID FROM HostingPlans
WHERE PlanID = @PlanID

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

IF @ServerID = 0
SELECT @ServerID = ServerID FROM Packages
WHERE PackageID = @PackageID

IF @PackageID = 0 SET @PackageID = NULL
IF @ServerID = 0 SET @ServerID = NULL

-- update record
UPDATE HostingPlans SET
	PackageID = @PackageID,
	ServerID = @ServerID,
	PlanName = @PlanName,
	PlanDescription = @PlanDescription,
	Available = @Available,
	SetupPrice = @SetupPrice,
	RecurringPrice = @RecurringPrice,
	RecurrenceLength = @RecurrenceLength,
	RecurrenceUnit = @RecurrenceUnit
WHERE PlanID = @PlanID

BEGIN TRAN

-- update quotas
EXEC UpdateHostingPlanQuotas @ActorID, @PlanID, @QuotasXml

DECLARE @ExceedingQuotas AS TABLE (QuotaID int, QuotaName nvarchar(50), QuotaValue int)
INSERT INTO @ExceedingQuotas
SELECT * FROM dbo.GetPackageExceedingQuotas(@PackageID) WHERE QuotaValue > 0

SELECT * FROM @ExceedingQuotas

IF EXISTS(SELECT * FROM @ExceedingQuotas)
BEGIN
	ROLLBACK TRAN
	RETURN
END

COMMIT TRAN

RETURN
				*/
				#endregion

				// check rights
				var userId = HostingPlans
					.Where(p => p.PlanId == planId)
					.Select(p => p.UserId)
					.FirstOrDefault();

				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				if (serverId == 0)
				{
					serverId = Packages
						.Where(p => p.PackageId == packageId)
						.Select(p => p.ServerId)
						.FirstOrDefault() ?? 0;
				}

				// update record
				var plan = HostingPlans
					.FirstOrDefault(p => p.PlanId == planId);
				plan.PackageId = packageId;
				plan.ServerId = serverId;
				plan.PlanName = planName;
				plan.PlanDescription = planDescription;
				plan.Available = available;
				plan.SetupPrice = setupPrice;
				plan.RecurringPrice = recurringPrice;
				plan.RecurrenceLength = recurrenceLength;
				plan.RecurrenceUnit = recurrenceUnit;
				SaveChanges();

				using (var transaction = Database.BeginTransaction())
				{
					// update quotas
					UpdateHostingPlanQuotas(actorId, planId, quotasXml);

					var exceedingQuotas = GetPackageExceedingQuotas(packageId)
						.Where(q => q.QuotaValue > 0)
						.ToArray();

					if (exceedingQuotas.Any()) transaction.Rollback();
					else transaction.Commit();

					return EntityDataSet(exceedingQuotas);
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateHostingPlan",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@planId", planId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@serverId", serverId),
					new SqlParameter("@planName", planName),
					new SqlParameter("@planDescription", planDescription),
					new SqlParameter("@available", available),
					new SqlParameter("@setupPrice", setupPrice),
					new SqlParameter("@recurringPrice", recurringPrice),
					new SqlParameter("@recurrenceUnit", recurrenceUnit),
					new SqlParameter("@recurrenceLength", recurrenceLength),
					new SqlParameter("@quotasXml", quotasXml));
			}
		}

		/*
		// TODO: This method is missing from the stored procedures
		public int CopyHostingPlan(int planId, int userId, int packageId)
		{

			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
				*//*
				#endregion

			}
			else
			{
				SqlParameter prmPlanId = new SqlParameter("@DestinationPlanID", SqlDbType.Int);
				prmPlanId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "CopyHostingPlan",
					new SqlParameter("@SourcePlanID", planId),
					new SqlParameter("@UserID", userId),
					new SqlParameter("@PackageID", packageId),
					prmPlanId);

				return Convert.ToInt32(prmPlanId.Value);
			}
		} */

		public int DeleteHostingPlan(int actorId, int planId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteHostingPlan]
(
	@ActorID int,
	@PlanID int,
	@Result int OUTPUT
)
AS
SET @Result = 0

-- check rights
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM HostingPlans
WHERE PlanID = @PlanID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- check if some packages uses this plan
IF EXISTS (SELECT PackageID FROM Packages WHERE PlanID = @PlanID)
BEGIN
	SET @Result = -1
	RETURN
END

-- check if some package addons uses this plan
IF EXISTS (SELECT PackageID FROM PackageAddons WHERE PlanID = @PlanID)
BEGIN
	SET @Result = -2
	RETURN
END

-- delete hosting plan
DELETE FROM HostingPlans
WHERE PlanID = @PlanID

RETURN
				*/
				#endregion

				// check rights
				var packageId = HostingPlans
					.Where(p => p.PlanId == planId)
					.Select(p => p.PackageId)
					.FirstOrDefault();
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				// check if some packages uses this plan
				if (Packages.Any(p => p.PlanId == planId)) return -1;

				// check if some package addons uses this plan
				if (PackageAddons.Any(a => a.PlanId == planId)) return -2;

				// delete hosting plan
				HostingPlans.Where(p => p.PlanId == planId).ExecuteDelete();

				return 0;
			}
			else
			{
				SqlParameter prmResult = new SqlParameter("@Result", SqlDbType.Int);
				prmResult.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteHostingPlan",
					prmResult,
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PlanId", planId));

				return Convert.ToInt32(prmResult.Value);
			}
		}
		#endregion

		#region Packages

		// Packages
		public DataSet GetMyPackages(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetMyPackages]
(
	@ActorID int,
	@UserID int
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

SELECT
	P.PackageID,
	P.ParentPackageID,
	P.PackageName,
	P.StatusID,
	P.PlanID,
	P.PurchaseDate,
  	P.StatusIDchangeDate,

	dbo.GetItemComments(P.PackageID, 'PACKAGE', @ActorID) AS Comments,

	-- server
	ISNULL(P.ServerID, 0) AS ServerID,
	ISNULL(S.ServerName, 'None') AS ServerName,
	ISNULL(S.Comments, '') AS ServerComments,
	ISNULL(S.VirtualServer, 1) AS VirtualServer,

	-- hosting plan
	HP.PlanName,

	-- user
	P.UserID,
	U.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	U.RoleID,
	U.Email,

	P.DefaultTopPackage
FROM Packages AS P
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
LEFT OUTER JOIN Servers AS S ON P.ServerID = S.ServerID
LEFT OUTER JOIN HostingPlans AS HP ON P.PlanID = HP.PlanID
WHERE P.UserID = @UserID
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var packages = Packages
					.Where(p => p.UserId == userId)
					.Select(p => new
					{
						p.PackageId,
						p.ParentPackageId,
						p.PackageName,
						p.StatusId,
						p.PlanId,
						p.PurchaseDate,
						p.StatusIdChangeDate,
						// server
						ServerId = p.ServerId ?? 0,
						ServerName = p.Server != null ? p.Server.ServerName : "None",
						ServerComments = p.Server != null ? p.Server.Comments : "",
						VirtualServer = p.Server != null ? p.Server.VirtualServer : true,
						// hosting plan
						p.HostingPlan.PlanName,
						// user
						p.UserId,
						p.User.Username,
						p.User.FirstName,
						p.User.LastName,
						FullName = p.User.FirstName + " " + p.User.LastName,
						p.User.RoleId,
						p.User.Email,
						p.DefaultTopPackage
					})
					.AsEnumerable()
					.Select(p => new
					{
						p.PackageId,
						p.ParentPackageId,
						p.PackageName,
						p.StatusId,
						p.PlanId,
						p.PurchaseDate,
						p.StatusIdChangeDate,
						Comments = Local.GetItemComments(p.PackageId, "PACKAGE", actorId),
						// server
						p.ServerId,
						p.ServerName,
						p.ServerComments,
						p.VirtualServer,
						// hosting plan
						p.PlanName,
						// user
						p.UserId,
						p.Username,
						p.FirstName,
						p.LastName,
						p.FullName,
						p.RoleId,
						p.Email,
						p.DefaultTopPackage
					});
				return EntityDataSet(packages);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetMyPackages",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@UserID", userId));
			}
		}

		public DataSet GetPackages(int actorId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackages]
(
	@ActorID int,
	@UserID int
)
AS

SELECT
	P.PackageID,
	P.ParentPackageID,
	P.PackageName,
	P.StatusID,
	P.PurchaseDate,   
  	P.StatusIDchangeDate,

	-- server
	ISNULL(P.ServerID, 0) AS ServerID,
	ISNULL(S.ServerName, 'None') AS ServerName,
	ISNULL(S.Comments, '') AS ServerComments,
	ISNULL(S.VirtualServer, 1) AS VirtualServer,

	-- hosting plan
	P.PlanID,
	HP.PlanName,

	-- user
	P.UserID,
	U.Username,
	U.FirstName,
	U.LastName,
	U.RoleID,
	U.Email,

	P.DefaultTopPackage
FROM Packages AS P
INNER JOIN Users AS U ON P.UserID = U.UserID
INNER JOIN Servers AS S ON P.ServerID = S.ServerID
INNER JOIN HostingPlans AS HP ON P.PlanID = HP.PlanID
WHERE
	P.UserID = @UserID	
RETURN
				*/
				#endregion

				var packages = Packages
					.Where(p => p.UserId == userId)
					.Select(p => new
					{
						p.PackageId,
						p.ParentPackageId,
						p.PackageName,
						p.StatusId,
						p.PurchaseDate,
						p.StatusIdChangeDate,
						// server
						ServerId = p.ServerId != null ? p.ServerId : 0,
						ServerName = p.Server != null ? p.Server.ServerName : "None",
						ServerComments = p.Server != null ? p.Server.Comments : "",
						VirtualServer = p.Server != null ? p.Server.VirtualServer : true,
						// hosting plan
						p.PlanId,
						p.HostingPlan.PlanName,
						// user
						p.UserId,
						p.User.Username,
						p.User.FirstName,
						p.User.LastName,
						p.User.RoleId,
						p.User.Email,
						p.DefaultTopPackage
					});
				return EntityDataSet(packages);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackages",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@UserID", userId));
			}
		}

		public DataSet GetNestedPackagesSummary(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetNestedPackagesSummary]
(
	@ActorID int,
	@PackageID int
)
AS
-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- ALL spaces
SELECT COUNT(PackageID) AS PackagesNumber FROM Packages
WHERE ParentPackageID = @PackageID

-- BY STATUS spaces
SELECT StatusID, COUNT(PackageID) AS PackagesNumber FROM Packages
WHERE ParentPackageID = @PackageID AND StatusID > 0
GROUP BY StatusID
ORDER BY StatusID

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var nofPackages = new[] { new { PackagesNumber = Packages
					.Where(p => p.ParentPackageId == packageId)
					.Count() } };

				// by status spaces
				var spaces = Packages
					.Where(p => p.ParentPackageId == packageId && p.StatusId > 0)
					.GroupBy(p => p.StatusId)
					.OrderBy(p => p.Key)
					.Select(p => new
					{
						StatusId = p.Key,
						PackagesNumber = p.Count()
					});

				return EntityDataSet(nofPackages, spaces);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetNestedPackagesSummary",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageID", packageId));
			}
		}

		public DataSet SearchServiceItemsPaged(int actorId, int userId, int itemTypeId, string filterValue,
			string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SearchServiceItemsPaged]
(
	@ActorID int,
	@UserID int,
	@ItemTypeID int,
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

-- build query and run it to the temporary table
DECLARE @sql nvarchar(2000)

IF @ItemTypeID <> 13
BEGIN
	SET @sql = '
	DECLARE @EndRow int
	SET @EndRow = @StartRow + @MaximumRows
	DECLARE @Items TABLE
	(
		ItemPosition int IDENTITY(1,1),
		ItemID int
	)
	INSERT INTO @Items (ItemID)
	SELECT
		SI.ItemID
	FROM ServiceItems AS SI
	INNER JOIN Packages AS P ON P.PackageID = SI.PackageID
	INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
	WHERE
		dbo.CheckUserParent(@UserID, P.UserID) = 1
		AND SI.ItemTypeID = @ItemTypeID
	'

	IF @FilterValue <> ''
	SET @sql = @sql + ' AND SI.ItemName LIKE @FilterValue '

	IF @SortColumn = '' OR @SortColumn IS NULL
	SET @SortColumn = 'ItemName'

	SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

	SET @sql = @sql + ' SELECT COUNT(ItemID) FROM @Items;
	SELECT

		SI.ItemID,
		SI.ItemName,

		P.PackageID,
		P.PackageName,
		P.StatusID,
		P.PurchaseDate,

		-- user
		P.UserID,
		U.Username,
		U.FirstName,
		U.LastName,
		U.FullName,
		U.RoleID,
		U.Email
	FROM @Items AS I
	INNER JOIN ServiceItems AS SI ON I.ItemID = SI.ItemID
	INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
	INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
	WHERE I.ItemPosition BETWEEN @StartRow AND @EndRow'
END
ELSE
BEGIN

	SET @SortColumn = REPLACE(@SortColumn, 'ItemName', 'DomainName')

	SET @sql = '
	DECLARE @EndRow int
	SET @EndRow = @StartRow + @MaximumRows
	DECLARE @Items TABLE
	(
		ItemPosition int IDENTITY(1,1),
		ItemID int
	)
	INSERT INTO @Items (ItemID)
	SELECT
		D.DomainID
	FROM Domains AS D
	INNER JOIN Packages AS P ON P.PackageID = D.PackageID
	INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
	WHERE
		dbo.CheckUserParent(@UserID, P.UserID) = 1
	'

	IF @FilterValue <> ''
	SET @sql = @sql + ' AND D.DomainName LIKE @FilterValue '

	IF @SortColumn = '' OR @SortColumn IS NULL
	SET @SortColumn = 'DomainName'

	SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

	SET @sql = @sql + ' SELECT COUNT(ItemID) FROM @Items;
	SELECT

		D.DomainID AS ItemID,
		D.DomainName AS ItemName,

		P.PackageID,
		P.PackageName,
		P.StatusID,
		P.PurchaseDate,

		-- user
		P.UserID,
		U.Username,
		U.FirstName,
		U.LastName,
		U.FullName,
		U.RoleID,
		U.Email
	FROM @Items AS I
	INNER JOIN Domains AS D ON I.ItemID = D.DomainID
	INNER JOIN Packages AS P ON D.PackageID = P.PackageID
	INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
	WHERE I.ItemPosition BETWEEN @StartRow AND @EndRow AND D.IsDomainPointer=0'
END

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int, @UserID int, @FilterValue nvarchar(50), @ItemTypeID int, @ActorID int',
@StartRow, @MaximumRows, @UserID, @FilterValue, @ItemTypeID, @ActorID

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				if (itemTypeId != 13)
				{
					using (var childUsers = UserChildren(userId))
					{
						var items = ServiceItems
							.Where(s => s.ItemTypeId == itemTypeId)
							.Join(Packages, s => s.PackageId, p => p.PackageId, (s, p) => new
							{
								Item = s,
								Package = p
							})
							.Join(UsersDetailed, s => s.Package.UserId, u => u.UserId, (s, u) => new
							{
								s.Item,
								s.Package,
								User = u
							})
							.Join(childUsers, s => s.User.UserId, u => u, (s, u) => s)
							//.Where(s => CheckUserParent(userId, s.User.UserId))
							.Select(s => new
							{
								s.Item.ItemId,
								s.Item.ItemName,
								s.Package.PackageId,
								s.Package.PackageName,
								s.Package.StatusId,
								s.Package.PurchaseDate,
								// user
								s.Package.UserId,
								s.User.Username,
								s.User.FirstName,
								s.User.LastName,
								s.User.FullName,
								s.User.RoleId,
								s.User.Email
							});

						if (!string.IsNullOrEmpty(filterValue)) items = items.Where(it => it.ItemName == filterValue);

						var count = items.Count();

						if (string.IsNullOrEmpty(sortColumn)) items = items.OrderBy(it => it.ItemName);
						else items = items.OrderBy(sortColumn);

						items = items.Skip(startRow).Take(maximumRows);

						return EntityDataSet(count, items);
					}
				}
				else
				{
					//sortColumn = sortColumn.Replace("ItemName", "DomainName");

					using (var childUsers = UserChildren(userId)) {
						var domains = Domains
							.Join(Packages, d => d.PackageId, p => p.PackageId, (d, p) => new
							{
								Domain = d,
								Package = p
							})
							.Join(UsersDetailed, d => d.Package.UserId, u => u.UserId, (d, u) => new
							{
								d.Domain,
								d.Package,
								User = u
							})
							.Join(childUsers, d => d.User.UserId, u => u, (d, u) => d)
							//.Where(d => CheckUserParent(userId, d.User.UserId))
							.Select(d => new
							{
								ItemId = d.Domain.DomainId,
								ItemName = d.Domain.DomainName,
								d.Package.PackageId,
								d.Package.PackageName,
								d.Package.StatusId,
								d.Package.PurchaseDate,
								// user
								d.Package.UserId,
								d.User.Username,
								d.User.FirstName,
								d.User.LastName,
								d.User.FullName,
								d.User.RoleId,
								d.User.Email
							});

						if (!string.IsNullOrEmpty(filterValue)) domains = domains.Where(it => it.ItemName == filterValue);

						var count = domains.Count();

						if (string.IsNullOrEmpty(sortColumn)) domains = domains.OrderBy(it => it.ItemName);
						else domains = domains.OrderBy(sortColumn);

						domains = domains.Skip(startRow).Take(maximumRows);

						return EntityDataSet(count, domains);
					}
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "SearchServiceItemsPaged",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@UserID", userId),
					new SqlParameter("@itemTypeId", itemTypeId),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public DataSet GetPackagesPaged(int actorId, int userId, string filterColumn, string filterValue,
			string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackagesPaged]
(
	@ActorID int,
	@UserID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS

-- build query and run it to the temporary table
DECLARE @sql nvarchar(2000)

SET @sql = '
DECLARE @HasUserRights bit
SET @HasUserRights = dbo.CheckActorUserRights(@ActorID, @UserID)

DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows
DECLARE @Packages TABLE
(
	ItemPosition int IDENTITY(1,1),
	PackageID int
)
INSERT INTO @Packages (PackageID)
SELECT
	P.PackageID
FROM Packages AS P
--INNER JOIN UsersTree(@UserID, 1) AS UT ON P.UserID = UT.UserID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
INNER JOIN Servers AS S ON P.ServerID = S.ServerID
INNER JOIN HostingPlans AS HP ON P.PlanID = HP.PlanID
WHERE
	P.UserID <> @UserID AND dbo.CheckUserParent(@UserID, P.UserID) = 1
	AND @HasUserRights = 1 '

IF @FilterColumn <> '' AND @FilterValue <> ''
SET @sql = @sql + ' AND ' + @FilterColumn + ' LIKE @FilterValue '

IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + ' SELECT COUNT(PackageID) FROM @Packages;
SELECT
	P.PackageID,
	P.PackageName,
	P.StatusID,
	P.PurchaseDate,

	dbo.GetItemComments(P.PackageID, ''PACKAGE'', @ActorID) AS Comments,

	-- server
	P.ServerID,
	ISNULL(S.ServerName, ''None'') AS ServerName,
	ISNULL(S.Comments, '''') AS ServerComments,
	ISNULL(S.VirtualServer, 1) AS VirtualServer,

	-- hosting plan
	P.PlanID,
	HP.PlanName,

	-- user
	P.UserID,
	U.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	U.RoleID,
	U.Email
FROM @Packages AS TP
INNER JOIN Packages AS P ON TP.PackageID = P.PackageID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
INNER JOIN Servers AS S ON P.ServerID = S.ServerID
INNER JOIN HostingPlans AS HP ON P.PlanID = HP.PlanID
WHERE TP.ItemPosition BETWEEN @StartRow AND @EndRow'

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int, @UserID int, @FilterValue nvarchar(50), @ActorID int',
@StartRow, @MaximumRows, @UserID, @FilterValue, @ActorID

RETURN
				*/
				#endregion

				var hasUserRights = CheckActorUserRights(actorId, userId);

				using (var userChildren = UsersTree(userId, true))
				{
					var packages = Packages
						.Where(p => hasUserRights && p.UserId != userId)
						.Join(userChildren, p => p.UserId, u => u, (p, u) => p)
						.Select(p => new
						{
							p.PackageId,
							p.PackageName,
							p.StatusId,
							p.PurchaseDate,
							// server
							p.ServerId,
							ServerName = p.Server.ServerName != null ? p.Server.ServerName : "None",
							ServerComments = p.Server.Comments != null ? p.Server.Comments : "",
							p.Server.VirtualServer,
							// hosting plan
							p.PlanId,
							p.HostingPlan.PlanName,
							// user
							p.UserId,
							p.User.Username,
							p.User.FirstName,
							p.User.LastName,
							FullName = p.User.FirstName + " " + p.User.LastName,
							p.User.RoleId,
							p.User.Email
						});

					if (!string.IsNullOrEmpty(filterValue) && !string.IsNullOrEmpty(filterColumn))
					{
						packages = packages.Where(DynamicFunctions.ColumnLike(packages, filterColumn, filterValue));
					}

					var count = packages.Count();

					if (!string.IsNullOrEmpty(sortColumn)) packages = packages.OrderBy(sortColumn);

					packages = packages.Skip(startRow).Take(maximumRows);

					var packagesSelected = packages
						.AsEnumerable()
						.Select(p => new
						{
							p.PackageId,
							p.PackageName,
							p.StatusId,
							p.PurchaseDate,
							Comments = Local.GetItemComments(p.PackageId, "PACKAGE", actorId),
							// server
							p.ServerId,
							p.ServerName,
							p.ServerComments,
							p.VirtualServer,
							// hosting plan
							p.PlanId,
							p.PlanName,
							// user
							p.UserId,
							p.Username,
							p.FirstName,
							p.LastName,
							p.FullName,
							p.RoleId,
							p.Email
						});

					return EntityDataSet(count, packagesSelected);
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackagesPaged",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@UserID", userId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public DataSet GetNestedPackagesPaged(int actorId, int packageId, string filterColumn, string filterValue,
			int statusId, int planId, int serverId, string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetNestedPackagesPaged]
(
	@ActorID int,
	@PackageID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@StatusID int,
	@PlanID int,
	@ServerID int,
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS

-- build query and run it to the temporary table
DECLARE @sql nvarchar(2000)

SET @sql = '
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR(''You are not allowed to access this package'', 16, 1)

DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows
DECLARE @Packages TABLE
(
	ItemPosition int IDENTITY(1,1),
	PackageID int
)
INSERT INTO @Packages (PackageID)
SELECT
	P.PackageID
FROM Packages AS P
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
INNER JOIN Servers AS S ON P.ServerID = S.ServerID
INNER JOIN HostingPlans AS HP ON P.PlanID = HP.PlanID
WHERE
	P.ParentPackageID = @PackageID
	AND ((@StatusID = 0) OR (@StatusID > 0 AND P.StatusID = @StatusID))
	AND ((@PlanID = 0) OR (@PlanID > 0 AND P.PlanID = @PlanID))
	AND ((@ServerID = 0) OR (@ServerID > 0 AND P.ServerID = @ServerID)) '

IF @FilterValue <> ''
BEGIN
	IF @FilterColumn <> ''
		SET @sql = @sql + ' AND ' + @FilterColumn + ' LIKE @FilterValue '
	ELSE
		SET @sql = @sql + '
			AND (Username LIKE @FilterValue
			OR FullName LIKE @FilterValue
			OR Email LIKE @FilterValue) '
END

-- TODO bug? No sorting if @SortColumn is empty?
IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '
ELSE
SET @sql = @sql + ' ORDER BY P.PackageName '

SET @sql = @sql + ' SELECT COUNT(PackageID) FROM @Packages;
SELECT
	P.PackageID,
	P.PackageName,
	P.StatusID,
	P.PurchaseDate,    
  	P.StatusIDchangeDate,

	dbo.GetItemComments(P.PackageID, ''PACKAGE'', @ActorID) AS Comments,

	-- server
	P.ServerID,
	ISNULL(S.ServerName, ''None'') AS ServerName,
	ISNULL(S.Comments, '''') AS ServerComments,
	ISNULL(S.VirtualServer, 1) AS VirtualServer,

	-- hosting plan
	P.PlanID,
	HP.PlanName,

	-- user
	P.UserID,
	U.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	U.RoleID,
	U.Email
FROM @Packages AS TP
INNER JOIN Packages AS P ON TP.PackageID = P.PackageID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
INNER JOIN Servers AS S ON P.ServerID = S.ServerID
INNER JOIN HostingPlans AS HP ON P.PlanID = HP.PlanID
WHERE TP.ItemPosition BETWEEN @StartRow AND @EndRow'

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int, @PackageID int, @FilterValue nvarchar(50), @ActorID int, @StatusID int, @PlanID int, @ServerID int',
@StartRow, @MaximumRows, @PackageID, @FilterValue, @ActorID, @StatusID, @PlanID, @ServerID

RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var packages = Packages
					.Where(p => p.ParentPackageId == packageId &&
						(statusId == 0 || statusId > 0 && p.StatusId == statusId) &&
						(planId == 0 || planId > 0 && p.PlanId == planId) &&
						(serverId == 0 || serverId > 0 && p.ServerId == serverId))
					.Select(p => new
					{
						p.PackageId,
						p.PackageName,
						p.StatusId,
						p.PurchaseDate,
						p.StatusIdChangeDate,
						// server
						p.ServerId,
						ServerName = p.Server.ServerName != null ? p.Server.ServerName : "None",
						ServerComments = p.Server.Comments != null ? p.Server.Comments : "",
						p.Server.VirtualServer,
						// hosting plan
						p.PlanId,
						p.HostingPlan.PlanName,
						// user
						p.UserId,
						p.User.Username,
						p.User.FirstName,
						p.User.LastName,
						FullName = p.User.FirstName + " " + p.User.LastName,
						p.User.RoleId,
						p.User.Email
					});

				if (!string.IsNullOrEmpty(filterValue))
				{
					if (!string.IsNullOrEmpty(filterColumn))
					{
						packages = packages.Where(DynamicFunctions.ColumnLike(packages, filterColumn, filterValue));
					}
					else
					{
#if NETFRAMEWORK
						packages = packages.Where(p => DbFunctions.Like(p.Username, filterValue) ||
							DbFunctions.Like(p.FullName, filterValue) ||
							DbFunctions.Like(p.Email, filterValue));
#else
						packages = packages.Where(p => EF.Functions.Like(p.Username, filterValue) ||
							EF.Functions.Like(p.FullName, filterValue) ||
							EF.Functions.Like(p.Email, filterValue));
#endif
					}
				}

				var count = packages.Count();

				if (!string.IsNullOrEmpty(sortColumn)) packages = packages.OrderBy(sortColumn);
				else packages = packages.OrderBy(p => p.PackageName);

				packages = packages.Skip(startRow).Take(maximumRows);

				var packagesSelected = packages
					.AsEnumerable()
					.Select(p => new {
						p.PackageId,
						p.PackageName,
						p.StatusId,
						p.PurchaseDate,
						p.StatusIdChangeDate,
						Comments = Local.GetItemComments(p.PackageId, "PACKAGE", actorId),
						// server
						p.ServerId,
						p.ServerName,
						p.ServerComments,
						p.VirtualServer,
						// hosting plan
						p.PlanId,
						p.PlanName,
						// user
						p.UserId,
						p.Username,
						p.FirstName,
						p.LastName,
						p.FullName,
						p.RoleId,
						p.Email
					});

				return EntityDataSet(count, packagesSelected);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetNestedPackagesPaged",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@statusId", statusId),
					new SqlParameter("@planId", planId),
					new SqlParameter("@serverId", serverId),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public DataSet GetPackagePackages(int actorId, int packageId, bool recursive)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackagePackages]
(
	@ActorID int,
	@PackageID int,
	@Recursive bit
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SELECT
	P.PackageID,
	P.ParentPackageID,
	P.PackageName,
	P.StatusID,
	P.PurchaseDate,

	-- server
	P.ServerID,
	ISNULL(S.ServerName, 'None') AS ServerName,
	ISNULL(S.Comments, '') AS ServerComments,
	ISNULL(S.VirtualServer, 1) AS VirtualServer,

	-- hosting plan
	P.PlanID,
	HP.PlanName,

	-- user
	P.UserID,
	U.Username,
	U.FirstName,
	U.LastName,
	U.RoleID,
	U.Email
FROM Packages AS P
INNER JOIN Users AS U ON P.UserID = U.UserID
INNER JOIN Servers AS S ON P.ServerID = S.ServerID
INNER JOIN HostingPlans AS HP ON P.PlanID = HP.PlanID
WHERE
	((@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, P.PackageID) = 1)
		OR (@Recursive = 0 AND P.ParentPackageID = @PackageID))
	AND P.PackageID <> @PackageID
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				IQueryable<Data.Entities.Package> packagesFiltered;
				TempIdSet childPackages = null;
				try
				{
					if (!recursive) packagesFiltered = Packages.Where(p => p.ParentPackageId == packageId);
					else
					{
						childPackages = PackagesTree(packageId, true);
						packagesFiltered = Packages.Join(childPackages, p => p.PackageId, ch => ch, (p, ch) => p);
					}

					var packages = packagesFiltered
						.Where(p => p.PackageId != packageId)
						// &&
						// (recursive && CheckPackageParent(packageId, p.PackageId) ||
						// !recursive && p.ParentPackageId == packageId))
						.Join(Users, p => p.UserId, u => u.UserId, (p, u) => new
						{
							Package = p,
							User = u
						})
						.Join(Servers, p => p.Package.ServerId, s => s.ServerId, (p, s) => new
						{
							p.Package,
							p.User,
							Server = s
						})
						.Join(HostingPlans, p => p.Package.PlanId, hp => hp.PlanId, (p, hp) => new
						{
							p.Package.PackageId,
							p.Package.ParentPackageId,
							p.Package.PackageName,
							p.Package.StatusId,
							p.Package.PurchaseDate,
							// server
							p.Package.ServerId,
							ServerName = p.Server.ServerName != null ? p.Server.ServerName : "None",
							ServerComments = p.Server.Comments != null ? p.Server.Comments : "",
							p.Server.VirtualServer,
							// hosting plan
							p.Package.PlanId,
							hp.PlanName,
							// user
							p.Package.UserId,
							p.User.Username,
							p.User.FirstName,
							p.User.LastName,
							p.User.RoleId,
							p.User.Email
						});
					return EntityDataSet(packages);
				} finally
				{
					childPackages?.Dispose();
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackagePackages",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@recursive", recursive));
			}
		}

		public IDataReader GetPackage(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackage]
(
	@PackageID int,
	@ActorID int
)
AS

-- Note: ActorID is not verified
-- check both requested and parent package

SELECT
	P.PackageID,
	P.ParentPackageID,
	P.UserID,
	P.PackageName,
	P.PackageComments,
	P.ServerID,
	P.StatusID,
	P.PlanID,
	P.PurchaseDate,     
  	P.StatusIDchangeDate,
	P.OverrideQuotas,
	P.DefaultTopPackage
FROM Packages AS P
WHERE P.PackageID = @PackageID
RETURN
				*/
				#endregion

				// TODO Note: actorId is not verified
				// check both requested and parent package

				var packages = Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => new
					{
						p.PackageId,
						p.ParentPackageId,
						p.UserId,
						p.PackageName,
						p.PackageComments,
						p.ServerId,
						p.StatusId,
						p.PlanId,
						p.PurchaseDate,
						p.StatusIdChangeDate,
						p.OverrideQuotas,
						p.DefaultTopPackage
					});
				return EntityDataReader(packages);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackage",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageID", packageId));
			}
		}

		public int CalculatePackageDiskspace(int packageId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CalculatePackageDiskspace]
(
	@PackageID int
)
RETURNS int
AS
BEGIN

DECLARE @Diskspace int

SELECT
	@Diskspace = ROUND(CONVERT(float, SUM(ISNULL(PD.DiskSpace, 0))) / 1024 / 1024, 0) -- in megabytes
FROM PackagesTreeCache AS PT
INNER JOIN Packages AS P ON PT.PackageID = P.PackageID
INNER JOIN PackagesDiskspace AS PD ON P.PackageID = PD.PackageID
INNER JOIN HostingPlanResources AS HPR ON PD.GroupID = HPR.GroupID
	AND HPR.PlanID = P.PlanID AND HPR.CalculateDiskspace = 1
WHERE PT.ParentPackageID = @PackageID

RETURN @Diskspace
END
			*/
			#endregion

			const long MB = 1024 * 1024;

			int diskspace = (int)(((PackagesTreeCaches
				.Where(t => t.ParentPackageId == packageId)
				.Join(Packages, t => t.PackageId, p => p.PackageId, (t, p) => p)
				.Join(PackagesDiskspaces, p => p.PackageId, pd => pd.PackageId, (p, pd) => new
				{
					Package = p,
					Diskspace = pd
				})
				.Join(HostingPlanResources.Where(hr => hr.CalculateDiskSpace == true),
					p => new { p.Diskspace.GroupId, p.Package.PlanId }, hr => new { hr.GroupId, PlanId = (int?)hr.PlanId },
					(p, hr) => p.Diskspace.DiskSpace)
				.Sum(space => (long?)space) ?? 0) + MB / 2) / MB);
			return diskspace;
		}

		public int CalculatePackageBandwidth(int packageId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[CalculatePackageBandwidth]
(
	@PackageID int
)
RETURNS int
AS
BEGIN

DECLARE @d datetime, @StartDate datetime, @EndDate datetime
SET @d = GETDATE()
SET @StartDate = DATEADD(Day, -DAY(@d) + 1, @d)
SET @EndDate = DATEADD(Day, -1, DATEADD(Month, 1, @StartDate))
--SET @EndDate =  GETDATE()
--SET @StartDate = DATEADD(month, -1, @EndDate)

-- remove hours and minutes
SET @StartDate = CONVERT(datetime, CONVERT(nvarchar, @StartDate, 112))
SET @EndDate = CONVERT(datetime, CONVERT(nvarchar, @EndDate, 112))

DECLARE @Bandwidth int
SELECT
	@Bandwidth = ROUND(CONVERT(float, SUM(ISNULL(PB.BytesSent + PB.BytesReceived, 0))) / 1024 / 1024, 0) -- in megabytes
FROM PackagesTreeCache AS PT
INNER JOIN Packages AS P ON PT.PackageID = P.PackageID
INNER JOIN PackagesBandwidth AS PB ON PT.PackageID = PB.PackageID
INNER JOIN HostingPlanResources AS HPR ON PB.GroupID = HPR.GroupID
	AND HPR.PlanID = P.PlanID AND HPR.CalculateBandwidth = 1
WHERE
	PT.ParentPackageID = @PackageID
	AND PB.LogDate BETWEEN @StartDate AND @EndDate

IF @Bandwidth IS NULL
SET @Bandwidth = 0

RETURN @Bandwidth
END
			*/
			#endregion

			const long MB = 1024 * 1024;

			var today = DateTime.Now.Date;
			var startDate = today.AddDays(-today.Day + 1);
			var endDate = startDate.AddMonths(1);

			int bandwidth = (int)(((PackagesTreeCaches
				.Where(t => t.ParentPackageId == packageId)
				.Join(Packages, t => t.PackageId, p => p.PackageId, (t, p) => p)
				.Join(PackagesBandwidths, p => p.PackageId, pb => pb.PackageId, (p, pb) => new
				{
					Package = p,
					Bandwidth = pb
				})
				.Where(p => startDate <= p.Bandwidth.LogDate && p.Bandwidth.LogDate < endDate)
				.Join(HostingPlanResources.Where(hr => hr.CalculateBandwidth == true),
					p => new { p.Bandwidth.GroupId, p.Package.PlanId }, hr => new { hr.GroupId, PlanId = (int?)hr.PlanId },
					(p, hr) => p.Bandwidth.BytesSent + p.Bandwidth.BytesReceived)
				.Sum(space => (long?)space) ?? 0) + MB / 2) / MB);
			return bandwidth;
		}

		public int CalculateQuotaUsage(int packageId, int quotaId)
		{
			#region Stored Procedure
			/*
ALTER FUNCTION [dbo].[CalculateQuotaUsage]
(
	@PackageID int,
	@QuotaID int
)
RETURNS int
AS
	BEGIN

		DECLARE @QuotaTypeID int
		DECLARE @QuotaName nvarchar(50)
		SELECT @QuotaTypeID = QuotaTypeID, @QuotaName = QuotaName FROM Quotas
		WHERE QuotaID = @QuotaID

		IF @QuotaTypeID <> 2
			RETURN 0

		DECLARE @Result int
		DECLARE @vhd TABLE (Size int)

		IF @QuotaID = 52 -- diskspace
			SET @Result = dbo.CalculatePackageDiskspace(@PackageID)
		ELSE IF @QuotaID = 51 -- bandwidth
			SET @Result = dbo.CalculatePackageBandwidth(@PackageID)
		ELSE IF @QuotaID = 53 -- domains
			SET @Result = (SELECT COUNT(D.DomainID) FROM PackagesTreeCache AS PT
				INNER JOIN Domains AS D ON D.PackageID = PT.PackageID
				WHERE IsSubDomain = 0 AND IsPreviewDomain = 0 AND IsDomainPointer = 0 AND PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 54 -- sub-domains
			SET @Result = (SELECT COUNT(D.DomainID) FROM PackagesTreeCache AS PT
				INNER JOIN Domains AS D ON D.PackageID = PT.PackageID
				WHERE IsSubDomain = 1 AND IsPreviewDomain = 0 AND IsDomainPointer = 0 AND PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 220 -- domain pointers
			SET @Result = (SELECT COUNT(D.DomainID) FROM PackagesTreeCache AS PT
				INNER JOIN Domains AS D ON D.PackageID = PT.PackageID
				WHERE IsDomainPointer = 1 AND PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 71 -- scheduled tasks
			SET @Result = (SELECT COUNT(S.ScheduleID) FROM PackagesTreeCache AS PT
				INNER JOIN Schedule AS S ON S.PackageID = PT.PackageID
				WHERE PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 305 -- RAM of VPS
			SET @Result = (SELECT SUM(CAST(SIP.PropertyValue AS int)) FROM ServiceItemProperties AS SIP
							INNER JOIN ServiceItems AS SI ON SIP.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID
							WHERE SIP.PropertyName = 'RamSize' AND PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 302 -- CpuNumber of VPS
			SET @Result = (SELECT SUM(CAST(SIP.PropertyValue AS int)) FROM ServiceItemProperties AS SIP
							INNER JOIN ServiceItems AS SI ON SIP.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID
							WHERE SIP.PropertyName = 'CpuCores' AND PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 306 -- HDD of VPS
		BEGIN
			INSERT INTO @vhd
			SELECT (SELECT SUM(CAST([value] AS int)) AS value FROM dbo.SplitString(SIP.PropertyValue,';')) FROM ServiceItemProperties AS SIP
							INNER JOIN ServiceItems AS SI ON SIP.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID
							WHERE SIP.PropertyName = 'HddSize' AND PT.ParentPackageID = @PackageID
			SET @Result = (SELECT SUM(Size) FROM @vhd)
		END
		ELSE IF @QuotaID = 309 -- External IP addresses of VPS
			SET @Result = (SELECT COUNT(PIP.PackageAddressID) FROM PackageIPAddresses AS PIP
							INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
							INNER JOIN PackagesTreeCache AS PT ON PIP.PackageID = PT.PackageID
							WHERE PT.ParentPackageID = @PackageID AND IP.PoolID = 3)
		ELSE IF @QuotaID = 555 -- CpuNumber of VPS2012
			SET @Result = (SELECT SUM(CAST(SIP.PropertyValue AS int)) FROM ServiceItemProperties AS SIP
							INNER JOIN ServiceItems AS SI ON SIP.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID
							WHERE SIP.PropertyName = 'CpuCores' AND PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 558 BEGIN -- RAM of VPS2012
			DECLARE @Result1 int
			SET @Result1 = (SELECT SUM(CAST(SIP.PropertyValue AS int)) FROM ServiceItemProperties AS SIP
							INNER JOIN ServiceItems AS SI ON SIP.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID
							WHERE SIP.PropertyName = 'RamSize' AND PT.ParentPackageID = @PackageID)
			DECLARE @Result2 int
			SET @Result2 = (SELECT SUM(CAST(SIP.PropertyValue AS int)) FROM ServiceItemProperties AS SIP
							INNER JOIN ServiceItems AS SI ON SIP.ItemID = SI.ItemID
							INNER JOIN ServiceItemProperties AS SIP2 ON 
								SIP2.ItemID = SI.ItemID AND SIP2.PropertyName = 'DynamicMemory.Enabled' AND SIP2.PropertyValue = 'True'
							INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID
							WHERE SIP.PropertyName = 'DynamicMemory.Maximum' AND PT.ParentPackageID = @PackageID)
			SET @Result = CASE WHEN isnull(@Result1,0) > isnull(@Result2,0) THEN @Result1 ELSE @Result2 END
		END
		ELSE IF @QuotaID = 559 -- HDD of VPS2012
		BEGIN
			INSERT INTO @vhd
			SELECT (SELECT SUM(CAST([value] AS int)) AS value FROM dbo.SplitString(SIP.PropertyValue,';')) FROM ServiceItemProperties AS SIP
							INNER JOIN ServiceItems AS SI ON SIP.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID
							WHERE SIP.PropertyName = 'HddSize' AND PT.ParentPackageID = @PackageID
			SET @Result = (SELECT SUM(Size) FROM @vhd)
		END
		ELSE IF @QuotaID = 562 -- External IP addresses of VPS2012
			SET @Result = (SELECT COUNT(PIP.PackageAddressID) FROM PackageIPAddresses AS PIP
							INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
							INNER JOIN PackagesTreeCache AS PT ON PIP.PackageID = PT.PackageID
							WHERE PT.ParentPackageID = @PackageID AND IP.PoolID = 3)
		ELSE IF @QuotaID = 728 -- Private Network VLANs of VPS2012
			SET @Result = (SELECT COUNT(PV.PackageVlanID) FROM PackageVLANs AS PV
							INNER JOIN PrivateNetworkVLANs AS V ON PV.VlanID = V.VlanID
							INNER JOIN PackagesTreeCache AS PT ON PV.PackageID = PT.PackageID
							WHERE PT.ParentPackageID = @PackageID AND PV.IsDmz = 0)
		ELSE IF @QuotaID = 752 -- DMZ Network VLANs of VPS2012
			SET @Result = (SELECT COUNT(PV.PackageVlanID) FROM PackageVLANs AS PV
							INNER JOIN PrivateNetworkVLANs AS V ON PV.VlanID = V.VlanID
							INNER JOIN PackagesTreeCache AS PT ON PV.PackageID = PT.PackageID
							WHERE PT.ParentPackageID = @PackageID AND PV.IsDmz = 1)
		ELSE IF @QuotaID = 100 -- Dedicated Web IP addresses
			SET @Result = (SELECT COUNT(PIP.PackageAddressID) FROM PackageIPAddresses AS PIP
							INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
							INNER JOIN PackagesTreeCache AS PT ON PIP.PackageID = PT.PackageID
							WHERE PT.ParentPackageID = @PackageID AND IP.PoolID = 2)
		ELSE IF @QuotaID = 350 -- RAM of VPSforPc
			SET @Result = (SELECT SUM(CAST(SIP.PropertyValue AS int)) FROM ServiceItemProperties AS SIP
							INNER JOIN ServiceItems AS SI ON SIP.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID
							WHERE SIP.PropertyName = 'Memory' AND PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 347 -- CpuNumber of VPSforPc
			SET @Result = (SELECT SUM(CAST(SIP.PropertyValue AS int)) FROM ServiceItemProperties AS SIP
							INNER JOIN ServiceItems AS SI ON SIP.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID
							WHERE SIP.PropertyName = 'CpuCores' AND PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 351 -- HDD of VPSforPc
		BEGIN
			INSERT INTO @vhd
			SELECT (SELECT SUM(CAST([value] AS int)) AS value FROM dbo.SplitString(SIP.PropertyValue,';')) FROM ServiceItemProperties AS SIP
							INNER JOIN ServiceItems AS SI ON SIP.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID
							WHERE SIP.PropertyName = 'HddSize' AND PT.ParentPackageID = @PackageID
			SET @Result = (SELECT SUM(Size) FROM @vhd)
		END
		ELSE IF @QuotaID = 354 -- External IP addresses of VPSforPc
			SET @Result = (SELECT COUNT(PIP.PackageAddressID) FROM PackageIPAddresses AS PIP
							INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
							INNER JOIN PackagesTreeCache AS PT ON PIP.PackageID = PT.PackageID
							WHERE PT.ParentPackageID = @PackageID AND IP.PoolID = 3)
		ELSE IF @QuotaID = 319 -- BB Users
			SET @Result = (SELECT COUNT(ea.AccountID) FROM ExchangeAccounts ea 
							INNER JOIN BlackBerryUsers bu ON ea.AccountID = bu.AccountID
							INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
							INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
							WHERE pt.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 320 -- OCS Users
			SET @Result = (SELECT COUNT(ea.AccountID) FROM ExchangeAccounts ea 
							INNER JOIN OCSUsers ocs ON ea.AccountID = ocs.AccountID
							INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
							INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
							WHERE pt.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 206 -- HostedSolution.Users
			SET @Result = (SELECT COUNT(ea.AccountID) FROM ExchangeAccounts AS ea
				INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
				INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
				WHERE pt.ParentPackageID = @PackageID AND ea.AccountType IN (1,5,6,7))
		ELSE IF @QuotaID = 78 -- Exchange2007.Mailboxes
			SET @Result = (SELECT COUNT(ea.AccountID) FROM ExchangeAccounts AS ea
				INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
				INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
				WHERE pt.ParentPackageID = @PackageID 
				AND ea.AccountType IN (1)
				AND ea.MailboxPlanId IS NOT NULL)
		ELSE IF @QuotaID = 731 -- Exchange2013.JournalingMailboxes
			SET @Result = (SELECT COUNT(ea.AccountID) FROM ExchangeAccounts AS ea
				INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
				INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
				WHERE pt.ParentPackageID = @PackageID 
				AND ea.AccountType IN (12)
				AND ea.MailboxPlanId IS NOT NULL)
		ELSE IF @QuotaID = 77 -- Exchange2007.DiskSpace
			SET @Result = (SELECT SUM(B.MailboxSizeMB) FROM ExchangeAccounts AS ea 
			INNER JOIN ExchangeMailboxPlans AS B ON ea.MailboxPlanId = B.MailboxPlanId 
			INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
			INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
			WHERE pt.ParentPackageID = @PackageID AND ea.AccountType in (1, 5, 6, 10, 12))
		ELSE IF @QuotaID = 370 -- Lync.Users
			SET @Result = (SELECT COUNT(ea.AccountID) FROM ExchangeAccounts AS ea
				INNER JOIN LyncUsers lu ON ea.AccountID = lu.AccountID
				INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
				INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
				WHERE pt.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 376 -- Lync.EVUsers
			SET @Result = (SELECT COUNT(ea.AccountID) FROM ExchangeAccounts AS ea
				INNER JOIN LyncUsers lu ON ea.AccountID = lu.AccountID
				INNER JOIN LyncUserPlans lp ON lu.LyncUserPlanId = lp.LyncUserPlanId
				INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
				INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
				WHERE pt.ParentPackageID = @PackageID AND lp.EnterpriseVoice = 1)
		ELSE IF @QuotaID = 381 -- Dedicated Lync Phone Numbers
			SET @Result = (SELECT COUNT(PIP.PackageAddressID) FROM PackageIPAddresses AS PIP
							INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
							INNER JOIN PackagesTreeCache AS PT ON PIP.PackageID = PT.PackageID
							WHERE PT.ParentPackageID = @PackageID AND IP.PoolID = 5)
		ELSE IF @QuotaID = 430 -- Enterprise Storage
			SET @Result = (SELECT SUM(ESF.FolderQuota) FROM EnterpriseFolders AS ESF
							INNER JOIN ServiceItems  SI ON ESF.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache PT ON SI.PackageID = PT.PackageID
							WHERE PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 431 -- Enterprise Storage Folders
			SET @Result = (SELECT COUNT(ESF.EnterpriseFolderID) FROM EnterpriseFolders AS ESF
							INNER JOIN ServiceItems  SI ON ESF.ItemID = SI.ItemID
							INNER JOIN PackagesTreeCache PT ON SI.PackageID = PT.PackageID
							WHERE PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 423 -- HostedSolution.SecurityGroups
			SET @Result = (SELECT COUNT(ea.AccountID) FROM ExchangeAccounts AS ea
				INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
				INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
				WHERE pt.ParentPackageID = @PackageID AND ea.AccountType IN (8,9))
		ELSE IF @QuotaID = 495 -- HostedSolution.DeletedUsers
			SET @Result = (SELECT COUNT(ea.AccountID) FROM ExchangeAccounts AS ea
				INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
				INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
				WHERE pt.ParentPackageID = @PackageID AND ea.AccountType = 11)
		ELSE IF @QuotaID = 450
			SET @Result = (SELECT COUNT(DISTINCT(RCU.[AccountId])) FROM [dbo].[RDSCollectionUsers] RCU
				INNER JOIN ExchangeAccounts EA ON EA.AccountId = RCU.AccountId
				INNER JOIN ServiceItems  si ON ea.ItemID = si.ItemID
				INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
				WHERE PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 451
			SET @Result = (SELECT COUNT(RS.[ID]) FROM [dbo].[RDSServers] RS				
				INNER JOIN ServiceItems  si ON RS.ItemID = si.ItemID
				INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
				WHERE PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaID = 491
			SET @Result = (SELECT COUNT(RC.[ID]) FROM [dbo].[RDSCollections] RC
				INNER JOIN ServiceItems  si ON RC.ItemID = si.ItemID
				INNER JOIN PackagesTreeCache pt ON si.PackageID = pt.PackageID
				WHERE PT.ParentPackageID = @PackageID)
		ELSE IF @QuotaName like 'ServiceLevel.%' -- Support Service Level Quota
		BEGIN
			DECLARE @LevelID int

			SELECT @LevelID = LevelID FROM SupportServiceLevels
			WHERE LevelName = REPLACE(@QuotaName,'ServiceLevel.','')

			IF (@LevelID IS NOT NULL)
			SET @Result = (SELECT COUNT(EA.AccountID)
				FROM SupportServiceLevels AS SL
				INNER JOIN ExchangeAccounts AS EA ON SL.LevelID = EA.LevelID
				INNER JOIN ServiceItems  SI ON EA.ItemID = SI.ItemID
				INNER JOIN PackagesTreeCache PT ON SI.PackageID = PT.PackageID
				WHERE EA.LevelID = @LevelID AND PT.ParentPackageID = @PackageID)
			ELSE SET @Result = 0
		END
		ELSE
			SET @Result = (SELECT COUNT(SI.ItemID) FROM Quotas AS Q
			INNER JOIN ServiceItems AS SI ON SI.ItemTypeID = Q.ItemTypeID
			INNER JOIN PackagesTreeCache AS PT ON SI.PackageID = PT.PackageID AND PT.ParentPackageID = @PackageID
			WHERE Q.QuotaID = @QuotaID)

		RETURN @Result
	END
GO
			*/
			#endregion

			var quota = Quotas
				.Where(q => q.QuotaId == quotaId)
				.Select(q => new { q.QuotaTypeId, q.QuotaName })
				.FirstOrDefault();

			if (quota?.QuotaTypeId != 2) return 0;

			int result = 0;

			switch (quotaId)
			{
				case 52: // diskspace
					result = CalculatePackageDiskspace(packageId);
					break;
				case 51: // bandwidth
					result = CalculatePackageBandwidth(packageId);
					break;
				case 53: // domains
					result = PackagesTreeCaches
						.Where(p => p.ParentPackageId == packageId)
						.Join(Domains, p => p.PackageId, d => d.PackageId, (p, d) => d)
						.Where(d => !d.IsSubDomain && !d.IsPreviewDomain && !d.IsDomainPointer)
						.Count();
					break;
				case 54: // sub-domains
					result = PackagesTreeCaches
						.Where(p => p.ParentPackageId == packageId)
						.Join(Domains, p => p.PackageId, d => d.PackageId, (p, d) => d)
						.Where(d => d.IsSubDomain && !d.IsPreviewDomain && !d.IsDomainPointer)
						.Count();
					break;
				case 220: // domain-pointers
					result = PackagesTreeCaches
						.Where(p => p.ParentPackageId == packageId)
						.Join(Domains, p => p.PackageId, d => d.PackageId, (p, d) => d)
						.Where(d => d.IsDomainPointer)
						.Count();
					break;
				case 71: // scheduled tasks
					result = PackagesTreeCaches
						.Where(p => p.ParentPackageId == packageId)
						.Join(Schedules, p => p.PackageId, s => s.PackageId, (p, s) => s)
						.Count();
					break;
				case 305: // RAM of VPS
					var ps = ServiceItemProperties
						.Join(ServiceItems, p => p.ItemId, s => s.ItemId, (p, s) => new
						{
							Property = p,
							Item = s
						})
						.Join(PackagesTreeCaches, p => p.Item.PackageId, t => t.PackageId, (p, t) => new
						{
							p.Property.PropertyName,
							t.ParentPackageId,
							p.Property.PropertyValue
						})
						.Where(p => p.PropertyName == "RamSize" && p.ParentPackageId == packageId);
					if (IsCore) result = ps.Sum(p => (int?)Convert.ToInt32(p.PropertyValue)) ?? 0;
					else result = ps
							.Select(p => p.PropertyValue)
							.Cast<int?>()
							.Sum() ?? 0;
					break;
				case 302: // CpuNumber of VPS
				case 555: // CpuNumber of VPS2012
				case 347: // CpuNumber of VPSforPc 
					ps = ServiceItemProperties
					.Join(ServiceItems, p => p.ItemId, s => s.ItemId, (p, s) => new
					{
						Property = p,
						Item = s
					})
					.Join(PackagesTreeCaches, p => p.Item.PackageId, t => t.PackageId, (p, t) => new
					{
						p.Property.PropertyName,
						t.ParentPackageId,
						p.Property.PropertyValue
					})
					.Where(p => p.PropertyName == "CpuCores" && p.ParentPackageId == packageId);
					if (IsCore) result = ps.Sum(p => (int?)Convert.ToInt32(p.PropertyValue)) ?? 0;
					else result = ps
							.Select(p => p.PropertyValue)
							.Cast<int?>()
							.Sum() ?? 0;
					break;
				case 306: // HDD of VPS
				case 559: // HDD of VPS2012
				case 351: // HDD of VPSforPc
					result = ServiceItemProperties
						.Join(ServiceItems, p => p.ItemId, s => s.ItemId, (p, s) => new
						{
							Property = p,
							Item = s
						})
						.Join(PackagesTreeCaches, p => p.Item.PackageId, t => t.PackageId, (p, t) => new
						{
							p.Property.PropertyName,
							t.ParentPackageId,
							p.Property.PropertyValue
						})
						.Where(p => p.PropertyName == "HddSize" && p.ParentPackageId == packageId)
						.AsEnumerable()
						.SelectMany(p => p.PropertyValue.Split(';'))
						.Sum(p => (int?)int.Parse(p)) ?? 0;
					break;
				case 309: // External IP addresses of VPS
				case 562: // External IP addresses of VPS2012
				case 354: // External IP addresses of VPSforPc
					result = PackageIpAddresses
						.Join(IpAddresses, p => p.AddressId, ip => ip.AddressId, (p, ip) => new
						{
							Package = p,
							Ip = ip
						})
						.Join(PackagesTreeCaches, p => p.Package.PackageId, t => t.PackageId, (p, t) => new
						{
							t.ParentPackageId,
							p.Ip.PoolId
						})
						.Where(p => p.ParentPackageId == packageId && p.PoolId == 3)
						.Count();
					break;
				case 558: // RAM of VPS2012
					int fixedMem, dynamicMem;
					ps = ServiceItemProperties
						.Join(ServiceItems, p => p.ItemId, s => s.ItemId, (p, s) => new
						{
							Property = p,
							Item = s
						})
						.Join(PackagesTreeCaches, p => p.Item.PackageId, t => t.PackageId, (p, t) => new
						{
							p.Property.PropertyName,
							t.ParentPackageId,
							p.Property.PropertyValue
						})
						.Where(p => p.PropertyName == "RamSize" && p.ParentPackageId == packageId);
					if (IsCore) fixedMem = ps.Sum(p => (int?)Convert.ToInt32(p.PropertyValue)) ?? 0;
					else fixedMem = ps
							.Select(p => p.PropertyValue)
							.Cast<int?>()
							.Sum() ?? 0;

					ps = ServiceItemProperties
						.Join(ServiceItems, p => p.ItemId, s => s.ItemId, (p, s) => new
						{
							Property = p,
							Item = s
						})
						.Join(ServiceItemProperties.Where(p => p.PropertyName == "DynamicMemory.Enabled" && p.PropertyValue.Equals("True", StringComparison.OrdinalIgnoreCase)),
							p => p.Item.ItemId, sp => sp.ItemId, (p, sp) => p)
						.Join(PackagesTreeCaches, p => p.Item.PackageId, t => t.PackageId, (p, t) => new
						{
							p.Property.PropertyName,
							t.ParentPackageId,
							p.Property.PropertyValue
						})
						.Where(p => p.PropertyName == "DynamicMemory.Maximum" && p.ParentPackageId == packageId);
					if (IsCore) dynamicMem = ps.Sum(p => (int?)Convert.ToInt32(p.PropertyValue)) ?? 0;
					else dynamicMem = ps
							.Select(p => p.PropertyValue)
							.Cast<int?>()
							.Sum() ?? 0;

					result = Math.Max(fixedMem, dynamicMem);
					break;
				case 728: // Private Network VLANs of VPS2012
					result = PackageVlans
						.Join(PrivateNetworkVlans, v => v.VlanId, pv => pv.VlanId, (v, pv) => v)
						.Join(PackagesTreeCaches, v => v.PackageId, t => t.PackageId, (v, t) => new
						{
							Vlan = v,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId && !t.Vlan.IsDmz)
						.Count();
					break;
				case 752: // DMZ Network VLANs of VPS2012
					result = PackageVlans
						.Join(PrivateNetworkVlans, v => v.VlanId, pv => pv.VlanId, (v, pv) => v)
						.Join(PackagesTreeCaches, v => v.PackageId, t => t.PackageId, (v, t) => new
						{
							Vlan = v,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId && t.Vlan.IsDmz)
						.Count();
					break;
				case 100: // Dedicated Web IP addresses
					result = PackageIpAddresses
						.Join(IpAddresses, p => p.AddressId, ip => ip.AddressId, (p, ip) => new
						{
							Package = p,
							Ip = ip
						})
						.Join(PackagesTreeCaches, p => p.Package.PackageId, t => t.PackageId, (p, t) => new
						{
							t.ParentPackageId,
							p.Ip.PoolId
						})
						.Where(p => p.ParentPackageId == packageId && p.PoolId == 2)
						.Count();
					break;
				case 350: // RAM of VPSforPc
					ps = ServiceItemProperties
						.Join(ServiceItems, p => p.ItemId, s => s.ItemId, (p, s) => new
						{
							Property = p,
							Item = s
						})
						.Join(PackagesTreeCaches, p => p.Item.PackageId, t => t.PackageId, (p, t) => new
						{
							p.Property.PropertyName,
							t.ParentPackageId,
							p.Property.PropertyValue
						})
						.Where(p => p.PropertyName == "Memory" && p.ParentPackageId == packageId);
					if (IsCore) result = ps.Sum(p => (int?)Convert.ToInt32(p.PropertyValue)) ?? 0;
					else result = ps
							.Select(p => p.PropertyValue)
							.Cast<int?>()
							.Sum() ?? 0;
					break;
				case 319: // BB Users
					result = ExchangeAccounts
						.Join(BlackBerryUsers, ea => ea.AccountId, bb => bb.AccountId, (ea, bb) => ea)
						.Join(ServiceItems, ea => ea.ItemId, si => si.ItemId, (ea, si) => si)
						.Join(PackagesTreeCaches, si => si.PackageId, t => t.PackageId, (si, t) => t)
						.Where(t => t.ParentPackageId == packageId)
						.Count();
					break;
				case 320: // OCS Users
					result = ExchangeAccounts
						.Join(OcsUsers, ea => ea.AccountId, ocs => ocs.AccountId, (ea, ocs) => ea)
						.Join(ServiceItems, ea => ea.ItemId, si => si.ItemId, (ea, si) => si)
						.Join(PackagesTreeCaches, si => si.PackageId, t => t.PackageId, (si, t) => t)
						.Where(t => t.ParentPackageId == packageId)
						.Count();
					break;
				case 206: // HostedSolution.Users
					var accountTypes = new [] { ExchangeAccountType.Mailbox, ExchangeAccountType.Room, 
						ExchangeAccountType.Equipment, ExchangeAccountType.User };
					result = ExchangeAccounts
						.Join(ServiceItems, ea => ea.ItemId, si => si.ItemId, (ea, si) => new
						{
							Exchange = ea,
							Item = si
						})
						.Join(PackagesTreeCaches, ea => ea.Item.PackageId, t => t.PackageId, (ea, t) => new
						{
							ea.Exchange,
							ea.Item,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId && accountTypes.Any(type => t.Exchange.AccountType == type))
						.Count();
					break;
				case 78: // Exchange2007.Mailboxes
					result = ExchangeAccounts
						.Join(ServiceItems, ea => ea.ItemId, si => si.ItemId, (ea, si) => new
						{
							Exchange = ea,
							Item = si
						})
						.Join(PackagesTreeCaches, ea => ea.Item.PackageId, t => t.PackageId, (ea, t) => new
						{
							ea.Exchange,
							ea.Item,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId && t.Exchange.MailboxPlanId != null &&
							t.Exchange.AccountType == ExchangeAccountType.Mailbox)
						.Count();
					break;
				case 731: // Exchange2013.JournalingMailboxes
					result = ExchangeAccounts
						.Join(ServiceItems, ea => ea.ItemId, si => si.ItemId, (ea, si) => new
						{
							Exchange = ea,
							Item = si
						})
						.Join(PackagesTreeCaches, ea => ea.Item.PackageId, t => t.PackageId, (ea, t) => new
						{
							ea.Exchange,
							ea.Item,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId && t.Exchange.MailboxPlanId != null &&
							t.Exchange.AccountType == ExchangeAccountType.JournalingMailbox)
						.Count();
					break;
				case 77: // Exchange2007.DiskSpace
					accountTypes = new [] { ExchangeAccountType.Mailbox, ExchangeAccountType.Room,
						ExchangeAccountType.Equipment, ExchangeAccountType.SharedMailbox,
						ExchangeAccountType.JournalingMailbox };
					result = ExchangeAccounts
						.Join(ExchangeMailboxPlans, ea => ea.MailboxPlanId, ep => ep.MailboxPlanId, (ea, ep) => new
						{
							Exchange = ea,
							MailboxPlan = ep
						})
						.Join(ServiceItems, ea => ea.Exchange.ItemId, si => si.ItemId, (ea, si) => new
						{
							ea.Exchange,
							ea.MailboxPlan,
							Item = si
						})
						.Join(PackagesTreeCaches, ea => ea.Item.PackageId, t => t.PackageId, (ea, t) => new
						{
							ea.Exchange,
							ea.MailboxPlan,
							ea.Item,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId &&
							accountTypes.Any(type => t.Exchange.AccountType == type))
						.Sum(t => (int?)t.MailboxPlan.MailboxSizeMb) ?? 0;
					break;
				case 370: // Lync.Users
					result = ExchangeAccounts
						.Join(LyncUsers, ea => ea.AccountId, lu => lu.AccountId, (ea, lu) => ea)
						.Join(ServiceItems, ea => ea.ItemId, si => si.ItemId, (ea, si) => new
						{
							Exchange = ea,
							Item = si
						})
						.Join(PackagesTreeCaches, ea => ea.Item.PackageId, t => t.PackageId, (ea, t) => new
						{
							ea.Exchange,
							ea.Item,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId)
						.Count();
					break;
				case 376: // Lync.EVUsers
					result = ExchangeAccounts
						.Join(LyncUsers, ea => ea.AccountId, lu => lu.AccountId, (ea, lu) => new
						{
							Exchange = ea,
							LyncUser = lu,
						})
						.Join(LyncUserPlans, ea => ea.LyncUser.LyncUserPlanId, lp => lp.LyncUserPlanId, (ea, lp) => new
						{
							ea.Exchange,
							ea.LyncUser,
							LyncUserPlan = lp,
						})
						.Join(ServiceItems, ea => ea.Exchange.ItemId, si => si.ItemId, (ea, si) => new
						{
							ea.Exchange,
							ea.LyncUser,
							ea.LyncUserPlan,
							Item = si
						})
						.Join(PackagesTreeCaches, ea => ea.Item.PackageId, t => t.PackageId, (ea, t) => new
						{
							ea.Exchange,
							ea.LyncUser,
							ea.LyncUserPlan,
							ea.Item,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId && t.LyncUserPlan.EnterpriseVoice)
						.Count();
					break;
				case 381: // Dedicated Lync Phone Numbers
					result = PackageIpAddresses
						.Join(IpAddresses, p => p.AddressId, ip => ip.AddressId, (p, ip) => new
						{
							Package = p,
							Ip = ip
						})
						.Join(PackagesTreeCaches, p => p.Package.PackageId, t => t.PackageId, (p, t) => new
						{
							t.ParentPackageId,
							p.Ip.PoolId
						})
						.Where(p => p.ParentPackageId == packageId && p.PoolId == 5)
						.Count();
					break;
				case 430: // Enterprise Storage
					result = EnterpriseFolders
						.Join(ServiceItems, ef => ef.ItemId, si => si.ItemId, (ef, si) => new
						{
							Folder = ef,
							Item = si
						})
						.Join(PackagesTreeCaches, ef => ef.Item.PackageId, t => t.PackageId, (ef, t) => new
						{
							ef.Folder,
							ef.Item,
							Tree = t
						})
						.Where(ef => ef.Tree.ParentPackageId == packageId)
						.Sum(ef => (int?)ef.Folder.FolderQuota) ?? 0;
					break;
				case 431: // Enterprise Storage Folders
					result = EnterpriseFolders
						.Join(ServiceItems, ef => ef.ItemId, si => si.ItemId, (ef, si) => new
						{
							Folder = ef,
							Item = si
						})
						.Join(PackagesTreeCaches, ef => ef.Item.PackageId, t => t.PackageId, (ef, t) => new
						{
							ef.Folder,
							ef.Item,
							Tree = t
						})
						.Where(ef => ef.Tree.ParentPackageId == packageId)
						.Count();
					break;
				case 423: // HostedSolution.SecurityGroups
					accountTypes = new [] { ExchangeAccountType.SecurityGroup,
						ExchangeAccountType.DefaultSecurityGroup };
					result = ExchangeAccounts
						.Join(ServiceItems, ea => ea.ItemId, si => si.ItemId, (ea, si) => new
						{
							Exchange = ea,
							Item = si
						})
						.Join(PackagesTreeCaches, ea => ea.Item.PackageId, t => t.PackageId, (ea, t) => new
						{
							ea.Exchange,
							ea.Item,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId &&
							accountTypes.Any(type => t.Exchange.AccountType == type))
						.Count();
					break;
				case 495: // HostedSolution.DeletedUsers
					result = ExchangeAccounts
						.Join(ServiceItems, ea => ea.ItemId, si => si.ItemId, (ea, si) => new
						{
							Exchange = ea,
							Item = si
						})
						.Join(PackagesTreeCaches, ea => ea.Item.PackageId, t => t.PackageId, (ea, t) => new
						{
							ea.Exchange,
							ea.Item,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId &&
							t.Exchange.AccountType == ExchangeAccountType.DeletedUser)
						.Count();
					break;
				case 450: // RDSCollectionUsers
					result = RdsCollectionUsers
						.Join(ExchangeAccounts, rds => rds.AccountId, ea => ea.AccountId, (rds, ea) => ea)
						.Join(ServiceItems, ea => ea.ItemId, si => si.ItemId, (ea, si) => new
						{
							Exchange = ea,
							Item = si
						})
						.Join(PackagesTreeCaches, ea => ea.Item.PackageId, t => t.PackageId, (ea, t) => new
						{
							ea.Exchange,
							Tree = t
						})
						.Where(t => t.Tree.ParentPackageId == packageId &&
							t.Exchange.AccountType == ExchangeAccountType.DeletedUser)
						.GroupBy(ea => ea.Exchange.AccountId)
						.Count();
					break;
				case 451: // RDSServers
					result = RdsServers
						.Join(ServiceItems, s => s.ItemId, si => si.ItemId, (s, si) => si)
						.Join(PackagesTreeCaches, si => si.PackageId, t => t.PackageId, (s, t) => t)
						.Where(t => t.ParentPackageId == packageId)
						.Count();
					break;
				case 491: // RDSCollections
					result = RdsCollections
						.Join(ServiceItems, rc => rc.ItemId, si => si.ItemId, (s, si) => si)
						.Join(PackagesTreeCaches, si => si.PackageId, t => t.PackageId, (s, t) => t)
						.Where(t => t.ParentPackageId == packageId)
						.Count();
					break;
				default:
					if (quota.QuotaName.StartsWith("ServiceLevel.")) // Support Service Level Quota
					{
						var levelName = quota.QuotaName.Substring("ServiceLevel.".Length);
						var levelId = SupportServiceLevels
							.Where(l => l.LevelName == levelName)
							.Select(l => (int?)l.LevelId)
							.FirstOrDefault();
						if (levelId != null)
						{
							result = ExchangeAccounts
								.Join(ServiceItems, ea => ea.ItemId, si => si.ItemId, (ea, si) => new
								{
									Exchange = ea,
									Item = si
								})
								.Join(PackagesTreeCaches, ea => ea.Item.PackageId, t => t.PackageId, (ea, t) => new
								{
									ea.Exchange,
									ea.Item,
									Tree = t
								})
								.Where(t => t.Tree.ParentPackageId == packageId && t.Exchange.LevelId == levelId)
								.Count();
						}
						else result = 0;
					}
					else
					{
						result = Quotas
							.Where(q => q.QuotaId == quotaId)
							.Join(ServiceItems, q => q.ItemTypeId, si => si.ItemTypeId, (q, si) => si)
							.Join(PackagesTreeCaches, si => si.PackageId, t => t.PackageId, (si, t) => t)
							.Where(t => t.ParentPackageId == packageId)
							.Count();
					}
					break;
			}
			return result;
		}

		public DataSet GetPackageQuotas(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageQuotas]
(
	@ActorID int,
	@PackageID int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @PlanID int, @ParentPackageID int
SELECT @PlanID = PlanID, @ParentPackageID = ParentPackageID FROM Packages
WHERE PackageID = @PackageID

-- get resource groups
SELECT
	RG.GroupID,
	RG.GroupName,
	ISNULL(HPR.CalculateDiskSpace, 0) AS CalculateDiskSpace,
	ISNULL(HPR.CalculateBandwidth, 0) AS CalculateBandwidth,
	--dbo.GetPackageAllocatedResource(@ParentPackageID, RG.GroupID, 0) AS ParentEnabled
	CASE
		WHEN RG.GroupName = 'Service Levels' THEN dbo.GetPackageServiceLevelResource(@ParentPackageID, RG.GroupID, 0)
		ELSE dbo.GetPackageAllocatedResource(@ParentPackageID, RG.GroupID, 0)
	END AS ParentEnabled
FROM ResourceGroups AS RG
LEFT OUTER JOIN HostingPlanResources AS HPR ON RG.GroupID = HPR.GroupID AND HPR.PlanID = @PlanID
--WHERE dbo.GetPackageAllocatedResource(@PackageID, RG.GroupID, 0) = 1
WHERE (dbo.GetPackageAllocatedResource(@PackageID, RG.GroupID, 0) = 1 AND RG.GroupName <> 'Service Levels') OR
	  (dbo.GetPackageServiceLevelResource(@PackageID, RG.GroupID, 0) = 1 AND RG.GroupName = 'Service Levels')
ORDER BY RG.GroupOrder

-- return quotas
DECLARE @OrgsCount INT
SET @OrgsCount = dbo.GetPackageAllocatedQuota(@PackageID, 205) -- 205 - HostedSolution.Organizations
SET @OrgsCount = CASE WHEN ISNULL(@OrgsCount, 0) < 1 THEN 1 ELSE @OrgsCount END

SELECT
	Q.QuotaID,
	Q.GroupID,
	Q.QuotaName,
	Q.QuotaDescription,
	Q.QuotaTypeID,
	QuotaValue = CASE WHEN Q.PerOrganization = 1 AND dbo.GetPackageAllocatedQuota(@PackageID, Q.QuotaID) <> -1 THEN 
					dbo.GetPackageAllocatedQuota(@PackageID, Q.QuotaID) * @OrgsCount 
				 ELSE 
					dbo.GetPackageAllocatedQuota(@PackageID, Q.QuotaID) 
				 END,
	QuotaValuePerOrganization = dbo.GetPackageAllocatedQuota(@PackageID, Q.QuotaID),
	dbo.GetPackageAllocatedQuota(@ParentPackageID, Q.QuotaID) AS ParentQuotaValue,
	ISNULL(dbo.CalculateQuotaUsage(@PackageID, Q.QuotaID), 0) AS QuotaUsedValue,
	Q.PerOrganization
FROM Quotas AS Q
WHERE Q.HideQuota IS NULL OR Q.HideQuota = 0
ORDER BY Q.QuotaOrder

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var package = Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => new { p.PlanId, p.ParentPackageId })
					.FirstOrDefault();
				var packagePlanId = package?.PlanId;
				var parentPackageId = package?.ParentPackageId;
				
				// get resource groups
				var groups = ResourceGroups
					.OrderBy(r => r.GroupOrder)
					.GroupJoin(HostingPlanResources,
						r => new { r.GroupId, PlanId = packagePlanId },
						hr => new { hr.GroupId, PlanId = (int?)hr.PlanId },
						(r, hr) => new
						{
							Group = r,
							HostingPlans = hr
						})
					.SelectMany(g => g.HostingPlans.DefaultIfEmpty(), (g, hr) => new
					{
						g.Group.GroupId,
						g.Group.GroupName,
						CalculateDiskSpace = hr != null ? hr.CalculateDiskSpace : false,
						CalculateBandwidth = hr != null ? hr.CalculateBandwidth : false,
					})
					.AsEnumerable()
					.Where(r => r.GroupName != "Service Levels" && Local.GetPackageAllocatedResource(packageId, r.GroupId, 0) ||
						r.GroupName == "Service Levels" && Local.GetPackageServiceLevelResource(packageId, r.GroupId, 0))
					.Select(g => new
					{
						g.GroupId,
						g.GroupName,
						g.CalculateDiskSpace,
						g.CalculateBandwidth,
						ParentEnabled = g.GroupName == "Service Levels" ?
							Local.GetPackageServiceLevelResource(package.ParentPackageId, g.GroupId, 0) :
							Local.GetPackageAllocatedResource(package.ParentPackageId, g.GroupId, 0)
					});

				// return quotas
				var nofOrgs = GetPackageAllocatedQuota(packageId, 205); // 205 - HostedSolution.Organizations
				if (nofOrgs < 1) nofOrgs = 1;

				var quotas = Quotas
					.Where(q => q.HideQuota != true)
					.OrderBy(q => q.QuotaOrder)
					.AsEnumerable()
					.Select(q => new
					{
						Quota = q,
						AllocatedQuota = Local.GetPackageAllocatedQuota(packageId, q.QuotaId)
					})
					.Select(q => new
					{
						q.Quota.QuotaId,
						q.Quota.GroupId,
						q.Quota.QuotaName,
						q.Quota.QuotaDescription,
						q.Quota.QuotaTypeId,
						QuotaValue = q.Quota.PerOrganization == 1 && q.AllocatedQuota != -1 ?
							q.AllocatedQuota * nofOrgs :
							q.AllocatedQuota,
						QuotaValuePerOrganization = q.AllocatedQuota,
						ParentQuotaValue = Local.GetPackageAllocatedQuota(package.ParentPackageId, q.Quota.QuotaId),
						QuotaUsedValue = Local.CalculateQuotaUsage(packageId, q.Quota.QuotaId),
						q.Quota.PerOrganization
					});
				return EntityDataSet(groups, quotas);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackageQuotas",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageID", packageId));
			}
		}

		public DataSet GetParentPackageQuotas(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetParentPackageQuotas]
(
	@ActorID int,
	@PackageID int
)
AS

-- check rights
IF dbo.CheckActorParentPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @PlanID int, @ParentPackageID int
SELECT @PlanID = PlanID, @ParentPackageID = ParentPackageID FROM Packages
WHERE PackageID = @PackageID

-- get resource groups
SELECT
	RG.GroupID,
	RG.GroupName,
	ISNULL(HPR.CalculateDiskSpace, 0) AS CalculateDiskSpace,
	ISNULL(HPR.CalculateBandwidth, 0) AS CalculateBandwidth,
	--dbo.GetPackageAllocatedResource(@ParentPackageID, RG.GroupID, 0) AS ParentEnabled
	CASE
		WHEN RG.GroupName = 'Service Levels' THEN dbo.GetPackageServiceLevelResource(@ParentPackageID, RG.GroupID, 0)
		ELSE dbo.GetPackageAllocatedResource(@ParentPackageID, RG.GroupID, 0)
	END AS ParentEnabled
FROM ResourceGroups AS RG
LEFT OUTER JOIN HostingPlanResources AS HPR ON RG.GroupID = HPR.GroupID AND HPR.PlanID = @PlanID
--WHERE dbo.GetPackageAllocatedResource(@PackageID, RG.GroupID, 0) = 1
WHERE (dbo.GetPackageAllocatedResource(@PackageID, RG.GroupID, 0) = 1 AND RG.GroupName <> 'Service Levels') OR
	  (dbo.GetPackageServiceLevelResource(@PackageID, RG.GroupID, 0) = 1 AND RG.GroupName = 'Service Levels')
ORDER BY RG.GroupOrder

-- return quotas
DECLARE @OrgsCount INT
SET @OrgsCount = dbo.GetPackageAllocatedQuota(@PackageID, 205) -- 205 - HostedSolution.Organizations
SET @OrgsCount = CASE WHEN ISNULL(@OrgsCount, 0) < 1 THEN 1 ELSE @OrgsCount END

SELECT
	Q.QuotaID,
	Q.GroupID,
	Q.QuotaName,
	Q.QuotaDescription,
	Q.QuotaTypeID,
	QuotaValue = CASE WHEN Q.PerOrganization = 1 AND dbo.GetPackageAllocatedQuota(@PackageID, Q.QuotaID) <> -1 THEN 
					dbo.GetPackageAllocatedQuota(@PackageID, Q.QuotaID) * @OrgsCount 
				 ELSE 
					dbo.GetPackageAllocatedQuota(@PackageID, Q.QuotaID) 
				 END,
	QuotaValuePerOrganization = dbo.GetPackageAllocatedQuota(@PackageID, Q.QuotaID),
	dbo.GetPackageAllocatedQuota(@ParentPackageID, Q.QuotaID) AS ParentQuotaValue,
	ISNULL(dbo.CalculateQuotaUsage(@PackageID, Q.QuotaID), 0) AS QuotaUsedValue,
	Q.PerOrganization
FROM Quotas AS Q
WHERE Q.HideQuota IS NULL OR Q.HideQuota = 0
ORDER BY Q.QuotaOrder

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorParentPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				// TODO is this implementation really just the same as GetPackageQuotas?
				var package = Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => new { p.PlanId, p.ParentPackageId })
					.FirstOrDefault();
				// get resource groups
				var groups = ResourceGroups
					.OrderBy(r => r.GroupOrder)
					.GroupJoin(HostingPlanResources.Where(r => r.PlanId == package.PlanId),
						r => r.GroupId, hr => hr.GroupId, (r, hr) => new
					{
						Group = r,
						Resources = hr
					})
					.SelectMany(g => g.Resources.DefaultIfEmpty(), (g, hr) => new
					{
						g.Group.GroupId,
						g.Group.GroupName,
						CalculateDiskSpace = hr != null ? hr.CalculateDiskSpace : false,
						CalculateBandwidth = hr != null ? hr.CalculateBandwidth : false,
					})
					.AsEnumerable()
					.Where(r => r.GroupName != "Service Levels" && Local.GetPackageAllocatedResource(packageId, r.GroupId, 0) ||
						r.GroupName == "Service Levels" && Local.GetPackageServiceLevelResource(packageId, r.GroupId, 0))
					.Select(g => new
					{
						g.GroupId,
						g.GroupName,
						ParentEnabled = g.GroupName == "Service Levels" ?
							Local.GetPackageServiceLevelResource(package.ParentPackageId, g.GroupId, 0) :
							Local.GetPackageAllocatedResource(package.ParentPackageId, g.GroupId, 0)
					});
				// return quotas
				var nofOrgs = GetPackageAllocatedQuota(packageId, 205); // 205 - HostedSolution.Organizations
				if (nofOrgs < 1) nofOrgs = 1;

				var quotas = Quotas
					.Where(q => q.HideQuota != true)
					.OrderBy(q => q.QuotaOrder)
					.AsEnumerable()
					.Select(q => new
					{
						Quota = q,
						AllocatedQuota = Local.GetPackageAllocatedQuota(packageId, q.QuotaId)
					})
					.Select(q => new
					{
						q.Quota.QuotaId,
						q.Quota.GroupId,
						q.Quota.QuotaName,
						q.Quota.QuotaDescription,
						q.Quota.QuotaTypeId,
						QuotaValue = q.Quota.PerOrganization == 1 && q.AllocatedQuota != -1 ?
							q.AllocatedQuota * nofOrgs :
							q.AllocatedQuota,
						QuotaValuePerOrganization = q.AllocatedQuota,
						ParentQuotaValue = Local.GetPackageAllocatedQuota(package.ParentPackageId, q.Quota.QuotaId),
						QuotaUsedValue = Local.CalculateQuotaUsage(packageId, q.Quota.QuotaId),
						q.Quota.PerOrganization
					});
				return EntityDataSet(groups, quotas);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetParentPackageQuotas",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageID", packageId));
			}
		}

		public DataSet GetPackageQuotasForEdit(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageQuotasForEdit]
(
	@ActorID int,
	@PackageID int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @ServerID int, @ParentPackageID int, @PlanID int
SELECT @ServerID = ServerID, @ParentPackageID = ParentPackageID, @PlanID = PlanID FROM Packages
WHERE PackageID = @PackageID

-- get resource groups
SELECT
	RG.GroupID,
	RG.GroupName,
	ISNULL(PR.CalculateDiskSpace, ISNULL(HPR.CalculateDiskSpace, 0)) AS CalculateDiskSpace,
	ISNULL(PR.CalculateBandwidth, ISNULL(HPR.CalculateBandwidth, 0)) AS CalculateBandwidth,
		--dbo.GetPackageAllocatedResource(@PackageID, RG.GroupID, @ServerID) AS Enabled,
	CASE
		WHEN RG.GroupName = 'Service Levels' THEN dbo.GetPackageServiceLevelResource(PackageID, RG.GroupID, @ServerID)
		ELSE dbo.GetPackageAllocatedResource(PackageID, RG.GroupID, @ServerID)
	END AS Enabled,
	--dbo.GetPackageAllocatedResource(@ParentPackageID, RG.GroupID, @ServerID) AS ParentEnabled
	CASE
		WHEN RG.GroupName = 'Service Levels' THEN dbo.GetPackageServiceLevelResource(@ParentPackageID, RG.GroupID, @ServerID)
		ELSE dbo.GetPackageAllocatedResource(@ParentPackageID, RG.GroupID, @ServerID)
	END AS ParentEnabled
FROM ResourceGroups AS RG
LEFT OUTER JOIN PackageResources AS PR ON RG.GroupID = PR.GroupID AND PR.PackageID = @PackageID
LEFT OUTER JOIN HostingPlanResources AS HPR ON RG.GroupID = HPR.GroupID AND HPR.PlanID = @PlanID
ORDER BY RG.GroupOrder

-- return quotas
SELECT
	Q.QuotaID,
	Q.GroupID,
	Q.QuotaName,
	Q.QuotaDescription,
	Q.QuotaTypeID,
	CASE
		WHEN PQ.QuotaValue IS NULL THEN dbo.GetPackageAllocatedQuota(@PackageID, Q.QuotaID)
		ELSE PQ.QuotaValue
	END QuotaValue,
	dbo.GetPackageAllocatedQuota(@ParentPackageID, Q.QuotaID) AS ParentQuotaValue
FROM Quotas AS Q
LEFT OUTER JOIN PackageQuotas AS PQ ON PQ.QuotaID = Q.QuotaID AND PQ.PackageID = @PackageID
ORDER BY Q.QuotaOrder

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var package = Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => new { p.ServerId, p.PlanId, p.ParentPackageId })
					.FirstOrDefault();
				// get resource groups
				var groups = ResourceGroups
					.OrderBy(r => r.GroupOrder)
					.GroupJoin(HostingPlanResources.Where(r => r.PlanId == package.PlanId), r => r.GroupId, hr => hr.GroupId, (r, hr) => new
					{
						Group = r,
						Resources = hr
						//HostingPlan = hr.SingleOrDefault()
					})
					.SelectMany(g => g.Resources.DefaultIfEmpty(), (g, hr) => new
					{
						g.Group.GroupId,
						g.Group.GroupName,
						CalculateDiskSpace = hr != null ? hr.CalculateDiskSpace : false,
						CalculateBandwidth = hr != null ? hr.CalculateBandwidth : false,
					})
					.AsEnumerable()
					.Select(g => new
					{
						Enabled = g.GroupName == "Service Levels" ?
							Local.GetPackageServiceLevelResource(packageId, g.GroupId, package.ServerId) :
							Local.GetPackageAllocatedResource(packageId, g.GroupId, package.ServerId),
						ParentEnabled = g.GroupName == "Service Levels" ?
							Local.GetPackageServiceLevelResource(package.ParentPackageId, g.GroupId, package.ServerId) :
							Local.GetPackageAllocatedResource(package.ParentPackageId, g.GroupId, package.ServerId)
					});
				// return quotas
				var nofOrgs = GetPackageAllocatedQuota(packageId, 205); // 205 - HostedSolution.Organizations
				if (nofOrgs < 1) nofOrgs = 1;

				var quotas = Quotas
					.Where(q => q.HideQuota != true)
					.OrderBy(q => q.QuotaOrder)
					.AsEnumerable()
					.Select(q => new
					{
						Quota = q,
						AllocatedQuota = Local.GetPackageAllocatedQuota(packageId, q.QuotaId)
					})
					.Select(q => new
					{
						q.Quota.QuotaId,
						q.Quota.GroupId,
						q.Quota.QuotaName,
						q.Quota.QuotaDescription,
						q.Quota.QuotaTypeId,
						QuotaValue = q.Quota.PerOrganization == 1 && q.AllocatedQuota != -1 ?
							q.AllocatedQuota * nofOrgs :
							q.AllocatedQuota,
						QuotaValuePerOrganization = q.AllocatedQuota,
						ParentQuotaValue = Local.GetPackageAllocatedQuota(package.ParentPackageId, q.Quota.QuotaId),
						QuotaUsedValue = Local.CalculateQuotaUsage(packageId, q.Quota.QuotaId),
						q.Quota.PerOrganization
					});
				return EntityDataSet(groups, quotas);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackageQuotasForEdit",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageID", packageId));
			}
		}

		public IEnumerable<int> PackageParents(int packageId)
		{
			#region Stored Procedure
			/*
CREATE FUNCTION [dbo].[PackageParents]
(
	@PackageID int
)
RETURNS @T TABLE (PackageOrder int IDENTITY(1,1), PackageID int)
AS
BEGIN
	-- insert current user
	INSERT @T VALUES (@PackageID)

	-- owner
	DECLARE @ParentPackageID int, @TmpPackageID int
	SET @TmpPackageID = @PackageID

	WHILE 10 = 10
	BEGIN

		SET @ParentPackageID = NULL --reset var
		SELECT @ParentPackageID = ParentPackageID FROM Packages
		WHERE PackageID = @TmpPackageID

		IF @ParentPackageID IS NULL -- parent not found
		BREAK

		INSERT @T VALUES (@ParentPackageID)

		SET @TmpPackageID = @ParentPackageID
	END

RETURN
END
			*/
			#endregion

			int? pid = packageId;
			while (pid != null)
			{
				yield return pid.Value;
				pid = Packages
					.Where(p => p.PackageId == pid)
					.Select(p => p.ParentPackageId)
					.FirstOrDefault();
			}
		}

		public DataSet AddPackage(int actorId, out int packageId, int userId, int planId, string packageName,
			string packageComments, int statusId, DateTime purchaseDate)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddPackage]
(
	@ActorID int,
	@PackageID int OUTPUT,
	@UserID int,
	@PackageName nvarchar(300),
	@PackageComments ntext,
	@StatusID int,
	@PlanID int,
	@PurchaseDate datetime
)
AS

DECLARE @ParentPackageID int, @PlanServerID int
SELECT @ParentPackageID = PackageID, @PlanServerID = ServerID FROM HostingPlans
WHERE PlanID = @PlanID

IF @ParentPackageID = 0 OR @ParentPackageID IS NULL
SELECT @ParentPackageID = PackageID FROM Packages
WHERE ParentPackageID IS NULL -- root space

DECLARE @datelastyear datetime = DATEADD(year,-1,GETDATE())

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @ParentPackageID) = 0
BEGIN
	RAISERROR('You are not allowed to access this package', 16, 1);
	RETURN;
END

BEGIN TRAN
-- insert package
INSERT INTO Packages
(
	ParentPackageID,
	UserID,
	PackageName,
	PackageComments,
	ServerID,
	StatusID,
	PlanID,
	PurchaseDate,
	BandwidthUpdated
)
VALUES
(
	@ParentPackageID,
	@UserID,
	@PackageName,
	@PackageComments,
	@PlanServerID,
	@StatusID,
	@PlanID,
	@PurchaseDate,
	@datelastyear
)

SET @PackageID = SCOPE_IDENTITY()

-- add package to packages cache
INSERT INTO PackagesTreeCache (ParentPackageID, PackageID)
SELECT PackageID, @PackageID FROM dbo.PackageParents(@PackageID)

DECLARE @ExceedingQuotas AS TABLE (QuotaID int, QuotaName nvarchar(50), QuotaValue int)
INSERT INTO @ExceedingQuotas
SELECT * FROM dbo.GetPackageExceedingQuotas(@ParentPackageID) WHERE QuotaValue > 0

SELECT * FROM @ExceedingQuotas

IF EXISTS(SELECT * FROM @ExceedingQuotas)
BEGIN
	ROLLBACK TRAN
	RETURN
END

COMMIT TRAN

RETURN
				*/
				#endregion

				var plan = HostingPlans
					.Where(hp => hp.PlanId == planId)
					.Select(hp => new { hp.PackageId, hp.ServerId })
					.FirstOrDefault();

				var parentPackageId = plan?.PackageId;

				if (parentPackageId == null || parentPackageId == 0)
				{
					parentPackageId = Packages
						.Where(p => p.ParentPackageId == null)
						.Select(p => p.PackageId)
						.FirstOrDefault();
				}

				// check rights
				if (!CheckActorPackageRights(actorId, parentPackageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var today = DateTime.Now.Date;
				var dateLastYear = today.AddYears(-1);

				using (var transaction = Database.BeginTransaction())
				{
					var package = new Data.Entities.Package()
					{
						ParentPackageId = parentPackageId,
						UserId = userId,
						PackageName = packageName,
						PackageComments = packageComments,
						ServerId = plan?.ServerId,
						StatusId = statusId,
						PlanId = planId,
						PurchaseDate = purchaseDate,
						BandwidthUpdated = dateLastYear,
						StatusIdChangeDate = DateTime.Now
					};
					Packages.Add(package);
					SaveChanges();

					var pid = packageId = package.PackageId;

					// add package to packages cache
					var parents = PackageParents(pid)
						.Select(parentId => new Data.Entities.PackagesTreeCache
						{
							PackageId = pid,
							ParentPackageId = parentId
						});
					PackagesTreeCaches.AddRange(parents);
					SaveChanges();

					var exceedingQuotas = GetPackageExceedingQuotas(packageId)
						.Where(q => q.QuotaValue > 0)
						.ToArray();

					if (exceedingQuotas.Any()) transaction.Rollback();
					else transaction.Commit();

					return EntityDataSet(exceedingQuotas);
				}
			}
			else
			{
				SqlParameter prmPackageId = new SqlParameter("@PackageID", SqlDbType.Int);
				prmPackageId.Direction = ParameterDirection.Output;

				DataSet ds = SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddPackage",
					prmPackageId,
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@userId", userId),
					new SqlParameter("@packageName", packageName),
					new SqlParameter("@packageComments", packageComments),
					new SqlParameter("@statusId", statusId),
					new SqlParameter("@planId", planId),
					new SqlParameter("@purchaseDate", purchaseDate));

				// read identity
				packageId = Convert.ToInt32(prmPackageId.Value);

				DistributePackageServices(actorId, packageId);

				return ds;
			}
		}

		public void UpdatePackageQuotas(int actorId, int packageId, string xml)
		{
			#region Stored Procedure
			/*
CREATE PROCEDURE [dbo].[UpdatePackageQuotas]
(
	@ActorID int,
	@PackageID int,
	@Xml ntext
)
AS

/*
XML Format:

<plan>
	<groups>
		<group id=""16"" enabled=""1"" calculateDiskSpace=""1"" calculateBandwidth=""1""/>
	</groups>
	<quotas>
		<quota id=""2"" value=""2""/>
	</quotas>
</plan>

*//*

--check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @OverrideQuotas bit
SELECT @OverrideQuotas = OverrideQuotas FROM Packages
WHERE PackageID = @PackageID

IF @OverrideQuotas = 0
BEGIN
	-- delete old Package resources
	DELETE FROM PackageResources
	WHERE PackageID = @PackageID

	-- delete old Package quotas
	DELETE FROM PackageQuotas
	WHERE PackageID = @PackageID
END

IF @OverrideQuotas = 1 AND @Xml IS NOT NULL
BEGIN
	--delete old Package resources
	DELETE FROM PackageResources
	WHERE PackageID = @PackageID

	-- delete old Package quotas
	DELETE FROM PackageQuotas
	WHERE PackageID = @PackageID

	DECLARE @idoc int
	--Create an internal representation of the XML document.
	EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

	-- update Package resources
	INSERT INTO PackageResources
	(
		PackageID,
		GroupID,
		CalculateDiskSpace,
		CalculateBandwidth
	)
	SELECT
		@PackageID,
		GroupID,
		CalculateDiskSpace,
		CalculateBandwidth
	FROM OPENXML(@idoc, '/plan/groups/group',1) WITH
	(
		GroupID int '@id',
		CalculateDiskSpace bit '@calculateDiskSpace',
		CalculateBandwidth bit '@calculateBandwidth'
	) as XRG

	-- update Package quotas
	INSERT INTO PackageQuotas
	(
		PackageID,
		QuotaID,
		QuotaValue
	)
	SELECT
		@PackageID,
		QuotaID,
		QuotaValue
	FROM OPENXML(@idoc, '/plan/quotas/quota',1) WITH
	(
		QuotaID int '@id',
		QuotaValue int '@value'
	) as PV

	-- remove document
	exec sp_xml_removedocument @idoc
END
RETURN
			*/
			#endregion

			// check rights
			if (!CheckActorPackageRights(actorId, packageId))
				throw new AccessViolationException("You are not allowed to access this package");

			// delete old Package resources
			PackageResources.Where(r => r.PackageId == packageId).ExecuteDelete();

			// delete old Package quotas
			PackageQuotas.Where(q => q.PackageId == packageId).ExecuteDelete();

			var overrideQuotas = Packages
				.Where(p => p.PackageId == packageId)
				.Select(p => p.OverrideQuotas)
				.FirstOrDefault();
			if (overrideQuotas)
			{
				var plan = XElement.Parse(xml);

				var resources = plan
					.Element("groups")
					.Elements()
					.Select(e => new Data.Entities.PackageResource
					{
						PackageId = packageId,
						GroupId = (int)e.Attribute("id"),
						CalculateDiskspace = (int)e.Attribute("calculateDiskSpace") == 1,
						CalculateBandwidth = (int)e.Attribute("calculateBandwidth") == 1
					});
				PackageResources.AddRange(resources);

				var quotas = plan
					.Element("quotas")
					.Elements()
					.Select(e => new Data.Entities.PackageQuota
					{
						PackageId = packageId,
						QuotaId = (int)e.Attribute("id"),
						QuotaValue = (int)e.Attribute("value")
					});
				PackageQuotas.AddRange(quotas);
			}

			SaveChanges();
		}

		public DataSet UpdatePackage(int actorId, int packageId, int planId, string packageName,
			string packageComments, int statusId, DateTime purchaseDate,
			bool overrideQuotas, string quotasXml, bool defaultTopPackage)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdatePackage]
(
	@ActorID int,
	@PackageID int,
	@PackageName nvarchar(300),
	@PackageComments ntext,
	@StatusID int,
	@PlanID int,
	@PurchaseDate datetime,
	@OverrideQuotas bit,
	@QuotasXml ntext,
	@DefaultTopPackage bit
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

BEGIN TRAN

DECLARE @ParentPackageID int
DECLARE @OldPlanID int

SELECT @ParentPackageID = ParentPackageID, @OldPlanID = PlanID FROM Packages
WHERE PackageID = @PackageID

-- update package
UPDATE Packages SET
	PackageName = @PackageName,
	PackageComments = @PackageComments,
	StatusID = @StatusID,
	PlanID = @PlanID,
	PurchaseDate = @PurchaseDate,
	OverrideQuotas = @OverrideQuotas,
	DefaultTopPackage = @DefaultTopPackage
WHERE
	PackageID = @PackageID

-- update quotas (if required)
EXEC UpdatePackageQuotas @ActorID, @PackageID, @QuotasXml

-- check resulting quotas
DECLARE @ExceedingQuotas AS TABLE (QuotaID int, QuotaName nvarchar(50), QuotaValue int)

-- check exceeding quotas if plan has been changed
IF (@OldPlanID <> @PlanID) OR (@OverrideQuotas = 1)
BEGIN
	INSERT INTO @ExceedingQuotas
	SELECT * FROM dbo.GetPackageExceedingQuotas(@ParentPackageID) WHERE QuotaValue > 0
END

SELECT * FROM @ExceedingQuotas

IF EXISTS(SELECT * FROM @ExceedingQuotas)
BEGIN
	ROLLBACK TRAN
	RETURN
END

COMMIT TRAN
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var package = Packages
					.Where(p => p.PackageId == packageId)
					.FirstOrDefault();
				if (package != null)
				{

					using (var transaction = Database.BeginTransaction())
					{
						var oldPlanId = package.PlanId;
						package.PackageName = packageName;
						package.PackageComments = packageComments;
						package.StatusId = statusId;
						package.PlanId = planId;
						package.PurchaseDate = purchaseDate;
						package.OverrideQuotas = overrideQuotas;
						package.DefaultTopPackage = defaultTopPackage;
						SaveChanges();

						// update quotas (if required)
						UpdatePackageQuotas(actorId, packageId, quotasXml);

						// check exceeding quotas if plan has been changed
						ExceedingQuota[] exceedingQuotas;

						if (oldPlanId != planId || overrideQuotas)
						{
							exceedingQuotas = GetPackageExceedingQuotas(packageId)
								.Where(q => q.QuotaValue > 0)
								.ToArray();
						}
						else exceedingQuotas = new ExceedingQuota[0];

						if (exceedingQuotas.Any()) transaction.Rollback();
						else transaction.Commit();

						return EntityDataSet(exceedingQuotas);
					}
				}
				else return EntityDataSet(new ExceedingQuota[0]);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdatePackage",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@packageName", packageName),
					new SqlParameter("@packageComments", packageComments),
					new SqlParameter("@statusId", statusId),
					new SqlParameter("@planId", planId),
					new SqlParameter("@purchaseDate", purchaseDate),
					new SqlParameter("@overrideQuotas", overrideQuotas),
					new SqlParameter("@quotasXml", quotasXml),
					new SqlParameter("@defaultTopPackage", defaultTopPackage));
			}
		}
		public void ChangePackageUser(int actorId, int packageId, int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[ChangePackageUser]
(
	@PackageID int,
	@ActorID int,
	@UserID int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

BEGIN TRAN

UPDATE Packages
SET UserID = @UserID
WHERE PackageID = @PackageID

COMMIT TRAN

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

#if NETCOREAPP
				Packages.Where(p => p.PackageId == packageId).ExecuteUpdate(set => set.SetProperty(p => p.UserId, userId));
#else
				foreach (var package in Packages.Where(p => p.PackageId == packageId)) package.UserId = userId;
				SaveChanges();
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "ChangePackageUser",
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@UserId", userId));
			}
		}

		public void UpdatePackageName(int actorId, int packageId, string packageName,
			string packageComments)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdatePackageName]
(
	@ActorID int,
	@PackageID int,
	@PackageName nvarchar(300),
	@PackageComments ntext
)
AS

-- check rights
DECLARE @UserID int
SELECT @UserID = UserID FROM Packages
WHERE PackageID = @PackageID

IF NOT(dbo.CheckActorPackageRights(@ActorID, @PackageID) = 1
	OR @UserID = @ActorID
	OR EXISTS(SELECT UserID FROM Users WHERE UserID = @ActorID AND OwnerID = @UserID AND IsPeer = 1))
RAISERROR('You are not allowed to access this package', 16, 1)

-- update package
UPDATE Packages SET
	PackageName = @PackageName,
	PackageComments = @PackageComments
WHERE
	PackageID = @PackageID

RETURN
				*/
				#endregion

				var userId = Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => p.UserId)
					.FirstOrDefault();

				if (!CheckActorPackageRights(actorId, packageId) || userId == actorId ||
					Users.Any(u => u.OwnerId == userId && u.IsPeer))
					throw new AccessViolationException("You are not allowed to access this package");

				// update package
#if NETCOREAPP
				Packages.Where(p => p.PackageId == packageId)
					.ExecuteUpdate(set => set
						.SetProperty(p => p.PackageName, packageName)
						.SetProperty(p => p.PackageComments, packageComments));
#else
				foreach (var package in Packages.Where(p => p.PackageId == packageId)) {
					package.PackageName = packageName;
					package.PackageComments = packageComments;
				}
				SaveChanges();
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdatePackageName",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@packageName", packageName),
					new SqlParameter("@packageComments", packageComments));
			}
		}

		public void DeletePackage(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeletePackage]
(
	@ActorID int,
	@PackageID int
)
AS
BEGIN
	-- check rights
	IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
	RAISERROR('You are not allowed to access this package', 16, 1)

	BEGIN TRAN

	-- remove package from cache
	DELETE FROM PackagesTreeCache
	WHERE
		ParentPackageID = @PackageID OR
		PackageID = @PackageID

	-- delete package comments
	DELETE FROM Comments
	WHERE ItemID = @PackageID AND ItemTypeID = 'PACKAGE'

	-- delete diskspace
	DELETE FROM PackagesDiskspace
	WHERE PackageID = @PackageID

	-- delete bandwidth
	DELETE FROM PackagesBandwidth
	WHERE PackageID = @PackageID

	-- delete settings
	DELETE FROM PackageSettings
	WHERE PackageID = @PackageID

	-- delete domains
	DELETE FROM Domains
	WHERE PackageID = @PackageID

	-- delete package IP addresses
	DELETE FROM PackageIPAddresses
	WHERE PackageID = @PackageID

	-- delete service items
	DELETE FROM ServiceItems
	WHERE PackageID = @PackageID

	-- delete global DNS records
	DELETE FROM GlobalDnsRecords
	WHERE PackageID = @PackageID

	-- delete package services
	DELETE FROM PackageServices
	WHERE PackageID = @PackageID

	-- delete package quotas
	DELETE FROM PackageQuotas
	WHERE PackageID = @PackageID

	-- delete package resources
	DELETE FROM PackageResources
	WHERE PackageID = @PackageID

	-- delete package
	DELETE FROM Packages
	WHERE PackageID = @PackageID

	COMMIT TRAN
END
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var transaction = Database.BeginTransaction())
				{
					// remove package from cache
					PackagesTreeCaches.Where(p => p.ParentPackageId == packageId || p.PackageId == packageId)
						.ExecuteDelete();

					// delete package comments
					Comments.Where(c => c.ItemId == packageId && c.ItemTypeId == "PACKAGE")
						.ExecuteDelete();

					// delete diskspace
					PackagesDiskspaces.Where(d => d.PackageId == packageId).ExecuteDelete();

					// delete bandwidth
					PackagesBandwidths.Where(b => b.PackageId == packageId).ExecuteDelete();

					// delete settings
					PackageSettings.Where(s => s.PackageId == packageId).ExecuteDelete();

					// delete domains
					Domains.Where(d => d.PackageId == packageId).ExecuteDelete();

					// delete package IP addresses
					PackageIpAddresses.Where(ip => ip.PackageId == packageId).ExecuteDelete();

					// delete service items
					ServiceItems.Where(s => s.PackageId == packageId).ExecuteDelete();

					// delete global DNS records
					GlobalDnsRecords.Where(r => r.PackageId == packageId).ExecuteDelete();

					// delete package services
					PackageServices.Where(s => s.PackageId == packageId).ExecuteDelete();

					// delete package quotas
					PackageQuotas.Where(q => q.PackageId == packageId).ExecuteDelete();

					// delete package resources
					PackageResources.Where(r => r.PackageId == packageId).ExecuteDelete();

					// delete package
					Packages.Where(p => p.PackageId == packageId).ExecuteDelete();

					transaction.Commit();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeletePackage",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageID", packageId));
			}
		}

		// Package Add-ons
		public DataSet GetPackageAddons(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageAddons]
(
	@ActorID int,
	@PackageID int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SELECT
	PA.PackageAddonID,
	PA.PackageID,
	PA.PlanID,
	PA.Quantity,
	PA.PurchaseDate,
	PA.StatusID,
	PA.Comments,
	HP.PlanName,
	HP.PlanDescription
FROM PackageAddons AS PA
INNER JOIN HostingPlans AS HP ON PA.PlanID = HP.PlanID
WHERE PA.PackageID = @PackageID
RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var addons = PackageAddons
					.Where(a => a.PackageId == packageId)
					.Join(HostingPlans, a => a.PlanId, hp => hp.PlanId, (a, hp) => new
					{
						a.PackageAddonId,
						a.PackageId,
						a.PlanId,
						a.Quantity,
						a.PurchaseDate,
						a.StatusId,
						a.Comments,
						hp.PlanName,
						hp.PlanDescription
					});
				return EntityDataSet(addons);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackageAddons",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageID", packageId));
			}
		}

		public IDataReader GetPackageAddon(int actorId, int packageAddonId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageAddon]
(
	@ActorID int,
	@PackageAddonID int
)
AS

-- check rights
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM PackageAddons
WHERE PackageAddonID = @PackageAddonID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SELECT
	PackageAddonID,
	PackageID,
	PlanID,
	PurchaseDate,
	Quantity,
	StatusID,
	Comments
FROM PackageAddons AS PA
WHERE PA.PackageAddonID = @PackageAddonID
RETURN
				*/
				#endregion

				var packageId = PackageAddons
					.Where(p => p.PackageAddonId == packageAddonId)
					.Select(p => p.PackageId)
					.FirstOrDefault();
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var addon = PackageAddons
					.Where(a => a.PackageAddonId == packageAddonId)
					.Select(a => new
					{
						a.PackageAddonId,
						a.PackageId,
						a.PlanId,
						a.PurchaseDate,
						a.Quantity,
						a.StatusId,
						a.Comments
					});
				return EntityDataReader(addon);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackageAddon",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageAddonID", packageAddonId));
			}
		}

		public DataSet AddPackageAddon(int actorId, out int addonId, int packageId, int planId, int quantity,
			int statusId, DateTime purchaseDate, string comments)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddPackageAddon]
(
	@ActorID int,
	@PackageAddonID int OUTPUT,
	@PackageID int,
	@PlanID int,
	@Quantity int,
	@StatusID int,
	@PurchaseDate datetime,
	@Comments ntext
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

BEGIN TRAN

DECLARE @ParentPackageID int
SELECT @ParentPackageID = ParentPackageID FROM Packages
WHERE PackageID = @PackageID

-- insert record
INSERT INTO PackageAddons
(
	PackageID,
	PlanID,
	PurchaseDate,
	Quantity,
	StatusID,
	Comments
)
VALUES
(
	@PackageID,
	@PlanID,
	@PurchaseDate,
	@Quantity,
	@StatusID,
	@Comments
)

SET @PackageAddonID = SCOPE_IDENTITY()

DECLARE @ExceedingQuotas AS TABLE (QuotaID int, QuotaName nvarchar(50), QuotaValue int)
INSERT INTO @ExceedingQuotas
SELECT * FROM dbo.GetPackageExceedingQuotas(@ParentPackageID) WHERE QuotaValue > 0

SELECT * FROM @ExceedingQuotas

IF EXISTS(SELECT * FROM @ExceedingQuotas)
BEGIN
	ROLLBACK TRAN
	RETURN
END

COMMIT TRAN
RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var parentPackageId = Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => p.ParentPackageId)
					.FirstOrDefault();
				using (var transaction = Database.BeginTransaction())
				{
					var addon = new Data.Entities.PackageAddon()
					{
						PackageId = packageId,
						PlanId = planId,
						PurchaseDate = purchaseDate,
						Quantity = quantity,
						StatusId = statusId,
						Comments = comments
					};
					PackageAddons.Add(addon);
					SaveChanges();

					addonId = addon.PackageAddonId;

					var exceedingQuotas = GetPackageExceedingQuotas(packageId)
						.Where(q => q.QuotaValue > 0)
						.ToArray();

					if (exceedingQuotas.Any()) transaction.Rollback();
					else transaction.Commit();

					return EntityDataSet(exceedingQuotas);
				}
			}
			else
			{
				SqlParameter prmPackageAddonId = new SqlParameter("@PackageAddonID", SqlDbType.Int);
				prmPackageAddonId.Direction = ParameterDirection.Output;

				DataSet ds = SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddPackageAddon",
					prmPackageAddonId,
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@planId", planId),
					new SqlParameter("@Quantity", quantity),
					new SqlParameter("@statusId", statusId),
					new SqlParameter("@PurchaseDate", purchaseDate),
					new SqlParameter("@Comments", comments));

				// read identity
				addonId = Convert.ToInt32(prmPackageAddonId.Value);

				return ds;
			}
		}

		public DataSet UpdatePackageAddon(int actorId, int packageAddonId, int planId, int quantity,
			int statusId, DateTime purchaseDate, string comments)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdatePackageAddon]
(
	@ActorID int,
	@PackageAddonID int,
	@PlanID int,
	@Quantity int,
	@PurchaseDate datetime,
	@StatusID int,
	@Comments ntext
)
AS

DECLARE @PackageID int
SELECT @PackageID = PackageID FROM PackageAddons
WHERE PackageAddonID = @PackageAddonID

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

BEGIN TRAN

DECLARE @ParentPackageID int
SELECT @ParentPackageID = ParentPackageID FROM Packages
WHERE PackageID = @PackageID

-- update record
UPDATE PackageAddons SET
	PlanID = @PlanID,
	Quantity = @Quantity,
	PurchaseDate = @PurchaseDate,
	StatusID = @StatusID,
	Comments = @Comments
WHERE PackageAddonID = @PackageAddonID

DECLARE @ExceedingQuotas AS TABLE (QuotaID int, QuotaName nvarchar(50), QuotaValue int)
INSERT INTO @ExceedingQuotas
SELECT * FROM dbo.GetPackageExceedingQuotas(@ParentPackageID) WHERE QuotaValue > 0

SELECT * FROM @ExceedingQuotas

IF EXISTS(SELECT * FROM @ExceedingQuotas)
BEGIN
	ROLLBACK TRAN
	RETURN
END

COMMIT TRAN

RETURN
				*/
				#endregion

				var package = PackageAddons
					.FirstOrDefault(a => a.PackageAddonId == packageAddonId);
				if (package != null)
				{
					if (!CheckActorPackageRights(actorId, package.PackageId))
						throw new AccessViolationException("You are not allowed to access this package");

					using (var transaction = Database.BeginTransaction())
					{
						var parentPackageId = Packages
							.Where(p => p.PackageId == package.PackageId)
							.Select(p => p.ParentPackageId)
							.FirstOrDefault();

						package.PlanId = planId;
						package.Quantity = quantity;
						package.PurchaseDate = purchaseDate;
						package.StatusId = statusId;
						package.Comments = comments;
						SaveChanges();

						var exceedingQuotas = GetPackageExceedingQuotas(package.PackageId)
							.Where(q => q.QuotaValue > 0)
							.ToArray();

						if (exceedingQuotas.Any()) transaction.Rollback();
						else transaction.Commit();

						return EntityDataSet(exceedingQuotas);
					}
				}
				else return EntityDataSet(new ExceedingQuota[0]);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdatePackageAddon",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageAddonID", packageAddonId),
					new SqlParameter("@planId", planId),
					new SqlParameter("@Quantity", quantity),
					new SqlParameter("@statusId", statusId),
					new SqlParameter("@PurchaseDate", purchaseDate),
					new SqlParameter("@Comments", comments));
			}
		}

		public void DeletePackageAddon(int actorId, int packageAddonId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeletePackageAddon]
(
	@ActorID int,
	@PackageAddonID int
)
AS

DECLARE @PackageID int
SELECT @PackageID = PackageID FROM PackageAddons
WHERE PackageAddonID = @PackageAddonID

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- delete record
DELETE FROM PackageAddons
WHERE PackageAddonID = @PackageAddonID

RETURN
				*/
				#endregion

				var package = PackageAddons
					.FirstOrDefault(a => a.PackageAddonId == packageAddonId);

				if (package != null)
				{
					if (!CheckActorPackageRights(actorId, package.PackageId))
						throw new AccessViolationException("You are not allowed to access this package");

					PackageAddons.Remove(package);

					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeletePackageAddon",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageAddonID", packageAddonId));
			}
		}

		public void UpdateServerPackageServices(int serverId)
		{
			// FIXME
			const int defaultActorID = 1; // serveradmin

			if (UseEntityFramework)
			{
				// get server packages
				var packages = Packages
					.Where(p => p.ServerId == serverId);
				// call DistributePackageServices for all packages on this server
				foreach (var package in packages)
					DistributePackageServices(defaultActorID, package.PackageId);
			}
			else
			{
				// get server packages
				IDataReader packagesReader = SqlHelper.ExecuteReader(ConnectionString, CommandType.Text,
					 @"SELECT PackageID FROM Packages WHERE ServerID = @ServerID",
					 new SqlParameter("@ServerID", serverId));

				// call DistributePackageServices for all packages on this server
				while (packagesReader.Read())
				{
					int packageId = (int)packagesReader["PackageID"];
					DistributePackageServices(defaultActorID, packageId);
				}
			}
		}

		public void DistributePackageServices(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DistributePackageServices]
(
	@ActorID int,
	@PackageID int
)
AS

-- get primary distribution group
DECLARE @PrimaryGroupID int
DECLARE @VirtualServer bit
DECLARE @PlanID int
DECLARE @ServerID int
SELECT
	@PrimaryGroupID = ISNULL(S.PrimaryGroupID, 0),
	@VirtualServer = S.VirtualServer,
	@PlanID = P.PlanID,
	@ServerID = P.ServerID
FROM Packages AS P
INNER JOIN Servers AS S ON P.ServerID = S.ServerID
WHERE P.PackageID = @PackageID

-- get the list of available groups from hosting plan
DECLARE @Groups TABLE
(
	GroupID int,
	PrimaryGroup bit
)

INSERT INTO @Groups (GroupID, PrimaryGroup)
SELECT
	RG.GroupID,
	CASE WHEN RG.GroupID = @PrimaryGroupID THEN 1 -- mark primary group
	ELSE 0
	END
FROM ResourceGroups AS RG
WHERE dbo.GetPackageAllocatedResource(@PackageID, RG.GroupID, NULL) = 1
AND RG.GroupID NOT IN
(
	SELECT P.GroupID
	FROM PackageServices AS PS
	INNER JOIN Services AS S ON PS.ServiceID = S.ServiceID
	INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
	WHERE PS.PackageID = @PackageID
)

IF @VirtualServer <> 1
BEGIN
	-- PHYSICAL SERVER
	-- just return the list of services based on the plan
	INSERT INTO PackageServices (PackageID, ServiceID)
	SELECT
		@PackageID,
		S.ServiceID
	FROM Services AS S
	INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
	INNER JOIN @Groups AS G ON P.GroupID = G.GroupID
	WHERE S.ServerID = @ServerID
		AND S.ServiceID NOT IN (SELECT ServiceID FROM PackageServices WHERE PackageID = @PackageID)
END
ELSE
BEGIN
	-- VIRTUAL SERVER

	DECLARE @GroupID int, @PrimaryGroup int
	DECLARE GroupsCursor CURSOR FOR
	SELECT GroupID, PrimaryGroup FROM @Groups
	ORDER BY PrimaryGroup DESC

	OPEN GroupsCursor

	WHILE (10 = 10)
	BEGIN    --LOOP 10: thru groups
		FETCH NEXT FROM GroupsCursor
		INTO @GroupID, @PrimaryGroup

		IF (@@fetch_status <> 0)
		BEGIN
			DEALLOCATE GroupsCursor
			BREAK
		END

		-- read group information
		DECLARE @DistributionType int, @BindDistributionToPrimary int
		SELECT
			@DistributionType = DistributionType,
			@BindDistributionToPrimary = BindDistributionToPrimary
		FROM VirtualGroups AS VG
		WHERE ServerID = @ServerID AND GroupID = @GroupID

		-- bind distribution to primary
		IF @BindDistributionToPrimary = 1 AND @PrimaryGroup = 0 AND @PrimaryGroupID <> 0
		BEGIN
			-- if only one service found just use it and do not distribute
			IF (SELECT COUNT(*) FROM VirtualServices AS VS
				INNER JOIN Services AS S ON VS.ServiceID = S.ServiceID
				INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
				WHERE VS.ServerID = @ServerID AND P.GroupID = @GroupID) = 1
				BEGIN
					INSERT INTO PackageServices (PackageID, ServiceID)
					SELECT
						@PackageID,
						VS.ServiceID
					FROM VirtualServices AS VS
					INNER JOIN Services AS S ON VS.ServiceID = S.ServiceID
					INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
					WHERE VS.ServerID = @ServerID AND P.GroupID = @GroupID
				END
			ELSE
				BEGIN
					DECLARE @PrimaryServerID int
					-- try to get primary distribution server
					SELECT
						@PrimaryServerID = S.ServerID
					FROM PackageServices AS PS
					INNER JOIN Services AS S ON PS.ServiceID = S.ServiceID
					INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
					WHERE PS.PackageID = @PackageID AND P.GroupID = @PrimaryGroupID

					INSERT INTO PackageServices (PackageID, ServiceID)
					SELECT
						@PackageID,
						VS.ServiceID
					FROM VirtualServices AS VS
					INNER JOIN Services AS S ON VS.ServiceID = S.ServiceID
					INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
					WHERE VS.ServerID = @ServerID AND P.GroupID = @GroupID AND S.ServerID = @PrimaryServerID
				END
		END
		ELSE
		BEGIN

			-- DISTRIBUTION
			DECLARE @Services TABLE
			(
				ServiceID int,
				ItemsNumber int,
				RandomNumber int
			)

			DELETE FROM @Services

			INSERT INTO @Services (ServiceID, ItemsNumber, RandomNumber)
			SELECT
				VS.ServiceID,
				(SELECT COUNT(ItemID) FROM ServiceItems WHERE ServiceID = VS.ServiceID),
				RAND()
			FROM VirtualServices AS VS
			INNER JOIN Services AS S ON VS.ServiceID = S.ServiceID
			INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
			WHERE VS.ServerID = @ServerID AND P.GroupID = @GroupID

			-- BALANCED DISTRIBUTION
			IF @DistributionType = 1
			BEGIN
				-- get the less allocated service
				INSERT INTO PackageServices (PackageID, ServiceID)
				SELECT TOP 1
					@PackageID,
					ServiceID
				FROM @Services
				ORDER BY ItemsNumber
			END
			ELSE
			-- RANDOMIZED DISTRIBUTION
			BEGIN
				-- get the less allocated service
				INSERT INTO PackageServices (PackageID, ServiceID)
				SELECT TOP 1
					@PackageID,
					ServiceID
				FROM @Services
				ORDER BY RandomNumber
			END
		END

		IF @PrimaryGroup = 1
		SET @PrimaryGroupID = @GroupID

	END -- while groups

END -- end virtual server

RETURN
				*/
				#endregion

				var random = new Random();

				var package = Packages
					.Include(p => p.Server)
					.Include(p => p.Services)
#if NetCore
					.ThenInclude(s => s.Provider)
#else
					.Include(p => p.Services.Select(s => s.Provider))
#endif
					.Where(p => p.PackageId == packageId)
					.SingleOrDefault();

				// get the list of available groups from hosting plan
				var packageGroups = Packages
					.Where(p => p.PackageId == packageId)
					.SelectMany(p => p.Services)
					.Select(s => s.Provider.GroupId)
					.ToArray();
				var groups = ResourceGroups
					.AsEnumerable()
					.Where(r => Local.GetPackageAllocatedResource(packageId, r.GroupId, null) &&
						!packageGroups.Contains(r.GroupId))
					.Select(r => new { r.GroupId, PrimaryGroup = r.GroupId == package.Server.PrimaryGroupId });

				if (!package.Server.VirtualServer)
				{   // Physical Server
					// just return the list of services based on the plan
					using (var groupIds = new TempIdSet(this, groups.Select(g => g.GroupId)))
					{
						var services = package.Services.ToHashSet();
						foreach (var service in package.Services
							.Where(s => s.ServerId == package.ServerId)
							.Join(groupIds, s => s.Provider.GroupId, g => g, (s, g) => s))
						{
							if (!services.Contains(service)) package.Services.Add(service);
						}
					}
				} else
				{   // Virtual Server
					var primaryGroupId = package.Server.PrimaryGroupId;

					foreach (var group in groups.OrderByDescending(g => g.PrimaryGroup))
					{
						// read group information
						var virtualGroup = VirtualGroups
							.Where(v => v.ServerId == package.ServerId && v.GroupId == group.GroupId)
							.Select(v => new { v.DistributionType, v.BindDistributionToPrimary })
							.FirstOrDefault();
						var virtualServices = VirtualServices
							.Include(v => v.Service)
							.Where(v => v.ServerId == package.ServerId &&
								v.Service.Provider.GroupId == group.GroupId);

						// bind distribution to primary
						if (virtualGroup.BindDistributionToPrimary == true && group.PrimaryGroup &&
							primaryGroupId != 0)
						{
							// if only one service found just use it and do not distribute
							if (virtualServices.Count() == 1)
							{
								package.Services.Add(virtualServices
									.Select(v => v.Service)
									.First());
							}
							else
							{
								// try to get primary distribution server
								var primaryServerId = package.Services
									.Where(s => s.Provider.GroupId == package.Server.PrimaryGroupId)
									.Select(s => s.ServerId)
									.FirstOrDefault();
								foreach (var virtualService in virtualServices
									.Where(v => v.Service.ServerId == primaryServerId))
								{
									package.Services.Add(virtualService.Service);
								}
							}
						} else // Distribution
						{
							var services = virtualServices
								.Select(v => new
								{
									v.ServiceId,
									ItemsNumber = v.Service.ServiceItems.Count(),
									RandomNumber = random.Next(),
									v.Service
								});

							if (virtualGroup.DistributionType == 1) // Balanced distribution
							{
								// get the less allocated service
								var service = services
									.OrderBy(s => s.ItemsNumber)
									.FirstOrDefault();
								if (service != null) package.Services.Add(service.Service);
							} else // Randomized distribution
							{
								var service = services
									.OrderBy(s => s.RandomNumber)
									.FirstOrDefault();
								if (service != null) package.Services.Add(service.Service);
							}
						}

						if (group.PrimaryGroup) primaryGroupId = group.GroupId;
					}
				}

				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DistributePackageServices",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageID", packageId));
			}
		}

#endregion

		#region Packages Settings
		public IDataReader GetPackageSettings(int actorId, int packageId, string settingsName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageSettings]
(
	@ActorID int,
	@PackageID int,
	@SettingsName nvarchar(50)
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @ParentPackageID int, @TmpPackageID int
SET @TmpPackageID = @PackageID

WHILE 10 = 10
BEGIN
	IF @TmpPackageID < 2 -- system package
	BEGIN
		SELECT
			@TmpPackageID AS PackageID,
			'Dump' AS PropertyName,
			'' AS PropertyValue
	END
	ELSE
	BEGIN
		-- user package
		IF EXISTS
		(
			SELECT PropertyName FROM PackageSettings
			WHERE SettingsName = @SettingsName AND PackageID = @TmpPackageID
		)
		BEGIN
			SELECT
				PackageID,
				PropertyName,
				PropertyValue
			FROM
				PackageSettings
			WHERE
				PackageID = @TmpPackageID AND
				SettingsName = @SettingsName

			BREAK
		END
	END

	SET @ParentPackageID = NULL --reset var

	-- get owner
	SELECT
		@ParentPackageID = ParentPackageID
	FROM Packages
	WHERE PackageID = @TmpPackageID

	IF @ParentPackageID IS NULL -- the last parent
	BREAK

	SET @TmpPackageID = @ParentPackageID
END

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				if (packageId <= 1) // system package
				{
					return EntityDataReader(new Data.Entities.PackageSetting[]
					{
						new Data.Entities.PackageSetting() { PackageId = packageId, PropertyName = "Dump", PropertyValue = "" }
					});
				}
				else // user package
				{
					int? pid = packageId;
					Data.Entities.PackageSetting settings = null;
					while (pid != null)
					{
						settings = PackageSettings
							.FirstOrDefault(s => s.SettingsName == settingsName && s.PackageId == pid);
						if (settings != null) break;
						
						// get owner
						pid = Packages
							.Where(p => p.PackageId == pid)
							.Select(p => p.ParentPackageId)
							.FirstOrDefault();
					}

					if (settings != null)
					{
						return EntityDataReader(new Data.Entities.PackageSetting[] { settings });
					} else {
						return EntityDataReader(new Data.Entities.PackageSetting[0]);
					}
				}
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackageSettings",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@SettingsName", settingsName));
			}
		}
		public void UpdatePackageSettings(int actorId, int packageId, string settingsName, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdatePackageSettings]
(
	@ActorID int,
	@PackageID int,
	@SettingsName nvarchar(50),
	@Xml ntext
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- delete old properties
BEGIN TRAN
DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

-- Execute a SELECT statement that uses the OPENXML rowset provider.
DELETE FROM PackageSettings
WHERE PackageID = @PackageID AND SettingsName = @SettingsName

INSERT INTO PackageSettings
(
	PackageID,
	SettingsName,
	PropertyName,
	PropertyValue
)
SELECT
	@PackageID,
	@SettingsName,
	PropertyName,
	PropertyValue
FROM OPENXML(@idoc, '/properties/property',1) WITH
(
	PropertyName nvarchar(50) '@name',
	PropertyValue ntext '@value'
) as PV

-- remove document
exec sp_xml_removedocument @idoc

COMMIT TRAN

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");
	
				using (var transaction = Database.BeginTransaction())
				{
					// delete old properties
					PackageSettings
						.Where(s => s.PackageId == packageId && s.SettingsName == settingsName)
						.ExecuteDelete();

					var settings = XElement.Parse(xml)
						.Elements()
						.Select(e => new Data.Entities.PackageSetting
						{
							PackageId = packageId,
							SettingsName = settingsName,
							PropertyName = (string)e.Attribute("name"),
							PropertyValue = (string)e.Attribute("value")
						});
					PackageSettings.AddRange(settings);
					SaveChanges();

					transaction.Commit();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdatePackageSettings",
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@SettingsName", settingsName),
					new SqlParameter("@Xml", xml));
			}
		}
		#endregion

		#region Quotas
		public IDataReader GetProviderServiceQuota(int providerId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetProviderServiceQuota]
(
	@ProviderID int
)
AS

SELECT TOP 1
	Q.QuotaID,
	Q.GroupID,
	Q.QuotaName,
	Q.QuotaDescription,
	Q.QuotaTypeID,
	Q.ServiceQuota
FROM Providers AS P
INNER JOIN Quotas AS Q ON P.GroupID = Q.GroupID
WHERE P.ProviderID = @ProviderID AND Q.ServiceQuota = 1

RETURN
				*/
				#endregion

				var quota = Providers
					.Where(p => p.ProviderId == providerId)
					.Join(Quotas, p => p.GroupId, q => q.GroupId, (p, q) => q)
					.Where(q => q.ServiceQuota == true)
					.Take(1);
				return EntityDataReader(quota);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetProviderServiceQuota",
					new SqlParameter("@providerId", providerId));
			}
		}

		public IDataReader GetPackageQuota(int actorId, int packageId, string quotaName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageQuota]
(
	@ActorID int,
	@PackageID int,
	@QuotaName nvarchar(50)
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- return quota
DECLARE @OrgsCount INT
SET @OrgsCount = dbo.GetPackageAllocatedQuota(@PackageID, 205) -- 205 - HostedSolution.Organizations
SET @OrgsCount = CASE WHEN ISNULL(@OrgsCount, 0) < 1 THEN 1 ELSE @OrgsCount END

SELECT
	Q.QuotaID,
	Q.QuotaName,
	Q.QuotaDescription,
	Q.QuotaTypeID,
	QuotaAllocatedValue = CASE WHEN Q.PerOrganization = 1 AND ISNULL(dbo.GetPackageAllocatedQuota(@PackageId, Q.QuotaID), 0) <> -1 THEN 
					ISNULL(dbo.GetPackageAllocatedQuota(@PackageId, Q.QuotaID), 0) * @OrgsCount 
				 ELSE 
					ISNULL(dbo.GetPackageAllocatedQuota(@PackageId, Q.QuotaID), 0)
				 END,
	QuotaAllocatedValuePerOrganization = ISNULL(dbo.GetPackageAllocatedQuota(@PackageId, Q.QuotaID), 0),
	ISNULL(dbo.CalculateQuotaUsage(@PackageId, Q.QuotaID), 0) AS QuotaUsedValue
FROM Quotas AS Q
WHERE Q.QuotaName = @QuotaName

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var orgsCount = GetPackageAllocatedQuota(packageId, 205); // 205 - HostedSolution.Organizations
				if (orgsCount < 1) orgsCount = 1;

				var quotas = Quotas
					.Where(q => q.QuotaName == quotaName)
					.AsEnumerable()
					.Select(q => new
					{
						Quota = q,
						AllocatedQuota = Local.GetPackageAllocatedQuota(packageId, q.QuotaId)
					})
					.Select(q => new {
						q.Quota.QuotaId,
						q.Quota.QuotaName,
						q.Quota.QuotaDescription,
						q.Quota.QuotaTypeId,
						QuotaAllocatedValue = q.Quota.PerOrganization == 1 && q.AllocatedQuota != -1 ?
							q.AllocatedQuota * orgsCount : q.AllocatedQuota,
						QuotaAllocatedValuePerOrganization = q.AllocatedQuota,
						QuotaUsedValue = Local.CalculateQuotaUsage(packageId, q.Quota.QuotaId)
					});
				return EntityDataReader(quotas);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPackageQuota",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@QuotaName", quotaName));
			}
		}
		#endregion

		#region Log
		public void AddAuditLogRecord(string recordId, int severityId,
			int userId, string username, int packageId, int itemId, string itemName, DateTime startDate, DateTime finishDate, string sourceName,
			string taskName, string executionLog)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddAuditLogRecord]
(
	@RecordID varchar(32),
	@SeverityID int,
	@UserID int,
	@PackageID int,
	@Username nvarchar(50),
	@ItemID int,
	@StartDate datetime,
	@FinishDate datetime,
	@SourceName varchar(50),
	@TaskName varchar(50),
	@ItemName nvarchar(50),
	@ExecutionLog ntext
)
AS

IF @ItemID = 0 SET @ItemID = NULL
IF @UserID = 0 OR @UserID = -1 SET @UserID = NULL

INSERT INTO AuditLog
(
	RecordID,
	SeverityID,
	UserID,
	PackageID,
	Username,
	ItemID,
	SourceName,
	StartDate,
	FinishDate,
	TaskName,
	ItemName,
	ExecutionLog
)
VALUES
(
	@RecordID,
	@SeverityID,
	@UserID,
	@PackageID,
	@Username,
	@ItemID,
	@SourceName,
	@StartDate,
	@FinishDate,
	@TaskName,
	@ItemName,
	@ExecutionLog
)
RETURN
				*/
				#endregion

				var log = new Data.Entities.AuditLog()
				{
					RecordId = recordId,
					SeverityId = severityId,
					UserId = userId != 0 && userId != -1 ? userId : null,
					PackageId = packageId,
					Username = username,
					ItemId = itemId != 0 ? itemId : null,
					SourceName = sourceName,
					StartDate = startDate,
					FinishDate = finishDate,
					TaskName = taskName,
					ItemName = itemName,
					ExecutionLog = executionLog
				};
				AuditLogs.Add(log);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddAuditLogRecord",
					new SqlParameter("@recordId", recordId),
					new SqlParameter("@severityId", severityId),
					new SqlParameter("@UserID", userId),
					new SqlParameter("@username", username),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@ItemId", itemId),
					new SqlParameter("@itemName", itemName),
					new SqlParameter("@startDate", startDate),
					new SqlParameter("@finishDate", finishDate),
					new SqlParameter("@sourceName", sourceName),
					new SqlParameter("@taskName", taskName),
					new SqlParameter("@executionLog", executionLog));
			}
		}

		public DataSet GetAuditLogRecordsPaged(int actorId, int userId, int packageId, int itemId, string itemName, DateTime startDate, DateTime endDate,
			int severityId, string sourceName, string taskName, string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetAuditLogRecordsPaged]
(
	@ActorID int,
	@UserID int,
	@PackageID int,
	@ItemID int,
	@ItemName nvarchar(100),
	@StartDate datetime,
	@EndDate datetime,
	@SeverityID int,
	@SourceName varchar(100),
	@TaskName varchar(100),
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

IF @SourceName IS NULL SET @SourceName = ''
IF @TaskName IS NULL SET @TaskName = ''
IF @ItemName IS NULL SET @ItemName = ''

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'L.StartDate DESC'

-- build query and run it to the temporary table
DECLARE @sql nvarchar(2000)

SET @sql = '
DECLARE @IsAdmin bit
SET @IsAdmin = 0
IF EXISTS(SELECT UserID FROM Users WHERE UserID = @ActorID AND RoleID = 1)
SET @IsAdmin = 1

DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows
DECLARE @Records TABLE
(
	ItemPosition int IDENTITY(1,1),
	RecordID varchar(32)
)
INSERT INTO @Records (RecordID)
SELECT
	L.RecordID
FROM AuditLog AS L
WHERE
((@PackageID = 0 AND dbo.CheckUserParent(@UserID, L.UserID) = 1 OR (L.UserID IS NULL AND @IsAdmin = 1))
	OR (@PackageID > 0 AND L.PackageID = @PackageID))
AND L.StartDate BETWEEN @StartDate AND @EndDate
AND ((@SourceName = '''') OR (@SourceName <> '''' AND L.SourceName = @SourceName))
AND ((@TaskName = '''') OR (@TaskName <> '''' AND L.TaskName = @TaskName))
AND ((@ItemID = 0) OR (@ItemID > 0 AND L.ItemID = @ItemID))
AND ((@ItemName = '''') OR (@ItemName <> '''' AND L.ItemName LIKE @ItemName))
AND ((@SeverityID = -1) OR (@SeverityID > -1 AND L.SeverityID = @SeverityID)) '

IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + ' SELECT COUNT(RecordID) FROM @Records;
SELECT
	TL.RecordID,
    L.SeverityID,
    L.StartDate,
    L.FinishDate,
    L.ItemID,
    L.SourceName,
    L.TaskName,
    L.ItemName,
    L.ExecutionLog,

    ISNULL(L.UserID, 0) AS UserID,
	L.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	ISNULL(U.RoleID, 0) AS RoleID,
	U.Email,
	CASE U.IsPeer
		WHEN 1 THEN U.OwnerID
		ELSE U.UserID
	END EffectiveUserID
FROM @Records AS TL
INNER JOIN AuditLog AS L ON TL.RecordID = L.RecordID
LEFT OUTER JOIN UsersDetailed AS U ON L.UserID = U.UserID
WHERE TL.ItemPosition BETWEEN @StartRow + 1 AND @EndRow'

exec sp_executesql @sql, N'@TaskName varchar(100), @SourceName varchar(100), @PackageID int, @ItemID int, @ItemName nvarchar(100), @StartDate datetime,
@EndDate datetime, @StartRow int, @MaximumRows int, @UserID int, @ActorID int, @SeverityID int',
@TaskName, @SourceName, @PackageID, @ItemID, @ItemName, @StartDate, @EndDate, @StartRow, @MaximumRows, @UserID, @ActorID,
@SeverityID

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				if (sourceName == null) sourceName = "";
				if (taskName == null) taskName = "";
				if (itemName == null) itemName = "";

				var isAdmin = Users.Any(u => u.UserId == actorId && u.RoleId == 1);

				TempIdSet childUsers = null;
				try {
					IQueryable<Data.Entities.AuditLog> logs = AuditLogs;

					if (packageId == 0)
					{
						childUsers = UserChildren(userId);
						logs = logs
							.Join(childUsers, l => l.UserId, u => u, (l, u) => l);
						if (isAdmin) logs = logs.Concat(AuditLogs.Where(l => l.UserId == null));
					}
					else
					{
						logs = logs.Where(l => l.UserId == null && isAdmin || l.PackageId == packageId);
					}

					logs = logs
						.Where(l => startDate <= l.StartDate && l.StartDate < endDate &&
							(sourceName == "" || l.SourceName == sourceName) &&
							(taskName == "" || l.TaskName == taskName) &&
							(itemId == 0 || l.ItemId == itemId) &&
#if NETFRAMEWORK
							(itemName == "" || DbFunctions.Like(l.ItemName, itemName)) &&
#else
							(itemName == "" || EF.Functions.Like(l.ItemName, itemName)) &&
#endif
							(severityId == -1 || severityId > -1 && l.SeverityId == severityId));

					var count = logs.Count();

					if (!string.IsNullOrEmpty(sortColumn)) logs = logs.OrderBy(sortColumn);
					else logs = logs.OrderByDescending(l => l.StartDate);

					logs = logs.Skip(startRow).Take(maximumRows);

					var logsWithUser = logs
						.GroupJoin(UsersDetailed, l => l.UserId, u => u.UserId, (l, u) => new
						{
							l.RecordId,
							l.SeverityId,
							l.StartDate,
							l.FinishDate,
							l.ItemId,
							l.SourceName,
							l.TaskName,
							l.ItemName,
							l.ExecutionLog,
							UserId = l.UserId ?? 0,
							l.Username,
							Users = u
						})
						.SelectMany(l => l.Users.DefaultIfEmpty(), (l, u) => new
						{
							l.RecordId,
							l.SeverityId,
							l.StartDate,
							l.FinishDate,
							l.ItemId,
							l.SourceName,
							l.TaskName,
							l.ItemName,
							l.ExecutionLog,
							l.UserId,
							l.Username,
							FirstName = u != null ? u.FirstName : null,
							LastName = u != null ? u.LastName : null,
							FullName = u != null ? u.FullName : null,
							RoleId = u != null ? u.RoleId : 0,
							Email = u != null ? u.Email : null,
							EffectiveUserId = u != null ?
								(u.IsPeer ? u.OwnerId : u.UserId) : null
						});
					return EntityDataSet(count, logsWithUser);
				} finally {
					childUsers?.Dispose();
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetAuditLogRecordsPaged",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@UserID", userId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@itemId", itemId),
					new SqlParameter("@itemName", itemName),
					new SqlParameter("@StartDate", startDate),
					new SqlParameter("@EndDate", endDate),
					new SqlParameter("@severityId", severityId),
					new SqlParameter("@sourceName", sourceName),
					new SqlParameter("@taskName", taskName),
					new SqlParameter("@sortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public DataSet GetAuditLogSources()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetAuditLogSources]
AS

SELECT SourceName FROM AuditLogSources

RETURN
				*/
				#endregion

				var sources = AuditLogSources.Select(l => new { l.SourceName });
				return EntityDataSet(sources);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetAuditLogSources");
			}
		}

		public DataSet GetAuditLogTasks(string sourceName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetAuditLogTasks]
(
	@SourceName varchar(100)
)
AS

IF @SourceName = '' SET @SourceName = NULL

SELECT SourceName, TaskName FROM AuditLogTasks
WHERE (@SourceName = NULL OR @SourceName IS NOT NULL AND SourceName = @SourceName)

RETURN
				*/
				#endregion

				if (sourceName == "") sourceName = null;
				var tasks = AuditLogTasks
					.Where(t => sourceName == null || t.SourceName == sourceName)
					.Select(t => new { t.SourceName, t.TaskName });
				return EntityDataSet(tasks);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetAuditLogTasks",
					new SqlParameter("@sourceName", sourceName));
			}
		}

		public IDataReader GetAuditLogRecord(string recordId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetAuditLogRecord]
(
	@RecordID varchar(32)
)
AS

SELECT
	L.RecordID,
    L.SeverityID,
    L.StartDate,
    L.FinishDate,
    L.ItemID,
    L.SourceName,
    L.TaskName,
    L.ItemName,
    L.ExecutionLog,

    ISNULL(L.UserID, 0) AS UserID,
	L.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	ISNULL(U.RoleID, 0) AS RoleID,
	U.Email
FROM AuditLog AS L
LEFT OUTER JOIN UsersDetailed AS U ON L.UserID = U.UserID
WHERE RecordID = @RecordID
RETURN
				*/
				#endregion

				var logsWithUser = AuditLogs
					.Where(l => l.RecordId == recordId)
					.GroupJoin(UsersDetailed, l => l.UserId, u => u.UserId, (l, u) => new
					 {
						 l.RecordId,
						 l.SeverityId,
						 l.StartDate,
						 l.FinishDate,
						 l.ItemId,
						 l.SourceName,
						 l.TaskName,
						 l.ItemName,
						 l.ExecutionLog,
						 UserId = l.UserId ?? 0,
						 l.Username,
						 Users = u
					 })
					.SelectMany(l => l.Users.DefaultIfEmpty(), (l, u) => new
					{
						l.RecordId,
						l.SeverityId,
						l.StartDate,
						l.FinishDate,
						l.ItemId,
						l.SourceName,
						l.TaskName,
						l.ItemName,
						l.ExecutionLog,
						l.UserId,
						l.Username,
						FirstName = u != null ? u.FirstName : null,
						LastName = u != null ? u.LastName : null,
						FullName = u != null ? u.FullName : null,
						RoleId = u != null ? u.RoleId : 0,
						Email = u != null ? u.Email : null,
					});
				return EntityDataReader(logsWithUser);

			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetAuditLogRecord",
					new SqlParameter("@recordId", recordId));
			}
		}

		public void DeleteAuditLogRecords(int actorId, int userId, int itemId, string itemName, DateTime startDate, DateTime endDate,
			int severityId, string sourceName, string taskName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteAuditLogRecords]
(
	@ActorID int,
	@UserID int,
	@ItemID int,
	@ItemName nvarchar(100),
	@StartDate datetime,
	@EndDate datetime,
	@SeverityID int,
	@SourceName varchar(100),
	@TaskName varchar(100)
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

DECLARE @IsAdmin bit
SET @IsAdmin = 0
IF EXISTS(SELECT UserID FROM Users WHERE UserID = @ActorID AND RoleID = 1)
SET @IsAdmin = 1

DELETE FROM AuditLog
WHERE (dbo.CheckUserParent(@UserID, UserID) = 1 OR (UserID IS NULL AND @IsAdmin = 1))
AND StartDate BETWEEN @StartDate AND @EndDate
AND ((@SourceName = '') OR (@SourceName <> '' AND SourceName = @SourceName))
AND ((@TaskName = '') OR (@TaskName <> '' AND TaskName = @TaskName))
AND ((@ItemID = 0) OR (@ItemID > 0 AND ItemID = @ItemID))
AND ((@ItemName = '') OR (@ItemName <> '' AND ItemName LIKE @ItemName))

RETURN
				*/
				#endregion

				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var isAdmin = Users.Any(u => u.UserId == actorId && u.RoleId == 1);

				using (var childUsers = UserChildren(userId)) {
					var logs = AuditLogs
						.Where(l => startDate <= l.StartDate && l.StartDate < endDate &&
							(string.IsNullOrEmpty(sourceName) || l.SourceName == sourceName) &&
							(string.IsNullOrEmpty(taskName) || l.TaskName == taskName) &&
							(itemId <= 0 || itemId == l.ItemId) &&
#if NETFRAMEWORK
							(string.IsNullOrEmpty(itemName) || DbFunctions.Like(l.ItemName, itemName)));
#else
							(string.IsNullOrEmpty(itemName) || EF.Functions.Like(l.ItemName, itemName)));
#endif
					logs = logs.Where(l => l.UserId == null && isAdmin)
						.Concat(logs
							.Join(childUsers, l => l.UserId, u => u, (l, u) => l));
					logs.ExecuteDelete();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteAuditLogRecords",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@userId", userId),
					new SqlParameter("@itemId", itemId),
					new SqlParameter("@itemName", itemName),
					new SqlParameter("@startDate", startDate),
					new SqlParameter("@endDate", endDate),
					new SqlParameter("@severityId", severityId),
					new SqlParameter("@sourceName", sourceName),
					new SqlParameter("@taskName", taskName));
			}
		}

		public void DeleteAuditLogRecordsComplete()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteAuditLogRecordsComplete]
AS

TRUNCATE TABLE AuditLog

RETURN
				*/
				#endregion

				if (!IsSqlite)
				{
#if NETCOREAPP
					Database.ExecuteSqlRaw("TRUNCATE TABLE AuditLog");
#else
					Database.ExecuteSqlCommand("TRUNCATE TABLE AuditLog");
#endif
				} else
				{
#if NETCOREAPP
					Database.ExecuteSqlRaw("DELETE FROM AuditLog");
#else
					Database.ExecuteSqlCommand("DELETE FROM AuditLog");
#endif
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteAuditLogRecordsComplete");
			}
		}

#endregion

		#region Reports
		public DataSet GetPackagesBandwidthPaged(int actorId, int userId, int packageId,
			DateTime startDate, DateTime endDate, string sortColumn,
			int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackagesBandwidthPaged]
(
	@ActorID int,
	@UserID int,
	@PackageID int,
	@StartDate datetime,
	@EndDate datetime,
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @sql nvarchar(4000)

SET @sql = '
DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows

DECLARE @Report TABLE
(
	ItemPosition int IDENTITY(0,1),
	PackageID int,
	QuotaValue int,
	Bandwidth int,
	UsagePercentage int,
	PackagesNumber int
)

INSERT INTO @Report (PackageID, QuotaValue, Bandwidth, UsagePercentage, PackagesNumber)
SELECT
	P.PackageID,
	PB.QuotaValue,
	PB.Bandwidth,
	UsagePercentage = 	CASE
							WHEN PB.QuotaValue = -1 THEN 0
							WHEN PB.QuotaValue <> 0 THEN PB.Bandwidth * 100 / PB.QuotaValue
							ELSE 0
						END,
	(SELECT COUNT(NP.PackageID) FROM Packages AS NP WHERE NP.ParentPackageID = P.PackageID) AS PackagesNumber
FROM Packages AS P
LEFT OUTER JOIN
(
	SELECT
		P.PackageID,
		dbo.GetPackageAllocatedQuota(P.PackageID, 51) AS QuotaValue, -- bandwidth
		ROUND(CONVERT(float, SUM(ISNULL(PB.BytesSent + PB.BytesReceived, 0))) / 1024 / 1024, 0) AS Bandwidth -- in megabytes
	FROM Packages AS P
	INNER JOIN PackagesTreeCache AS PT ON P.PackageID = PT.ParentPackageID
	INNER JOIN Packages AS PC ON PT.PackageID = PC.PackageID
	INNER JOIN PackagesBandwidth AS PB ON PT.PackageID = PB.PackageID
	INNER JOIN HostingPlanResources AS HPR ON PB.GroupID = HPR.GroupID
		AND HPR.PlanID = PC.PlanID
	WHERE PB.LogDate BETWEEN @StartDate AND @EndDate
		AND HPR.CalculateBandwidth = 1
	GROUP BY P.PackageID
) AS PB ON P.PackageID = PB.PackageID
WHERE (@PackageID = -1 AND P.UserID = @UserID) OR
	(@PackageID <> -1 AND P.ParentPackageID = @PackageID) '

IF @SortColumn = '' OR @SortColumn IS NULL
SET @SortColumn = 'UsagePercentage DESC'

SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + '
SELECT COUNT(PackageID) FROM @Report

SELECT
	R.PackageID,
	ISNULL(R.QuotaValue, 0) AS QuotaValue,
	ISNULL(R.Bandwidth, 0) AS Bandwidth,
	ISNULL(R.UsagePercentage, 0) AS UsagePercentage,

	-- package
	P.PackageName,
	ISNULL(R.PackagesNumber, 0) AS PackagesNumber,
	P.StatusID,

	-- user
	P.UserID,
	U.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	U.RoleID,
	U.Email,
	dbo.GetItemComments(U.UserID, ''USER'', @ActorID) AS UserComments
FROM @Report AS R
INNER JOIN Packages AS P ON R.PackageID = P.PackageID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
WHERE R.ItemPosition BETWEEN @StartRow AND @EndRow
'

exec sp_executesql @sql, N'@ActorID int, @UserID int, @PackageID int, @StartDate datetime, @EndDate datetime, @StartRow int, @MaximumRows int',
@ActorID, @UserID, @PackageID, @StartDate, @EndDate, @StartRow, @MaximumRows

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var packagesGrouped = Packages
					.Join(PackagesTreeCaches, p => p.PackageId, t => t.ParentPackageId, (p, t) => new { P = p, T = t })
					.Join(Packages, pp => pp.T.PackageId, pc => pc.PackageId, (pp, pc) => new { pp.P, pp.T, PC = pc })
					.Join(PackagesBandwidths, pp => pp.PC.PackageId, pb => pb.PackageId, (pp, pb) => new { pp.P, pp.PC, PB = pb })
					.Join(HostingPlanResources, pp => new { pp.PC.PlanId, pp.PB.GroupId }, hpr => new { PlanId = (int?)hpr.PlanId, hpr.GroupId },
						(pp, hpr) => new { pp.P, pp.PC, pp.PB, HPR = hpr })
					.Where(p => startDate <= p.PB.LogDate && p.PB.LogDate < endDate && p.HPR.CalculateBandwidth == true)
					.GroupBy(p => p.P.PackageId)
					.Select(p => new
					{
						PackageId = p.Key,
						// QuotaValue = GetPackageAllocatedQuota(p.Key, 51),
						Bandwidth = p.Sum(s => s.PB.BytesSent + s.PB.BytesReceived)
					});
				var packages = Packages
					.Where(p => packageId == -1 && p.UserId == userId ||
						packageId != -1 && p.ParentPackageId == packageId)
					.GroupJoin(packagesGrouped, p => p.PackageId, pg => pg.PackageId, (p, pg) => new
					{
						Package = p,
						PackageGroup = pg
					})
					.SelectMany(p => p.PackageGroup.DefaultIfEmpty(), (p, pg) => new
					{
						p.Package.PackageId,
						p.Package.PackageName,
						p.Package.StatusId,
						p.Package.UserId,
						Bandwidth = pg != null ? pg.Bandwidth : 0,
						GroupedPackageId = pg != null ? (int?)pg.PackageId : null
					})
					.Join(UsersDetailed, p => p.UserId, u => u.UserId, (p, u) => new
					{
						p.PackageId,
						p.Bandwidth,
						p.GroupedPackageId,
						//UsagePercentage = p.PG != null ? (p.PG.QuotaValue > 0 ? p.PG.Bandwidth * 100 / p.PG.QuotaValue : 0) : 0,
						PackagesNumber = Packages.Count(np => np.ParentPackageId == p.PackageId),
						p.PackageName,
						p.StatusId,
						p.UserId,
						u.Username,
						u.FirstName,
						u.LastName,
						u.FullName,
						u.RoleId,
						u.Email,
						//UserComments = GetItemComments(u.UserId, "USER", actorId)
					});

				var count = packages.Count();

				if (!string.IsNullOrEmpty(sortColumn) && !sortColumn.StartsWith("PackagesNumber") &&
					!sortColumn.StartsWith("QuotaValue"))
				{
					packages = packages.OrderBy(sortColumn);
					packages = packages.Skip(startRow).Take(maximumRows);

				}

				var packagesSelected = packages
					.AsEnumerable()
					.Select(p => new
					{
						Package = p,
						QuotaValue = p.GroupedPackageId != null ?
							Local.GetPackageAllocatedQuota(p.GroupedPackageId, 51) : 0
					})
					.Select(p => new
					{
						p.Package.PackageId,
						p.Package.Bandwidth,
						p.Package.PackageName,
						p.QuotaValue,
						UsagePercentage = (int)(p.QuotaValue > 0 ? p.Package.Bandwidth * 100 / p.QuotaValue : 0),
						//PackagesNumber = Local.Packages.Count(np => np.ParentPackageId == p.Package.PackageId),
						p.Package.PackagesNumber,
						p.Package.StatusId,
						p.Package.UserId,
						p.Package.Username,
						p.Package.FirstName,
						p.Package.LastName,
						p.Package.FullName,
						p.Package.RoleId,
						p.Package.Email,
						UserComments = Local.GetItemComments(p.Package.UserId, "USER", actorId)
					});

				if (string.IsNullOrEmpty(sortColumn))
				{
					packagesSelected = packagesSelected
						.OrderByDescending(p => p.UsagePercentage)
						.Skip(startRow).Take(maximumRows);
				}
				else if (sortColumn.StartsWith("PackagesNumber"))
				{
					if (sortColumn.EndsWith(" desc", StringComparison.OrdinalIgnoreCase))
					{
						packagesSelected = packagesSelected.OrderByDescending(p => p.PackagesNumber);
					}
					else
					{
						packagesSelected = packagesSelected.OrderBy(p => p.PackagesNumber);
					}
					packagesSelected = packagesSelected.Skip(startRow).Take(maximumRows);
				}
				else if (sortColumn.StartsWith("QuotaValue"))
				{
					if (sortColumn.EndsWith(" desc", StringComparison.OrdinalIgnoreCase))
					{
						packagesSelected = packagesSelected.OrderByDescending(p => p.QuotaValue);
					}
					else
					{
						packagesSelected = packagesSelected.OrderBy(p => p.QuotaValue);
					}
					packagesSelected = packagesSelected.Skip(startRow).Take(maximumRows);
				}

				return EntityDataSet(count, packagesSelected);
			}
			else
			{
				return ExecuteLongDataSet(
					ObjectQualifier + "GetPackagesBandwidthPaged",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@userId", userId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@StartDate", startDate),
					new SqlParameter("@EndDate", endDate),
					new SqlParameter("@sortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public DataSet GetPackagesDiskspacePaged(int actorId, int userId, int packageId, string sortColumn,
			int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackagesDiskspacePaged]
(
	@ActorID int,
	@UserID int,
	@PackageID int,
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @sql nvarchar(4000)

SET @sql = '
DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows

DECLARE @Report TABLE
(
	ItemPosition int IDENTITY(0,1),
	PackageID int,
	QuotaValue int,
	Diskspace int,
	UsagePercentage int,
	PackagesNumber int
)

INSERT INTO @Report (PackageID, QuotaValue, Diskspace, UsagePercentage, PackagesNumber)
SELECT
	P.PackageID,
	PD.QuotaValue,
	PD.Diskspace,
	UsagePercentage = 	CASE
							WHEN PD.QuotaValue = -1 THEN 0
							WHEN PD.QuotaValue <> 0 THEN PD.Diskspace * 100 / PD.QuotaValue
							ELSE 0
						END,
	(SELECT COUNT(NP.PackageID) FROM Packages AS NP WHERE NP.ParentPackageID = P.PackageID) AS PackagesNumber
FROM Packages AS P
LEFT OUTER JOIN
(
	SELECT
		P.PackageID,
		dbo.GetPackageAllocatedQuota(P.PackageID, 52) AS QuotaValue, -- diskspace
		ROUND(CONVERT(float, SUM(ISNULL(PD.DiskSpace, 0))) / 1024 / 1024, 0) AS Diskspace -- in megabytes
	FROM Packages AS P
	INNER JOIN PackagesTreeCache AS PT ON P.PackageID = PT.ParentPackageID
	INNER JOIN Packages AS PC ON PT.PackageID = PC.PackageID
	INNER JOIN PackagesDiskspace AS PD ON PT.PackageID = PD.PackageID
	INNER JOIN HostingPlanResources AS HPR ON PD.GroupID = HPR.GroupID
		AND HPR.PlanID = PC.PlanID
	WHERE HPR.CalculateDiskspace = 1
	GROUP BY P.PackageID
) AS PD ON P.PackageID = PD.PackageID
WHERE (@PackageID = -1 AND P.UserID = @UserID) OR
	(@PackageID <> -1 AND P.ParentPackageID = @PackageID)
'

IF @SortColumn = '' OR @SortColumn IS NULL
SET @SortColumn = 'UsagePercentage DESC'

SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + '
SELECT COUNT(PackageID) FROM @Report

SELECT
	R.PackageID,
	ISNULL(R.QuotaValue, 0) AS QuotaValue,
	ISNULL(R.Diskspace, 0) AS Diskspace,
	ISNULL(R.UsagePercentage, 0) AS UsagePercentage,

	-- package
	P.PackageName,
	ISNULL(R.PackagesNumber, 0) AS PackagesNumber,
	P.StatusID,

	-- user
	P.UserID,
	U.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	U.RoleID,
	U.Email,
	dbo.GetItemComments(U.UserID, ''USER'', @ActorID) AS UserComments
FROM @Report AS R
INNER JOIN Packages AS P ON R.PackageID = P.PackageID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
WHERE R.ItemPosition BETWEEN @StartRow AND @EndRow
'

exec sp_executesql @sql, N'@ActorID int, @UserID int, @PackageID int, @StartRow int, @MaximumRows int',
@ActorID, @UserID, @PackageID, @StartRow, @MaximumRows

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var packagesGrouped = Packages
					.Join(PackagesTreeCaches, p => p.PackageId, t => t.ParentPackageId, (p, t) => new { P = p, T = t })
					.Join(Packages, pp => pp.T.PackageId, pc => pc.PackageId, (pp, pc) => new { pp.P, pp.T, PC = pc })
					.Join(PackagesDiskspaces, pp => pp.PC.PackageId, pd => pd.PackageId, (pp, pd) => new { pp.P, pp.PC, PD = pd })
					.Join(HostingPlanResources, pp => new { pp.PC.PlanId, pp.PD.GroupId }, hpr => new { PlanId = (int?)hpr.PlanId, hpr.GroupId },
						(pp, hpr) => new { pp.P, pp.PC, pp.PD, HPR = hpr })
					.Where(p => p.HPR.CalculateDiskSpace == true)
					.GroupBy(p => p.P.PackageId)
					.Select(p => new
					{
						PackageId = p.Key,
						// QuotaValue = GetPackageAllocatedQuota(p.Key, 51),
						Diskspace = p.Sum(s => s.PD.DiskSpace) / 1024 / 1024
					});
				var packages = Packages
					.Where(p => packageId == -1 && p.UserId == userId ||
						packageId != -1 && p.ParentPackageId == packageId)
					.GroupJoin(packagesGrouped, p => p.PackageId, pg => pg.PackageId, (p, pg) => new
					{
						Package = p,
						PackageGroup = pg
					})
					.SelectMany(p => p.PackageGroup.DefaultIfEmpty(), (p, pg) => new
					{
						p.Package.PackageId,
						p.Package.PackageName,
						p.Package.StatusId,
						p.Package.UserId,
						GroupedPackageId = pg != null ? (int?)pg.PackageId : null,
						Diskspace = pg != null ? pg.Diskspace : 0
					})
					.Join(UsersDetailed, p => p.UserId, u => u.UserId, (p, u) => new
					{
						p.PackageId,
						p.GroupedPackageId,
						//QuotaValue = p.PG != null ? p.PG.QuotaValue : 0,
						p.Diskspace,
						//UsagePercentage = p.PG != null ? (p.PG.QuotaValue > 0 ? p.PG.Diskspace * 100 / p.PG.QuotaValue : 0) : 0,
						PackagesNumber = Packages.Count(np => np.ParentPackageId == p.PackageId),
						p.PackageName,
						p.StatusId,
						p.UserId,
						u.Username,
						u.FirstName,
						u.LastName,
						u.FullName,
						u.RoleId,
						u.Email,
						//UserComments = GetItemComments(u.UserId, "USER", actorId)
					});

				var count = packages.Count();

				if (!string.IsNullOrEmpty(sortColumn) && !sortColumn.StartsWith("PackagesNumber") &&
					!sortColumn.StartsWith("QuotaValue"))
				{
					packages = packages.OrderBy(sortColumn);
					packages = packages.Skip(startRow).Take(maximumRows);
				}

				var packagesSelected = packages
					.AsEnumerable()
					.Select(p => new
					{
						Package = p,
						QuotaValue = p.GroupedPackageId != null ?
							Local.GetPackageAllocatedQuota(p.GroupedPackageId, 51) : 0,
					})
					.Select(p => new
					{
						p.Package.PackageId,
						p.QuotaValue,
						p.Package.Diskspace,
						UsagePercentage = (int)(p.QuotaValue > 0 ? p.Package.Diskspace * 100 / p.QuotaValue : 0),
						//PackagesNumber = Local.Packages.Count(np => np.ParentPackageId == p.Package.PackageId),
						p.Package.PackagesNumber,
						p.Package.PackageName,
						p.Package.StatusId,
						p.Package.UserId,
						p.Package.Username,
						p.Package.FirstName,
						p.Package.LastName,
						p.Package.FullName,
						p.Package.RoleId,
						p.Package.Email,
						UserComments = Local.GetItemComments(p.Package.UserId, "USER", actorId)
					});

				if (string.IsNullOrEmpty(sortColumn))
				{
					packagesSelected = packagesSelected
						.OrderByDescending(p => p.UsagePercentage);
					packagesSelected = packagesSelected.Skip(startRow).Take(maximumRows);
				} else if (sortColumn.StartsWith("PackagesNumber"))
				{
					if (sortColumn.EndsWith(" desc", StringComparison.OrdinalIgnoreCase))
					{
						packagesSelected = packagesSelected
							.OrderByDescending(p => p.PackagesNumber);
					}
					else
					{
						packagesSelected = packagesSelected
							.OrderBy(p => p.PackagesNumber);
					}
					packagesSelected = packagesSelected.Skip(startRow).Take(maximumRows);
				}
				else if (sortColumn.StartsWith("QuotaValue"))
				{
					if (sortColumn.EndsWith(" desc", StringComparison.OrdinalIgnoreCase))
					{
						packagesSelected = packagesSelected
							.OrderByDescending(p => p.QuotaValue);
					}
					else
					{
						packagesSelected = packagesSelected
							.OrderBy(p => p.QuotaValue);
					}
					packagesSelected = packagesSelected.Skip(startRow).Take(maximumRows);
				}

				return EntityDataSet(count, packagesSelected);
			}
			else
			{
				return ExecuteLongDataSet(
					ObjectQualifier + "GetPackagesDiskspacePaged",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@userId", userId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@sortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public DataSet GetPackageBandwidth(int actorId, int packageId, DateTime startDate, DateTime endDate)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageBandwidth]
(
	@ActorID int,
	@PackageID int,
	@StartDate datetime,
	@EndDate datetime
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SELECT
	RG.GroupID,
	RG.GroupName,
	ROUND(CONVERT(float, ISNULL(GB.BytesSent, 0)) / 1024 / 1024, 0) AS MegaBytesSent,
	ROUND(CONVERT(float, ISNULL(GB.BytesReceived, 0)) / 1024 / 1024, 0) AS MegaBytesReceived,
	ROUND(CONVERT(float, ISNULL(GB.BytesTotal, 0)) / 1024 / 1024, 0) AS MegaBytesTotal,
	ISNULL(GB.BytesSent, 0) AS BytesSent,
	ISNULL(GB.BytesReceived, 0) AS BytesReceived,
	ISNULL(GB.BytesTotal, 0) AS BytesTotal
FROM ResourceGroups AS RG
LEFT OUTER JOIN
(
	SELECT
		PB.GroupID,
		SUM(ISNULL(PB.BytesSent, 0)) AS BytesSent,
		SUM(ISNULL(PB.BytesReceived, 0)) AS BytesReceived,
		SUM(ISNULL(PB.BytesSent, 0)) + SUM(ISNULL(PB.BytesReceived, 0)) AS BytesTotal
	FROM PackagesTreeCache AS PT
	INNER JOIN PackagesBandwidth AS PB ON PT.PackageID = PB.PackageID
	INNER JOIN Packages AS P ON PB.PackageID = P.PackageID
	INNER JOIN HostingPlanResources AS HPR ON PB.GroupID = HPR.GroupID AND HPR.PlanID = P.PlanID
		AND HPR.CalculateBandwidth = 1
	WHERE
		PT.ParentPackageID = @PackageID
		AND PB.LogDate BETWEEN @StartDate AND @EndDate
	GROUP BY PB.GroupID
) AS GB ON RG.GroupID = GB.GroupID
WHERE GB.BytesTotal > 0
ORDER BY RG.GroupOrder

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var packagesGrouped = PackagesTreeCaches
					.Where(p => p.ParentPackageId == packageId)
					.Join(PackagesBandwidths.Where(pb => startDate <= pb.LogDate && pb.LogDate < endDate),
						pt => pt.PackageId, pb => pb.PackageId, (pt, pb) => new { PT = pt, PB = pb })
					.Join(Packages, pb => pb.PB.PackageId, p => p.PackageId, (pb, p) => new { pb.PT, pb.PB, P = p })
					.Join(HostingPlanResources.Where(hp => hp.CalculateBandwidth == true), p => new { p.PB.GroupId, p.P.PlanId },
						hpr => new { hpr.GroupId, PlanId = (int?)hpr.PlanId }, (p, hpr) => new { p.P, p.PB, p.PT, HPR = hpr })
					.GroupBy(p => p.PB.GroupId)
					.Select(p => new
					{
						GroupId = p.Key,
						BytesSent = p.Sum(pb => (long?)pb.PB.BytesSent) ?? 0,
						BytesReceived = p.Sum(pb => (long?)pb.PB.BytesReceived) ?? 0
					});
				var packages = ResourceGroups
					.OrderBy(rg => rg.GroupOrder)
					.GroupJoin(packagesGrouped, r => r.GroupId, g => g.GroupId, (rg, pg) => new
					{
						rg.GroupId,
						rg.GroupName,
						PackageGroup = pg
					})
					.SelectMany(g => g.PackageGroup.DefaultIfEmpty(), (g, pg) => new
					{
						g.GroupId,
						g.GroupName,
						MegaBytesSent = pg != null ? (pg.BytesSent + MB / 2) / MB : 0,
						MegaBytesReceived = pg != null ? (pg.BytesReceived + MB / 2) / MB : 0,
						MegaBytesTotal = pg != null ? (pg.BytesSent + pg.BytesReceived + MB / 2) / MB : 0,
						BytesSent = pg != null ? pg.BytesSent : 0,
						BytesReceived = pg != null ? pg.BytesReceived : 0,
						BytesTotal = pg != null ? pg.BytesSent + pg.BytesReceived : 0
					})
					.Where(g => g.BytesTotal > 0);

				return EntityDataSet(packages);
			}
			else
			{
				return ExecuteLongDataSet(
					ObjectQualifier + "GetPackageBandwidth",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@StartDate", startDate),
					new SqlParameter("@EndDate", endDate));
			}
		}

		public DataSet GetPackageDiskspace(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageDiskspace]
(
	@ActorID int,
	@PackageID int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SELECT
	RG.GroupID,
	RG.GroupName,
	ROUND(CONVERT(float, ISNULL(GD.Diskspace, 0)) / 1024 / 1024, 0) AS Diskspace,
	ISNULL(GD.Diskspace, 0) AS DiskspaceBytes
FROM ResourceGroups AS RG
LEFT OUTER JOIN
(
	SELECT
		PD.GroupID,
		SUM(ISNULL(PD.DiskSpace, 0)) AS Diskspace -- in megabytes
	FROM PackagesTreeCache AS PT
	INNER JOIN PackagesDiskspace AS PD ON PT.PackageID = PD.PackageID
	INNER JOIN Packages AS P ON PT.PackageID = P.PackageID
	INNER JOIN HostingPlanResources AS HPR ON PD.GroupID = HPR.GroupID
		AND HPR.PlanID = P.PlanID AND HPR.CalculateDiskspace = 1
	WHERE PT.ParentPackageID = @PackageID
	GROUP BY PD.GroupID
) AS GD ON RG.GroupID = GD.GroupID
WHERE GD.Diskspace <> 0
ORDER BY RG.GroupOrder

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var packagesGrouped = PackagesTreeCaches
				.Where(p => p.ParentPackageId == packageId)
					.Join(PackagesDiskspaces, pt => pt.PackageId, pd => pd.PackageId, (pt, pd) => new { PT = pt, PD = pd })
					.Join(Packages, pb => pb.PD.PackageId, p => p.PackageId, (pb, p) => new { pb.PT, pb.PD, P = p })
					.Join(HostingPlanResources.Where(hp => hp.CalculateDiskSpace == true), p => new { p.PD.GroupId, p.P.PlanId },
						hpr => new { hpr.GroupId, PlanId = (int?)hpr.PlanId }, (p, hpr) => new { p.P, p.PD, p.PT, HPR = hpr })
					.GroupBy(p => p.PD.GroupId)
					.Select(p => new
					{
						GroupId = p.Key,
						Diskspace = p.Sum(pb => (long?)pb.PD.DiskSpace) ?? 0
					});
				var packages = ResourceGroups
					.OrderBy(rg => rg.GroupOrder)
					.GroupJoin(packagesGrouped, r => r.GroupId, g => g.GroupId, (rg, pg) => new
					{
						rg.GroupId,
						rg.GroupName,
						PackageGroup = pg
					})
					.SelectMany(g => g.PackageGroup.DefaultIfEmpty(), (g, pg) => new
					{
						g.GroupId,
						g.GroupName,
						Diskspace = pg != null ? (pg.Diskspace + MB/2) / MB : 0,
						DiskspaceBytes = pg != null ? pg.Diskspace : 0
					})
					.Where(g => g.DiskspaceBytes > 0);

				return EntityDataSet(packages);
			}
			else
			{
				return ExecuteLongDataSet(
					ObjectQualifier + "GetPackageDiskspace",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@PackageId", packageId));
			}
		}

		#endregion

		#region Scheduler

		public IDataReader GetBackgroundTask(string taskId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetBackgroundTask]
(
	@TaskID NVARCHAR(255)
)
AS

SELECT TOP 1
	T.ID,
	T.Guid,
	T.TaskID,
	T.ScheduleID,
	T.PackageID,
	T.UserID,
	T.EffectiveUserID,
	T.TaskName,
	T.ItemID,
	T.ItemName,
	T.StartDate,
	T.FinishDate,
	T.IndicatorCurrent,
	T.IndicatorMaximum,
	T.MaximumExecutionTime,
	T.Source,
	T.Severity,
	T.Completed,
	T.NotifyOnComplete,
	T.Status
FROM BackgroundTasks AS T
INNER JOIN BackgroundTaskStack AS TS
	ON TS.TaskId = T.ID
WHERE T.TaskID = @TaskID 
				*/
				#endregion

				var tasks = BackgroundTasks
					.Where(t => t.TaskId == taskId)
					.Join(BackgroundTaskStacks, t => t.Id, ts => ts.TaskId, (t, ts) => new
					{
						t.Id,
						t.Guid,
						t.TaskId,
						t.ScheduleId,
						t.PackageId,
						t.UserId,
						t.EffectiveUserId,
						t.TaskName,
						t.ItemId,
						t.ItemName,
						t.StartDate,
						t.FinishDate,
						t.IndicatorCurrent,
						t.IndicatorMaximum,
						t.MaximumExecutionTime,
						t.Source,
						t.Severity,
						t.Completed,
						t.NotifyOnComplete,
						t.Status
					})
					.Take(1);

				return EntityDataReader(tasks);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetBackgroundTask",
					new SqlParameter("@taskId", taskId));
			}
		}

		public IDataReader GetScheduleBackgroundTasks(int scheduleId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetScheduleBackgroundTasks]
(
	@ScheduleID INT
)
AS

SELECT
	T.ID,
	T.Guid,
	T.TaskID,
	T.ScheduleId,
	T.PackageId,
	T.UserId,
	T.EffectiveUserId,
	T.TaskName,
	T.ItemId,
	T.ItemName,
	T.StartDate,
	T.FinishDate,
	T.IndicatorCurrent,
	T.IndicatorMaximum,
	T.MaximumExecutionTime,
	T.Source,
	T.Severity,
	T.Completed,
	T.NotifyOnComplete,
	T.Status
FROM BackgroundTasks AS T
WHERE T.Guid = (
	SELECT Guid FROM BackgroundTasks
	WHERE ScheduleID = @ScheduleID
		AND Completed = 0 AND Status IN (1, 3))
				*/
				#endregion

				var tasksGuids = BackgroundTasks
					.Where(t => t.ScheduleId == scheduleId && t.Completed == false &&
						(t.Status == BackgroundTaskStatus.Run || t.Status == BackgroundTaskStatus.Starting))
					.Select(t => t.Guid);
				var tasks = BackgroundTasks
					.Join(tasksGuids, t => t.Guid, tg => tg, (t, tg) => new
					{
						t.Id,
						t.Guid,
						t.TaskId,
						t.ScheduleId,
						t.PackageId,
						t.UserId,
						t.EffectiveUserId,
						t.TaskName,
						t.ItemId,
						t.ItemName,
						t.StartDate,
						t.FinishDate,
						t.IndicatorCurrent,
						t.IndicatorMaximum,
						t.MaximumExecutionTime,
						t.Source,
						t.Severity,
						t.Completed,
						t.NotifyOnComplete,
						t.Status
					});
				return EntityDataReader(tasks);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetScheduleBackgroundTasks",
					new SqlParameter("@scheduleId", scheduleId));
			}
		}

		public IEnumerable<int> GetChildUsersId(int userId)
		{
			if (Users.Any(u => u.UserId == userId)) yield return userId;

			var descendants = Users
				.Where(u => u.OwnerId == userId)
				.Select(u => u.UserId)
				.ToArray();
			while (descendants.Any())
			{
				foreach (var child in descendants) yield return child;

				descendants = Users
					.Join(descendants, u => u.OwnerId, d => d, (u, d) => u.UserId)
					.ToArray();
			}
		}

		public IDataReader GetBackgroundTasks(int actorId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetBackgroundTasks]
(
	@ActorID INT
)
AS

 with GetChildUsersId(id) as (
    select UserID
    from Users
    where UserID = @ActorID
    union all
    select C.UserId
    from GetChildUsersId P
    inner join Users C on P.id = C.OwnerID
)

SELECT 
	T.ID,
	T.Guid,
	T.TaskID,
	T.ScheduleId,
	T.PackageId,
	T.UserId,
	T.EffectiveUserId,
	T.TaskName,
	T.ItemId,
	T.ItemName,
	T.StartDate,
	T.FinishDate,
	T.IndicatorCurrent,
	T.IndicatorMaximum,
	T.MaximumExecutionTime,
	T.Source,
	T.Severity,
	T.Completed,
	T.NotifyOnComplete,
	T.Status
FROM BackgroundTasks AS T
INNER JOIN (SELECT T.Guid, MIN(T.StartDate) AS Date
			FROM BackgroundTasks AS T
			INNER JOIN BackgroundTaskStack AS TS
				ON TS.TaskId = T.ID
			WHERE T.UserID in (select id from GetChildUsersId)
			GROUP BY T.Guid) AS TT ON TT.Guid = T.Guid AND TT.Date = T.StartDate
				*/
				#endregion

				var children = GetChildUsersId(actorId)
					.ToArray();
				var tasksGrouped = BackgroundTasks
					.Join(children, t => t.UserId, uid => uid, (t, uid) => t)
					.Join(BackgroundTaskStacks, t => t.Id, ts => ts.TaskId, (t, ts) => t)
					.GroupBy(t => t.Guid)
					.Select(ts => new { Guid = ts.Key, Date = ts.Min(t => t.StartDate) });

				var tasks = BackgroundTasks
					.Join(tasksGrouped, t => new { t.Guid, t.StartDate }, tg => new { tg.Guid, StartDate = tg.Date }, (t, tg) => new
					{
						t.Id,
						t.Guid,
						t.TaskId,
						t.ScheduleId,
						t.PackageId,
						t.UserId,
						t.EffectiveUserId,
						t.TaskName,
						t.ItemId,
						t.ItemName,
						t.StartDate,
						t.FinishDate,
						t.IndicatorCurrent,
						t.IndicatorMaximum,
						t.MaximumExecutionTime,
						t.Source,
						t.Severity,
						t.Completed,
						t.NotifyOnComplete,
						t.Status
					});
				return EntityDataReader(tasks);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetBackgroundTasks",
					new SqlParameter("@actorId", actorId));
			}
		}

		public IDataReader GetBackgroundTasks(Guid guid)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetThreadBackgroundTasks]
(
	@Guid UNIQUEIDENTIFIER
)
AS

SELECT
	T.ID,
	T.Guid,
	T.TaskID,
	T.ScheduleId,
	T.PackageId,
	T.UserId,
	T.EffectiveUserId,
	T.TaskName,
	T.ItemId,
	T.ItemName,
	T.StartDate,
	T.FinishDate,
	T.IndicatorCurrent,
	T.IndicatorMaximum,
	T.MaximumExecutionTime,
	T.Source,
	T.Severity,
	T.Completed,
	T.NotifyOnComplete,
	T.Status
FROM BackgroundTasks AS T
INNER JOIN BackgroundTaskStack AS TS
	ON TS.TaskId = T.ID
WHERE T.Guid = @Guid
				*/
				#endregion

				var tasks = BackgroundTasks
					.Where(t => t.Guid == guid)
					.Join(BackgroundTaskStacks, t => t.Id, ts => ts.TaskId, (t, ts) => new
					{
						t.Id,
						t.Guid,
						t.TaskId,
						t.ScheduleId,
						t.PackageId,
						t.UserId,
						t.EffectiveUserId,
						t.TaskName,
						t.ItemId,
						t.ItemName,
						t.StartDate,
						t.FinishDate,
						t.IndicatorCurrent,
						t.IndicatorMaximum,
						t.MaximumExecutionTime,
						t.Source,
						t.Severity,
						t.Completed,
						t.NotifyOnComplete,
						t.Status
					});
				return EntityDataReader(tasks);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetThreadBackgroundTasks",
					new SqlParameter("@guid", guid));
			}
		}

		public IDataReader GetProcessBackgroundTasks(BackgroundTaskStatus status)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetProcessBackgroundTasks]
(	
	@Status INT
)
AS

SELECT
	T.ID,
	T.TaskID,
	T.ScheduleId,
	T.PackageId,
	T.UserId,
	T.EffectiveUserId,
	T.TaskName,
	T.ItemId,
	T.ItemName,
	T.StartDate,
	T.FinishDate,
	T.IndicatorCurrent,
	T.IndicatorMaximum,
	T.MaximumExecutionTime,
	T.Source,
	T.Severity,
	T.Completed,
	T.NotifyOnComplete,
	T.Status
FROM BackgroundTasks AS T
WHERE T.Completed = 0 AND T.Status = @Status
				*/
				#endregion

				var tasks = BackgroundTasks
					.Where(t => t.Completed == false && t.Status == status)
					.Select(t => new
					{
						t.Id,
						t.TaskId,
						t.ScheduleId,
						t.PackageId,
						t.UserId,
						t.EffectiveUserId,
						t.TaskName,
						t.ItemId,
						t.ItemName,
						t.StartDate,
						t.FinishDate,
						t.IndicatorCurrent,
						t.IndicatorMaximum,
						t.MaximumExecutionTime,
						t.Source,
						t.Severity,
						t.Completed,
						t.NotifyOnComplete,
						t.Status
					});
				return EntityDataReader(tasks);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetProcessBackgroundTasks",
					new SqlParameter("@status", (int)status));
			}
		}

		public IDataReader GetBackgroundTopTask(Guid guid)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetBackgroundTopTask]
(
	@Guid UNIQUEIDENTIFIER
)
AS

SELECT TOP 1
	T.ID,
	T.Guid,
	T.TaskID,
	T.ScheduleId,
	T.PackageId,
	T.UserId,
	T.EffectiveUserId,
	T.TaskName,
	T.ItemId,
	T.ItemName,
	T.StartDate,
	T.FinishDate,
	T.IndicatorCurrent,
	T.IndicatorMaximum,
	T.MaximumExecutionTime,
	T.Source,
	T.Severity,
	T.Completed,
	T.NotifyOnComplete,
	T.Status
FROM BackgroundTasks AS T
INNER JOIN BackgroundTaskStack AS TS
	ON TS.TaskId = T.ID
WHERE T.Guid = @Guid
ORDER BY T.StartDate ASC
				*/
				#endregion

				var tasks = BackgroundTasks
					.Where(t => t.Guid == guid)
					.Join(BackgroundTaskStacks, t => t.Id, ts => ts.TaskId, (t, ts) => t)
					.OrderBy(t => t.StartDate)
					.Take(1)
					.Select(t => new
					{
						t.Id,
						t.Guid,
						t.TaskId,
						t.ScheduleId,
						t.PackageId,
						t.UserId,
						t.EffectiveUserId,
						t.TaskName,
						t.ItemId,
						t.ItemName,
						t.StartDate,
						t.FinishDate,
						t.IndicatorCurrent,
						t.IndicatorMaximum,
						t.MaximumExecutionTime,
						t.Source,
						t.Severity,
						t.Completed,
						t.NotifyOnComplete,
						t.Status
					});
				return EntityDataReader(tasks);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetBackgroundTopTask",
					new SqlParameter("@guid", guid));
			}
		}

		public int AddBackgroundTask(Guid guid, string taskId, int scheduleId, int packageId, int userId,
			int effectiveUserId, string taskName, int itemId, string itemName, DateTime startDate,
			int indicatorCurrent, int indicatorMaximum, int maximumExecutionTime, string source,
			int severity, bool completed, bool notifyOnComplete, BackgroundTaskStatus status)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddBackgroundTask]
(
	@BackgroundTaskID INT OUTPUT,
	@Guid UNIQUEIDENTIFIER,
	@TaskID NVARCHAR(255),
	@ScheduleID INT,
	@PackageID INT,
	@UserID INT,
	@EffectiveUserID INT,
	@TaskName NVARCHAR(255),
	@ItemID INT,
	@ItemName NVARCHAR(255),
	@StartDate DATETIME,
	@IndicatorCurrent INT,
	@IndicatorMaximum INT,
	@MaximumExecutionTime INT,
	@Source NVARCHAR(MAX),
	@Severity INT,
	@Completed BIT,
	@NotifyOnComplete BIT,
	@Status INT
)
AS

INSERT INTO BackgroundTasks
(
	Guid,
	TaskID,
	ScheduleID,
	PackageID,
	UserID,
	EffectiveUserID,
	TaskName,
	ItemID,
	ItemName,
	StartDate,
	IndicatorCurrent,
	IndicatorMaximum,
	MaximumExecutionTime,
	Source,
	Severity,
	Completed,
	NotifyOnComplete,
	Status
)
VALUES
(
	@Guid,
	@TaskID,
	@ScheduleID,
	@PackageID,
	@UserID,
	@EffectiveUserID,
	@TaskName,
	@ItemID,
	@ItemName,
	@StartDate,
	@IndicatorCurrent,
	@IndicatorMaximum,
	@MaximumExecutionTime,
	@Source,
	@Severity,
	@Completed,
	@NotifyOnComplete,
	@Status
)

SET @BackgroundTaskID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var task = new Data.Entities.BackgroundTask()
				{
					Guid = guid,
					TaskId = taskId,
					ScheduleId = scheduleId,
					PackageId = packageId,
					UserId = userId,
					EffectiveUserId = effectiveUserId,
					TaskName = taskName,
					ItemId = itemId,
					ItemName = itemName,
					StartDate = startDate,
					IndicatorCurrent = indicatorCurrent,
					IndicatorMaximum = indicatorMaximum,
					MaximumExecutionTime = maximumExecutionTime,
					Source = source,
					Severity = severity,
					Completed = completed,
					NotifyOnComplete = notifyOnComplete,
					Status = status
				};
				BackgroundTasks.Add(task);
				SaveChanges();
				return task.Id;
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@BackgroundTaskID", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddBackgroundTask",
					prmId,
					new SqlParameter("@guid", guid),
					new SqlParameter("@taskId", taskId),
					new SqlParameter("@scheduleId", scheduleId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@userId", userId),
					new SqlParameter("@effectiveUserId", effectiveUserId),
					new SqlParameter("@taskName", taskName),
					new SqlParameter("@itemId", itemId),
					new SqlParameter("@itemName", itemName),
					new SqlParameter("@startDate", startDate),
					new SqlParameter("@indicatorCurrent", indicatorCurrent),
					new SqlParameter("@indicatorMaximum", indicatorMaximum),
					new SqlParameter("@maximumExecutionTime", maximumExecutionTime),
					new SqlParameter("@source", source),
					new SqlParameter("@severity", severity),
					new SqlParameter("@completed", completed),
					new SqlParameter("@notifyOnComplete", notifyOnComplete),
					new SqlParameter("@status", status));

				// read identity
				return Convert.ToInt32(prmId.Value);
			}
		}

		public void AddBackgroundTaskLog(int taskId, DateTime date, string exceptionStackTrace,
			bool innerTaskStart, int severity, string text, int textIdent, string xmlParameters)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddBackgroundTaskLog]
(
	@TaskID INT,
	@Date DATETIME,
	@ExceptionStackTrace NTEXT,
	@InnerTaskStart INT,
	@Severity INT,
	@Text NTEXT,
	@TextIdent INT,
	@XmlParameters NTEXT
)
AS

INSERT INTO BackgroundTaskLogs
(
	TaskID,
	Date,
	ExceptionStackTrace,
	InnerTaskStart,
	Severity,
	Text,
	TextIdent,
	XmlParameters
)
VALUES
(
	@TaskID,
	@Date,
	@ExceptionStackTrace,
	@InnerTaskStart,
	@Severity,
	@Text,
	@TextIdent,
	@XmlParameters
)
				*/
				#endregion

				var log = new Data.Entities.BackgroundTaskLog()
				{
					TaskId = taskId,
					Date = date,
					ExceptionStackTrace = exceptionStackTrace,
					InnerTaskStart = innerTaskStart ? 1 : 0,
					Severity = severity,
					Text = text,
					TextIdent = textIdent,
					XmlParameters = xmlParameters
				};
				BackgroundTaskLogs.Add(log);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddBackgroundTaskLog",
					new SqlParameter("@taskId", taskId),
					new SqlParameter("@date", date),
					new SqlParameter("@exceptionStackTrace", exceptionStackTrace),
					new SqlParameter("@innerTaskStart", innerTaskStart),
					new SqlParameter("@severity", severity),
					new SqlParameter("@text", text),
					new SqlParameter("@textIdent", textIdent),
					new SqlParameter("@xmlParameters", xmlParameters));
			}
		}

		public IDataReader GetBackgroundTaskLogs(int taskId, DateTime startLogTime)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetBackgroundTaskLogs]
(
	@TaskID INT,
	@StartLogTime DATETIME
)
AS

SELECT
	L.LogID,
	L.TaskID,
	L.Date,
	L.ExceptionStackTrace,
	L.InnerTaskStart,
	L.Severity,
	L.Text,
	L.XmlParameters
FROM BackgroundTaskLogs AS L
WHERE L.TaskID = @TaskID AND L.Date >= @StartLogTime
ORDER BY L.Date
				*/
				#endregion

				var logs = BackgroundTaskLogs
					.Where(l => l.TaskId == taskId && l.Date >= startLogTime)
					.OrderBy(l => l.Date)
					.Select(l => new
					{
						l.LogId,
						l.TaskId,
						l.Date,
						l.ExceptionStackTrace,
						InnerTaskStart = l.InnerTaskStart != null && l.InnerTaskStart != 0,
						l.Severity,
						l.Text,
						l.XmlParameters
					});
				return EntityDataReader(logs);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetBackgroundTaskLogs",
					new SqlParameter("@taskId", taskId),
					new SqlParameter("@startLogTime", startLogTime));
			}
		}

		public void UpdateBackgroundTask(Guid guid, int taskId, int scheduleId, int packageId, string taskName, int itemId,
			string itemName, DateTime finishDate, int indicatorCurrent, int indicatorMaximum, int maximumExecutionTime,
			string source, int severity, bool completed, bool notifyOnComplete, BackgroundTaskStatus status)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateBackgroundTask]
(
	@Guid UNIQUEIDENTIFIER,
	@TaskID INT,
	@ScheduleID INT,
	@PackageID INT,
	@TaskName NVARCHAR(255),
	@ItemID INT,
	@ItemName NVARCHAR(255),
	@FinishDate DATETIME,
	@IndicatorCurrent INT,
	@IndicatorMaximum INT,
	@MaximumExecutionTime INT,
	@Source NVARCHAR(MAX),
	@Severity INT,
	@Completed BIT,
	@NotifyOnComplete BIT,
	@Status INT
)
AS

UPDATE BackgroundTasks
SET
	Guid = @Guid,
	ScheduleID = @ScheduleID,
	PackageID = @PackageID,
	TaskName = @TaskName,
	ItemID = @ItemID,
	ItemName = @ItemName,
	FinishDate = @FinishDate,
	IndicatorCurrent = @IndicatorCurrent,
	IndicatorMaximum = @IndicatorMaximum,
	MaximumExecutionTime = @MaximumExecutionTime,
	Source = @Source,
	Severity = @Severity,
	Completed = @Completed,
	NotifyOnComplete = @NotifyOnComplete,
	Status = @Status
WHERE ID = @TaskID
				*/
				#endregion

				var task = BackgroundTasks
					.FirstOrDefault(t => t.Id == taskId);
				if (task != null)
				{
					task.Guid = guid;
					task.ScheduleId = scheduleId;
					task.PackageId = packageId;
					task.TaskName = taskName;
					task.ItemId = itemId;
					task.ItemName = itemName;
					task.FinishDate = finishDate == DateTime.MinValue ? null : finishDate;
					task.IndicatorCurrent = indicatorCurrent;
					task.IndicatorMaximum = indicatorMaximum;
					task.MaximumExecutionTime = maximumExecutionTime;
					task.Source = source;
					task.Severity = severity;
					task.Completed = completed;
					task.NotifyOnComplete = notifyOnComplete;
					task.Status = status;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateBackgroundTask",
					new SqlParameter("@Guid", guid),
					new SqlParameter("@taskId", taskId),
					new SqlParameter("@scheduleId", scheduleId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@taskName", taskName),
					new SqlParameter("@itemId", itemId),
					new SqlParameter("@itemName", itemName),
					new SqlParameter("@finishDate", finishDate == DateTime.MinValue ? DBNull.Value : (object)finishDate),
					new SqlParameter("@indicatorCurrent", indicatorCurrent),
					new SqlParameter("@indicatorMaximum", indicatorMaximum),
					new SqlParameter("@maximumExecutionTime", maximumExecutionTime),
					new SqlParameter("@source", source),
					new SqlParameter("@severity", severity),
					new SqlParameter("@completed", completed),
					new SqlParameter("@notifyOnComplete", notifyOnComplete),
					new SqlParameter("@status", (int)status));

			}
		}

		public IDataReader GetBackgroundTaskParams(int taskId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetBackgroundTaskParams]
(
	@TaskID INT
)
AS

SELECT
	P.ParameterID,
	P.TaskID,
	P.Name,
	P.SerializerValue,
	P.TypeName
FROM BackgroundTaskParameters AS P
WHERE P.TaskID = @TaskID
				*/
				#endregion

				var parameters = BackgroundTaskParameters
					.Where(p => p.TaskId == taskId)
					.Select(p => new { p.ParameterId, p.TaskId, p.Name, p.SerializerValue, p.TypeName });
				return EntityDataReader(parameters);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetBackgroundTaskParams",
					new SqlParameter("@taskId", taskId));
			}
		}

		public void AddBackgroundTaskParam(int taskId, string name, string value, string typeName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddBackgroundTaskParam]
(
	@TaskID INT,
	@Name NVARCHAR(255),
	@Value NTEXT,
	@TypeName NVARCHAR(255)
)
AS

INSERT INTO BackgroundTaskParameters
(
	TaskID,
	Name,
	SerializerValue,
	TypeName
)
VALUES
(
	@TaskID,
	@Name,
	@Value,
	@TypeName
)
				*/
				#endregion

				var parameter = new Data.Entities.BackgroundTaskParameter()
				{
					TaskId = taskId,
					Name = name,
					SerializerValue = value,
					TypeName = typeName
				};
				BackgroundTaskParameters.Add(parameter);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddBackgroundTaskParam",
					new SqlParameter("@taskId", taskId),
					new SqlParameter("@name", name),
					new SqlParameter("@value", value),
					new SqlParameter("@typeName", typeName));
			}
		}

		public void DeleteBackgroundTaskParams(int taskId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteBackgroundTaskParams]
(
	@TaskID INT
)
AS

DELETE FROM BackgroundTaskParameters
WHERE TaskID = @TaskID
				*/
				#endregion

				BackgroundTaskParameters.Where(p => p.TaskId == taskId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteBackgroundTaskParams",
					new SqlParameter("@taskId", taskId));
			}
		}

		public void AddBackgroundTaskStack(int taskId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddBackgroundTaskStack]
(
	@TaskID INT
)
AS

INSERT INTO BackgroundTaskStack
(
	TaskID
)
VALUES
(
	@TaskID
)
				*/
				#endregion

				var stack = new Data.Entities.BackgroundTaskStack()
				{
					TaskId = taskId
				};
				BackgroundTaskStacks.Add(stack);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddBackgroundTaskStack",
					new SqlParameter("@taskId", taskId));
			}
		}

		public void DeleteBackgroundTasks(Guid guid)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteBackgroundTasks]
(
	@Guid UNIQUEIDENTIFIER
)
AS

DELETE FROM BackgroundTaskStack
WHERE TaskID IN (SELECT ID FROM BackgroundTasks WHERE Guid = @Guid)

DELETE FROM BackgroundTaskLogs
WHERE TaskID IN (SELECT ID FROM BackgroundTasks WHERE Guid = @Guid)

DELETE FROM BackgroundTaskParameters
WHERE TaskID IN (SELECT ID FROM BackgroundTasks WHERE Guid = @Guid)

DELETE FROM BackgroundTasks
WHERE ID IN (SELECT ID FROM BackgroundTasks WHERE Guid = @Guid)
				*/
				#endregion

				var tasks = BackgroundTasks
					.Where(t => t.Guid == guid);

				BackgroundTaskStacks
					.Join(tasks, ts => ts.TaskId, t => t.Id, (ts, t) => ts)
					.ExecuteDelete();

				BackgroundTaskLogs
					.Join(tasks, tl => tl.TaskId, t => t.Id, (tl, t) => tl)
					.ExecuteDelete();

				BackgroundTaskParameters
					.Join(tasks, tp => tp.TaskId, t => t.Id, (tp, t) => tp)
					.ExecuteDelete();

				tasks.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteBackgroundTasks",
					new SqlParameter("@guid", guid));
			}
		}

		public void DeleteBackgroundTask(int taskId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteBackgroundTask]
(
	@ID INT
)
AS

DELETE FROM BackgroundTaskStack
WHERE TaskID = @ID

DELETE FROM BackgroundTaskLogs
WHERE TaskID = @ID

DELETE FROM BackgroundTaskParameters
WHERE TaskID = @ID

DELETE FROM BackgroundTasks
WHERE ID = @ID
				*/
				#endregion

				BackgroundTaskStacks.Where(ts => ts.TaskId == taskId).ExecuteDelete();

				BackgroundTaskLogs.Where(tl => tl.TaskId == taskId).ExecuteDelete();

				BackgroundTaskParameters.Where(tp => tp.TaskId == taskId).ExecuteDelete();

				BackgroundTasks.Where(t => t.Id == taskId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteBackgroundTask",
					new SqlParameter("@id", taskId));
			}
		}

		// TODO bug, in GetScheuldeTask(int actorId) the WHERE clause is roleId <= t.RoleId and in
		// GetScheduleTask(int actorId, string taskId) the WHERE clause is roleId >= t.RoleId. Looks like a
		// bug, but I don't know if >= or <= is correct. I think roleId <= t.RoleID is correct, since a
		// lower roleId is more privileged.
		public IDataReader GetScheduleTasks(int actorId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetScheduleTasks]
(
	@ActorID int
)
AS

-- get user role
DECLARE @RoleID int
SELECT @RoleID = RoleID FROM Users
WHERE UserID = @ActorID

SELECT
	TaskID,
	TaskType,
	RoleID
FROM ScheduleTasks
WHERE @RoleID <= RoleID
RETURN
				*/
				#endregion

				var roleId = Users
					.Where(u => u.UserId == actorId)
					.Select(u => u.RoleId)
					.FirstOrDefault();
				var tasks = ScheduleTasks
					.Where(t => roleId <= t.RoleId)
					.Select(t => new { t.TaskId, t.TaskType, t.RoleId });
				return EntityDataReader(tasks);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetScheduleTasks",
					new SqlParameter("@actorId", actorId));
			}
		}

		// TODO bug, in GetScheuldeTask(int actorId) the WHERE clause is roleId <= t.RoleId and in
		// GetScheduleTask(int actorId, string taskId) the WHERE clause is roleId >= t.RoleId. Looks like a
		// bug, but I don't know if >= or <= is correct. I think roleId <= t.RoleID is correct, since a
		// lower roleId is more privileged. So I corrected the WHERE clause to roleId <= r.RoleId.
		public IDataReader GetScheduleTask(int actorId, string taskId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetScheduleTask]
(
	@ActorID int,
	@TaskID nvarchar(100)
)
AS

-- get user role
DECLARE @RoleID int
SELECT @RoleID = RoleID FROM Users
WHERE UserID = @ActorID

SELECT
	TaskID,
	TaskType,
	RoleID
FROM ScheduleTasks
WHERE
	TaskID = @TaskID
	AND @RoleID >= RoleID
RETURN
				*/
				#endregion

				var roleId = Users
					.Where(u => u.UserId == actorId)
					.Select(u => u.RoleId)
					.FirstOrDefault();
				var tasks = ScheduleTasks
					.Where(t => t.TaskId == taskId && roleId <= /* was >= */  t.RoleId)
					.Select(t => new { t.TaskId, t.TaskType, t.RoleId });
				return EntityDataReader(tasks);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetScheduleTask",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@taskId", taskId));
			}
		}

		public DataSet GetSchedules(int actorId, int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSchedules]
(
	@ActorID int,
	@PackageID int,
	@Recursive bit
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @Schedules TABLE
(
	ScheduleID int
)

INSERT INTO @Schedules (ScheduleID)
SELECT
	S.ScheduleID
FROM Schedule AS S
INNER JOIN PackagesTree(@PackageID, @Recursive) AS PT ON S.PackageID = PT.PackageID
ORDER BY S.Enabled DESC, S.NextRun

-- select schedules
SELECT
	S.ScheduleID,
	S.TaskID,
	ST.TaskType,
	ST.RoleID,
	S.PackageID,
	S.ScheduleName,
	S.ScheduleTypeID,
	S.Interval,
	S.FromTime,
	S.ToTime,
	S.StartTime,
	S.LastRun,
	S.NextRun,
	S.Enabled,
	1 AS StatusID,
	S.PriorityID,
	S.MaxExecutionTime,
	S.WeekMonthDay,
	-- bug ISNULL(0, ...) always is not NULL
	-- ISNULL(0, (SELECT TOP 1 SeverityID FROM AuditLog WHERE ItemID = S.ScheduleID AND SourceName = ''SCHEDULER'' ORDER BY StartDate DESC)) AS LastResult,
	ISNULL((SELECT TOP 1 SeverityID FROM AuditLog WHERE ItemID = S.ScheduleID AND SourceName = 'SCHEDULER' ORDER BY StartDate DESC), 0) AS LastResult,

	U.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	U.RoleID,
	U.Email
FROM @Schedules AS STEMP
INNER JOIN Schedule AS S ON STEMP.ScheduleID = S.ScheduleID
INNER JOIN Packages AS P ON S.PackageID = P.PackageID
INNER JOIN ScheduleTasks AS ST ON S.TaskID = ST.TaskID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID

-- select schedule parameters
SELECT
	S.ScheduleID,
	STP.ParameterID,
	STP.DataTypeID,
	ISNULL(SP.ParameterValue, STP.DefaultValue) AS ParameterValue
FROM @Schedules AS STEMP
INNER JOIN Schedule AS S ON STEMP.ScheduleID = S.ScheduleID
INNER JOIN ScheduleTaskParameters AS STP ON S.TaskID = STP.TaskID
LEFT OUTER JOIN ScheduleParameters AS SP ON STP.ParameterID = SP.ParameterID AND SP.ScheduleID = S.ScheduleID
RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var tree = PackagesTree(actorId, true))
				{
					var scheduleIds = Schedules
						.Join(tree, s => s.PackageId, pt => pt, (s, pt) => new { s.ScheduleId, s.Enabled, s.NextRun })
						.OrderByDescending(s => s.Enabled)
						.ThenBy(s => s.NextRun)
						.Select(s => s.ScheduleId)
						.ToArray();
					var schedules = scheduleIds
						.Join(Schedules, sid => sid, s => s.ScheduleId, (sid, s) => s)
						.Select(s => new
						{
							s.ScheduleId,
							s.TaskId,
							s.Task.TaskType,
							s.Task.RoleId,
							s.PackageId,
							s.ScheduleName,
							s.ScheduleTypeId,
							s.Interval,
							s.FromTime,
							s.ToTime,
							s.StartTime,
							s.LastRun,
							s.NextRun,
							s.Enabled,
							StatusId = ScheduleStatus.Idle,
							s.PriorityId,
							s.MaxExecutionTime,
							s.WeekMonthDay,
							LastResult = AuditLogs
								.Where(l => l.ItemId == s.ScheduleId && l.SourceName == "SCHEDULER")
								.OrderByDescending(l => l.StartDate)
								.Select(l => l.SeverityId)
								.FirstOrDefault(),
							s.Package.User.Username,
							s.Package.User.FirstName,
							s.Package.User.LastName,
							FullName = s.Package.User.FirstName + " " + s.Package.User.LastName,
							UserRoleId = s.Package.User.RoleId,
							s.Package.User.Email
						});
					var parameters = scheduleIds
						.Join(Schedules, sid => sid, s => s.ScheduleId, (sid, s) => s)
						.Join(ScheduleTaskParameters, s => s.TaskId, sp => sp.TaskId, (s, sp) => new { Schedule = s, TaskParameter = sp })
						.GroupJoin(ScheduleParameters, s => new { s.TaskParameter.ParameterId, s.Schedule.ScheduleId }, sp => new { sp.ParameterId, sp.ScheduleId }, (s, sp) => new
						{
							s.Schedule.ScheduleId,
							s.TaskParameter.ParameterId,
							s.TaskParameter.DataTypeId,
							s.TaskParameter.DefaultValue,
							Parameters = sp
						})
						.SelectMany(s => s.Parameters.DefaultIfEmpty(), (s, sp) => new
						{
							s.ScheduleId,
							s.ParameterId,
							s.DataTypeId,
							ParameterValue = sp != null ? sp.ParameterValue : s.DefaultValue
						});
					return EntityDataSet(schedules, parameters);
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetSchedules",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@recursive", true));
			}
		}

		public DataSet GetSchedulesPaged(int actorId, int packageId, bool recursive,
			string filterColumn, string filterValue, string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSchedulesPaged]
(
	@ActorID int,
	@PackageID int,
	@Recursive bit,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS
BEGIN

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @condition nvarchar(400)
SET @condition = ' 1 = 1 '

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
	IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
		SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
	ELSE
		SET @condition = @condition + '
			AND (ScheduleName LIKE ''' + @FilterValue + '''
			OR Username LIKE ''' + @FilterValue + '''
			OR FullName LIKE ''' + @FilterValue + '''
			OR Email LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'S.ScheduleName ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(S.ScheduleID) FROM Schedule AS S
INNER JOIN PackagesTree(@PackageID, @Recursive) AS PT ON S.PackageID = PT.PackageID
INNER JOIN Packages AS P ON S.PackageID = P.PackageID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
WHERE ' + @condition + '

DECLARE @Schedules AS TABLE
(
	ScheduleID int
);

WITH TempSchedules AS (
	SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
		S.ScheduleID
	FROM Schedule AS S
	INNER JOIN Packages AS P ON S.PackageID = P.PackageID
	INNER JOIN PackagesTree(@PackageID, @Recursive) AS PT ON S.PackageID = PT.PackageID
	INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID
	WHERE ' + @condition + '
)

INSERT INTO @Schedules
SELECT ScheduleID FROM TempSchedules
WHERE TempSchedules.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
	S.ScheduleID,
	S.TaskID,
	ST.TaskType,
	ST.RoleID,
	S.ScheduleName,
	S.ScheduleTypeID,
	S.Interval,
	S.FromTime,
	S.ToTime,
	S.StartTime,
	S.LastRun,
	S.NextRun,
	S.Enabled,
	1 AS StatusID,
	S.PriorityID,
	S.MaxExecutionTime,
	S.WeekMonthDay,
	-- bug ISNULL(0, ...) always is not NULL
	-- ISNULL(0, (SELECT TOP 1 SeverityID FROM AuditLog WHERE ItemID = S.ScheduleID AND SourceName = ''SCHEDULER'' ORDER BY StartDate DESC)) AS LastResult,
	ISNULL((SELECT TOP 1 SeverityID FROM AuditLog WHERE ItemID = S.ScheduleID AND SourceName = 'SCHEDULER' ORDER BY StartDate DESC), 0) AS LastResult,

	-- packages
	P.PackageID,
	P.PackageName,

	-- user
	P.UserID,
	U.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	U.RoleID,
	U.Email
FROM @Schedules AS STEMP
INNER JOIN Schedule AS S ON STEMP.ScheduleID = S.ScheduleID
INNER JOIN ScheduleTasks AS ST ON S.TaskID = ST.TaskID
INNER JOIN Packages AS P ON S.PackageID = P.PackageID
INNER JOIN UsersDetailed AS U ON P.UserID = U.UserID'

exec sp_executesql @sql, N'@PackageID int, @StartRow int, @MaximumRows int, @Recursive bit',
@PackageID, @StartRow, @MaximumRows, @Recursive

END
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var tree = PackagesTree(packageId, recursive))
				{
					var schedules = Schedules
						.Join(Packages, s => s.PackageId, p => p.PackageId, (s, p) => new { S = s, P = p })
						.Join(tree, s => s.S.PackageId, pt => pt, (s, pt) => s)
						.Join(UsersDetailed, s => s.P.UserId, u => u.UserId, (s, u) => new
						{
							s.S.ScheduleId,
							s.S.TaskId,
							s.S.Task.TaskType,
							//s.S.Task.RoleId,
							s.S.ScheduleName,
							s.S.ScheduleTypeId,
							s.S.Interval,
							s.S.FromTime,
							s.S.ToTime,
							s.S.StartTime,
							s.S.LastRun,
							s.S.NextRun,
							s.S.Enabled,
							StatusId = ScheduleStatus.Idle,
							s.S.PriorityId,
							s.S.MaxExecutionTime,
							s.S.WeekMonthDay,
							LastResult = AuditLogs
								.Where(l => l.ItemId == s.S.ScheduleId && l.SourceName == "SCHEDULER")
								.OrderByDescending(l => l.StartDate)
								.Select(l => l.SeverityId)
								.FirstOrDefault(),
							s.P.PackageId,
							s.P.PackageName,
							s.P.UserId,
							u.Username,
							u.FirstName,
							u.LastName,
							u.FullName,
							u.RoleId,
							u.Email
						});

					if (!string.IsNullOrEmpty(filterValue))
					{
						if (!string.IsNullOrEmpty(filterColumn))
						{
							schedules = schedules.Where(DynamicFunctions.ColumnLike(schedules, filterColumn, filterValue));
						}
						else
						{
#if NETFRAMEWORK
						schedules = schedules.Where(s => DbFunctions.Like(s.ScheduleName, filterValue) ||
							DbFunctions.Like(s.Username, filterValue) ||
							DbFunctions.Like(s.FullName, filterValue) ||
							DbFunctions.Like(s.Email, filterValue));
#else
							schedules = schedules.Where(s => EF.Functions.Like(s.ScheduleName, filterValue) ||
								EF.Functions.Like(s.Username, filterValue) ||
								EF.Functions.Like(s.FullName, filterValue) ||
								EF.Functions.Like(s.Email, filterValue));
#endif
						}
					}

					var count = schedules.Count();

					if (!string.IsNullOrEmpty(sortColumn))
					{
						schedules = schedules.OrderBy(sortColumn);
					}
					else
					{
						schedules = schedules.OrderBy(s => s.ScheduleName);
					}

					schedules = schedules.Skip(startRow).Take(maximumRows);

					return EntityDataSet(count, schedules);
				}
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetSchedulesPaged",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@recursive", recursive),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public DataSet GetSchedule(int actorId, int scheduleId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSchedule]
(
	@ActorID int,
	@ScheduleID int
)
AS

-- select schedule
SELECT TOP 1
	S.ScheduleID,
	S.TaskID,
	S.PackageID,
	S.ScheduleName,
	S.ScheduleTypeID,
	S.Interval,
	S.FromTime,
	S.ToTime,
	S.StartTime,
	S.LastRun,
	S.NextRun,
	S.Enabled,
	S.HistoriesNumber,
	S.PriorityID,
	S.MaxExecutionTime,
	S.WeekMonthDay,
	1 AS StatusID
FROM Schedule AS S
WHERE
	S.ScheduleID = @ScheduleID
	AND dbo.CheckActorPackageRights(@ActorID, S.PackageID) = 1

-- select task
SELECT
	ST.TaskID,
	ST.TaskType,
	ST.RoleID
FROM Schedule AS S
INNER JOIN ScheduleTasks AS ST ON S.TaskID = ST.TaskID
WHERE
	S.ScheduleID = @ScheduleID
	AND dbo.CheckActorPackageRights(@ActorID, S.PackageID) = 1

-- select schedule parameters
SELECT
	S.ScheduleID,
	STP.ParameterID,
	STP.DataTypeID,
	ISNULL(SP.ParameterValue, STP.DefaultValue) AS ParameterValue
FROM Schedule AS S
INNER JOIN ScheduleTaskParameters AS STP ON S.TaskID = STP.TaskID
LEFT OUTER JOIN ScheduleParameters AS SP ON STP.ParameterID = SP.ParameterID AND SP.ScheduleID = S.ScheduleID
WHERE
	S.ScheduleID = @ScheduleID
	AND dbo.CheckActorPackageRights(@ActorID, S.PackageID) = 1

RETURN
				*/
				#endregion

				var schedule = Schedules
					.Where(s => s.ScheduleId == scheduleId)
					.AsEnumerable()
					.Where(s => Local.CheckActorPackageRights(actorId, s.PackageId))
					.Take(1)
					.Select(s => new
					{
						s.ScheduleId,
						s.TaskId,
						s.PackageId,
						s.ScheduleName,
						s.ScheduleTypeId,
						s.Interval,
						s.FromTime,
						s.ToTime,
						s.StartTime,
						s.LastRun,
						s.NextRun,
						s.Enabled,
						s.HistoriesNumber,
						s.PriorityId,
						s.MaxExecutionTime,
						s.WeekMonthDay,
						StatusId = 1
					});

				var task = schedule
					.Join(ScheduleTasks, s => s.TaskId, st => st.TaskId, (s, st) => new
					{
						st.TaskId, st.TaskType, st.RoleId
					});

				var parameter = schedule
					.Join(ScheduleTaskParameters, s => s.TaskId, stp => stp.TaskId, (s, stp) => new
					{
						Schedule = s,
						TaskParameter = stp
					})
					.GroupJoin(ScheduleParameters, s => new { s.TaskParameter.ParameterId, s.Schedule.ScheduleId },
						sp => new { sp.ParameterId, sp.ScheduleId }, (s, sp) => new
					{
						s.Schedule.ScheduleId,
						s.TaskParameter.ParameterId,
						s.TaskParameter.DataTypeId,
						s.TaskParameter.DefaultValue,
						Parameters = sp
					})
					.SelectMany(s => s.Parameters.DefaultIfEmpty(), (s, sp) => new {
						s.ScheduleId,
						s.ParameterId,
						s.DataTypeId,
						ParameterValue = sp != null ? sp.ParameterValue : s.DefaultValue
					});

				return EntityDataSet(schedule, task, parameter);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetSchedule",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@scheduleId", scheduleId));
			}
		}
		public IDataReader GetScheduleInternal(int scheduleId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetScheduleInternal]
(
	@ScheduleID int
)
AS

-- select schedule
SELECT
	S.ScheduleID,
	S.TaskID,
	ST.TaskType,
	ST.RoleID,
	S.PackageID,
	S.ScheduleName,
	S.ScheduleTypeID,
	S.Interval,
	S.FromTime,
	S.ToTime,
	S.StartTime,
	S.LastRun,
	S.NextRun,
	S.Enabled,
	1 AS StatusID,
	S.PriorityID,
	S.HistoriesNumber,
	S.MaxExecutionTime,
	S.WeekMonthDay
FROM Schedule AS S
INNER JOIN ScheduleTasks AS ST ON S.TaskID = ST.TaskID
WHERE ScheduleID = @ScheduleID
RETURN
				*/
				#endregion

				var schedule = Schedules
					.Where(s => s.ScheduleId == scheduleId)
					.Select(s => new
					{
						s.ScheduleId,
						s.TaskId,
						s.Task.TaskType,
						s.Task.RoleId,
						s.PackageId,
						s.ScheduleName,
						s.ScheduleTypeId,
						s.Interval,
						s.FromTime,
						s.ToTime,
						s.StartTime,
						s.LastRun,
						s.NextRun,
						s.Enabled,
						StatusId = 1,
						s.PriorityId,
						s.HistoriesNumber,
						s.MaxExecutionTime,
						s.WeekMonthDay
					});

				return EntityDataReader(schedule);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetScheduleInternal",
					new SqlParameter("@scheduleId", scheduleId));
			}
		}
		public DataSet GetNextSchedule()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetNextSchedule]
AS

-- find next schedule
DECLARE @ScheduleID int
DECLARE @TaskID nvarchar(100)
SELECT TOP 1
	@ScheduleID = ScheduleID,
	@TaskID = TaskID
FROM Schedule AS S
WHERE Enabled = 1
ORDER BY NextRun ASC

-- select schedule
SELECT TOP 1
	S.ScheduleID,
	S.TaskID,
	S.PackageID,
	S.ScheduleName,
	S.ScheduleTypeID,
	S.Interval,
	S.FromTime,
	S.ToTime,
	S.StartTime,
	S.LastRun,
	S.NextRun,
	S.Enabled,
	S.HistoriesNumber,
	S.PriorityID,
	S.MaxExecutionTime,
	S.WeekMonthDay,
	1 AS StatusID
FROM Schedule AS S
WHERE S.ScheduleID = @ScheduleID
ORDER BY NextRun ASC

-- select task
SELECT
	TaskID,
	TaskType,
	RoleID
FROM ScheduleTasks
WHERE TaskID = @TaskID

-- select schedule parameters
SELECT
	S.ScheduleID,
	STP.ParameterID,
	STP.DataTypeID,
	ISNULL(SP.ParameterValue, STP.DefaultValue) AS ParameterValue
FROM Schedule AS S
INNER JOIN ScheduleTaskParameters AS STP ON S.TaskID = STP.TaskID
LEFT OUTER JOIN ScheduleParameters AS SP ON STP.ParameterID = SP.ParameterID AND SP.ScheduleID = S.ScheduleID
WHERE S.ScheduleID = @ScheduleID
RETURN
				*/
				#endregion

				var next = Schedules
					.Where(s => s.Enabled)
					.OrderBy(s => s.NextRun)
					.Select(s => new
					{
						s.ScheduleId,
						s.TaskId
					})
					.FirstOrDefault();
				var nextScheduleId = next?.ScheduleId;

				var schedule = Schedules
					.Where(s => s.ScheduleId == nextScheduleId)
					.Take(1)
					.Select(s => new
					{
						s.ScheduleId,
						s.TaskId,
						s.PackageId,
						s.ScheduleName,
						s.ScheduleTypeId,
						s.Interval,
						s.FromTime,
						s.ToTime,
						s.StartTime,
						s.LastRun,
						s.NextRun,
						s.Enabled,
						s.HistoriesNumber,
						s.PriorityId,
						s.MaxExecutionTime,
						s.WeekMonthDay,
						StatusId = 1
					});

				var task = ScheduleTasks
					.Where(st => st.TaskId == next.TaskId)
					.Select(st => new
					{
						st.TaskId,
						st.TaskType,
						st.RoleId
					});

				var parameter = ScheduleTaskParameters
					.Where(stp => stp.TaskId == next.TaskId)
					.GroupJoin(ScheduleParameters, stp => new { stp.ParameterId, ScheduleId = nextScheduleId },
						sp => new { sp.ParameterId, ScheduleId = (int?)sp.ScheduleId }, (stp, sp) => new
					{
						ScheduleId = nextScheduleId,
						stp.ParameterId,
						stp.DataTypeId,
						stp.DefaultValue,
						Parameters = sp
					})
					.SelectMany(p => p.Parameters.DefaultIfEmpty(), (p, sp) => new
					{
						p.ScheduleId,
						p.ParameterId,
						p.DataTypeId,
						ParameterValue = sp != null ? sp.ParameterValue : p.DefaultValue
					});

				return EntityDataSet(schedule, task, parameter);

			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetNextSchedule");
			}
		}
		public IDataReader GetScheduleParameters(int actorId, string taskId, int scheduleId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetScheduleParameters]
(
	@ActorID int,
	@TaskID nvarchar(100),
	@ScheduleID int
)
AS

-- check rights
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM Schedule
WHERE ScheduleID = @ScheduleID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SELECT
	@ScheduleID AS ScheduleID,
	STP.ParameterID,
	STP.DataTypeID,
	SP.ParameterValue,
	STP.DefaultValue
FROM ScheduleTaskParameters AS STP
LEFT OUTER JOIN ScheduleParameters AS SP ON STP.ParameterID = SP.ParameterID AND SP.ScheduleID = @ScheduleID
WHERE STP.TaskID = @TaskID
ORDER BY STP.ParameterOrder

RETURN
				*/
				#endregion

				// check rights
				var packageId = Schedules
					.Where(s => s.ScheduleId == scheduleId)
					.Select(s => s.PackageId)
					.FirstOrDefault();
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var parameters = ScheduleTaskParameters
					.Where(stp => stp.TaskId == taskId)
					.OrderBy(stp => stp.ParameterOrder)
					.GroupJoin(ScheduleParameters, stp => new { stp.ParameterId, ScheduleId = scheduleId },
						sp => new { sp.ParameterId, sp.ScheduleId }, (stp, sp) => new
					{
						ScheduleId = scheduleId,
						stp.ParameterId,
						stp.DataTypeId,
						stp.DefaultValue,
						Parameters = sp
					})
					.SelectMany(s => s.Parameters.DefaultIfEmpty(), (s, sp) => new
					{
						s.ScheduleId,
						s.ParameterId,
						s.DataTypeId,
						s.DefaultValue,
						ParameterValue = sp != null ? sp.ParameterValue : null,
					});

				return EntityDataReader(parameters);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetScheduleParameters",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@taskId", taskId),
					new SqlParameter("@scheduleId", scheduleId));
			}
		}

		/// <summary>
		/// Loads view configuration for the task with specified id.
		/// </summary>
		/// <param name="taskId">Task id which points to task for which view configuration will be loaded.</param>
		/// <returns>View configuration for the task with supplied id.</returns>
		public IDataReader GetScheduleTaskViewConfigurations(string taskId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetScheduleTaskViewConfigurations]
(
	@TaskID nvarchar(100)
)
AS

SELECT
	@TaskID AS TaskID,
	STVC.ConfigurationID,
	STVC.Environment,
	STVC.Description
FROM ScheduleTaskViewConfiguration AS STVC
WHERE STVC.TaskID = @TaskID

RETURN
				*/
				#endregion

				var conf = ScheduleTaskViewConfigurations
					.Where(c => c.TaskId == taskId)
					.Select(c => new
					{
						TaskId = taskId,
						c.ConfigurationId,
						c.Environment,
						c.Description
					});

				return EntityDataReader(conf);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetScheduleTaskViewConfigurations",
					new SqlParameter("@taskId", taskId));
			}
		}

		public int AddSchedule(int actorId, string taskId, int packageId,
			string scheduleName, string scheduleTypeId, int interval,
			DateTime fromTime, DateTime toTime, DateTime startTime,
			DateTime nextRun, bool enabled, string priorityId, int historiesNumber,
			int maxExecutionTime, int weekMonthDay, string xmlParameters)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddSchedule]
(
	@ActorID int,
	@ScheduleID int OUTPUT,
	@TaskID nvarchar(100),
	@PackageID int,
	@ScheduleName nvarchar(100),
	@ScheduleTypeID nvarchar(50),
	@Interval int,
	@FromTime datetime,
	@ToTime datetime,
	@StartTime datetime,
	@NextRun datetime,
	@Enabled bit,
	@PriorityID nvarchar(50),
	@HistoriesNumber int,
	@MaxExecutionTime int,
	@WeekMonthDay int,
	@XmlParameters ntext
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- insert record
BEGIN TRAN
INSERT INTO Schedule
(
	TaskID,
	PackageID,
	ScheduleName,
	ScheduleTypeID,
	Interval,
	FromTime,
	ToTime,
	StartTime,
	NextRun,
	Enabled,
	PriorityID,
	HistoriesNumber,
	MaxExecutionTime,
	WeekMonthDay
)
VALUES
(
	@TaskID,
	@PackageID,
	@ScheduleName,
	@ScheduleTypeID,
	@Interval,
	@FromTime,
	@ToTime,
	@StartTime,
	@NextRun,
	@Enabled,
	@PriorityID,
	@HistoriesNumber,
	@MaxExecutionTime,
	@WeekMonthDay
)

SET @ScheduleID = SCOPE_IDENTITY()

DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @XmlParameters

-- Execute a SELECT statement that uses the OPENXML rowset provider.
DELETE FROM ScheduleParameters
WHERE ScheduleID = @ScheduleID

INSERT INTO ScheduleParameters
(
	ScheduleID,
	ParameterID,
	ParameterValue
)
SELECT
	@ScheduleID,
	ParameterID,
	ParameterValue
FROM OPENXML(@idoc, '/parameters/parameter',1) WITH
(
	ParameterID nvarchar(50) '@id',
	ParameterValue nvarchar(3000) '@value'
) as PV

-- remove document
exec sp_xml_removedocument @idoc

COMMIT TRAN

RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var transaction = Database.BeginTransaction())
				{
					var schedule = new Data.Entities.Schedule()
					{
						TaskId = taskId,
						PackageId = packageId,
						ScheduleName = scheduleName,
						ScheduleTypeId = scheduleTypeId,
						Interval = interval,
						FromTime = fromTime,
						ToTime = toTime,
						StartTime = startTime,
						NextRun = nextRun,
						Enabled = enabled,
						PriorityId = priorityId,
						HistoriesNumber = historiesNumber,
						MaxExecutionTime = maxExecutionTime,
						WeekMonthDay = weekMonthDay
					};
					Schedules.Add(schedule);
					SaveChanges();

					ScheduleParameters
						.Where(p => p.ScheduleId == schedule.ScheduleId)
						.ExecuteDelete();

					var parameters = XElement.Parse(xmlParameters)
						.Elements()
						.Select(e => new Data.Entities.ScheduleParameter
						{
							ScheduleId = schedule.ScheduleId,
							ParameterId = (string)e.Attribute("id"),
							ParameterValue = (string)e.Attribute("value")
						});
					ScheduleParameters.AddRange(parameters);
					SaveChanges();

					transaction.Commit();

					return schedule.ScheduleId;
				}
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@ScheduleID", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddSchedule",
					prmId,
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@taskId", taskId),
					new SqlParameter("@packageId", packageId),
					new SqlParameter("@scheduleName", scheduleName),
					new SqlParameter("@scheduleTypeId", scheduleTypeId),
					new SqlParameter("@interval", interval),
					new SqlParameter("@fromTime", fromTime),
					new SqlParameter("@toTime", toTime),
					new SqlParameter("@startTime", startTime),
					new SqlParameter("@nextRun", nextRun),
					new SqlParameter("@enabled", enabled),
					new SqlParameter("@priorityId", priorityId),
					new SqlParameter("@historiesNumber", historiesNumber),
					new SqlParameter("@maxExecutionTime", maxExecutionTime),
					new SqlParameter("@weekMonthDay", weekMonthDay),
					new SqlParameter("@xmlParameters", xmlParameters));

				// read identity
				return Convert.ToInt32(prmId.Value);
			}
		}

		public void UpdateSchedule(int actorId, int scheduleId, string taskId,
			string scheduleName, string scheduleTypeId, int interval,
			DateTime fromTime, DateTime toTime, DateTime startTime,
			DateTime lastRun, DateTime nextRun, bool enabled, string priorityId,
			int historiesNumber, int maxExecutionTime, int weekMonthDay, string xmlParameters)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateSchedule]
(
	@ActorID int,
	@ScheduleID int,
	@TaskID nvarchar(100),
	@ScheduleName nvarchar(100),
	@ScheduleTypeID nvarchar(50),
	@Interval int,
	@FromTime datetime,
	@ToTime datetime,
	@StartTime datetime,
	@LastRun datetime,
	@NextRun datetime,
	@Enabled bit,
	@PriorityID nvarchar(50),
	@HistoriesNumber int,
	@MaxExecutionTime int,
	@WeekMonthDay int,
	@XmlParameters ntext
)
AS

-- check rights
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM Schedule
WHERE ScheduleID = @ScheduleID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

BEGIN TRAN

UPDATE Schedule
SET
	TaskID = @TaskID,
	ScheduleName = @ScheduleName,
	ScheduleTypeID = @ScheduleTypeID,
	Interval = @Interval,
	FromTime = @FromTime,
	ToTime = @ToTime,
	StartTime = @StartTime,
	LastRun = @LastRun,
	NextRun = @NextRun,
	Enabled = @Enabled,
	PriorityID = @PriorityID,
	HistoriesNumber = @HistoriesNumber,
	MaxExecutionTime = @MaxExecutionTime,
	WeekMonthDay = @WeekMonthDay
WHERE
	ScheduleID = @ScheduleID

DECLARE @idoc int
--Create an internal representation of the XML document.
EXEC sp_xml_preparedocument @idoc OUTPUT, @XmlParameters

-- Execute a SELECT statement that uses the OPENXML rowset provider.
DELETE FROM ScheduleParameters
WHERE ScheduleID = @ScheduleID

INSERT INTO ScheduleParameters
(
	ScheduleID,
	ParameterID,
	ParameterValue
)
SELECT
	@ScheduleID,
	ParameterID,
	ParameterValue
FROM OPENXML(@idoc, '/parameters/parameter',1) WITH 
(
	ParameterID nvarchar(50) '@id',
	ParameterValue nvarchar(3000) '@value'
) as PV

-- remove document
exec sp_xml_removedocument @idoc

COMMIT TRAN
RETURN
				*/
				#endregion

				// check rights
				var packageId = Schedules
					.Where(s => s.ScheduleId == scheduleId)
					.Select(s => s.PackageId)
					.FirstOrDefault();
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var transaction = Database.BeginTransaction())
				{
					var schedule = Schedules.FirstOrDefault(s => s.ScheduleId == scheduleId);
					if (schedule != null)
					{
						schedule.TaskId = taskId;
						schedule.ScheduleName = scheduleName;
						schedule.ScheduleTypeId = scheduleTypeId;
						schedule.Interval = interval;
						schedule.FromTime = fromTime;
						schedule.ToTime = toTime;
						schedule.StartTime = startTime;
						schedule.LastRun = lastRun;
						schedule.NextRun = nextRun;
						schedule.Enabled = enabled;
						schedule.PriorityId = priorityId;
						schedule.HistoriesNumber = historiesNumber;
						schedule.MaxExecutionTime = maxExecutionTime;
						schedule.WeekMonthDay = weekMonthDay;
						SaveChanges();

						ScheduleParameters.Where(p => p.ScheduleId == schedule.ScheduleId).ExecuteDelete();

						var parameters = XElement.Parse(xmlParameters)
							.Elements()
							.Select(e => new Data.Entities.ScheduleParameter
							{
								ScheduleId = schedule.ScheduleId,
								ParameterId = (string)e.Attribute("id"),
								ParameterValue = (string)e.Attribute("value")
							});
						ScheduleParameters.AddRange(parameters);
						SaveChanges();

						transaction.Commit();
					}
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateSchedule",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@scheduleId", scheduleId),
					new SqlParameter("@taskId", taskId),
					new SqlParameter("@scheduleName", scheduleName),
					new SqlParameter("@scheduleTypeId", scheduleTypeId),
					new SqlParameter("@interval", interval),
					new SqlParameter("@fromTime", fromTime),
					new SqlParameter("@toTime", toTime),
					new SqlParameter("@startTime", startTime),
					new SqlParameter("@lastRun", (lastRun == DateTime.MinValue) ? DBNull.Value : (object)lastRun),
					new SqlParameter("@nextRun", nextRun),
					new SqlParameter("@enabled", enabled),
					new SqlParameter("@priorityId", priorityId),
					new SqlParameter("@historiesNumber", historiesNumber),
					new SqlParameter("@maxExecutionTime", maxExecutionTime),
					new SqlParameter("@weekMonthDay", weekMonthDay),
					new SqlParameter("@xmlParameters", xmlParameters));
			}
		}

		public void DeleteSchedule(int actorId, int scheduleId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteSchedule]
(
	@ActorID int,
	@ScheduleID int
)
AS

-- check rights
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM Schedule
WHERE ScheduleID = @ScheduleID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

BEGIN TRAN
-- delete schedule parameters
DELETE FROM ScheduleParameters
WHERE ScheduleID = @ScheduleID

-- delete schedule
DELETE FROM Schedule
WHERE ScheduleID = @ScheduleID

COMMIT TRAN

RETURN
				*/
				#endregion

				// check rights
				var packageId = Schedules
					.Where(s => s.ScheduleId == scheduleId)
					.Select(s => s.PackageId)
					.FirstOrDefault();
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				using (var transaction = Database.BeginTransaction())
				{
					ScheduleParameters.Where(sp => sp.ScheduleId == scheduleId).ExecuteDelete();
					Schedules.Where(s => s.ScheduleId == scheduleId).ExecuteDelete();

					transaction.Commit();
				}

			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteSchedule",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@scheduleId", scheduleId));
			}
		}

		/*
		// TODO This rotuine is not present in the Stored Procedures
		public DataSet GetScheduleHistories(int actorId, int scheduleId)
		{
			throw new NotImplementedException();

			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
				*//*
				#endregion

			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetScheduleHistories",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@scheduleId", scheduleId));
			}
		}

		// TODO This rotuine is not present in the Stored Procedures
		public IDataReader GetScheduleHistory(int actorId, int scheduleHistoryId)
		{
			throw new NotImplementedException();

			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
				*//*
				#endregion

			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetScheduleHistory",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@scheduleHistoryId", scheduleHistoryId));
			}
		}

		// TODO This rotuine is not present in the Stored Procedures
		public int AddScheduleHistory(int actorId, int scheduleId,
			DateTime startTime, DateTime finishTime, string statusId, string executionLog)
		{
			throw new NotImplementedException();

			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
				*//*
				#endregion

			}
			else
			{
				SqlParameter prmId = new SqlParameter("@ScheduleHistoryID", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddScheduleHistory",
					prmId,
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@scheduleId", scheduleId),
					new SqlParameter("@startTime", (startTime == DateTime.MinValue) ? DBNull.Value : (object)startTime),
					new SqlParameter("@finishTime", (finishTime == DateTime.MinValue) ? DBNull.Value : (object)finishTime),
					new SqlParameter("@statusId", statusId),
					new SqlParameter("@executionLog", executionLog));

				// read identity
				return Convert.ToInt32(prmId.Value);
			}
		}

		// TODO This rotuine is not present in the Stored Procedures
		public void UpdateScheduleHistory(int actorId, int scheduleHistoryId,
			DateTime startTime, DateTime finishTime, string statusId, string executionLog)
		{
			throw new NotImplementedException();

			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
				*//*
				#endregion

			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateScheduleHistory",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@scheduleHistoryId", scheduleHistoryId),
					new SqlParameter("@startTime", (startTime == DateTime.MinValue) ? DBNull.Value : (object)startTime),
					new SqlParameter("@finishTime", (finishTime == DateTime.MinValue) ? DBNull.Value : (object)finishTime),
					new SqlParameter("@statusId", statusId),
					new SqlParameter("@executionLog", executionLog));
			}
		}

		// TODO This rotuine is not present in the Stored Procedures
		public void DeleteScheduleHistories(int actorId, int scheduleId)
		{
			throw new NotImplementedException();

			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
				*//*
				#endregion

			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteScheduleHistories",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@scheduleId", scheduleId));
			}
		}*/
#endregion

		#region Comments
		public DataSet GetComments(int actorId, int userId, string itemTypeId, int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetComments]
(
	@ActorID int,
	@UserID int,
	@ItemTypeID varchar(50),
	@ItemID int
)
AS

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to access this account', 16, 1)

SELECT
	C.CommentID,
	C.ItemTypeID,
	C.ItemID,
	C.UserID,
	C.CreatedDate,
	C.CommentText,
	C.SeverityID,

	-- user
	U.Username,
	U.FirstName,
	U.LastName,
	U.FullName,
	U.RoleID,
	U.Email
FROM Comments AS C
INNER JOIN UsersDetailed AS U ON C.UserID = U.UserID
WHERE
	ItemTypeID = @ItemTypeID
	AND ItemID = @ItemID
	AND dbo.CheckUserParent(@UserID, C.UserID) = 1
ORDER BY C.CreatedDate ASC
RETURN
				*/
				#endregion

				//check rights
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to access this account");

				var comments = Comments
					.Where(c => c.ItemTypeId == itemTypeId && c.ItemId == itemId)
					.AsEnumerable()
					.Where(c => Local.CheckUserParent(userId, c.UserId))
					.OrderBy(c => c.CreatedDate)
					.Select(c => new
					{
						c.CommentId,
						c.ItemTypeId,
						c.ItemId,
						c.UserId,
						c.CreatedDate,
						c.CommentText,
						c.SeverityId,
						//user
						c.User.Username,
						c.User.FirstName,
						c.User.LastName,
						FullName = c.User.FirstName + " " + c.User.LastName,
						c.User.RoleId,
						c.User.Email
					});

				return EntityDataSet(comments);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetComments",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@userId", userId),
					new SqlParameter("@itemTypeId", itemTypeId),
					new SqlParameter("@itemId", itemId));
			}
		}

		public void AddComment(int actorId, string itemTypeId, int itemId,
			 string commentText, int severityId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddComment]
(
	@ActorID int,
	@ItemTypeID varchar(50),
	@ItemID int,
	@CommentText nvarchar(1000),
	@SeverityID int
)
AS
INSERT INTO Comments
(
	ItemTypeID,
	ItemID,
	UserID,
	CreatedDate,
	CommentText,
	SeverityID
)
VALUES
(
	@ItemTypeID,
	@ItemID,
	@ActorID,
	GETDATE(),
	@CommentText,
	@SeverityID
)
RETURN				*/
				#endregion

				var comment = new Data.Entities.Comment()
				{
					ItemTypeId = itemTypeId,
					ItemId = itemId,
					UserId = actorId,
					CreatedDate = DateTime.Now,
					CommentText = commentText,
					SeverityId = severityId
				};
				Comments.Add(comment);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddComment",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@itemTypeId", itemTypeId),
					new SqlParameter("@itemId", itemId),
					new SqlParameter("@commentText", commentText),
					new SqlParameter("@severityId", severityId));
			}
		}

		public void DeleteComment(int actorId, int commentId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteComment]
(
	@ActorID int,
	@CommentID int
)
AS

-- check rights
DECLARE @UserID int
SELECT @UserID = UserID FROM Comments
WHERE CommentID = @CommentID

-- check rights
IF dbo.CheckActorUserRights(@ActorID, @UserID) = 0
RAISERROR('You are not allowed to perform this operation', 16, 1)

-- delete comment
DELETE FROM Comments
WHERE CommentID = @CommentID

RETURN
				*/
				#endregion

				// check rights
				var userId = Comments
					.Where(c => c.CommentId == commentId)
					.Select(c => (int?)c.UserId)
					.FirstOrDefault();
				if (!CheckActorUserRights(actorId, userId))
					throw new AccessViolationException("You are not allowed to perform this operation");

				Comments.Where(c => c.CommentId == commentId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteComment",
					new SqlParameter("@actorId", actorId),
					new SqlParameter("@commentId", commentId));
			}
		}
		#endregion

		#region Helper Methods
		private string VerifyColumnName(string str)
		{
			if (str == null)
				str = "";
			return Regex.Replace(str, @"[^\w\. ]", "");
		}

		private string VerifyColumnValue(string str)
		{
			return String.IsNullOrEmpty(str) ? str : str.Replace("'", "''");
		}

		private DataSet ExecuteLongDataSet(string spName, params SqlParameter[] parameters)
		{
			return ExecuteLongDataSet(spName, CommandType.StoredProcedure, parameters);
		}

		private DataSet ExecuteLongQueryDataSet(string spName, params SqlParameter[] parameters)
		{
			return ExecuteLongDataSet(spName, CommandType.Text, parameters);
		}

		private DataSet ExecuteLongDataSet(string commandText, CommandType commandType, params SqlParameter[] parameters)
		{
			SqlConnection conn = new SqlConnection(ConnectionString);
			SqlCommand cmd = new SqlCommand(commandText, conn);
			cmd.CommandType = commandType;
			cmd.CommandTimeout = 300;

			if (parameters != null)
			{
				foreach (SqlParameter prm in parameters)
				{
					cmd.Parameters.Add(prm);
				}
			}

			DataSet ds = new DataSet();
			try
			{
				SqlDataAdapter da = new SqlDataAdapter(cmd);
				da.Fill(ds);
			}
			finally
			{
				if (conn.State == ConnectionState.Open)
					conn.Close();
			}

			return ds;
		}

		private void ExecuteLongNonQuery(string spName, params SqlParameter[] parameters)
		{
			SqlConnection conn = new SqlConnection(ConnectionString);
			SqlCommand cmd = new SqlCommand(spName, conn);
			cmd.CommandType = CommandType.StoredProcedure;
			cmd.CommandTimeout = 300;

			if (parameters != null)
			{
				foreach (SqlParameter prm in parameters)
				{
					cmd.Parameters.Add(prm);
				}
			}

			try
			{
				conn.Open();
				cmd.ExecuteNonQuery();
			}
			finally
			{
				if (conn.State == ConnectionState.Open)
					conn.Close();
			}
		}

		public DataTable EntityDataTable<TEntity>(IEnumerable<TEntity> set) where TEntity: class => new EntityDataTable<TEntity>(set);
		public DataSet EntityDataSet(params DataTable[] tables)
		{
			var dataSet = new DataSet();
			foreach (var table in tables) dataSet.Tables.Add(table);
			return dataSet;
		}
		public DataSet EntityDataSet<TEntity>(IEnumerable<TEntity> set) where TEntity : class
			=> EntityDataSet(EntityDataTable(set));
		public DataSet EntityDataSet<TEntity>(int count, IEnumerable<TEntity> set) where TEntity : class
			=> EntityDataSet(CountDataTable(count), EntityDataTable(set));
		public DataSet EntityDataSet<TEntity1, TEntity2>(int count, IEnumerable<TEntity1> set1, IEnumerable<TEntity2> set2)
			where TEntity1 : class where TEntity2 : class
			=> EntityDataSet(CountDataTable(count), EntityDataTable(set1), EntityDataTable(set2));
		public DataSet EntityDataSet<TEntity1, TEntity2>(IEnumerable<TEntity1> set1, IEnumerable<TEntity2> set2)
			where TEntity1 : class where TEntity2 : class
			=> EntityDataSet(EntityDataTable(set1), EntityDataTable(set2));
		public DataSet EntityDataSet<TEntity1, TEntity2, TEntity3>(IEnumerable<TEntity1> set1, IEnumerable<TEntity2> set2, IEnumerable<TEntity3> set3)
			where TEntity1 : class where TEntity2 : class where TEntity3 : class
			=> EntityDataSet(EntityDataTable(set1), EntityDataTable(set2), EntityDataTable(set3));
		public DataTable CountDataTable(int count)
		{
			var table = new DataTable();
			table.Columns.Add(new DataColumn("Column1", typeof(int)));
			table.Rows.Add(count);
			return table;
		}
		public CountDataReader<TEntity> EntityDataReader<TEntity>(int count, IEnumerable<TEntity> set) where TEntity : class => new CountDataReader<TEntity>(set, count);
		public EntityDataReader<TEntity> EntityDataReader<TEntity>(IEnumerable<TEntity> set) where TEntity : class => new EntityDataReader<TEntity>(set);
		#endregion

		#region Exchange Server

		public int AddExchangeAccount(int itemId, ExchangeAccountType accountType, string accountName,
			string displayName, string primaryEmailAddress, bool mailEnabledPublicFolder,
			string mailboxManagerActions, string samAccountName, int mailboxPlanId, string subscriberNumber)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddExchangeAccount] 
(
	@AccountID int OUTPUT,
	@ItemID int,
	@AccountType int,
	@AccountName nvarchar(300),
	@DisplayName nvarchar(300),
	@PrimaryEmailAddress nvarchar(300),
	@MailEnabledPublicFolder bit,
	@MailboxManagerActions varchar(200),
	@SamAccountName nvarchar(100),
	@MailboxPlanId int,
	@SubscriberNumber nvarchar(32)
)
AS

INSERT INTO ExchangeAccounts
(
	ItemID,
	AccountType,
	AccountName,
	DisplayName,
	PrimaryEmailAddress,
	MailEnabledPublicFolder,
	MailboxManagerActions,
	SamAccountName,
	MailboxPlanId,
	SubscriberNumber,
	UserPrincipalName
)
VALUES
(
	@ItemID,
	@AccountType,
	@AccountName,
	@DisplayName,
	@PrimaryEmailAddress,
	@MailEnabledPublicFolder,
	@MailboxManagerActions,
	@SamAccountName,
	@MailboxPlanId,
	@SubscriberNumber,
	@PrimaryEmailAddress
)

SET @AccountID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var account = new Data.Entities.ExchangeAccount()
				{
					ItemId = itemId,
					AccountType = accountType,
					AccountName = accountName,
					DisplayName = displayName,
					PrimaryEmailAddress = primaryEmailAddress,
					MailEnabledPublicFolder = mailEnabledPublicFolder,
					MailboxManagerActions = mailboxManagerActions,
					SamAccountName = samAccountName,
					MailboxPlanId = mailboxPlanId,
					SubscriberNumber = subscriberNumber,
					UserPrincipalName = primaryEmailAddress,
					CreatedDate = DateTime.Now
				};
				ExchangeAccounts.Add(account);
				SaveChanges();
				return account.AccountId;
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@AccountID", SqlDbType.Int);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddExchangeAccount",
					outParam,
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@AccountType", accountType),
					new SqlParameter("@AccountName", accountName),
					new SqlParameter("@DisplayName", displayName),
					new SqlParameter("@PrimaryEmailAddress", primaryEmailAddress),
					new SqlParameter("@MailEnabledPublicFolder", mailEnabledPublicFolder),
					new SqlParameter("@MailboxManagerActions", mailboxManagerActions),
					new SqlParameter("@SamAccountName", samAccountName),
					new SqlParameter("@MailboxPlanId", (mailboxPlanId == 0) ? (object)DBNull.Value : (object)mailboxPlanId),
					new SqlParameter("@SubscriberNumber", (string.IsNullOrEmpty(subscriberNumber) ? (object)DBNull.Value : (object)subscriberNumber)));

				return Convert.ToInt32(outParam.Value);
			}
		}

		public void AddExchangeAccountEmailAddress(int accountId, string emailAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddExchangeAccountEmailAddress]
(
	@AccountID int,
	@EmailAddress nvarchar(300)
)
AS
INSERT INTO ExchangeAccountEmailAddresses
(
	AccountID,
	EmailAddress
)
VALUES
(
	@AccountID,
	@EmailAddress
)
RETURN
				*/
				#endregion

				var address = new Data.Entities.ExchangeAccountEmailAddress()
				{
					AccountId = accountId,
					EmailAddress = emailAddress
				};
				ExchangeAccountEmailAddresses.Add(address);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddExchangeAccountEmailAddress",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@EmailAddress", emailAddress));
			}
		}

		public void AddExchangeOrganization(int itemId, string organizationId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddExchangeOrganization]
(
	@ItemID int,
	@OrganizationID nvarchar(128)
)
AS

IF NOT EXISTS(SELECT * FROM ExchangeOrganizations WHERE OrganizationID = @OrganizationID)
BEGIN
	INSERT INTO ExchangeOrganizations
	(ItemID, OrganizationID)
	VALUES
	(@ItemID, @OrganizationID)
END

RETURN
				*/
				#endregion

				if (!ExchangeOrganizations.Any(eo => eo.OrganizationId == organizationId))
				{
					var organization = new Data.Entities.ExchangeOrganization()
					{
						ItemId = itemId,
						OrganizationId = organizationId
					};
					ExchangeOrganizations.Add(organization);
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddExchangeOrganization",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@OrganizationID", organizationId));
			}
		}

		public void AddExchangeOrganizationDomain(int itemId, int domainId, bool isHost)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddExchangeOrganizationDomain]
(
	@ItemID int,
	@DomainID int,
	@IsHost bit
)
AS
INSERT INTO ExchangeOrganizationDomains
(ItemID, DomainID, IsHost)
VALUES
(@ItemID, @DomainID, @IsHost)
RETURN
				*/
				#endregion

				var domain = new Data.Entities.ExchangeOrganizationDomain()
				{
					ItemId = itemId,
					DomainId = domainId,
					IsHost = isHost
				};
				ExchangeOrganizationDomains.Add(domain);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddExchangeOrganizationDomain",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@DomainID", domainId),
					new SqlParameter("@IsHost", isHost));
			}
		}

		public void ChangeExchangeAcceptedDomainType(int itemId, int domainId, int domainTypeId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[ChangeExchangeAcceptedDomainType]
(
	@ItemID int,
	@DomainID int,
	@DomainTypeID int
)
AS
UPDATE ExchangeOrganizationDomains
SET DomainTypeID=@DomainTypeID
WHERE ItemID=ItemID AND DomainID=@DomainID
RETURN
				*/
				#endregion

#if NETFRAMEWORK
				foreach (var domain in ExchangeOrganizationDomains.Where(d => d.ItemId == itemId && d.DomainId == domainId))
				{
					domain.DomainTypeId = domainTypeId;
				}
				SaveChanges();
#else
				ExchangeOrganizationDomains
					.Where(d => d.ItemId == itemId && d.DomainId == domainId)
					.ExecuteUpdate(set => set.SetProperty(d => d.DomainTypeId, domainTypeId));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"ChangeExchangeAcceptedDomainType",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@DomainID", domainId),
					new SqlParameter("@DomainTypeID", domainTypeId));
			}
		}

		public IDataReader GetExchangeOrganizationStatistics(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeOrganizationStatistics] 
(
	@ItemID int
)
AS

DECLARE @ARCHIVESIZE INT
IF -1 in (SELECT B.ArchiveSizeMB FROM ExchangeAccounts AS A INNER JOIN ExchangeMailboxPlans AS B ON A.MailboxPlanId = B.MailboxPlanId WHERE A.ItemID=@ItemID)
BEGIN
	SET @ARCHIVESIZE = -1
END
ELSE
BEGIN
	SET @ARCHIVESIZE = (SELECT SUM(B.ArchiveSizeMB) FROM ExchangeAccounts AS A INNER JOIN ExchangeMailboxPlans AS B ON A.MailboxPlanId = B.MailboxPlanId WHERE A.ItemID=@ItemID AND A.AccountType in (1, 5, 6, 10, 12) AND B.EnableArchiving = 1)
END

IF -1 IN (SELECT B.MailboxSizeMB FROM ExchangeAccounts AS A INNER JOIN ExchangeMailboxPlans AS B ON A.MailboxPlanId = B.MailboxPlanId WHERE A.ItemID=@ItemID)
BEGIN
SELECT
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE (AccountType = 1) AND ItemID = @ItemID) AS CreatedMailboxes,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE (AccountType = 10) AND ItemID = @ItemID) AS CreatedSharedMailboxes,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE (AccountType = 5 OR AccountType = 6) AND ItemID = @ItemID) AS CreatedResourceMailboxes,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE AccountType = 2 AND ItemID = @ItemID) AS CreatedContacts,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE AccountType = 3 AND ItemID = @ItemID) AS CreatedDistributionLists,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE AccountType = 4 AND ItemID = @ItemID) AS CreatedPublicFolders,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE AccountType = 12 AND ItemID = @ItemID) AS CreatedJournalingMailboxes,
	(SELECT COUNT(*) FROM ExchangeOrganizationDomains WHERE ItemID = @ItemID) AS CreatedDomains,
	(SELECT MIN(B.MailboxSizeMB) FROM ExchangeAccounts AS A INNER JOIN ExchangeMailboxPlans AS B ON A.MailboxPlanId = B.MailboxPlanId WHERE A.ItemID=@ItemID AND A.AccountType in (1, 5, 6, 10, 12)) AS UsedDiskSpace,
	(SELECT MIN(B.RecoverableItemsSpace) FROM ExchangeAccounts AS A INNER JOIN ExchangeMailboxPlans AS B ON A.MailboxPlanId = B.MailboxPlanId WHERE A.ItemID=@ItemID AND A.AccountType in (1, 5, 6, 10, 12) AND B.AllowLitigationHold = 1) AS UsedLitigationHoldSpace,
	@ARCHIVESIZE AS UsedArchingStorage
END
ELSE
BEGIN
SELECT
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE (AccountType = 1) AND ItemID = @ItemID) AS CreatedMailboxes,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE (AccountType = 10) AND ItemID = @ItemID) AS CreatedSharedMailboxes,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE (AccountType = 5 OR AccountType = 6) AND ItemID = @ItemID) AS CreatedResourceMailboxes,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE AccountType = 2 AND ItemID = @ItemID) AS CreatedContacts,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE AccountType = 3 AND ItemID = @ItemID) AS CreatedDistributionLists,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE AccountType = 4 AND ItemID = @ItemID) AS CreatedPublicFolders,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE AccountType = 12 AND ItemID = @ItemID) AS CreatedJournalingMailboxes,
	(SELECT COUNT(*) FROM ExchangeOrganizationDomains WHERE ItemID = @ItemID) AS CreatedDomains,
	(SELECT SUM(B.MailboxSizeMB) FROM ExchangeAccounts AS A INNER JOIN ExchangeMailboxPlans AS B ON A.MailboxPlanId = B.MailboxPlanId WHERE A.ItemID=@ItemID AND A.AccountType in (1, 5, 6, 10, 12)) AS UsedDiskSpace,
	(SELECT SUM(B.RecoverableItemsSpace) FROM ExchangeAccounts AS A INNER JOIN ExchangeMailboxPlans AS B ON A.MailboxPlanId = B.MailboxPlanId WHERE A.ItemID=@ItemID AND A.AccountType in (1, 5, 6, 10, 12) AND B.AllowLitigationHold = 1) AS UsedLitigationHoldSpace,
	@ARCHIVESIZE AS UsedArchingStorage
END

RETURN
				*/
				#endregion

				var accounts = ExchangeAccounts
					.Where(a => a.ItemId == itemId);
				var archiveSizeUnlimited = accounts
					.Any(a => a.MailboxPlan.ArchiveSizeMb == -1);
				var mailboxSizeUnlimited = accounts
					.Any(a => a.MailboxPlan.MailboxSizeMb == -1);
				var accountTypes = new ExchangeAccountType[] { ExchangeAccountType.Mailbox, ExchangeAccountType.Room,
					ExchangeAccountType.Equipment, ExchangeAccountType.SharedMailbox, ExchangeAccountType.JournalingMailbox };
				var specialAccounts = accounts
					.Where(a => accountTypes.Any(t => t == a.AccountType));
				var archiveSize = archiveSizeUnlimited ? -1 : specialAccounts
					.Where(a => a.MailboxPlan.EnableArchiving == true)
					.Sum(a => a.MailboxPlan.ArchiveSizeMb);
				var tmp = new
				{
					CreatedMailboxes = accounts.Count(a => a.AccountType == ExchangeAccountType.Mailbox),
					CreatedSharedMailboxes = accounts.Count(a => a.AccountType == ExchangeAccountType.SharedMailbox),
					CreatedResourceMailboxes = accounts.Count(a => 
						a.AccountType == ExchangeAccountType.Room ||
						a.AccountType == ExchangeAccountType.Equipment),
					CreatedContacts = accounts.Count(a => a.AccountType == ExchangeAccountType.Contact),
					CreatedDistributionLists = accounts.Count(a => a.AccountType == ExchangeAccountType.DistributionList),
					CreatedPublicFolders = accounts.Count(a => a.AccountType == ExchangeAccountType.PublicFolder),
					CreatedJournalingMailboxes = accounts.Count(a => a.AccountType == ExchangeAccountType.JournalingMailbox),
					CreatedDomains = ExchangeOrganizationDomains.Count(d => d.ItemId == itemId),
					UsedDiskSpaces = specialAccounts
							.Select(a => a.MailboxPlan.MailboxSizeMb),
					UsedLitigationHoldSpaces = specialAccounts
							.Where(a => a.MailboxPlan.AllowLitigationHold == true)
							.Select(a => a.MailboxPlan.RecoverableItemsSpace),
					UsedArchingStorage = archiveSize
				};
				if (mailboxSizeUnlimited)
				{
					var sizes = new
					{
						tmp.CreatedMailboxes,
						tmp.CreatedSharedMailboxes,
						tmp.CreatedResourceMailboxes,
						tmp.CreatedContacts,
						tmp.CreatedDistributionLists,
						tmp.CreatedPublicFolders,
						tmp.CreatedJournalingMailboxes,
						tmp.CreatedDomains,
						UsedDiskSpace = tmp.UsedDiskSpaces.Min(),
						UsedLitigationHoldSpace = tmp.UsedLitigationHoldSpaces.Min(),
						UsedArchingStorage = archiveSize
					};
					return EntityDataReader(new[] { sizes });
				} else
				{
					var sizes = new
					{
						tmp.CreatedMailboxes,
						tmp.CreatedSharedMailboxes,
						tmp.CreatedResourceMailboxes,
						tmp.CreatedContacts,
						tmp.CreatedDistributionLists,
						tmp.CreatedPublicFolders,
						tmp.CreatedJournalingMailboxes,
						tmp.CreatedDomains,
						UsedDiskSpace = tmp.UsedDiskSpaces.Sum(),
						UsedLitigationHoldSpace = tmp.UsedLitigationHoldSpaces.Sum(),
						UsedArchingStorage = archiveSize
					};
					return EntityDataReader(new[] { sizes });
				}
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeOrganizationStatistics",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public void DeleteUserEmailAddresses(int accountId, string primaryAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
-- =============================================
-- Description:	Delete user email addresses except primary email
-- =============================================
CREATE PROCEDURE [dbo].[DeleteUserEmailAddresses]
	@AccountId int,
	@PrimaryEmailAddress nvarchar(300)
AS
BEGIN

DELETE FROM
	ExchangeAccountEmailAddresses
WHERE
	AccountID = @AccountID AND LOWER(EmailAddress) <> LOWER(@PrimaryEmailAddress)
END
				*/
				#endregion

				ExchangeAccountEmailAddresses
					.Where(a => a.AccountId == accountId && a.EmailAddress.ToLower() != primaryAddress.ToLower())
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteUserEmailAddresses",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@PrimaryEmailAddress", primaryAddress));
			}
		}

		public void DeleteExchangeAccount(int itemId, int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteExchangeAccount]
(
	@ItemID int,
	@AccountID int
)
AS

-- delete e-mail addresses
DELETE FROM ExchangeAccountEmailAddresses
WHERE AccountID = @AccountID

-- delete account
DELETE FROM ExchangeAccounts
WHERE ItemID = @ItemID AND AccountID = @AccountID

RETURN
				*/
				#endregion

				ExchangeAccountEmailAddresses.Where(a => a.AccountId == accountId).ExecuteDelete();

				ExchangeAccounts.Where(a => a.ItemId == itemId && a.AccountId == accountId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteExchangeAccount",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@AccountID", accountId));
			}
		}

		public void DeleteExchangeAccountEmailAddress(int accountId, string emailAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteExchangeAccountEmailAddress]
(
	@AccountID int,
	@EmailAddress nvarchar(300)
)
AS
DELETE FROM ExchangeAccountEmailAddresses
WHERE AccountID = @AccountID AND EmailAddress = @EmailAddress
RETURN
				*/
				#endregion

				ExchangeAccountEmailAddresses.Where(a => a.AccountId == accountId && a.EmailAddress == emailAddress)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteExchangeAccountEmailAddress",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@EmailAddress", emailAddress));
			}
		}

		public void DeleteExchangeOrganization(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteExchangeOrganization]
(
	@ItemID int
)
AS
BEGIN TRAN
	DELETE FROM ExchangeMailboxPlans WHERE ItemID = @ItemID
	DELETE FROM ExchangeOrganizations WHERE ItemID = @ItemID
COMMIT TRAN
RETURN
				*/
				#endregion

				using (var transaction = Database.BeginTransaction())
				{
					ExchangeMailboxPlans.Where(p => p.ItemId == itemId).ExecuteDelete();
					ExchangeOrganizations.Where(o => o.ItemId == itemId).ExecuteDelete();
					transaction.Commit();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteExchangeOrganization",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public void DeleteExchangeOrganizationDomain(int itemId, int domainId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteExchangeOrganizationDomain]
(
	@ItemID int,
	@DomainID int
)
AS
DELETE FROM ExchangeOrganizationDomains
WHERE DomainID = @DomainID AND ItemID = @ItemID
RETURN
				*/
				#endregion

				ExchangeOrganizationDomains.Where(d => d.DomainId == domainId && d.ItemId == itemId)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteExchangeOrganizationDomain",
					new SqlParameter("@ItemId", itemId),
					new SqlParameter("@DomainID", domainId));
			}
		}

		public bool ExchangeAccountEmailAddressExists(string emailAddress, bool checkContacts)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[ExchangeAccountEmailAddressExists]
(
	@EmailAddress nvarchar(300),
	@checkContacts bit,
	@Exists bit OUTPUT
)
AS
	SET @Exists = 0
	IF EXISTS(SELECT * FROM [dbo].[ExchangeAccountEmailAddresses] WHERE [EmailAddress] = @EmailAddress)
		BEGIN
			SET @Exists = 1
		END
	ELSE IF EXISTS(SELECT * FROM [dbo].[ExchangeAccounts] WHERE [PrimaryEmailAddress] = @EmailAddress AND ([AccountType] <> 2 OR @checkContacts = 1))
		BEGIN
			SET @Exists = 1
		END

	RETURN
				*/
				#endregion

				return ExchangeAccountEmailAddresses.Any(a => a.EmailAddress == emailAddress) ||
					ExchangeAccounts.Any(a => a.PrimaryEmailAddress == emailAddress && (checkContacts || a.AccountType != ExchangeAccountType.Contact));
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@Exists", SqlDbType.Bit);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"ExchangeAccountEmailAddressExists",
					new SqlParameter("@EmailAddress", emailAddress),
					new SqlParameter("@checkContacts", checkContacts),
					outParam);

				return Convert.ToBoolean(outParam.Value);
			}
		}

		public bool ExchangeOrganizationDomainExists(int domainId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[ExchangeOrganizationDomainExists]
(
	@DomainID int,
	@Exists bit OUTPUT
)
AS
SET @Exists = 0
IF EXISTS(SELECT * FROM ExchangeOrganizationDomains WHERE DomainID = @DomainID)
BEGIN
	SET @Exists = 1
END
RETURN
				*/
				#endregion

				return ExchangeOrganizationDomains.Any(d => d.DomainId == domainId);
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@Exists", SqlDbType.Bit);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"ExchangeOrganizationDomainExists",
					new SqlParameter("@DomainID", domainId),
					outParam);

				return Convert.ToBoolean(outParam.Value);
			}
		}
		public bool ExchangeOrganizationExists(string organizationId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[ExchangeOrganizationExists]
(
	@OrganizationID nvarchar(10),
	@Exists bit OUTPUT
)
AS
SET @Exists = 0
IF EXISTS(SELECT * FROM ExchangeOrganizations WHERE OrganizationID = @OrganizationID)
BEGIN
	SET @Exists = 1
END

RETURN
				*/
				#endregion

				return ExchangeOrganizations.Any(o => o.OrganizationId == organizationId);
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@Exists", SqlDbType.Bit);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"ExchangeOrganizationExists",
					new SqlParameter("@OrganizationID", organizationId),
					outParam);

				return Convert.ToBoolean(outParam.Value);
			}
		}
		public bool ExchangeAccountExists(string accountName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[ExchangeAccountExists]
(
	@AccountName nvarchar(20),
	@Exists bit OUTPUT
)
AS
SET @Exists = 0
IF EXISTS(SELECT * FROM ExchangeAccounts WHERE sAMAccountName LIKE '%\'+@AccountName)
BEGIN
	SET @Exists = 1
END

RETURN
				*/
				#endregion

				return ExchangeAccounts.Any(a => a.SamAccountName.EndsWith($"\\{accountName}"));
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@Exists", SqlDbType.Bit);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"ExchangeAccountExists",
					new SqlParameter("@AccountName", accountName),
					outParam);

				return Convert.ToBoolean(outParam.Value);
			}
		}
		public void UpdateExchangeAccount(int accountId, string accountName, ExchangeAccountType accountType,
			string displayName, string primaryEmailAddress, bool mailEnabledPublicFolder,
			string mailboxManagerActions, string samAccountName, int mailboxPlanId, int archivePlanId, string subscriberNumber,
			bool EnableArchiving)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
-- Password column removed
CREATE PROCEDURE [dbo].[UpdateExchangeAccount] 
(
	@AccountID int,
	@AccountName nvarchar(300),
	@DisplayName nvarchar(300),
	@PrimaryEmailAddress nvarchar(300),
	@AccountType int,
	@SamAccountName nvarchar(100),
	@MailEnabledPublicFolder bit,
	@MailboxManagerActions varchar(200),
	@MailboxPlanId int,
	@ArchivingMailboxPlanId int,
	@SubscriberNumber varchar(32),
	@EnableArchiving bit
)
AS

BEGIN TRAN	

IF (@MailboxPlanId = -1) 
BEGIN
	SET @MailboxPlanId = NULL
END

UPDATE ExchangeAccounts SET
	AccountName = @AccountName,
	DisplayName = @DisplayName,
	PrimaryEmailAddress = @PrimaryEmailAddress,
	MailEnabledPublicFolder = @MailEnabledPublicFolder,
	MailboxManagerActions = @MailboxManagerActions,	
	AccountType =@AccountType,
	SamAccountName = @SamAccountName,
	MailboxPlanId = @MailboxPlanId,
	SubscriberNumber = @SubscriberNumber,
	ArchivingMailboxPlanId = @ArchivingMailboxPlanId,
	EnableArchiving = @EnableArchiving

WHERE
	AccountID = @AccountID

IF (@@ERROR <> 0 )
	BEGIN
		ROLLBACK TRANSACTION
		RETURN -1
	END

COMMIT TRAN
RETURN
				*/
				#endregion

				var account = ExchangeAccounts.FirstOrDefault(a => a.AccountId == accountId);
				if (account != null)
				{
					account.AccountName = accountName;
					account.DisplayName = displayName;
					account.PrimaryEmailAddress = primaryEmailAddress;
					account.MailEnabledPublicFolder = mailEnabledPublicFolder;
					account.MailboxManagerActions = mailboxManagerActions;
					account.AccountType = accountType;
					account.SamAccountName = samAccountName;
					account.MailboxPlanId = mailboxPlanId == -1 ? null : mailboxPlanId;
					account.SubscriberNumber = subscriberNumber;
					account.ArchivingMailboxPlanId = archivePlanId;
					account.EnableArchiving = EnableArchiving;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateExchangeAccount",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@AccountName", accountName),
					new SqlParameter("@DisplayName", displayName),
					new SqlParameter("@AccountType", (int)accountType),
					new SqlParameter("@PrimaryEmailAddress", primaryEmailAddress),
					new SqlParameter("@MailEnabledPublicFolder", mailEnabledPublicFolder),
					new SqlParameter("@MailboxManagerActions", mailboxManagerActions),
					new SqlParameter("@SamAccountName", samAccountName),
					new SqlParameter("@MailboxPlanId", (mailboxPlanId == 0) ? (object)DBNull.Value : (object)mailboxPlanId),
					new SqlParameter("@ArchivingMailboxPlanId", (archivePlanId < 1) ? (object)DBNull.Value : (object)archivePlanId),
					new SqlParameter("@SubscriberNumber", (string.IsNullOrEmpty(subscriberNumber) ? (object)DBNull.Value : (object)subscriberNumber)),
					new SqlParameter("@EnableArchiving", EnableArchiving));
			}
		}
		public void UpdateExchangeAccountServiceLevelSettings(int accountId, int levelId, bool isVIP)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateExchangeAccountSLSettings]
(
	@AccountID int,
	@LevelID int,
	@IsVIP bit
)
AS

BEGIN TRAN	

	IF (@LevelID = -1) 
	BEGIN
		SET @LevelID = NULL
	END

	UPDATE ExchangeAccounts SET
		LevelID = @LevelID,
		IsVIP = @IsVIP
	WHERE
		AccountID = @AccountID

	IF (@@ERROR <> 0 )
		BEGIN
			ROLLBACK TRANSACTION
			RETURN -1
		END
COMMIT TRAN
RETURN 
				*/
				#endregion

				var account = ExchangeAccounts.FirstOrDefault(a => a.AccountId == accountId);
				if (account != null)
				{
					account.LevelId = levelId != -1 ? levelId : null;
					account.IsVip = isVIP;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateExchangeAccountSLSettings",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@LevelID", (levelId == 0) ? (object)DBNull.Value : (object)levelId),
					new SqlParameter("@IsVIP", isVIP));
			}
		}

		public void UpdateExchangeAccountUserPrincipalName(int accountId, string userPrincipalName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
 CREATE PROCEDURE [dbo].[UpdateExchangeAccountUserPrincipalName]
(
	@AccountID int,
	@UserPrincipalName nvarchar(300)
)
AS

UPDATE ExchangeAccounts SET
	UserPrincipalName = @UserPrincipalName
WHERE
	AccountID = @AccountID

RETURN
				*/
				#endregion

				var account = ExchangeAccounts.FirstOrDefault(a => a.AccountId == accountId);
				if (account != null)
				{
					account.UserPrincipalName = userPrincipalName;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateExchangeAccountUserPrincipalName",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@UserPrincipalName", userPrincipalName));
			}
		}
		public IDataReader GetExchangeAccount(int itemId, int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
-- Password column removed
CREATE PROCEDURE [dbo].[GetExchangeAccount] 
(
	@ItemID int,
	@AccountID int
)
AS
SELECT
	E.AccountID,
	E.ItemID,
	E.AccountType,
	E.AccountName,
	E.DisplayName,
	E.PrimaryEmailAddress,
	E.MailEnabledPublicFolder,
	E.MailboxManagerActions,
	E.SamAccountName,
	E.MailboxPlanId,
	P.MailboxPlan,
	E.SubscriberNumber,
	E.UserPrincipalName,
	E.ArchivingMailboxPlanId, 
	AP.MailboxPlan as 'ArchivingMailboxPlan',
	E.EnableArchiving,
	E.LevelID,
	E.IsVIP
FROM
	ExchangeAccounts AS E
LEFT OUTER JOIN ExchangeMailboxPlans AS P ON E.MailboxPlanId = P.MailboxPlanId	
LEFT OUTER JOIN ExchangeMailboxPlans AS AP ON E.ArchivingMailboxPlanId = AP.MailboxPlanId
WHERE
	E.ItemID = @ItemID AND
	E.AccountID = @AccountID
RETURN
				*/
				#endregion

				var account = ExchangeAccounts
					.Where(a => a.ItemId == itemId && a.AccountId == accountId)
					.GroupJoin(ExchangeMailboxPlans, a => a.ArchivingMailboxPlanId, p => p.MailboxPlanId, (a, p) => new
					{
						Account = a,
						ArchivingMailboxPlans = p
					})
					.SelectMany(a => a.ArchivingMailboxPlans.DefaultIfEmpty(), (a, p) => new
					{
						a.Account.AccountId,
						a.Account.ItemId,
						a.Account.AccountType,
						a.Account.AccountName,
						a.Account.DisplayName,
						a.Account.PrimaryEmailAddress,
						a.Account.MailEnabledPublicFolder,
						a.Account.MailboxManagerActions,
						a.Account.SamAccountName,
						a.Account.MailboxPlanId,
						a.Account.MailboxPlan.MailboxPlan,
						a.Account.SubscriberNumber,
						a.Account.UserPrincipalName,
						a.Account.ArchivingMailboxPlanId,
						ArchivingMailboxPlan = p != null ? (int?)p.MailboxPlanId : null,
						a.Account.EnableArchiving,
						a.Account.LevelId,
						a.Account.IsVip
					});

				return EntityDataReader(account);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeAccount",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@AccountID", accountId));
			}
		}
		public IDataReader GetExchangeAccountByAccountName(int itemId, string accountName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
-- Password column removed
CREATE PROCEDURE [dbo].[GetExchangeAccountByAccountName] 
(
	@ItemID int,
	@AccountName nvarchar(300)
)
AS
SELECT
	E.AccountID,
	E.ItemID,
	E.AccountType,
	E.AccountName,
	E.DisplayName,
	E.PrimaryEmailAddress,
	E.MailEnabledPublicFolder,
	E.MailboxManagerActions,
	E.SamAccountName,
	E.MailboxPlanId,
	P.MailboxPlan,
	E.SubscriberNumber,
	E.UserPrincipalName,
	E.ArchivingMailboxPlanId, 
	AP.MailboxPlan as 'ArchivingMailboxPlan',
	E.EnableArchiving
FROM
	ExchangeAccounts AS E
LEFT OUTER JOIN ExchangeMailboxPlans AS P ON E.MailboxPlanId = P.MailboxPlanId	
LEFT OUTER JOIN ExchangeMailboxPlans AS AP ON E.ArchivingMailboxPlanId = AP.MailboxPlanId
WHERE
	E.ItemID = @ItemID AND
	E.AccountName = @AccountName
RETURN
				*/
				#endregion

				var account = ExchangeAccounts
					.Where(a => a.ItemId == itemId && a.AccountName == accountName)
					.GroupJoin(ExchangeMailboxPlans, a => a.ArchivingMailboxPlanId, p => p.MailboxPlanId, (a, p) => new
					{
						Account = a,
						ArchvingMailboxPlans = p
					})
					.SelectMany(a => a.ArchvingMailboxPlans.DefaultIfEmpty(), (a, p) => new
					{
						a.Account.AccountId,
						a.Account.ItemId,
						a.Account.AccountType,
						a.Account.AccountName,
						a.Account.DisplayName,
						a.Account.PrimaryEmailAddress,
						a.Account.MailEnabledPublicFolder,
						a.Account.MailboxManagerActions,
						a.Account.SamAccountName,
						a.Account.MailboxPlanId,
						a.Account.MailboxPlan.MailboxPlan,
						a.Account.SubscriberNumber,
						a.Account.UserPrincipalName,
						a.Account.ArchivingMailboxPlanId,
						ArchivingMailboxPlan = p != null ? (int?)p.MailboxPlanId : null,
						a.Account.EnableArchiving
					});

				return EntityDataReader(account);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeAccountByAccountName",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@AccountName", accountName));
			}
		}
		public IDataReader GetExchangeAccountByMailboxPlanId(int itemId, int MailboxPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeAccountByMailboxPlanId] 
(
	@ItemID int,
	@MailboxPlanId int
)
AS

IF (@MailboxPlanId < 0)
BEGIN
SELECT
	E.AccountID,
	E.ItemID,
	E.AccountType,
	E.AccountName,
	E.DisplayName,
	E.PrimaryEmailAddress,
	E.MailEnabledPublicFolder,
	E.MailboxManagerActions,
	E.SamAccountName,
	E.MailboxPlanId,
	P.MailboxPlan,
	E.SubscriberNumber,
	E.UserPrincipalName,
	E.ArchivingMailboxPlanId, 
	AP.MailboxPlan as 'ArchivingMailboxPlan',
	E.EnableArchiving
FROM
	ExchangeAccounts AS E
LEFT OUTER JOIN ExchangeMailboxPlans AS P ON E.MailboxPlanId = P.MailboxPlanId	
LEFT OUTER JOIN ExchangeMailboxPlans AS AP ON E.ArchivingMailboxPlanId = AP.MailboxPlanId
WHERE
	E.ItemID = @ItemID AND
	E.MailboxPlanId IS NULL AND
	E.AccountType IN (1,5,6,10,12) 
RETURN
				
END
ELSE
IF (@ItemId = 0)
BEGIN
SELECT
	E.AccountID,
	E.ItemID,
	E.AccountType,
	E.AccountName,
	E.DisplayName,
	E.PrimaryEmailAddress,
	E.MailEnabledPublicFolder,
	E.MailboxManagerActions,
	E.SamAccountName,
	E.MailboxPlanId,
	P.MailboxPlan,
	E.SubscriberNumber,
	E.UserPrincipalName,
	E.ArchivingMailboxPlanId, 
	AP.MailboxPlan as 'ArchivingMailboxPlan',
	E.EnableArchiving
FROM
	ExchangeAccounts AS E
LEFT OUTER JOIN ExchangeMailboxPlans AS P ON E.MailboxPlanId = P.MailboxPlanId	
LEFT OUTER JOIN ExchangeMailboxPlans AS AP ON E.ArchivingMailboxPlanId = AP.MailboxPlanId
WHERE
	E.MailboxPlanId = @MailboxPlanId AND
	E.AccountType IN (1,5,6,10,12) 
END
ELSE
BEGIN
SELECT
	E.AccountID,
	E.ItemID,
	E.AccountType,
	E.AccountName,
	E.DisplayName,
	E.PrimaryEmailAddress,
	E.MailEnabledPublicFolder,
	E.MailboxManagerActions,
	E.SamAccountName,
	E.MailboxPlanId,
	P.MailboxPlan,
	E.SubscriberNumber,
	E.UserPrincipalName,
	E.ArchivingMailboxPlanId, 
	AP.MailboxPlan as 'ArchivingMailboxPlan',
	E.EnableArchiving
FROM
	ExchangeAccounts AS E
LEFT OUTER JOIN ExchangeMailboxPlans AS P ON E.MailboxPlanId = P.MailboxPlanId	
LEFT OUTER JOIN ExchangeMailboxPlans AS AP ON E.ArchivingMailboxPlanId = AP.MailboxPlanId
WHERE
	E.ItemID = @ItemID AND
	E.MailboxPlanId = @MailboxPlanId AND
	E.AccountType IN (1,5,6,10,12) 
RETURN
END
				*/
				#endregion

				var accountTypes = new ExchangeAccountType[] { ExchangeAccountType.Mailbox, ExchangeAccountType.Room,
					ExchangeAccountType.Equipment, ExchangeAccountType.SharedMailbox, ExchangeAccountType.JournalingMailbox };

				IQueryable<Data.Entities.ExchangeAccount> accounts = ExchangeAccounts;

				if (MailboxPlanId < 0) {
					accounts = accounts
						.Where(a => a.ItemId == itemId && a.MailboxPlanId == null && accountTypes.Any(t => t == a.AccountType));
				} else if (itemId == 0) {
					accounts = accounts
						.Where(a => a.MailboxPlanId == MailboxPlanId && accountTypes.Any(t => t == a.AccountType));
				} else
				{
					accounts = accounts
						.Where(a => a.ItemId == itemId && a.MailboxPlanId == MailboxPlanId &&
							accountTypes.Any(t => t == a.AccountType));
				}

				var account = accounts
					.GroupJoin(ExchangeMailboxPlans, a => a.ArchivingMailboxPlanId, p => p.MailboxPlanId, (a, p) => new
					{
						Account = a,
						ArchivingMailboxPlans = p
					})
					.SelectMany(a => a.ArchivingMailboxPlans.DefaultIfEmpty(), (a, p) => new
					{
						a.Account,
						ArchivingMailboxPlan = p != null ? (int?)p.MailboxPlanId : null
					})
					.Select(a => new
					{
						a.Account.AccountId,
						a.Account.ItemId,
						a.Account.AccountType,
						a.Account.AccountName,
						a.Account.DisplayName,
						a.Account.PrimaryEmailAddress,
						a.Account.MailEnabledPublicFolder,
						a.Account.MailboxManagerActions,
						a.Account.SamAccountName,
						a.Account.MailboxPlanId,
						a.Account.MailboxPlan.MailboxPlan,
						a.Account.SubscriberNumber,
						a.Account.UserPrincipalName,
						a.Account.ArchivingMailboxPlanId,
						a.ArchivingMailboxPlan,
						a.Account.EnableArchiving
					});

				return EntityDataReader(account);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeAccountByMailboxPlanId",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@MailboxPlanId", MailboxPlanId));
			}
		}

		public IDataReader GetExchangeAccountEmailAddresses(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeAccountEmailAddresses]
(
	@AccountID int
)
AS
SELECT
	AddressID,
	AccountID,
	EmailAddress
FROM
	ExchangeAccountEmailAddresses
WHERE
	AccountID = @AccountID
RETURN
				*/
				#endregion

				var addresses = ExchangeAccountEmailAddresses
					.Where(a => a.AccountId == accountId)
					.Select(a => new { a.AddressId, a.AccountId, a.EmailAddress });
				return EntityDataReader(addresses);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeAccountEmailAddresses",
					new SqlParameter("@AccountID", accountId));
			}
		}
		public IDataReader GetExchangeOrganizationDomains(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeOrganizationDomains]
(
	@ItemID int
)
AS
SELECT
	ED.DomainID,
	D.DomainName,
	ED.IsHost,
	ED.DomainTypeID
FROM
	ExchangeOrganizationDomains AS ED
INNER JOIN Domains AS D ON ED.DomainID = D.DomainID
WHERE ED.ItemID = @ItemID
RETURN
				*/
				#endregion

				var domains = ExchangeOrganizationDomains
					.Where(d => d.ItemId == itemId)
					.Join(Domains, ed => ed.DomainId, d => d.DomainId, (ed, d) => new
					{
						ed.DomainId,
						d.DomainName,
						ed.IsHost,
						ed.DomainTypeId
					});
				return EntityDataReader(domains);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeOrganizationDomains",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public IDataReader GetExchangeAccounts(int itemId, ExchangeAccountType accountType)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeAccounts]
(
	@ItemID int,
	@AccountType int
)
AS
SELECT
	E.AccountID,
	E.ItemID,
	E.AccountType,
	E.AccountName,
	E.DisplayName,
	E.PrimaryEmailAddress,
	E.MailEnabledPublicFolder,
	E.MailboxPlanId,
	P.MailboxPlan,
	E.SubscriberNumber,
	E.UserPrincipalName
FROM
	ExchangeAccounts  AS E
LEFT OUTER JOIN ExchangeMailboxPlans AS P ON E.MailboxPlanId = P.MailboxPlanId
WHERE
	E.ItemID = @ItemID AND
	(E.AccountType = @AccountType OR @AccountType = 0)
ORDER BY DisplayName
RETURN
				*/
				#endregion

				var accounts = ExchangeAccounts
					.Where(a => a.ItemId == itemId && (accountType == ExchangeAccountType.Undefined || a.AccountType == accountType))
					.OrderBy(a => a.DisplayName)
					.Select(a => new
					{
						a.AccountId,
						a.ItemId,
						a.AccountType,
						a.AccountName,
						a.DisplayName,
						a.PrimaryEmailAddress,
						a.MailEnabledPublicFolder,
						a.MailboxPlanId,
						a.MailboxPlan.MailboxPlan,
						a.SubscriberNumber,
						a.UserPrincipalName
					});

				return EntityDataReader(accounts);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeAccounts",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@AccountType", accountType));
			}
		}
		public IDataReader GetExchangeAccountByAccountNameWithoutItemId(string userPrincipalName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeAccountByAccountNameWithoutItemId] 
(
	@UserPrincipalName nvarchar(300)
)
AS
SELECT
	E.AccountID,
	E.ItemID,
	E.AccountType,
	E.AccountName,
	E.DisplayName,
	E.PrimaryEmailAddress,
	E.MailEnabledPublicFolder,
	E.MailboxManagerActions,
	E.SamAccountName,
	E.MailboxPlanId,
	P.MailboxPlan,
	E.SubscriberNumber,
	E.UserPrincipalName,
	E.ArchivingMailboxPlanId, 
	AP.MailboxPlan as 'ArchivingMailboxPlan',
	E.EnableArchiving
FROM
	ExchangeAccounts AS E
LEFT OUTER JOIN ExchangeMailboxPlans AS P ON E.MailboxPlanId = P.MailboxPlanId	
LEFT OUTER JOIN ExchangeMailboxPlans AS AP ON E.ArchivingMailboxPlanId = AP.MailboxPlanId
WHERE
	E.UserPrincipalName = @UserPrincipalName
RETURN
				*/
				#endregion

				var account = ExchangeAccounts
					.Where(a => a.UserPrincipalName == userPrincipalName)
					.GroupJoin(ExchangeMailboxPlans, a => a.ArchivingMailboxPlanId, p => p.MailboxPlanId, (a, p) => new
					{
						Account = a,
						ArchivingMailboxPlans = p
						//ArchivingMailboxPlan = p.Any() ? (int?)p.Single().MailboxPlanId : null
					})
					.SelectMany(a => a.ArchivingMailboxPlans.DefaultIfEmpty(), (a, p) => new
					{
						a.Account.AccountId,
						a.Account.ItemId,
						a.Account.AccountType,
						a.Account.AccountName,
						a.Account.DisplayName,
						a.Account.PrimaryEmailAddress,
						a.Account.MailEnabledPublicFolder,
						a.Account.MailboxManagerActions,
						a.Account.SamAccountName,
						a.Account.MailboxPlanId,
						a.Account.MailboxPlan.MailboxPlan,
						a.Account.SubscriberNumber,
						a.Account.UserPrincipalName,
						a.Account.ArchivingMailboxPlanId,
						ArchivingMailboxPlan = p != null ? (int?)p.MailboxPlanId : null,
						a.Account.EnableArchiving
					});

				return EntityDataReader(account);

			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeAccountByAccountNameWithoutItemId",
					new SqlParameter("@UserPrincipalName", userPrincipalName));
			}
		}

		public IDataReader GetExchangeMailboxes(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeMailboxes]
	@ItemID int
AS
BEGIN
SELECT
	AccountID,
	ItemID,
	AccountType,
	AccountName,
	DisplayName,
	PrimaryEmailAddress,
	MailEnabledPublicFolder,
	SubscriberNumber,
	UserPrincipalName
FROM
	ExchangeAccounts
WHERE
	ItemID = @ItemID AND
	(AccountType =1  OR AccountType=5 OR AccountType=6)
ORDER BY 1

END
				*/
				#endregion

				var accounts = ExchangeAccounts
					.Where(a => a.ItemId == itemId && (a.AccountType == ExchangeAccountType.Mailbox ||
						a.AccountType == ExchangeAccountType.Room || a.AccountType == ExchangeAccountType.Equipment))
					.OrderBy(a => a.AccountId)
					.Select(a => new
					{
						a.AccountId,
						a.ItemId,
						a.AccountType,
						a.AccountName,
						a.DisplayName,
						a.PrimaryEmailAddress,
						a.MailEnabledPublicFolder,
						a.SubscriberNumber,
						a.UserPrincipalName
					});

				return EntityDataReader(accounts);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeMailboxes",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public IDataReader SearchExchangeAccountsByTypes(int actorId, int itemId, ExchangeAccountType[] accountTypes,
			string filterColumn, string filterValue, string sortColumn)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SearchExchangeAccountsByTypes]
(
	@ActorID int,
	@ItemID int,
	@AccountTypes nvarchar(30),
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50)
)
AS

DECLARE @PackageID int
SELECT @PackageID = PackageID FROM ServiceItems
WHERE ItemID = @ItemID

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

DECLARE @condition nvarchar(700)
SET @condition = 'EA.ItemID = @ItemID AND EA.AccountType IN (' + @AccountTypes + ')'

IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
AND @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
	IF @FilterColumn = 'PrimaryEmailAddress' AND @AccountTypes <> '2'
	BEGIN		
		SET @condition = @condition + ' AND EA.AccountID IN (SELECT EAEA.AccountID FROM ExchangeAccountEmailAddresses EAEA WHERE EAEA.EmailAddress LIKE ''' + @FilterValue + ''')'
	END
	ELSE
	BEGIN		
		SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
	END
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'EA.DisplayName ASC'

DECLARE @sql nvarchar(3500)
SET @sql = '
SELECT
	EA.AccountID,
	EA.ItemID,
	EA.AccountType,
	EA.AccountName,
	EA.DisplayName,
	EA.PrimaryEmailAddress,
	EA.MailEnabledPublicFolder,
	EA.MailboxPlanId,
	P.MailboxPlan, 
	EA.SubscriberNumber,
	EA.UserPrincipalName
FROM
	ExchangeAccounts  AS EA
LEFT OUTER JOIN ExchangeMailboxPlans AS P ON EA.MailboxPlanId = P.MailboxPlanId
	WHERE ' + @condition
	+ ' ORDER BY ' + @SortColumn

EXEC sp_executesql @sql, N'@ItemID int', @ItemID

RETURN
				*/
				#endregion

				var packageId = ServiceItems
					.Where(i => i.ItemId == itemId)
					.Select(i => i.PackageId)
					.FirstOrDefault();
				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var accounts = ExchangeAccounts
					.Where(a => a.ItemId == itemId && accountTypes.Any(t => t == a.AccountType));

				if (!string.IsNullOrEmpty(filterColumn) && !string.IsNullOrEmpty(filterValue))
				{
					if (filterColumn == "PrimaryEmailAddress" &&
						(accountTypes.Length != 1 || accountTypes[0] != ExchangeAccountType.Contact))
					{
#if NETFRAMEWORK
						accounts = accounts.Where(a => a.ExchangeAccountEmailAddresses.Any(e => DbFunctions.Like(e.EmailAddress, filterValue)));
#else
						accounts = accounts.Where(a => a.ExchangeAccountEmailAddresses.Any(e => EF.Functions.Like(e.EmailAddress, filterValue)));
#endif
					} else
					{
						accounts = accounts.Where(DynamicFunctions.ColumnLike(accounts, filterColumn, filterValue));
					}
				}

				if (!string.IsNullOrEmpty(sortColumn)) accounts = accounts.OrderBy(sortColumn);
				else accounts = accounts.OrderBy(a => a.DisplayName);

				var accountsSelected = accounts
					.Select(a => new
					{
						a.AccountId,
						a.ItemId,
						a.AccountType,
						a.AccountName,
						a.DisplayName,
						a.PrimaryEmailAddress,
						a.MailEnabledPublicFolder,
						a.MailboxPlanId,
						a.MailboxPlan.MailboxPlan,
						a.SubscriberNumber,
						a.UserPrincipalName
					});
				return EntityDataReader(accountsSelected);
			}
			else
			{
				var accountTypesAsString = string.Join(",", accountTypes.Select(t => (int)t));

				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"SearchExchangeAccountsByTypes",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@AccountTypes", accountTypesAsString),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)));
			}
		}

		public DataSet GetExchangeAccountsPaged(int actorId, int itemId, string accountTypesAsString,
			string filterColumn, string filterValue, string sortColumn, int startRow, int maximumRows, bool archiving)
		{
			// check input parameters
			if (!Regex.IsMatch(accountTypesAsString, @"^\s*([0-9]+|[a-zA-Z_][a-zA-Z0-9_]*)(\s*,\s*([0-9]+|[a-zA-Z_][a-zA-Z0-9_]*))*\s*$", RegexOptions.Singleline))
			{
				throw new ArgumentException("Wrong patameter", "accountTypesAsString");
			}

			accountTypesAsString = Regex.Replace(accountTypesAsString, @"[ \t]", ""); // remove whitespace

			var accountTypes = accountTypesAsString.Split(',')
				.Select(t =>
				{
					int type;
					ExchangeAccountType etype;
					if (int.TryParse(t, out type)) return (ExchangeAccountType)type;
					else if (Enum.TryParse<ExchangeAccountType>(t, out etype)) return etype;
					else throw new NotSupportedException($"Value {t} is not a valid ExchangeAccountType.");
				})
				.ToArray();

			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeAccountsPaged]
(
	@ActorID int,
	@ItemID int,
	@AccountTypes nvarchar(30),
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int,
	@Archiving bit
)
AS

DECLARE @PackageID int
SELECT @PackageID = PackageID FROM ServiceItems
WHERE ItemID = @ItemID

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
EA.AccountType IN (' + @AccountTypes + ')
AND EA.ItemID = @ItemID
'

IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
AND @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
	IF @FilterColumn = 'PrimaryEmailAddress' AND @AccountTypes <> '2'
	BEGIN		
		SET @condition = @condition + ' AND EA.AccountID IN (SELECT EAEA.AccountID FROM ExchangeAccountEmailAddresses EAEA WHERE EAEA.EmailAddress LIKE ''%' + @FilterValue + '%'')'
	END
	ELSE
	BEGIN		
		SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''%' + @FilterValue + '%'''
	END
END

if @Archiving = 1
BEGIN
	SET @condition = @condition + ' AND (EA.ArchivingMailboxPlanId > 0) ' 
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'EA.DisplayName ASC'

DECLARE @joincondition nvarchar(700)
	SET @joincondition = ',P.MailboxPlan FROM ExchangeAccounts AS EA
	LEFT OUTER JOIN ExchangeMailboxPlans AS P ON EA.MailboxPlanId = P.MailboxPlanId'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(EA.AccountID) FROM ExchangeAccounts AS EA
WHERE ' + @condition + ';

WITH Accounts AS (
	SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
		EA.AccountID,
		EA.ItemID,
		EA.AccountType,
		EA.AccountName,
		EA.DisplayName,
		EA.PrimaryEmailAddress,
		EA.MailEnabledPublicFolder,
		EA.MailboxPlanId,
		EA.SubscriberNumber,
		EA.UserPrincipalName,
		EA.LevelID,
		EA.IsVIP ' + @joincondition +
	' WHERE ' + @condition + '
)

SELECT * FROM Accounts
WHERE Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows
'

print @sql

exec sp_executesql @sql, N'@ItemID int, @StartRow int, @MaximumRows int',
@ItemID, @StartRow, @MaximumRows

RETURN
				*/
				#endregion

				var packageId = ServiceItems
					.Where(i => i.ItemId == itemId)
					.Select(i => i.PackageId)
					.FirstOrDefault();
				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var accounts = ExchangeAccounts
					.Where(a => a.ItemId == itemId && accountTypes.Any(t => t == a.AccountType));

				if (!string.IsNullOrEmpty(filterColumn) && !string.IsNullOrEmpty(filterValue))
				{
					if (filterColumn == "PrimaryEmailAddress" &&
						(accountTypes.Length != 1 || accountTypes[0] != ExchangeAccountType.Contact))
					{
#if NETFRAMEWORK
						accounts = accounts.Where(a => a.ExchangeAccountEmailAddresses.Any(e => DbFunctions.Like(e.EmailAddress, filterValue)));
#else
						accounts = accounts.Where(a => a.ExchangeAccountEmailAddresses.Any(e => EF.Functions.Like(e.EmailAddress, filterValue)));
#endif
					}
					else
					{
						accounts = accounts.Where(DynamicFunctions.ColumnLike(accounts, filterColumn, filterValue));
					}
				}

				if (archiving)
				{
					accounts = accounts.Where(a => a.ArchivingMailboxPlanId > 0);
				}

				var count = accounts.Count();

				if (!string.IsNullOrEmpty(sortColumn)) accounts = accounts.OrderBy(sortColumn);
				else accounts = accounts.OrderBy(a => a.DisplayName);

				accounts = accounts.Skip(startRow).Take(maximumRows);

				var accountsSelected = accounts
					.Select(a => new
					{
						a.AccountId,
						a.ItemId,
						a.AccountType,
						a.AccountName,
						a.DisplayName,
						a.PrimaryEmailAddress,
						a.MailEnabledPublicFolder,
						a.MailboxPlanId,
						a.MailboxPlan.MailboxPlan,
						a.SubscriberNumber,
						a.UserPrincipalName,
						a.LevelId,
						a.IsVip
					});

				return EntityDataSet(count, accountsSelected);
			}
			else
			{
				accountTypesAsString = string.Join(",", accountTypes.Select(t => ((int)t).ToString()));

				return SqlHelper.ExecuteDataset(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeAccountsPaged",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@AccountTypes", accountTypesAsString),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("@MaximumRows", maximumRows),
					new SqlParameter("@Archiving", archiving));
			}
		}
		public IDataReader SearchExchangeAccounts(int actorId, int itemId, bool includeMailboxes,
			bool includeContacts, bool includeDistributionLists, bool includeRooms, bool includeEquipment, bool includeSharedMailbox,
			bool includeSecurityGroups, string filterColumn, string filterValue, string sortColumn)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SearchExchangeAccounts]
(
	@ActorID int,
	@ItemID int,
	@IncludeMailboxes bit,
	@IncludeContacts bit,
	@IncludeDistributionLists bit,
	@IncludeRooms bit,
	@IncludeEquipment bit,
	@IncludeSharedMailbox bit,
	@IncludeSecurityGroups bit,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50)
)
AS
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM ServiceItems
WHERE ItemID = @ItemID

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
((@IncludeMailboxes = 1 AND EA.AccountType = 1)
OR (@IncludeContacts = 1 AND EA.AccountType = 2)
OR (@IncludeDistributionLists = 1 AND EA.AccountType = 3)
OR (@IncludeRooms = 1 AND EA.AccountType = 5)
OR (@IncludeEquipment = 1 AND EA.AccountType = 6)
OR (@IncludeSharedMailbox = 1 AND EA.AccountType = 10)
OR (@IncludeSecurityGroups = 1 AND EA.AccountType = 8))
AND EA.ItemID = @ItemID
'

IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
AND @FilterValue <> '' AND @FilterValue IS NOT NULL
SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'EA.DisplayName ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT
	EA.AccountID,
	EA.ItemID,
	EA.AccountType,
	EA.AccountName,
	EA.DisplayName,
	EA.PrimaryEmailAddress,
	EA.MailEnabledPublicFolder,
	EA.SubscriberNumber,
	EA.UserPrincipalName
FROM ExchangeAccounts AS EA
WHERE ' + @condition

print @sql

exec sp_executesql @sql, N'@ItemID int, @IncludeMailboxes int, @IncludeContacts int,
    @IncludeDistributionLists int, @IncludeRooms bit, @IncludeEquipment bit, @IncludeSharedMailbox bit, @IncludeSecurityGroups bit',
@ItemID, @IncludeMailboxes, @IncludeContacts, @IncludeDistributionLists, @IncludeRooms, @IncludeEquipment, @IncludeSharedMailbox, @IncludeSecurityGroups

RETURN
				*/
				#endregion

				var packageId = ServiceItems
					.Where(i => i.ItemId == itemId)
					.Select(i => i.PackageId)
					.FirstOrDefault();
				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var accounts = ExchangeAccounts
					.Where(a => a.ItemId == itemId && (
						(includeMailboxes && a.AccountType == ExchangeAccountType.Mailbox) ||
						(includeContacts && a.AccountType == ExchangeAccountType.Contact) ||
						(includeDistributionLists && a.AccountType == ExchangeAccountType.DistributionList) ||
						(includeRooms && a.AccountType == ExchangeAccountType.Room) ||
						(includeEquipment && a.AccountType == ExchangeAccountType.Equipment) ||
						(includeSecurityGroups && a.AccountType == ExchangeAccountType.SecurityGroup) ||
						(includeSharedMailbox && a.AccountType == ExchangeAccountType.SharedMailbox)));

				if (!string.IsNullOrEmpty(filterColumn) && !string.IsNullOrEmpty(filterValue))
				{
					accounts = accounts.Where(DynamicFunctions.ColumnLike(accounts, filterColumn, filterValue));
				}

				if (!string.IsNullOrEmpty(sortColumn)) accounts = accounts.OrderBy(sortColumn);
				else accounts = accounts.OrderBy(a => a.DisplayName);

				var accountsSelected = accounts
					.Select(a => new
					{
						a.AccountId,
						a.ItemId,
						a.AccountType,
						a.AccountName,
						a.DisplayName,
						a.PrimaryEmailAddress,
						a.MailEnabledPublicFolder,
						a.SubscriberNumber,
						a.UserPrincipalName
					});

				return EntityDataReader(accountsSelected);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"SearchExchangeAccounts",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@IncludeMailboxes", includeMailboxes),
					new SqlParameter("@IncludeContacts", includeContacts),
					new SqlParameter("@IncludeDistributionLists", includeDistributionLists),
					new SqlParameter("@IncludeRooms", includeRooms),
					new SqlParameter("@IncludeEquipment", includeEquipment),
					new SqlParameter("@IncludeSharedMailbox", includeSharedMailbox),
					new SqlParameter("@IncludeSecurityGroups", includeSecurityGroups),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)));
			}
		}

		public IDataReader SearchExchangeAccount(int actorId, ExchangeAccountType accountType, string primaryEmailAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SearchExchangeAccount]
(
      @ActorID int,
      @AccountType int,
      @PrimaryEmailAddress nvarchar(300)
)
AS

DECLARE @PackageID int
DECLARE @ItemID int
DECLARE @AccountID int

SELECT
      @AccountID = AccountID,
      @ItemID = ItemID
FROM ExchangeAccounts
WHERE PrimaryEmailAddress = @PrimaryEmailAddress
AND AccountType = @AccountType

-- check space rights
SELECT @PackageID = PackageID FROM ServiceItems
WHERE ItemID = @ItemID

IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

SELECT
	AccountID,
	ItemID,
	@PackageID AS PackageID,
	AccountType,
	AccountName,
	DisplayName,
	PrimaryEmailAddress,
	MailEnabledPublicFolder,
	MailboxManagerActions,
	SamAccountName,
	SubscriberNumber,
	UserPrincipalName
FROM ExchangeAccounts
WHERE AccountID = @AccountID

RETURN 
				*/
				#endregion

				var account = ExchangeAccounts
					.Where(a => a.PrimaryEmailAddress == primaryEmailAddress && a.AccountType == accountType)
					.Select(a => new { a.AccountId, a.ItemId, a.Item.PackageId })
					.FirstOrDefault();

				// check rights
				if (!CheckActorPackageRights(actorId, account.PackageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var accounts = ExchangeAccounts
					.Where(a => a.AccountId == account.AccountId)
					.Select(a => new
					{
						a.AccountId,
						a.ItemId,
						PackageId = account.PackageId,
						a.AccountType,
						a.AccountName,
						a.DisplayName,
						a.PrimaryEmailAddress,
						a.MailEnabledPublicFolder,
						a.MailboxManagerActions,
						a.SamAccountName,
						a.SubscriberNumber,
					});

				return EntityDataReader(accounts);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"SearchExchangeAccount",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@AccountType", (int)accountType),
					new SqlParameter("@PrimaryEmailAddress", primaryEmailAddress));
			}
		}
#endregion

		#region Exchange Mailbox Plans
		public int AddExchangeMailboxPlan(int itemId, string mailboxPlan, bool enableActiveSync, bool enableIMAP, bool enableMAPI, bool enableOWA, bool enablePOP, bool enableAutoReply,
			bool isDefault, int issueWarningPct, int keepDeletedItemsDays, int mailboxSizeMB, int maxReceiveMessageSizeKB, int maxRecipients,
			int maxSendMessageSizeKB, int prohibitSendPct, int prohibitSendReceivePct, bool hideFromAddressBook, int mailboxPlanType,
			bool enabledLitigationHold, int recoverableItemsSpace, int recoverableItemsWarning, string litigationHoldUrl, string litigationHoldMsg,
			bool archiving, bool EnableArchiving, int ArchiveSizeMB, int ArchiveWarningPct, bool enableForceArchiveDeletion, bool isForJournaling)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddExchangeMailboxPlan] 
(
	@MailboxPlanId int OUTPUT,
	@ItemID int,
	@MailboxPlan	nvarchar(300),
	@EnableActiveSync bit,
	@EnableIMAP bit,
	@EnableMAPI bit,
	@EnableOWA bit,
	@EnablePOP bit,
	@EnableAutoReply bit,
	@IsDefault bit,
	@IssueWarningPct int,
	@KeepDeletedItemsDays int,
	@MailboxSizeMB int,
	@MaxReceiveMessageSizeKB int,
	@MaxRecipients int,
	@MaxSendMessageSizeKB int,
	@ProhibitSendPct int,
	@ProhibitSendReceivePct int	,
	@HideFromAddressBook bit,
	@MailboxPlanType int,
	@AllowLitigationHold bit,
	@RecoverableItemsWarningPct int,
	@RecoverableItemsSpace int,
	@LitigationHoldUrl nvarchar(256),
	@LitigationHoldMsg nvarchar(512),
	@Archiving bit,
	@EnableArchiving bit,
	@ArchiveSizeMB int,
	@ArchiveWarningPct int,
	@EnableForceArchiveDeletion bit,
	@IsForJournaling bit
)
AS

IF (((SELECT Count(*) FROM ExchangeMailboxPlans WHERE ItemId = @ItemID) = 0) AND (@MailboxPlanType=0))
BEGIN
	SET @IsDefault = 1
END
ELSE
BEGIN
	IF ((@IsDefault = 1) AND (@MailboxPlanType=0))
	BEGIN
		UPDATE ExchangeMailboxPlans SET IsDefault = 0 WHERE ItemID = @ItemID
	END
END

INSERT INTO ExchangeMailboxPlans
(
	ItemID,
	MailboxPlan,
	EnableActiveSync,
	EnableIMAP,
	EnableMAPI,
	EnableOWA,
	EnablePOP,
	EnableAutoReply,
	IsDefault,
	IssueWarningPct,
	KeepDeletedItemsDays,
	MailboxSizeMB,
	MaxReceiveMessageSizeKB,
	MaxRecipients,
	MaxSendMessageSizeKB,
	ProhibitSendPct,
	ProhibitSendReceivePct,
	HideFromAddressBook,
	MailboxPlanType,
	AllowLitigationHold,
	RecoverableItemsWarningPct,
	RecoverableItemsSpace,
	LitigationHoldUrl,
	LitigationHoldMsg,
	Archiving,
	EnableArchiving,
	ArchiveSizeMB,
	ArchiveWarningPct,
	EnableForceArchiveDeletion,
	IsForJournaling
)
VALUES
(
	@ItemID,
	@MailboxPlan,
	@EnableActiveSync,
	@EnableIMAP,
	@EnableMAPI,
	@EnableOWA,
	@EnablePOP,
	@EnableAutoReply,
	@IsDefault,
	@IssueWarningPct,
	@KeepDeletedItemsDays,
	@MailboxSizeMB,
	@MaxReceiveMessageSizeKB,
	@MaxRecipients,
	@MaxSendMessageSizeKB,
	@ProhibitSendPct,
	@ProhibitSendReceivePct,
	@HideFromAddressBook,
	@MailboxPlanType,
	@AllowLitigationHold,
	@RecoverableItemsWarningPct,
	@RecoverableItemsSpace,
	@LitigationHoldUrl,
	@LitigationHoldMsg,
	@Archiving,
	@EnableArchiving,
	@ArchiveSizeMB,
	@ArchiveWarningPct,
	@EnableForceArchiveDeletion,
	@IsForJournaling
)

SET @MailboxPlanId = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				if (!ExchangeMailboxPlans.Any(p => p.ItemId == itemId) && mailboxPlanType == 0)
				{
					isDefault = true;
				} else if (isDefault && mailboxPlanType == 0)
				{
#if NETFRAMEWORK
					foreach (var plan0 in ExchangeMailboxPlans.Where(p => p.ItemId == itemId)) plan0.IsDefault = false;
					SaveChanges();
#else
					ExchangeMailboxPlans.Where(p => p.ItemId == itemId)
						.ExecuteUpdate(set => set.SetProperty(p => p.IsDefault, false));
#endif
				}

				var plan = new Data.Entities.ExchangeMailboxPlan() {
					ItemId = itemId,
					MailboxPlan = mailboxPlan,
					EnableActiveSync = enableActiveSync,
					EnableImap = enableIMAP,
					EnableMapi = enableMAPI,
					EnableOwa = enableOWA,
					EnablePop = enablePOP,
					EnableAutoReply = enableAutoReply,
					IsDefault = isDefault,
					IssueWarningPct = issueWarningPct,
					KeepDeletedItemsDays = keepDeletedItemsDays,
					MailboxSizeMb = mailboxSizeMB,
					MaxReceiveMessageSizeKb = maxReceiveMessageSizeKB,
					MaxRecipients = maxRecipients,
					MaxSendMessageSizeKb = maxSendMessageSizeKB,
					ProhibitSendPct = prohibitSendPct,
					ProhibitSendReceivePct = prohibitSendReceivePct,
					HideFromAddressBook = hideFromAddressBook,
					MailboxPlanType = mailboxPlanType,
					AllowLitigationHold = enabledLitigationHold,
					RecoverableItemsWarningPct = recoverableItemsWarning,
					RecoverableItemsSpace = recoverableItemsSpace,
					LitigationHoldUrl = litigationHoldUrl,
					LitigationHoldMsg = litigationHoldMsg,
					Archiving = archiving,
					EnableArchiving = EnableArchiving,
					ArchiveSizeMb = ArchiveSizeMB,
					ArchiveWarningPct = ArchiveWarningPct,
					EnableForceArchiveDeletion = enableForceArchiveDeletion,
					IsForJournaling = isForJournaling
				};
				ExchangeMailboxPlans.Add(plan);
				SaveChanges();

				return plan.MailboxPlanId;
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@MailboxPlanId", SqlDbType.Int);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddExchangeMailboxPlan",
					outParam,
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@MailboxPlan", mailboxPlan),
					new SqlParameter("@EnableActiveSync", enableActiveSync),
					new SqlParameter("@EnableIMAP", enableIMAP),
					new SqlParameter("@EnableMAPI", enableMAPI),
					new SqlParameter("@EnableOWA", enableOWA),
					new SqlParameter("@EnablePOP", enablePOP),
					new SqlParameter("@EnableAutoReply", enableAutoReply),
					new SqlParameter("@IsDefault", isDefault),
					new SqlParameter("@IssueWarningPct", issueWarningPct),
					new SqlParameter("@KeepDeletedItemsDays", keepDeletedItemsDays),
					new SqlParameter("@MailboxSizeMB", mailboxSizeMB),
					new SqlParameter("@MaxReceiveMessageSizeKB", maxReceiveMessageSizeKB),
					new SqlParameter("@MaxRecipients", maxRecipients),
					new SqlParameter("@MaxSendMessageSizeKB", maxSendMessageSizeKB),
					new SqlParameter("@ProhibitSendPct", prohibitSendPct),
					new SqlParameter("@ProhibitSendReceivePct", prohibitSendReceivePct),
					new SqlParameter("@HideFromAddressBook", hideFromAddressBook),
					new SqlParameter("@MailboxPlanType", mailboxPlanType),
					new SqlParameter("@AllowLitigationHold", enabledLitigationHold),
					new SqlParameter("@RecoverableItemsWarningPct", recoverableItemsWarning),
					new SqlParameter("@RecoverableItemsSpace", recoverableItemsSpace),
					new SqlParameter("@LitigationHoldUrl", litigationHoldUrl),
					new SqlParameter("@LitigationHoldMsg", litigationHoldMsg),
					new SqlParameter("@Archiving", archiving),
					new SqlParameter("@EnableArchiving", EnableArchiving),
					new SqlParameter("@ArchiveSizeMB", ArchiveSizeMB),
					new SqlParameter("@ArchiveWarningPct", ArchiveWarningPct),
					new SqlParameter("@EnableForceArchiveDeletion", enableForceArchiveDeletion),
					new SqlParameter("@IsForJournaling", isForJournaling));

				return Convert.ToInt32(outParam.Value);
			}
		}

		public void UpdateExchangeMailboxPlan(int mailboxPlanID, string mailboxPlan, bool enableActiveSync, bool enableIMAP, bool enableMAPI, bool enableOWA, bool enablePOP, bool enableAutoReply,
			bool isDefault, int issueWarningPct, int keepDeletedItemsDays, int mailboxSizeMB, int maxReceiveMessageSizeKB, int maxRecipients,
			int maxSendMessageSizeKB, int prohibitSendPct, int prohibitSendReceivePct, bool hideFromAddressBook, int mailboxPlanType,
			bool enabledLitigationHold, int recoverableItemsSpace, int recoverableItemsWarning, string litigationHoldUrl, string litigationHoldMsg,
			bool Archiving, bool EnableArchiving, int ArchiveSizeMB, int ArchiveWarningPct, bool enableForceArchiveDeletion, bool isForJournaling)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateExchangeMailboxPlan] 
(
	@MailboxPlanId int,
	@MailboxPlan	nvarchar(300),
	@EnableActiveSync bit,
	@EnableIMAP bit,
	@EnableMAPI bit,
	@EnableOWA bit,
	@EnablePOP bit,
	@EnableAutoReply bit,
	@IsDefault bit,
	@IssueWarningPct int,
	@KeepDeletedItemsDays int,
	@MailboxSizeMB int,
	@MaxReceiveMessageSizeKB int,
	@MaxRecipients int,
	@MaxSendMessageSizeKB int,
	@ProhibitSendPct int,
	@ProhibitSendReceivePct int	,
	@HideFromAddressBook bit,
	@MailboxPlanType int,
	@AllowLitigationHold bit,
	@RecoverableItemsWarningPct int,
	@RecoverableItemsSpace int,
	@LitigationHoldUrl nvarchar(256),
	@LitigationHoldMsg nvarchar(512),
	@Archiving bit,
	@EnableArchiving bit,
	@ArchiveSizeMB int,
	@ArchiveWarningPct int,
	@EnableForceArchiveDeletion bit,
	@IsForJournaling bit
)
AS

UPDATE ExchangeMailboxPlans SET
	MailboxPlan = @MailboxPlan,
	EnableActiveSync = @EnableActiveSync,
	EnableIMAP = @EnableIMAP,
	EnableMAPI = @EnableMAPI,
	EnableOWA = @EnableOWA,
	EnablePOP = @EnablePOP,
	EnableAutoReply = @EnableAutoReply,
	IsDefault = @IsDefault,
	IssueWarningPct= @IssueWarningPct,
	KeepDeletedItemsDays = @KeepDeletedItemsDays,
	MailboxSizeMB= @MailboxSizeMB,
	MaxReceiveMessageSizeKB= @MaxReceiveMessageSizeKB,
	MaxRecipients= @MaxRecipients,
	MaxSendMessageSizeKB= @MaxSendMessageSizeKB,
	ProhibitSendPct= @ProhibitSendPct,
	ProhibitSendReceivePct = @ProhibitSendReceivePct,
	HideFromAddressBook = @HideFromAddressBook,
	MailboxPlanType = @MailboxPlanType,
	AllowLitigationHold = @AllowLitigationHold,
	RecoverableItemsWarningPct = @RecoverableItemsWarningPct,
	RecoverableItemsSpace = @RecoverableItemsSpace, 
	LitigationHoldUrl = @LitigationHoldUrl,
	LitigationHoldMsg = @LitigationHoldMsg,
	Archiving = @Archiving,
	EnableArchiving = @EnableArchiving,
	ArchiveSizeMB = @ArchiveSizeMB,
	ArchiveWarningPct = @ArchiveWarningPct,
	EnableForceArchiveDeletion = @EnableForceArchiveDeletion,
	IsForJournaling = @IsForJournaling
WHERE MailboxPlanId = @MailboxPlanId

RETURN
				*/
				#endregion

				var plan = ExchangeMailboxPlans
					.FirstOrDefault(p => p.MailboxPlanId == mailboxPlanID);
				if (plan != null)
				{
					plan.MailboxPlan = mailboxPlan;
					plan.EnableActiveSync = enableActiveSync;
					plan.EnableImap = enableIMAP;
					plan.EnableMapi = enableMAPI;
					plan.EnableOwa = enableOWA;
					plan.EnablePop = enablePOP;
					plan.EnableAutoReply = enableAutoReply;
					plan.IsDefault = isDefault;
					plan.IssueWarningPct = issueWarningPct;
					plan.KeepDeletedItemsDays = keepDeletedItemsDays;
					plan.MailboxSizeMb = mailboxSizeMB;
					plan.MaxReceiveMessageSizeKb = maxReceiveMessageSizeKB;
					plan.MaxRecipients = maxRecipients;
					plan.MaxSendMessageSizeKb = maxSendMessageSizeKB;
					plan.ProhibitSendPct = prohibitSendPct;
					plan.ProhibitSendReceivePct = prohibitSendReceivePct;
					plan.HideFromAddressBook = hideFromAddressBook;
					plan.MailboxPlanType = mailboxPlanType;
					plan.AllowLitigationHold = enabledLitigationHold;
					plan.RecoverableItemsWarningPct = recoverableItemsWarning;
					plan.RecoverableItemsSpace = recoverableItemsSpace;
					plan.LitigationHoldUrl = litigationHoldUrl;
					plan.LitigationHoldMsg = litigationHoldMsg;
					plan.Archiving = Archiving;
					plan.EnableArchiving = EnableArchiving;
					plan.ArchiveSizeMb = ArchiveSizeMB;
					plan.ArchiveWarningPct = ArchiveWarningPct;
					plan.EnableForceArchiveDeletion = enableForceArchiveDeletion;
					plan.IsForJournaling = isForJournaling;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateExchangeMailboxPlan",
					new SqlParameter("@MailboxPlanID", mailboxPlanID),
					new SqlParameter("@MailboxPlan", mailboxPlan),
					new SqlParameter("@EnableActiveSync", enableActiveSync),
					new SqlParameter("@EnableIMAP", enableIMAP),
					new SqlParameter("@EnableMAPI", enableMAPI),
					new SqlParameter("@EnableOWA", enableOWA),
					new SqlParameter("@EnablePOP", enablePOP),
					new SqlParameter("@EnableAutoReply", enableAutoReply),
					new SqlParameter("@IsDefault", isDefault),
					new SqlParameter("@IssueWarningPct", issueWarningPct),
					new SqlParameter("@KeepDeletedItemsDays", keepDeletedItemsDays),
					new SqlParameter("@MailboxSizeMB", mailboxSizeMB),
					new SqlParameter("@MaxReceiveMessageSizeKB", maxReceiveMessageSizeKB),
					new SqlParameter("@MaxRecipients", maxRecipients),
					new SqlParameter("@MaxSendMessageSizeKB", maxSendMessageSizeKB),
					new SqlParameter("@ProhibitSendPct", prohibitSendPct),
					new SqlParameter("@ProhibitSendReceivePct", prohibitSendReceivePct),
					new SqlParameter("@HideFromAddressBook", hideFromAddressBook),
					new SqlParameter("@MailboxPlanType", mailboxPlanType),
					new SqlParameter("@AllowLitigationHold", enabledLitigationHold),
					new SqlParameter("@RecoverableItemsWarningPct", recoverableItemsWarning),
					new SqlParameter("@RecoverableItemsSpace", recoverableItemsSpace),
					new SqlParameter("@LitigationHoldUrl", litigationHoldUrl),
					new SqlParameter("@LitigationHoldMsg", litigationHoldMsg),
					new SqlParameter("@Archiving", Archiving),
					new SqlParameter("@EnableArchiving", EnableArchiving),
					new SqlParameter("@ArchiveSizeMB", ArchiveSizeMB),
					new SqlParameter("@ArchiveWarningPct", ArchiveWarningPct),
					new SqlParameter("@EnableForceArchiveDeletion", enableForceArchiveDeletion),
					new SqlParameter("@IsForJournaling", isForJournaling));
			}
		}

		public void DeleteExchangeMailboxPlan(int mailboxPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteExchangeMailboxPlan]
(
	@MailboxPlanId int
)
AS

-- delete mailboxplan
DELETE FROM ExchangeMailboxPlans
WHERE MailboxPlanId = @MailboxPlanId

RETURN
				*/
				#endregion

				ExchangeMailboxPlans.Where(p => p.MailboxPlanId == mailboxPlanId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteExchangeMailboxPlan",
					new SqlParameter("@MailboxPlanId", mailboxPlanId));
			}
		}

		public IDataReader GetExchangeMailboxPlan(int mailboxPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeMailboxPlan] 
(
	@MailboxPlanId int
)
AS
SELECT
	MailboxPlanId,
	ItemID,
	MailboxPlan,
	EnableActiveSync,
	EnableIMAP,
	EnableMAPI,
	EnableOWA,
	EnablePOP,
	EnableAutoReply,
	IsDefault,
	IssueWarningPct,
	KeepDeletedItemsDays,
	MailboxSizeMB,
	MaxReceiveMessageSizeKB,
	MaxRecipients,
	MaxSendMessageSizeKB,
	ProhibitSendPct,
	ProhibitSendReceivePct,
	HideFromAddressBook,
	MailboxPlanType,
	AllowLitigationHold,
	RecoverableItemsWarningPct,
	RecoverableItemsSpace,
	LitigationHoldUrl,
	LitigationHoldMsg,
	Archiving,
	EnableArchiving,
	ArchiveSizeMB,
	ArchiveWarningPct,
	EnableForceArchiveDeletion,
	IsForJournaling
FROM
	ExchangeMailboxPlans
WHERE
	MailboxPlanId = @MailboxPlanId
RETURN
				*/
				#endregion

				var plan = ExchangeMailboxPlans
					.Where(p => p.MailboxPlanId == mailboxPlanId)
					.Select(p => new
					{
						p.MailboxPlanId,
						p.ItemId,
						p.MailboxPlan,
						p.EnableActiveSync,
						p.EnableImap,
						p.EnableMapi,
						p.EnableOwa,
						p.EnablePop,
						p.EnableAutoReply,
						p.IsDefault,
						p.IssueWarningPct,
						p.KeepDeletedItemsDays,
						p.MailboxSizeMb,
						p.MaxReceiveMessageSizeKb,
						p.MaxRecipients,
						p.MaxSendMessageSizeKb,
						p.ProhibitSendPct,
						p.ProhibitSendReceivePct,
						p.HideFromAddressBook,
						p.MailboxPlanType,
						p.AllowLitigationHold,
						p.RecoverableItemsWarningPct,
						p.RecoverableItemsSpace,
						p.LitigationHoldUrl,
						p.LitigationHoldMsg,
						p.Archiving,
						p.EnableArchiving,
						p.ArchiveSizeMb,
						p.ArchiveWarningPct,
						p.EnableForceArchiveDeletion,
						p.IsForJournaling
					});
				return EntityDataReader(plan);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeMailboxPlan",
					new SqlParameter("@MailboxPlanId", mailboxPlanId));
			}
		}

		public IDataReader GetExchangeMailboxPlans(int itemId, bool archiving)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeMailboxPlans]
(
	@ItemID int,
	@Archiving bit
)
AS
SELECT
	MailboxPlanId,
	ItemID,
	MailboxPlan,
	EnableActiveSync,
	EnableIMAP,
	EnableMAPI,
	EnableOWA,
	EnablePOP,
	EnableAutoReply,
	IsDefault,
	IssueWarningPct,
	KeepDeletedItemsDays,
	MailboxSizeMB,
	MaxReceiveMessageSizeKB,
	MaxRecipients,
	MaxSendMessageSizeKB,
	ProhibitSendPct,
	ProhibitSendReceivePct,
	HideFromAddressBook,
	MailboxPlanType,
	Archiving,
	EnableArchiving,
	ArchiveSizeMB,
	ArchiveWarningPct,
	EnableForceArchiveDeletion,
	IsForJournaling
FROM
	ExchangeMailboxPlans
WHERE
	ItemID = @ItemID 
AND ((Archiving=@Archiving) OR ((@Archiving=0) AND (Archiving IS NULL)))
ORDER BY MailboxPlan
RETURN
				*/
				#endregion

				var plans = ExchangeMailboxPlans
					.Where(p => p.ItemId == itemId &&
						(p.Archiving == archiving || (archiving == false && p.Archiving == null)))
					.OrderBy(p => p.MailboxPlan)
					.Select(p => new
					{
						p.MailboxPlanId,
						p.ItemId,
						p.MailboxPlan,
						p.EnableActiveSync,
						p.EnableImap,
						p.EnableMapi,
						p.EnableOwa,
						p.EnablePop,
						p.EnableAutoReply,
						p.IsDefault,
						p.IssueWarningPct,
						p.KeepDeletedItemsDays,
						p.MailboxSizeMb,
						p.MaxReceiveMessageSizeKb,
						p.MaxRecipients,
						p.MaxSendMessageSizeKb,
						p.ProhibitSendPct,
						p.ProhibitSendReceivePct,
						p.HideFromAddressBook,
						p.MailboxPlanType,
						p.Archiving,
						p.EnableArchiving,
						p.ArchiveSizeMb,
						p.ArchiveWarningPct,
						p.EnableForceArchiveDeletion,
						p.IsForJournaling
					});
				return EntityDataReader(plans);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeMailboxPlans",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@Archiving", archiving));
			}
		}

		public IDataReader GetExchangeOrganization(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeOrganization]
(
	@ItemID int
)
AS
SELECT
	ItemID,
	ExchangeMailboxPlanID,
	LyncUserPlanID,
	SfBUserPlanID
FROM
	ExchangeOrganizations
WHERE
	ItemID = @ItemID
RETURN
				*/
				#endregion

				var orgs = ExchangeOrganizations
					.Where(o => o.ItemId == itemId)
					.Select(o => new
					{
						o.ItemId, o.ExchangeMailboxPlanId, o.LyncUserPlanId, o.SfBuserPlanId
					});
				return EntityDataReader(orgs);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeOrganization",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public void SetOrganizationDefaultExchangeMailboxPlan(int itemId, int mailboxPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetOrganizationDefaultExchangeMailboxPlan]
(
	@ItemID int,
	@MailboxPlanId int
)
AS

UPDATE ExchangeOrganizations SET
	ExchangeMailboxPlanID = @MailboxPlanId
WHERE
	ItemID = @ItemID

RETURN
				*/
				#endregion

#if NETFRAMEWORK
				foreach (var org in ExchangeOrganizations.Where(o => o.ItemId == itemId))
					org.ExchangeMailboxPlanId = mailboxPlanId;
				SaveChanges();
#else
				ExchangeOrganizations.Where(o => o.ItemId == itemId)
					.ExecuteUpdate(set => set.SetProperty(o => o.ExchangeMailboxPlanId, mailboxPlanId));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"SetOrganizationDefaultExchangeMailboxPlan",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@MailboxPlanId", mailboxPlanId));
			}
		}

		public void SetExchangeAccountMailboxPlan(int accountId, int mailboxPlanId, int archivePlanId, bool EnableArchiving)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetExchangeAccountMailboxplan] 
(
	@AccountID int,
	@MailboxPlanId int,
	@ArchivingMailboxPlanId int,
	@EnableArchiving bit
)
AS

UPDATE ExchangeAccounts SET
	MailboxPlanId = @MailboxPlanId,
	ArchivingMailboxPlanId = @ArchivingMailboxPlanId,
	EnableArchiving = @EnableArchiving
WHERE
	AccountID = @AccountID

RETURN
				*/
				#endregion

#if NETFRAMEWORK
				foreach (var account in ExchangeAccounts.Where(a => a.AccountId == accountId)) {
					account.MailboxPlanId = mailboxPlanId;
					account.ArchivingMailboxPlanId = archivePlanId;
					account.EnableArchiving = EnableArchiving;
				}
				SaveChanges();
#else
				ExchangeAccounts.Where(a => a.AccountId == accountId)
					.ExecuteUpdate(set => set
						.SetProperty(a => a.MailboxPlanId, mailboxPlanId)
						.SetProperty(a => a.ArchivingMailboxPlanId, archivePlanId)
						.SetProperty(a => a.EnableArchiving, EnableArchiving));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"SetExchangeAccountMailboxplan",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@MailboxPlanId", (mailboxPlanId == 0) ? (object)DBNull.Value : (object)mailboxPlanId),
					new SqlParameter("@ArchivingMailboxPlanId", (archivePlanId < 1) ? (object)DBNull.Value : (object)archivePlanId),
					new SqlParameter("@EnableArchiving", EnableArchiving));
			}
		}
#endregion

		#region Exchange Retention Policy Tags
		public int AddExchangeRetentionPolicyTag(int ItemID, string TagName, int TagType, int AgeLimitForRetention, int RetentionAction)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddExchangeRetentionPolicyTag] 
(
	@TagID int OUTPUT,
	@ItemID int,
	@TagName nvarchar(255),
	@TagType int,
	@AgeLimitForRetention int,
	@RetentionAction int
)
AS
BEGIN

INSERT INTO ExchangeRetentionPolicyTags
(
	ItemID,
	TagName,
	TagType,
	AgeLimitForRetention,
	RetentionAction
)
VALUES
(
	@ItemID,
	@TagName,
	@TagType,
	@AgeLimitForRetention,
	@RetentionAction
)

SET @TagID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var tag = new Data.Entities.ExchangeRetentionPolicyTag()
				{
					ItemId = ItemID,
					TagName = TagName,
					TagType = TagType,
					AgeLimitForRetention = AgeLimitForRetention,
					RetentionAction = RetentionAction
				};
				ExchangeRetentionPolicyTags.Add(tag);
				SaveChanges();
				return tag.TagId;
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@TagID", SqlDbType.Int);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddExchangeRetentionPolicyTag",
					outParam,
					new SqlParameter("@ItemID", ItemID),
					new SqlParameter("@TagName", TagName),
					new SqlParameter("@TagType", TagType),
					new SqlParameter("@AgeLimitForRetention", AgeLimitForRetention),
					new SqlParameter("@RetentionAction", RetentionAction));

				return Convert.ToInt32(outParam.Value);
			}
		}

		public void UpdateExchangeRetentionPolicyTag(int TagID, int ItemID, string TagName, int TagType, int AgeLimitForRetention, int RetentionAction)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateExchangeRetentionPolicyTag] 
(
	@TagID int,
	@ItemID int,
	@TagName nvarchar(255),
	@TagType int,
	@AgeLimitForRetention int,
	@RetentionAction int
)
AS

UPDATE ExchangeRetentionPolicyTags SET
	ItemID = @ItemID,
	TagName = @TagName,
	TagType = @TagType,
	AgeLimitForRetention = @AgeLimitForRetention,
	RetentionAction = @RetentionAction
WHERE TagID = @TagID

RETURN
				*/
				#endregion

				var tag = ExchangeRetentionPolicyTags
					.FirstOrDefault(t => t.TagId == TagID);
				if (tag != null)
				{
					tag.ItemId = ItemID;
					tag.TagName = TagName;
					tag.TagType = TagType;
					tag.AgeLimitForRetention = AgeLimitForRetention;
					tag.RetentionAction = RetentionAction;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateExchangeRetentionPolicyTag",
					new SqlParameter("@TagID", TagID),
					new SqlParameter("@ItemID", ItemID),
					new SqlParameter("@TagName", TagName),
					new SqlParameter("@TagType", TagType),
					new SqlParameter("@AgeLimitForRetention", AgeLimitForRetention),
					new SqlParameter("@RetentionAction", RetentionAction));
			}
		}

		public void DeleteExchangeRetentionPolicyTag(int TagID)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteExchangeRetentionPolicyTag]
(
        @TagID int
)
AS
DELETE FROM ExchangeRetentionPolicyTags
WHERE
	TagID = @TagID
RETURN
				*/
				#endregion

				ExchangeRetentionPolicyTags
					.Where(t => t.TagId == TagID)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteExchangeRetentionPolicyTag",
					new SqlParameter("@TagID", TagID));
			}
		}

		public IDataReader GetExchangeRetentionPolicyTag(int TagID)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeRetentionPolicyTag] 
(
	@TagID int
)
AS
SELECT
	TagID,
	ItemID,
	TagName,
	TagType,
	AgeLimitForRetention,
	RetentionAction
FROM
	ExchangeRetentionPolicyTags
WHERE
	TagID = @TagID
RETURN
				*/
				#endregion

				var tag = ExchangeRetentionPolicyTags
					.Where(t => t.TagId == TagID)
					.Select(t => new
					{
						t.TagId,
						t.ItemId,
						t.TagName,
						t.TagType,
						t.AgeLimitForRetention,
						t.RetentionAction
					});
				return EntityDataReader(tag);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeRetentionPolicyTag",
					new SqlParameter("@TagID", TagID));
			}
		}

		public IDataReader GetExchangeRetentionPolicyTags(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeRetentionPolicyTags]
(
	@ItemID int
)
AS
SELECT
	TagID,
	ItemID,
	TagName,
	TagType,
	AgeLimitForRetention,
	RetentionAction
FROM
	ExchangeRetentionPolicyTags
WHERE
	ItemID = @ItemID 
ORDER BY TagName
RETURN				*/
				#endregion

				var tags = ExchangeRetentionPolicyTags
					.Where(t => t.ItemId == itemId)
					.OrderBy(t => t.TagName)
					.Select(t => new
					{
						t.TagId,
						t.ItemId,
						t.TagName,
						t.TagType,
						t.AgeLimitForRetention,
						t.RetentionAction
					});
				return EntityDataReader(tags);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeRetentionPolicyTags",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public int AddExchangeMailboxPlanRetentionPolicyTag(int TagID, int MailboxPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddExchangeMailboxPlanRetentionPolicyTag] 
(
	@PlanTagID int OUTPUT,
	@TagID int,
	@MailboxPlanId int
)
AS
BEGIN

INSERT INTO ExchangeMailboxPlanRetentionPolicyTags
(
	TagID,
	MailboxPlanId
)
VALUES
(
	@TagID,
	@MailboxPlanId
)

SET @PlanTagID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var tag = new Data.Entities.ExchangeMailboxPlanRetentionPolicyTag()
				{
					TagId = TagID,
					MailboxPlanId = MailboxPlanId
				};
				ExchangeMailboxPlanRetentionPolicyTags.Add(tag);
				SaveChanges();
				return tag.PlanTagId;
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@PlanTagID", SqlDbType.Int);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddExchangeMailboxPlanRetentionPolicyTag",
					outParam,
					new SqlParameter("@TagID", TagID),
					new SqlParameter("@MailboxPlanId", MailboxPlanId));

				return Convert.ToInt32(outParam.Value);
			}
		}
		public void DeleteExchangeMailboxPlanRetentionPolicyTag(int PlanTagID)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteExchangeMailboxPlanRetentionPolicyTag]
(
        @PlanTagID int
)
AS
DELETE FROM ExchangeMailboxPlanRetentionPolicyTags
WHERE
	PlanTagID = @PlanTagID
RETURN
				*/
				#endregion

				ExchangeMailboxPlanRetentionPolicyTags.Where(t => t.PlanTagId == PlanTagID)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteExchangeMailboxPlanRetentionPolicyTag",
					new SqlParameter("@PlanTagID", PlanTagID));
			}
		}

		public IDataReader GetExchangeMailboxPlanRetentionPolicyTags(int MailboxPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeMailboxPlanRetentionPolicyTags]
(
	@MailboxPlanId int
)
AS
SELECT
	D.PlanTagID,
	D.TagID,
	D.MailboxPlanId,
	P.MailboxPlan,
	T.TagName
FROM
	ExchangeMailboxPlanRetentionPolicyTags AS D
LEFT OUTER JOIN ExchangeMailboxPlans AS P ON P.MailboxPlanId = D.MailboxPlanId	
LEFT OUTER JOIN ExchangeRetentionPolicyTags AS T ON T.TagID = D.TagID	
WHERE
	D.MailboxPlanId = @MailboxPlanId 
RETURN
			*/
				#endregion

				var tags = ExchangeMailboxPlanRetentionPolicyTags
					.Where(t => t.MailboxPlanId == MailboxPlanId)
					.GroupJoin(ExchangeMailboxPlans, t => t.MailboxPlanId, p => p.MailboxPlanId, (t, p) => new
					{
						t.PlanTagId,
						t.TagId,
						t.MailboxPlanId,
						MailboxPlans = p
					})
					.SelectMany(t => t.MailboxPlans.DefaultIfEmpty(), (t, p) => new
					{
						t.PlanTagId,
						t.TagId,
						t.MailboxPlanId,
						MailboxPlan = p != null ? p.MailboxPlan : null
					})
					.GroupJoin(ExchangeRetentionPolicyTags, d => d.TagId, t => t.TagId, (d, t) => new
					{
						d.PlanTagId,
						d.TagId,
						d.MailboxPlanId,
						d.MailboxPlan,
						Tags = t
					})
					.SelectMany(d => d.Tags.DefaultIfEmpty(), (d, t) => new
					{
						d.PlanTagId,
						d.TagId,
						d.MailboxPlanId,
						d.MailboxPlan,
						TagName = t != null ? t.TagName : null
					});
				return EntityDataReader(tags);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeMailboxPlanRetentionPolicyTags",
					new SqlParameter("@MailboxPlanId", MailboxPlanId));
			}
		}
		#endregion

		#region Exchange Disclaimers
		public int AddExchangeDisclaimer(int itemID, ExchangeDisclaimer disclaimer)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddExchangeDisclaimer] 
(
	@ExchangeDisclaimerId int OUTPUT,
	@ItemID int,
	@DisclaimerName	nvarchar(300),
	@DisclaimerText	nvarchar(MAX)
)
AS

INSERT INTO ExchangeDisclaimers
(
	ItemID,
	DisclaimerName,
	DisclaimerText
)
VALUES
(
	@ItemID,
	@DisclaimerName,
	@DisclaimerText
)

SET @ExchangeDisclaimerId = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var d = new Data.Entities.ExchangeDisclaimer()
				{
					ItemId = itemID,
					DisclaimerName = disclaimer.DisclaimerName,
					DisclaimerText = disclaimer.DisclaimerText
				};
				ExchangeDisclaimers.Add(d);
				SaveChanges();
				return d.ExchangeDisclaimerId;
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@ExchangeDisclaimerId", SqlDbType.Int);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddExchangeDisclaimer",
					outParam,
					new SqlParameter("@ItemID", itemID),
					new SqlParameter("@DisclaimerName", disclaimer.DisclaimerName),
					new SqlParameter("@DisclaimerText", disclaimer.DisclaimerText));

				return Convert.ToInt32(outParam.Value);
			}
		}

		public void UpdateExchangeDisclaimer(int itemID, ExchangeDisclaimer disclaimer)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
 CREATE PROCEDURE [dbo].[UpdateExchangeDisclaimer] 
(
	@ExchangeDisclaimerId int,
	@DisclaimerName nvarchar(300),
	@DisclaimerText nvarchar(MAX)
)
AS

UPDATE ExchangeDisclaimers SET
	DisclaimerName = @DisclaimerName,
	DisclaimerText = @DisclaimerText

WHERE ExchangeDisclaimerId = @ExchangeDisclaimerId

RETURN
				*/
				#endregion

#if NETFRAMEWORK
				var d = ExchangeDisclaimers
					.FirstOrDefault(e => e.ExchangeDisclaimerId == disclaimer.ExchangeDisclaimerId);
				if (d != null) {
					d.DisclaimerName = disclaimer.DisclaimerName;
					d.DisclaimerText = disclaimer.DisclaimerText;
					SaveChanges();
				}
#else
				ExchangeDisclaimers
					.Where(e => e.ExchangeDisclaimerId == disclaimer.ExchangeDisclaimerId)
					.ExecuteUpdate(set => set
						.SetProperty(d => d.DisclaimerName, disclaimer.DisclaimerName)
						.SetProperty(d => d.DisclaimerText, disclaimer.DisclaimerText));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateExchangeDisclaimer",
					new SqlParameter("@ExchangeDisclaimerId", disclaimer.ExchangeDisclaimerId),
					new SqlParameter("@DisclaimerName", disclaimer.DisclaimerName),
					new SqlParameter("@DisclaimerText", disclaimer.DisclaimerText));
			}
		}

		public void DeleteExchangeDisclaimer(int exchangeDisclaimerId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteExchangeDisclaimer]
(
	@ExchangeDisclaimerId int
)
AS

DELETE FROM ExchangeDisclaimers
WHERE ExchangeDisclaimerId = @ExchangeDisclaimerId

RETURN
				*/
				#endregion

				ExchangeDisclaimers.Where(d => d.ExchangeDisclaimerId == exchangeDisclaimerId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteExchangeDisclaimer",
					new SqlParameter("@ExchangeDisclaimerId", exchangeDisclaimerId));
			}
		}

		public IDataReader GetExchangeDisclaimer(int exchangeDisclaimerId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeDisclaimer] 
(
	@ExchangeDisclaimerId int
)
AS
SELECT
	ExchangeDisclaimerId,
	ItemID,
	DisclaimerName,
	DisclaimerText
FROM
	ExchangeDisclaimers
WHERE
	ExchangeDisclaimerId = @ExchangeDisclaimerId
RETURN
				*/
				#endregion

				var disclaimers = ExchangeDisclaimers
					.Where(d => d.ExchangeDisclaimerId == exchangeDisclaimerId)
					.Select(d => new
					{
						d.ExchangeDisclaimerId, d.ItemId, d.DisclaimerName, d.DisclaimerText
					});
				return EntityDataReader(disclaimers);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeDisclaimer",
					new SqlParameter("@ExchangeDisclaimerId", exchangeDisclaimerId));
			}
		}

		public IDataReader GetExchangeDisclaimers(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeDisclaimers]
(
	@ItemID int
)
AS
SELECT
	ExchangeDisclaimerId,
	ItemID,
	DisclaimerName,
	DisclaimerText
FROM
	ExchangeDisclaimers
WHERE
	ItemID = @ItemID 
ORDER BY DisclaimerName
RETURN
				*/
				#endregion

				var disclaimers = ExchangeDisclaimers
					.Where(d => d.ItemId == itemId)
					.Select(d => new
					{
						d.ExchangeDisclaimerId,
						d.ItemId,
						d.DisclaimerName,
						d.DisclaimerText
					})
					.OrderBy(d => d.DisclaimerName);
				return EntityDataReader(disclaimers);

			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeDisclaimers",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public void SetExchangeAccountDisclaimerId(int AccountID, int ExchangeDisclaimerId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
 CREATE PROCEDURE [dbo].[SetExchangeAccountDisclaimerId] 
(
	@AccountID int,
	@ExchangeDisclaimerId int
)
AS
UPDATE ExchangeAccounts SET
	ExchangeDisclaimerId = @ExchangeDisclaimerId
WHERE AccountID = @AccountID

RETURN
				*/
				#endregion

#if NETCOREAPP
				ExchangeAccounts
					.Where(a => a.AccountId == AccountID)
					.ExecuteUpdate(e => e
						.SetProperty(p => p.ExchangeDisclaimerId, ExchangeDisclaimerId));
#else
				var account = ExchangeAccounts
					.FirstOrDefault(a => a.AccountId == AccountID);
				account.ExchangeDisclaimerId = ExchangeDisclaimerId;
				SaveChanges();
#endif
			}
			else
			{
				object id = null;
				if (ExchangeDisclaimerId != -1) id = ExchangeDisclaimerId;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"SetExchangeAccountDisclaimerId",
					new SqlParameter("@AccountID", AccountID),
					new SqlParameter("@ExchangeDisclaimerId", id));
			}
		}

		public int GetExchangeAccountDisclaimerId(int AccountID)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeAccountDisclaimerId] 
(
	@AccountID int
)
AS
SELECT
	ExchangeDisclaimerId
FROM
	ExchangeAccounts
WHERE
	AccountID= @AccountID
RETURN
				*/
				#endregion

				return ExchangeAccounts
					.Where(a => a.AccountId == AccountID)
					.Select(a => a.ExchangeDisclaimerId)
					.FirstOrDefault() ?? -1;
			}
			else
			{
				object objReturn = SqlHelper.ExecuteScalar(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetExchangeAccountDisclaimerId",
					new SqlParameter("@AccountID", AccountID));

				int ret;
				if (!int.TryParse(objReturn.ToString(), out ret)) return -1;
				return ret;
			}
		}
#endregion

		#region Organizations

		public int AddAccessToken(AccessToken token)
		{
			return AddAccessToken(token.AccessTokenGuid, token.AccountId, token.ItemId, token.ExpirationDate, token.TokenType);
		}

		public int AddAccessToken(Guid accessToken, int accountId, int itemId, DateTime expirationDate, AccessTokenTypes type)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddAccessToken]
(
	@TokenID INT OUTPUT,
	@AccessToken UNIQUEIDENTIFIER,
	@ExpirationDate DATETIME,
	@AccountID INT,
	@ItemId INT,
	@TokenType INT
)
AS
INSERT INTO AccessTokens
(
	AccessTokenGuid,
	ExpirationDate,
	AccountID  ,
	ItemId,
	TokenType
)
VALUES
(
	@AccessToken  ,
	@ExpirationDate ,
	@AccountID,
	@ItemId,
	@TokenType
)

SET @TokenID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var token = new Data.Entities.AccessToken()
				{
					AccessTokenGuid = accessToken,
					ExpirationDate = expirationDate,
					AccountId = accountId,
					ItemId = itemId,
					TokenType = type
				};
				AccessTokens.Add(token);
				SaveChanges();
				return token.Id;
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@TokenID", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddAccessToken",
					prmId,
					new SqlParameter("@AccessToken", accessToken),
					new SqlParameter("@ExpirationDate", expirationDate),
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@ItemId", itemId),
					new SqlParameter("@TokenType", (int)type));

				// read identity
				return Convert.ToInt32(prmId.Value);
			}
		}

		public void SetAccessTokenResponseMessage(Guid accessToken, string response)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetAccessTokenSmsResponse]
(
	@AccessToken UNIQUEIDENTIFIER,
	@SmsResponse varchar(100)
)
AS
UPDATE [dbo].[AccessTokens] SET [SmsResponse] = @SmsResponse
WHERE [AccessTokenGuid] = @AccessToken
RETURN
				*/
				#endregion

#if NETFRAMEWORK
				var token = AccessTokens
					.FirstOrDefault(t => t.AccessTokenGuid == accessToken);
				if (token != null) {
					token.SmsResponse = response;
					SaveChanges();
				}
#else
				AccessTokens
					.Where(t => t.AccessTokenGuid == accessToken)
					.ExecuteUpdate(set => set
						.SetProperty(t => t.SmsResponse, response));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"SetAccessTokenSmsResponse",
					new SqlParameter("@AccessToken", accessToken),
					new SqlParameter("@SmsResponse", response));
			}
		}

		public void DeleteExpiredAccessTokens()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteExpiredAccessTokenTokens]
AS
DELETE FROM AccessTokens
WHERE ExpirationDate < getdate()
				*/
				#endregion

				var now = DateTime.Now;
				AccessTokens.Where(t => t.ExpirationDate < now).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteExpiredAccessTokenTokens");
			}
		}

		public IDataReader GetAccessTokenByAccessToken(Guid accessToken, AccessTokenTypes type)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetAccessTokenByAccessToken]
(
	@AccessToken UNIQUEIDENTIFIER,
	@TokenType INT
)
AS
SELECT 
	ID ,
	AccessTokenGuid,
	ExpirationDate,
	AccountID,
	ItemId,
	TokenType,
	SmsResponse
FROM AccessTokens 
Where AccessTokenGuid = @AccessToken AND ExpirationDate > getdate() AND TokenType = @TokenType
				*/
				#endregion

				var now = DateTime.Now;
				var token = AccessTokens
					.Where(t => t.AccessTokenGuid == accessToken && t.ExpirationDate > now && t.TokenType == type)
					.Select(t => new
					{
						t.Id,
						t.AccessTokenGuid,
						t.ExpirationDate,
						t.AccountId,
						t.ItemId,
						t.TokenType,
						t.SmsResponse
					});
				return EntityDataReader(token);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetAccessTokenByAccessToken",
					new SqlParameter("@AccessToken", accessToken),
					new SqlParameter("@TokenType", type));
			}
		}

		public void DeleteAccessToken(Guid accessToken, AccessTokenTypes type)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteAccessToken]
(
	@AccessToken UNIQUEIDENTIFIER,
	@TokenType INT
)
AS
DELETE FROM AccessTokens
WHERE AccessTokenGuid = @AccessToken AND TokenType = @TokenType
				*/
				#endregion

				AccessTokens
					.Where(a => a.AccessTokenGuid == accessToken && a.TokenType == type)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteAccessToken",
					new SqlParameter("@AccessToken", accessToken),
					new SqlParameter("@TokenType", type));
			}
		}

		public void UpdateOrganizationSettings(int itemId, string settingsName, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateExchangeOrganizationSettings]
(
	@ItemId INT ,
	@SettingsName nvarchar(100) ,
	@Xml nvarchar(max)
)
AS
IF NOT EXISTS (SELECT * FROM [dbo].[ExchangeOrganizationSettings] WHERE [ItemId] = @ItemId AND [SettingsName]= @SettingsName )
BEGIN
INSERT [dbo].[ExchangeOrganizationSettings] ([ItemId], [SettingsName], [Xml]) VALUES (@ItemId, @SettingsName, @Xml)
END
ELSE
UPDATE [dbo].[ExchangeOrganizationSettings] SET [Xml] = @Xml WHERE [ItemId] = @ItemId AND [SettingsName]= @SettingsName
				*/
				#endregion

				var setting = ExchangeOrganizationSettings
					.FirstOrDefault(s => s.ItemId == itemId && s.SettingsName == settingsName);
				if (setting != null)
				{
					setting.Xml = xml;
				} else
				{
					setting = new Data.Entities.ExchangeOrganizationSetting()
					{
						ItemId = itemId,
						SettingsName = settingsName,
						Xml = xml
					};
					ExchangeOrganizationSettings.Add(setting);
				}
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateExchangeOrganizationSettings",
					new SqlParameter("@ItemId", itemId),
					new SqlParameter("@SettingsName", settingsName),
					new SqlParameter("@Xml", xml));
			}
		}

		public IDataReader GetOrganizationSettings(int itemId, string settingsName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetExchangeOrganizationSettings]
(
	@ItemId INT ,
	@SettingsName nvarchar(100)
)
AS
SELECT 
	ItemId,
	SettingsName,
	Xml

FROM ExchangeOrganizationSettings 
Where ItemId = @ItemId AND SettingsName = @SettingsName
				*/
				#endregion

				var settings = ExchangeOrganizationSettings
					.Where(s => s.ItemId == itemId && s.SettingsName == settingsName)
					.Select(s => new
					{
						s.ItemId,
						s.SettingsName,
						s.Xml
					});
				return EntityDataReader(settings);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetExchangeOrganizationSettings",
					new SqlParameter("@ItemId", itemId),
					new SqlParameter("@SettingsName", settingsName));
			}
		}

		public int AddOrganizationDeletedUser(int accountId, int originAT, string storagePath, string folderName, string fileName, DateTime expirationDate)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddOrganizationDeletedUser] 
(
	@ID int OUTPUT,
	@AccountID int,
	@OriginAT int,
	@StoragePath nvarchar(255),
	@FolderName nvarchar(128),
	@FileName nvarchar(128),
	@ExpirationDate datetime
)
AS

INSERT INTO ExchangeDeletedAccounts
(
	AccountID,
	OriginAT,
	StoragePath,
	FolderName,
	FileName,
	ExpirationDate
)
VALUES
(
	@AccountID,
	@OriginAT,
	@StoragePath,
	@FolderName,
	@FileName,
	@ExpirationDate
)

SET @ID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var account = new Data.Entities.ExchangeDeletedAccount()
				{
					AccountId = accountId,
					OriginAt = originAT,
					StoragePath = storagePath,
					FolderName = folderName,
					FileName = fileName,
					ExpirationDate = expirationDate
				};
				ExchangeDeletedAccounts.Add(account);
				SaveChanges();
				return account.Id;
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@ID", SqlDbType.Int);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddOrganizationDeletedUser",
					outParam,
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@OriginAT", originAT),
					new SqlParameter("@StoragePath", storagePath),
					new SqlParameter("@FolderName", folderName),
					new SqlParameter("@FileName", fileName),
					new SqlParameter("@ExpirationDate", expirationDate));

				return Convert.ToInt32(outParam.Value);
			}
		}

		public void DeleteOrganizationDeletedUser(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteOrganizationDeletedUser]
(
	@ID int
)
AS
DELETE FROM	ExchangeDeletedAccounts WHERE AccountID = @ID
RETURN
				*/
				#endregion

				ExchangeDeletedAccounts
					.Where(a => a.AccountId == id)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"DeleteOrganizationDeletedUser",
					new SqlParameter("@ID", id));
			}
		}

		public IDataReader GetOrganizationDeletedUser(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOrganizationDeletedUser]
(
	@AccountID int
)
AS
SELECT
	EDA.AccountID,
	EDA.OriginAT,
	EDA.StoragePath,
	EDA.FolderName,
	EDA.FileName,
	EDA.ExpirationDate
FROM
	ExchangeDeletedAccounts AS EDA
WHERE
	EDA.AccountID = @AccountID
RETURN
				*/
				#endregion

				var account = ExchangeDeletedAccounts
					.Where(a => a.AccountId == accountId)
					.Select(a => new
					{
						a.AccountId,
						a.OriginAt,
						a.StoragePath,
						a.FolderName,
						a.FileName,
						a.ExpirationDate
					});
				return EntityDataReader(account);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetOrganizationDeletedUser",
					new SqlParameter("@AccountID", accountId));
			}
		}

		public IDataReader GetAdditionalGroups(int userId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetAdditionalGroups]
(
	@UserID INT
)
AS

SELECT
	AG.ID,
	AG.UserID,
	AG.GroupName
FROM AdditionalGroups AS AG
WHERE AG.UserID = @UserID
				*/
				#endregion

				var groups = AdditionalGroups
					.Where(g => g.UserId == userId);
				return EntityDataReader(groups);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetAdditionalGroups",
					new SqlParameter("@UserID", userId));
			}
		}

		public int AddAdditionalGroup(int userId, string groupName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddAdditionalGroup]
(
	@GroupID INT OUTPUT,
	@UserID INT,
	@GroupName NVARCHAR(255)
)
AS

INSERT INTO AdditionalGroups
(
	UserID,
	GroupName
)
VALUES
(
	@UserID,
	@GroupName
)

SET @GroupID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var group = new Data.Entities.AdditionalGroup() {
					UserId = userId,
					GroupName = groupName
				};
				AdditionalGroups.Add(group);
				SaveChanges();
				return group.Id;
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@GroupID", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddAdditionalGroup",
					prmId,
					new SqlParameter("@UserID", userId),
					new SqlParameter("@GroupName", groupName));

				// read identity
				return Convert.ToInt32(prmId.Value);
			}
		}

		public void DeleteAdditionalGroup(int groupId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteAdditionalGroup]
(
	@GroupID INT
)
AS

DELETE FROM AdditionalGroups
WHERE ID = @GroupID
				*/
				#endregion

				AdditionalGroups
					.Where(a => a.Id == groupId)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"DeleteAdditionalGroup",
					new SqlParameter("@GroupID", groupId));
			}
		}

		public void UpdateAdditionalGroup(int groupId, string groupName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateAdditionalGroup]
(
	@GroupID INT,
	@GroupName NVARCHAR(255)
)
AS

UPDATE AdditionalGroups SET
	GroupName = @GroupName
WHERE ID = @GroupID
				*/
				#endregion

#if NETCOREAPP
				AdditionalGroups
					.Where(a => a.Id == groupId)
					.ExecuteUpdate(e => e
						.SetProperty(p => p.GroupName, groupName));
#else
				var group = AdditionalGroups.FirstOrDefault(a => a.Id == groupId);
				if (group != null) {
					group.GroupName = groupName;
					SaveChanges();
				}
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateAdditionalGroup",
					new SqlParameter("@GroupID", groupId),
					new SqlParameter("@GroupName", groupName));
			}
		}
		public void DeleteOrganizationUser(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteOrganizationUsers]
	@ItemID int
AS
BEGIN
	SET NOCOUNT ON;

    DELETE FROM ExchangeAccounts WHERE ItemID = @ItemID
END
				*/
				#endregion

				ExchangeAccounts
					.Where(a => a.ItemId == itemId)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure, "DeleteOrganizationUsers",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public int GetItemIdByOrganizationId(string id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetItemIdByOrganizationId]
	@OrganizationId nvarchar(128)
AS
BEGIN
	SET NOCOUNT ON;

	SELECT
		ItemID
	FROM
		dbo.ExchangeOrganizations
	WHERE
		OrganizationId = @OrganizationId
END				*/
				#endregion

				return ExchangeOrganizations
					.Where(a => a.OrganizationId == id)
					.Select(a => a.ItemId)
					.FirstOrDefault();
			}
			else
			{
				object obj = SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "GetItemIdByOrganizationId",
					new SqlParameter("@OrganizationId", id));

				return (obj == null || DBNull.Value == obj) ? 0 : (int)obj;
			}
		}

		public IDataReader GetOrganizationStatistics(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOrganizationStatistics]
(
	@ItemID int
)
AS
SELECT
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE (AccountType = 7 OR AccountType = 1 OR AccountType = 6 OR AccountType = 5)  AND ItemID = @ItemID) AS CreatedUsers,
	(SELECT COUNT(*) FROM ExchangeOrganizationDomains WHERE ItemID = @ItemID) AS CreatedDomains,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE (AccountType = 8 OR AccountType = 9)  AND ItemID = @ItemID) AS CreatedGroups,
	(SELECT COUNT(*) FROM ExchangeAccounts WHERE AccountType = 11  AND ItemID = @ItemID) AS DeletedUsers
RETURN
				*/
				#endregion

				var accounts = ExchangeAccounts.Where(a => a.ItemId == itemId);
				var stats = new
				{
					CreatedUsers = accounts
						.Where(a => a.AccountType == ExchangeAccountType.User ||
							a.AccountType == ExchangeAccountType.Mailbox ||
							a.AccountType == ExchangeAccountType.Equipment ||
							a.AccountType == ExchangeAccountType.Room)
						.Count(),
					CreatedDomains = ExchangeOrganizationDomains
						.Where(d => d.ItemId == itemId)
						.Count(),
					CreatedGroups = accounts
						.Where(a => a.AccountType == ExchangeAccountType.SecurityGroup ||
							a.AccountType == ExchangeAccountType.DefaultSecurityGroup)
						.Count(),
					DeletedUsers = accounts
						.Where(a => a.AccountType == ExchangeAccountType.DeletedUser)
						.Count()
				};
				return EntityDataReader(new[] { stats });
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetOrganizationStatistics",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public IDataReader GetOrganizationGroupsByDisplayName(int itemId, string displayName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOrganizationGroupsByDisplayName]
(
	@ItemID int,
	@DisplayName NVARCHAR(255)
)
AS
SELECT
	AccountID,
	ItemID,
	AccountType,
	AccountName,
	DisplayName,
	UserPrincipalName
FROM
	ExchangeAccounts
WHERE
	ItemID = @ItemID AND DisplayName = @DisplayName AND (AccountType IN (8, 9))
RETURN
				*/
				#endregion

				var accounts = ExchangeAccounts
					.Where(a => a.ItemId == itemId && a.DisplayName == displayName &&
						(a.AccountType == ExchangeAccountType.SecurityGroup ||
						a.AccountType == ExchangeAccountType.DefaultSecurityGroup))
					.Select(a => new
					{
						a.AccountId,
						a.ItemId,
						a.AccountType,
						a.AccountName,
						a.DisplayName,
						a.UserPrincipalName
					});
				return EntityDataReader(accounts);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetOrganizationGroupsByDisplayName",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@DisplayName", displayName));
			}
		}

		public IDataReader SearchOrganizationAccounts(int actorId, int itemId,
			string filterColumn, string filterValue, string sortColumn, bool includeMailboxes)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SearchOrganizationAccounts]
(
	@ActorID int,
	@ItemID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@IncludeMailboxes bit
)
AS
DECLARE @PackageID int
SELECT @PackageID = PackageID FROM ServiceItems
WHERE ItemID = @ItemID

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
(EA.AccountType = 7 OR (EA.AccountType = 1 AND @IncludeMailboxes = 1)  )
AND EA.ItemID = @ItemID
'

IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
AND @FilterValue <> '' AND @FilterValue IS NOT NULL
SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'EA.DisplayName ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT
 EA.AccountID,
 EA.ItemID,
 EA.AccountType,
 EA.AccountName,
 EA.DisplayName,
 EA.PrimaryEmailAddress,
 EA.SubscriberNumber,
 EA.UserPrincipalName,
 EA.LevelID,
 EA.IsVIP,
 (CASE WHEN LU.AccountID IS NULL THEN ''false'' ELSE ''true'' END) as IsLyncUser,
 (CASE WHEN SfB.AccountID IS NULL THEN ''false'' ELSE ''true'' END) as IsSfBUser
FROM ExchangeAccounts AS EA
LEFT JOIN LyncUsers AS LU
ON LU.AccountID = EA.AccountID
LEFT JOIN SfBUsers AS SfB  
ON SfB.AccountID = EA.AccountID
WHERE ' + @condition + '
ORDER BY ' + @sortColumn

print @sql

exec sp_executesql @sql, N'@ItemID int, @IncludeMailboxes bit', 
@ItemID, @IncludeMailboxes

RETURN 
				*/
				#endregion

				var packageId = ServiceItems
					.Where(i => i.ItemId == itemId)
					.Select(i => i.PackageId)
					.FirstOrDefault();
				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var accounts = ExchangeAccounts
					.Where(a => a.ItemId == itemId &&
						(a.AccountType == ExchangeAccountType.User ||
						a.AccountType == ExchangeAccountType.Mailbox && includeMailboxes))
					.GroupJoin(LyncUsers, a => a.AccountId, lu => lu.AccountId, (a, lus) => new { A = a, LyncUsers = lus })
					.SelectMany(a => a.LyncUsers.DefaultIfEmpty(), (a, lu) => new { A = a.A, IsLyncUser = lu != null })
					.GroupJoin(SfBUsers, a => a.A.AccountId, su => su.AccountId, (a, sus) => new
					{
						a.A,
						a.IsLyncUser,
						SfBUsers = sus
					})
					.SelectMany(a => a.SfBUsers.DefaultIfEmpty(), (a, su) => new
					{
						a.A.AccountId,
						a.A.ItemId,
						a.A.AccountType,
						a.A.AccountName,
						a.A.DisplayName,
						a.A.PrimaryEmailAddress,
						a.A.SubscriberNumber,
						a.A.UserPrincipalName,
						a.A.LevelId,
						a.A.IsVip,
						a.IsLyncUser,
						IsSfBUser = su != null
					});

				if (!string.IsNullOrEmpty(filterValue) && !string.IsNullOrEmpty(filterColumn))
				{
					accounts = accounts.Where(DynamicFunctions.ColumnLike(accounts, filterColumn, filterValue));
				}

				if (!string.IsNullOrEmpty(sortColumn))
				{
					accounts = accounts.OrderBy(sortColumn);
				} else
				{
					accounts = accounts.OrderBy(a => a.DisplayName);
				}

				return EntityDataReader(accounts);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"SearchOrganizationAccounts",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@IncludeMailboxes", includeMailboxes));
			}
		}

		class OrganizationObject
		{
			public string ObjectName { get; set; }
			public int ObjectId { get; set; }
			public ExchangeAccountType	ObjectType { get; set; }
			public string DisplayName { get; set; }
			public int OwnerId { get; set; }
		}

		public DataSet GetOrganizationObjectsByDomain(int itemId, string domainName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOrganizationObjectsByDomain]
(
        @ItemID int,
        @DomainName nvarchar(100)
)
AS
SELECT
	'ExchangeAccounts' as ObjectName,
    AccountID as ObjectID,
	AccountType as ObjectType,
    DisplayName as DisplayName,
	0 as OwnerID
FROM
        ExchangeAccounts
WHERE
	UserPrincipalName LIKE '%@'+ @DomainName AND AccountType!=2
UNION
SELECT
	'ExchangeAccountEmailAddresses' as ObjectName,
	eam.AddressID as ObjectID,
	ea.AccountType as ObjectType,
	eam.EmailAddress as DisplayName,
	eam.AccountID as OwnerID
FROM
	ExchangeAccountEmailAddresses as eam
INNER JOIN 
	ExchangeAccounts ea
ON 
	ea.AccountID = eam.AccountID
WHERE
	(ea.PrimaryEmailAddress != eam.EmailAddress)
	AND (ea.UserPrincipalName != eam.EmailAddress)
	AND (eam.EmailAddress LIKE '%@'+ @DomainName)
UNION
SELECT 
	'SfBUsers' as ObjectName,
	ea.AccountID as ObjectID,
	ea.AccountType as ObjectType,
	ea.DisplayName as DisplayName,
	0 as OwnerID
FROM 
	ExchangeAccounts ea 
INNER JOIN 
	SfBUsers ou
ON 
	ea.AccountID = ou.AccountID
WHERE 
	ou.SipAddress LIKE '%@'+ @DomainName
UNION
SELECT 
	'LyncUsers' as ObjectName,
	ea.AccountID as ObjectID,
	ea.AccountType as ObjectType,
	ea.DisplayName as DisplayName,
	0 as OwnerID
FROM 
	ExchangeAccounts ea 
INNER JOIN 
	LyncUsers ou
ON 
	ea.AccountID = ou.AccountID
WHERE 
	ou.SipAddress LIKE '%@'+ @DomainName
ORDER BY 
	DisplayName
RETURN
				*/
				#endregion

				var objects = ExchangeAccounts
					.Where(a => a.AccountType != ExchangeAccountType.Contact &&
#if NETFRAMEWORK
						DbFunctions.Like(a.UserPrincipalName, "%@" + domainName))
#else
						EF.Functions.Like(a.UserPrincipalName, "%@" + domainName))
#endif
					.Select(a => new OrganizationObject()
					{
						ObjectName = "ExchangeAccounts",
						ObjectId = a.AccountId,
						ObjectType = a.AccountType,
						DisplayName = a.DisplayName,
						OwnerId = 0
					})
					.Union(ExchangeAccountEmailAddresses
						.Where(a =>
#if NETFRAMEWORK
							DbFunctions.Like(a.EmailAddress, "%@" + domainName) &&
#else
							EF.Functions.Like(a.EmailAddress, "%@" + domainName) &&
#endif
							a.EmailAddress != a.Account.PrimaryEmailAddress &&
							a.EmailAddress != a.Account.UserPrincipalName)
						.Select(a => new OrganizationObject()
						{
							ObjectName = "ExchangeAccountEmailAddresses",
							ObjectId = a.AddressId,
							ObjectType = a.Account.AccountType,
							DisplayName = a.EmailAddress,
							OwnerId = a.AccountId
						}))
					.Union(ExchangeAccounts
						.Join(SfBUsers, a => a.AccountId, u => u.AccountId, (a, u) => new { Account = a, User = u })
						.Where(a =>
#if NETFRAMEWORK
							DbFunctions.Like(a.User.SipAddress, "%@" + domainName))
#else
							EF.Functions.Like(a.User.SipAddress, "%@" + domainName))
#endif
						.Select(a => new OrganizationObject()
						{
							ObjectName = "SfBUsers",
							ObjectId = a.Account.AccountId,
							ObjectType = a.Account.AccountType,
							DisplayName = a.Account.DisplayName,
							OwnerId = 0
						}))
					.Union(ExchangeAccounts
						.Join(LyncUsers, a => a.AccountId, u => u.AccountId, (a, u) => new { Account = a, User = u })
						.Where(a =>
#if NETFRAMEWORK
							DbFunctions.Like(a.User.SipAddress, "%@" + domainName))
#else
							EF.Functions.Like(a.User.SipAddress, "%@" + domainName))
#endif
						.Select(a => new OrganizationObject()
						{
							ObjectName = "LyncUsers",
							ObjectId = a.Account.AccountId,
							ObjectType = a.Account.AccountType,
							DisplayName = a.Account.DisplayName,
							OwnerId = 0
						}))
					.OrderBy(o => o.DisplayName);
				return EntityDataSet(objects);
			}
			else
			{
				return SqlHelper.ExecuteDataset(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetOrganizationObjectsByDomain",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@DomainName", domainName));
			}
		}
#endregion

		#region CRM

		public int GetCRMUsersCount(int itemId, string name, string email, int CALType)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetCRMUsersCount] 
(
	@ItemID int,
	@Name nvarchar(400),
	@Email nvarchar(400),
	@CALType int
)
AS
BEGIN

IF (@Name IS NULL)
BEGIN
	SET @Name = '%'
END

IF (@Email IS NULL)
BEGIN
	SET @Email = '%'
END

SELECT 
	COUNT(ea.AccountID)		
FROM 
	ExchangeAccounts ea 
INNER JOIN 
	CRMUsers cu 
ON 
	ea.AccountID = cu.AccountID
WHERE 
	ea.ItemID = @ItemID AND ea.DisplayName LIKE @Name AND ea.PrimaryEmailAddress LIKE @Email
	AND ((cu.CALType = @CALType) OR (@CALType = -1))
END
				*/
				#endregion

				if (string.IsNullOrEmpty(name)) name = "%";
				if (string.IsNullOrEmpty(email)) email = "%";

				return ExchangeAccounts
					.Where(a => a.ItemId == itemId &&
#if NETFRAMEWORK
						DbFunctions.Like(a.DisplayName, name) && DbFunctions.Like(a.PrimaryEmailAddress, email))
#else
						EF.Functions.Like(a.DisplayName, name) && EF.Functions.Like(a.PrimaryEmailAddress, email))
#endif
					.Join(CrmUsers, a => a.AccountId, u => u.AccountId, (a, u) => u.CalType)
					.Count(cal => cal == CALType || CALType == -1);
			}
			else
			{
				SqlParameter[] sqlParams = new SqlParameter[]
				{
					new SqlParameter("@ItemID", itemId),
					GetFilterSqlParam("@Name", name),
					GetFilterSqlParam("@Email", email),
					new SqlParameter("@CALType", CALType)
				};

				return (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "GetCRMUsersCount", sqlParams);
			}
		}

		private SqlParameter GetFilterSqlParam(string paramName, string value)
		{
			if (string.IsNullOrEmpty(value))
				return new SqlParameter(paramName, DBNull.Value);

			return new SqlParameter(paramName, value);
		}

		public IDataReader GetCrmUsers(int itemId, string sortColumn, string sortDirection, string name, string email, int startRow, int count)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetCRMUsers]
(
	@ItemID int,
	@SortColumn nvarchar(40),
	@SortDirection nvarchar(20),
	@Name nvarchar(400),
	@Email nvarchar(400),
	@StartRow int,
	@Count int
)
AS

IF (@Name IS NULL)
BEGIN
	SET @Name = '%'
END

IF (@Email IS NULL)
BEGIN
	SET @Email = '%'
END

CREATE TABLE #TempCRMUsers
(
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[AccountID] [int],
	[ItemID] [int] NOT NULL,
	[AccountName] [nvarchar](300) NOT NULL,
	[DisplayName] [nvarchar](300) NOT NULL,
	[PrimaryEmailAddress] [nvarchar](300) NULL,
	[SamAccountName] [nvarchar](100) NULL
)

IF (@SortColumn = 'DisplayName')
BEGIN
	INSERT INTO
# TempCRMUsers
	SELECT
		ea.AccountID,
		ea.ItemID,
		ea.AccountName,
		ea.DisplayName,
		ea.PrimaryEmailAddress,
		ea.SamAccountName
	FROM
		ExchangeAccounts ea
	INNER JOIN
		CRMUsers cu
	ON
		ea.AccountID = cu.AccountID
	WHERE
		ea.ItemID = @ItemID AND ea.DisplayName LIKE @Name AND ea.PrimaryEmailAddress LIKE @Email
	ORDER BY
		ea.DisplayName
END
ELSE
BEGIN
	INSERT INTO
# TempCRMUsers
	SELECT
		ea.AccountID,
		ea.ItemID,
		ea.AccountName,
		ea.DisplayName,
		ea.PrimaryEmailAddress,
		ea.SamAccountName
	FROM
		ExchangeAccounts ea
	INNER JOIN
		CRMUsers cu
	ON
		ea.AccountID = cu.AccountID
	WHERE
		ea.ItemID = @ItemID AND ea.DisplayName LIKE @Name AND ea.PrimaryEmailAddress LIKE @Email
	ORDER BY
		ea.PrimaryEmailAddress
END

DECLARE @RetCount int
SELECT @RetCount = COUNT(ID) FROM #TempCRMUsers

IF (@SortDirection = 'ASC')
BEGIN
	SELECT * FROM #TempCRMUsers
	WHERE ID > @StartRow AND ID <= (@StartRow + @Count)
END
ELSE
BEGIN
	IF (@SortColumn = 'DisplayName')
	BEGIN
		SELECT * FROM #TempCRMUsers
			WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY DisplayName DESC
	END
	ELSE
	BEGIN
		SELECT * FROM #TempCRMUsers
			WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY PrimaryEmailAddress DESC
	END

END

DROP TABLE #TempCRMUsers
				*/
				#endregion

				if (string.IsNullOrEmpty(name)) name = "%";
				if (string.IsNullOrEmpty(email)) email = "%";

				var accounts = ExchangeAccounts
					.Where(a => a.ItemId == itemId &&
#if NETFRAMEWORK
						DbFunctions.Like(a.DisplayName, name) && DbFunctions.Like(a.PrimaryEmailAddress, email))
#else
						EF.Functions.Like(a.DisplayName, name) && EF.Functions.Like(a.PrimaryEmailAddress, email))
#endif
					.Join(CrmUsers, a => a.AccountId, u => u.AccountId, (a, u) => a)
					.Select(a => new
					{
						a.AccountId,
						a.ItemId,
						a.AccountName,
						a.DisplayName,
						a.PrimaryEmailAddress,
						a.SamAccountName
					});

				if (sortDirection == "ASC") {
					if (sortColumn == "DisplayName") accounts = accounts.OrderBy(a => a.DisplayName);
					else accounts = accounts.OrderBy(a => a.PrimaryEmailAddress);
				} else
				{
					if (sortColumn == "DisplayName") accounts = accounts.OrderByDescending(a => a.DisplayName);
					else accounts = accounts.OrderByDescending(a => a.PrimaryEmailAddress);
				}
				accounts = accounts.Skip(startRow).Take(count);
				return EntityDataReader(accounts);
			}
			else
			{
				SqlParameter[] sqlParams = new SqlParameter[] {
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@SortColumn", sortColumn),
					new SqlParameter("@SortDirection", sortDirection),
					GetFilterSqlParam("@Name", name),
					GetFilterSqlParam("@Email", email),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("Count", count)
				};

				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetCRMUsers", sqlParams);
			}
		}

		public IDataReader GetCRMOrganizationUsers(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetCRMOrganizationUsers]
	@ItemID int
AS
BEGIN
	SELECT
		ea.AccountID,
		ea.ItemID,
		ea.AccountName,
		ea.DisplayName,
		ea.PrimaryEmailAddress,
		ea.SamAccountName
	FROM
		ExchangeAccounts ea
	INNER JOIN
		CRMUsers cu
	ON
		ea.AccountID = cu.AccountID
	WHERE
		ea.ItemID = @ItemID
END
				*/
				#endregion

				var accounts = ExchangeAccounts
					.Where(a => a.ItemId == itemId)
					.Join(CrmUsers, a => a.AccountId, u => u.AccountId, (a, u) => a)
					.Select(a => new
					{
						a.AccountId,
						a.ItemId,
						a.AccountName,
						a.DisplayName,
						a.PrimaryEmailAddress,
						a.SamAccountName
					});
				return EntityDataReader(accounts);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure, "GetCRMOrganizationUsers",
					new SqlParameter[] { new SqlParameter("@ItemID", itemId) });
			}
		}

		public void CreateCRMUser(int itemId, Guid crmId, Guid businessUnitId, int CALType)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[InsertCRMUser] 
(
	@ItemID int,
	@CrmUserID uniqueidentifier,
	@BusinessUnitID uniqueidentifier,
	@CALType int
)
AS
BEGIN
	SET NOCOUNT ON;

INSERT INTO
	CRMUsers
(
	AccountID,
	CRMUserGuid,
	BusinessUnitID,
	CALType
)
VALUES 
(
	@ItemID, 
	@CrmUserID,
	@BusinessUnitID,
	@CALType
)

END
				*/
				#endregion

				var now = DateTime.Now;
				var user = new Data.Entities.CrmUser()
				{
					AccountId = itemId,
					CrmUserGuid = crmId,
					BusinessUnitId = businessUnitId,
					CalType = CALType,
					ChangedDate = now,
					CreatedDate = now
				};
				CrmUsers.Add(user);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure, "InsertCRMUser",
					new SqlParameter[] {
						new SqlParameter("@ItemID", itemId),
						new SqlParameter("@CrmUserID", crmId),
						new SqlParameter("@BusinessUnitId", businessUnitId),
						new SqlParameter("@CALType", CALType)
					});

			}
		}

		public void UpdateCRMUser(int itemId, int CALType)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateCRMUser]
(
	@ItemID int,
	@CALType int
)
AS
BEGIN
	SET NOCOUNT ON;

UPDATE [dbo].[CRMUsers]
   SET 
      CALType = @CALType
 WHERE AccountID = @ItemID

END
				*/
				#endregion

#if NETFRAMEWORK
				var user = CrmUsers.FirstOrDefault(u => u.AccountId == itemId);
				user.CalType = CALType;
				SaveChanges();
#else
				CrmUsers.Where(u => u.AccountId == itemId)
					.ExecuteUpdate(set => set
						.SetProperty(u => u.CalType, CALType));
#endif
			}
			else
			{
				SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure, "UpdateCRMUser",
					new SqlParameter[] {
						new SqlParameter("@ItemID", itemId),
						new SqlParameter("@CALType", CALType)
					});
			}
		}

		public IDataReader GetCrmUser(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetCRMUser]
	@AccountID int
AS
BEGIN
	SET NOCOUNT ON;
SELECT
	CRMUserGUID as CRMUserID,
	BusinessUnitID
FROM
	CRMUsers
WHERE
	AccountID = @AccountID
END
				*/
				#endregion

				var user = CrmUsers
					.Where(u => u.AccountId == accountId)
					.Select(u => new
					{
						CrmUserId = u.CrmUserGuid,
						u.BusinessUnitId
					});
				return EntityDataReader(user);
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure, "GetCRMUser",
					new SqlParameter[] { new SqlParameter("@AccountID", accountId) });
				return reader;
			}
		}

		public int GetCrmUserCount(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOrganizationCRMUserCount]
	@ItemID int
AS
BEGIN
SELECT
 COUNT(CRMUserID)
FROM
	CrmUsers CU
INNER JOIN
	ExchangeAccounts EA
ON
	CU.AccountID = EA.AccountID
WHERE EA.ItemID = @ItemID
END
		*/
				#endregion

				return ExchangeAccounts
					.Where(a => a.ItemId == itemId)
					.SelectMany(a => a.CrmUsers)
					.Count();
			}
			else
			{
				return (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "GetOrganizationCRMUserCount",
					new SqlParameter[] { new SqlParameter("@ItemID", itemId) });
			}
		}

		public void DeleteCrmOrganization(int organizationId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteCRMOrganization]
	@ItemID int
AS
BEGIN
	SET NOCOUNT ON
DELETE FROM dbo.CRMUsers WHERE AccountID IN (SELECT AccountID FROM dbo.ExchangeAccounts WHERE ItemID = @ItemID)
END
				*/
				#endregion

				CrmUsers.Where(u => u.Account.ItemId == organizationId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "DeleteCRMOrganization",
					new SqlParameter[] { new SqlParameter("@ItemID", organizationId) });
			}
		}
#endregion

		#region VPS - Virtual Private Servers

		public IDataReader GetVirtualMachinesPaged(int actorId, int packageId, string filterColumn, string filterValue,
			string sortColumn, int startRow, int maximumRows, bool recursive)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetVirtualMachinesPaged]
(
	@ActorID int,
	@PackageID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int,
	@Recursive bit
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
SI.ItemTypeID = 33 -- VPS
AND ((@Recursive = 0 AND P.PackageID = @PackageID)
OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, P.PackageID) = 1))
'

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
	IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
		SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
	ELSE
		SET @condition = @condition + '
			AND (ItemName LIKE ''' + @FilterValue + '''
			OR Username LIKE ''' + @FilterValue + '''
			OR ExternalIP LIKE ''' + @FilterValue + '''
			OR IPAddress LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'SI.ItemName ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(SI.ItemID) FROM Packages AS P
INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
INNER JOIN Users AS U ON P.UserID = U.UserID
LEFT OUTER JOIN (
	SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
	INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
	WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
) AS EIP ON SI.ItemID = EIP.ItemID
LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
WHERE ' + @condition + '

DECLARE @Items AS TABLE
(
	ItemID int
);

WITH TempItems AS (
	SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
		SI.ItemID
	FROM Packages AS P
	INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
	INNER JOIN Users AS U ON P.UserID = U.UserID
	LEFT OUTER JOIN (
		SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
		INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
		WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
	) AS EIP ON SI.ItemID = EIP.ItemID
	LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
	WHERE ' + @condition + '
)

INSERT INTO @Items
SELECT ItemID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
	SI.ItemID,
	SI.ItemName,
	SI.PackageID,
	P.PackageName,
	P.UserID,
	U.Username,

	EIP.ExternalIP,
	PIP.IPAddress
FROM @Items AS TSI
INNER JOIN ServiceItems AS SI ON TSI.ItemID = SI.ItemID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Users AS U ON P.UserID = U.UserID
LEFT OUTER JOIN (
	SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
	INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
	WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
) AS EIP ON SI.ItemID = EIP.ItemID
LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
'

--print @sql

exec sp_executesql @sql, N'@PackageID int, @StartRow int, @MaximumRows int, @Recursive bit',
@PackageID, @StartRow, @MaximumRows, @Recursive

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var externalIpAddresses = PackageIpAddresses
					.Where(pip => pip.IsPrimary == true)
					.Join(IpAddresses.Where(ip => ip.PoolId == 3), pip => pip.AddressId, ip => ip.AddressId, (pip, ip) => new
					{
						pip.ItemId,
						ip.ExternalIp
					});
				IQueryable<Data.Entities.Package> packages;
				TempIdSet childPackages = null;
				try
				{
					if (!recursive) packages = Packages.Where(p => p.PackageId == packageId);
					else
					{
						childPackages = PackagesTree(packageId, true);
						packages = Packages.Join(childPackages, p => p.PackageId, ch => ch, (p, ch) => p);
					}

					var items = packages
						.Join(ServiceItems.Where(si => si.ItemTypeId == 33 /* VPS */),
							p => p.PackageId, i => i.PackageId, (p, i) => new { Package = p, Item = i })
						.GroupJoin(PrivateIpAddresses.Where(ip => ip.IsPrimary), p => p.Item.ItemId, pip => pip.ItemId, (p, pip) => new
						{
							p.Package,
							p.Item,
							IpAddresses = pip
							//pip.Any() ? pip.Single().IpAddress : null
						})
						.SelectMany(p => p.IpAddresses.DefaultIfEmpty(), (p, pip) => new
						{
							p.Package,
							p.Item,
							pip.IpAddress
						})
						.GroupJoin(externalIpAddresses, p => p.Item.ItemId, eip => eip.ItemId, (p, eip) => new
						{
							p.Package,
							p.Item,
							p.IpAddress,
							ExternalIps = eip
						})
						.SelectMany(p => p.ExternalIps.DefaultIfEmpty(), (p, eip) => new {
							p.Item.ItemId,
							p.Item.ItemName,
							p.Item.PackageId,
							p.Package.PackageName,
							p.Package.UserId,
							p.Package.User.Username,
							p.IpAddress,
							ExternalIp = eip != null ? eip.ExternalIp : null
						});

					if (!string.IsNullOrEmpty(filterValue))
					{
						if (!string.IsNullOrEmpty(filterColumn)) items = items.Where(DynamicFunctions.ColumnLike(items, filterColumn, filterValue));
						else
						{
#if NETFRAMEWORK
							items = items.Where(i => DbFunctions.Like(i.ItemName, filterValue) ||
								DbFunctions.Like(i.Username, filterValue) || DbFunctions.Like(i.ExternalIp, filterValue) ||
								DbFunctions.Like(i.IpAddress, filterValue));
#else
						items = items.Where(i => EF.Functions.Like(i.ItemName, filterValue) ||
							EF.Functions.Like(i.Username, filterValue) || EF.Functions.Like(i.ExternalIp, filterValue) ||
							EF.Functions.Like(i.IpAddress, filterValue));
#endif
						}
					}

					var count = items.Count();

					if (string.IsNullOrEmpty(sortColumn)) items = items.OrderBy(sortColumn);
					else items = items.OrderBy(i => i.ItemName);

					items = items.Skip(startRow).Take(maximumRows);

					return EntityDataReader(count, items);
				} finally
				{
					childPackages?.Dispose();
				}
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetVirtualMachinesPaged",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("@MaximumRows", maximumRows),
					new SqlParameter("@Recursive", recursive));
				return reader;
			}
		}

		public IDataReader GetVirtualMachinesPaged2012(int actorId, int packageId, string filterColumn, string filterValue,
			string sortColumn, int startRow, int maximumRows, bool recursive)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
GO
CREATE PROCEDURE [dbo].[GetVirtualMachinesPaged2012]
(
	@ActorID int,
	@PackageID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int,
	@Recursive bit
)
AS
-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
SI.ItemTypeID = 41 -- VPS2012
AND ((@Recursive = 0 AND P.PackageID = @PackageID)
OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, P.PackageID) = 1))
'

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
	IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
		SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
	ELSE
		SET @condition = @condition + '
			AND (ItemName LIKE ''' + @FilterValue + '''
			OR Username LIKE ''' + @FilterValue + '''
			OR ExternalIP LIKE ''' + @FilterValue + '''
			OR IPAddress LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'SI.ItemName ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(SI.ItemID) FROM Packages AS P
INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
INNER JOIN Users AS U ON P.UserID = U.UserID
LEFT OUTER JOIN (
	SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
	INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
	WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
) AS EIP ON SI.ItemID = EIP.ItemID
LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
WHERE ' + @condition + '

DECLARE @Items AS TABLE
(
	ItemID int
);

WITH TempItems AS (
	SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
		SI.ItemID
	FROM Packages AS P
	INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
	INNER JOIN Users AS U ON P.UserID = U.UserID
	LEFT OUTER JOIN (
		SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
		INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
		WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
	) AS EIP ON SI.ItemID = EIP.ItemID
	LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
	LEFT OUTER JOIN DmzIPAddresses AS DIP ON DIP.ItemID = SI.ItemID AND DIP.IsPrimary = 1
	WHERE ' + @condition + '
)

INSERT INTO @Items
SELECT ItemID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
	SI.ItemID,
	SI.ItemName,
	SI.PackageID,
	P.PackageName,
	P.UserID,
	U.Username,

	EIP.ExternalIP,
	PIP.IPAddress,
	DIP.IPAddress AS DmzIP
FROM @Items AS TSI
INNER JOIN ServiceItems AS SI ON TSI.ItemID = SI.ItemID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Users AS U ON P.UserID = U.UserID
LEFT OUTER JOIN (
	SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
	INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
	WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
) AS EIP ON SI.ItemID = EIP.ItemID
LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
LEFT OUTER JOIN DmzIPAddresses AS DIP ON DIP.ItemID = SI.ItemID AND DIP.IsPrimary = 1
'

--print @sql

exec sp_executesql @sql, N'@PackageID int, @StartRow int, @MaximumRows int, @Recursive bit',
@PackageID, @StartRow, @MaximumRows, @Recursive

RETURN 
GO
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var externalIpAddresses = PackageIpAddresses
					.Where(pip => pip.IsPrimary == true)
					.Join(IpAddresses.Where(ip => ip.PoolId == 3), pip => pip.AddressId, ip => ip.AddressId, (pip, ip) => new
					{
						pip.ItemId,
						ip.ExternalIp
					});
				IQueryable<Data.Entities.Package> packages;
				TempIdSet childPackages = null;
				try
				{
					if (!recursive) packages = Packages.Where(p => p.PackageId == packageId);
					else
					{
						childPackages = PackagesTree(packageId, true);
						packages = Packages.Join(childPackages, p => p.PackageId, ch => ch, (p, ch) => p);
					}
					var items = packages
						.Join(ServiceItems.Where(si => si.ItemTypeId == 41 /* VPS2012 */),
							p => p.PackageId, i => i.PackageId, (p, i) => new { Package = p, Item = i })
						.GroupJoin(PrivateIpAddresses.Where(ip => ip.IsPrimary), p => p.Item.ItemId, pip => pip.ItemId, (p, pip) => new
						{
							p.Package,
							p.Item,
							IpAddresses = pip
						})
						.SelectMany(p => p.IpAddresses.DefaultIfEmpty(), (p, pip) => new
						{
							p.Package,
							p.Item,
							IpAddress = pip.IpAddress
						})
						.GroupJoin(DmzIpAddresses.Where(ip => ip.IsPrimary), p => p.Item.ItemId, dip => dip.ItemId, (p, dip) => new
						{
							p.Package,
							p.Item,
							p.IpAddress,
							DmzIps = dip
						})
						.SelectMany(p => p.DmzIps.DefaultIfEmpty(), (p, dip) => new
						{
							p.Package,
							p.Item,
							p.IpAddress,
							DmzIp = dip
						})
						.GroupJoin(externalIpAddresses, p => p.Item.ItemId, eip => eip.ItemId, (p, eip) => new
						{
							p.Package,
							p.Item,
							p.IpAddress,
							p.DmzIp,
							ExternalIps = eip
						})
						.SelectMany(p => p.ExternalIps.DefaultIfEmpty(), (p, eip) => new
						{
							p.Item.ItemId,
							p.Item.ItemName,
							p.Item.PackageId,
							p.Package.PackageName,
							p.Package.UserId,
							p.Package.User.Username,
							ExternalIp = eip != null ? eip.ExternalIp : null,
							p.IpAddress,
							p.DmzIp
						});

					if (!string.IsNullOrEmpty(filterValue))
					{
						if (!string.IsNullOrEmpty(filterColumn)) items = items.Where(DynamicFunctions.ColumnLike(items, filterColumn, filterValue));
						else
						{
#if NETFRAMEWORK
							items = items.Where(i => DbFunctions.Like(i.ItemName, filterValue) ||
								DbFunctions.Like(i.Username, filterValue) || DbFunctions.Like(i.ExternalIp, filterValue) ||
								DbFunctions.Like(i.IpAddress, filterValue));
#else
						items = items.Where(i => EF.Functions.Like(i.ItemName, filterValue) ||
							EF.Functions.Like(i.Username, filterValue) || EF.Functions.Like(i.ExternalIp, filterValue) ||
							EF.Functions.Like(i.IpAddress, filterValue));
#endif
						}
					}

					var count = items.Count();

					if (string.IsNullOrEmpty(sortColumn)) items = items.OrderBy(sortColumn);
					else items = items.OrderBy(i => i.ItemName);

					items = items.Skip(startRow).Take(maximumRows);

					return EntityDataReader(count, items);
				}
				finally
				{
					childPackages?.Dispose();
				}
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetVirtualMachinesPaged2012",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("@MaximumRows", maximumRows),
					new SqlParameter("@Recursive", recursive));
				return reader;
			}
		}

		public IDataReader GetVirtualMachinesPagedProxmox(int actorId, int packageId, string filterColumn, string filterValue,
			 string sortColumn, int startRow, int maximumRows, bool recursive)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetVirtualMachinesPagedProxmox]
(
	@ActorID int,
	@PackageID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int,
	@Recursive bit
)
AS
-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
RAISERROR('You are not allowed to access this package', 16, 1)

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
SI.ItemTypeID = 143 -- Proxmox
AND ((@Recursive = 0 AND P.PackageID = @PackageID)
OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, P.PackageID) = 1))
'

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
	IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
		SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
	ELSE
		SET @condition = @condition + '
			AND (ItemName LIKE ''' + @FilterValue + '''
			OR Username LIKE ''' + @FilterValue + '''
			OR ExternalIP LIKE ''' + @FilterValue + '''
			OR IPAddress LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'SI.ItemName ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(SI.ItemID) FROM Packages AS P
INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
INNER JOIN Users AS U ON P.UserID = U.UserID
LEFT OUTER JOIN (
	SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
	INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
	WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
) AS EIP ON SI.ItemID = EIP.ItemID
LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
WHERE ' + @condition + '

DECLARE @Items AS TABLE
(
	ItemID int
);

WITH TempItems AS (
	SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
		SI.ItemID
	FROM Packages AS P
	INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
	INNER JOIN Users AS U ON P.UserID = U.UserID
	LEFT OUTER JOIN (
		SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
		INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
		WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
	) AS EIP ON SI.ItemID = EIP.ItemID
	LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
	WHERE ' + @condition + '
)

INSERT INTO @Items
SELECT ItemID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
	SI.ItemID,
	SI.ItemName,
	SI.PackageID,
	P.PackageName,
	P.UserID,
	U.Username,

	EIP.ExternalIP,
	PIP.IPAddress
FROM @Items AS TSI
INNER JOIN ServiceItems AS SI ON TSI.ItemID = SI.ItemID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Users AS U ON P.UserID = U.UserID
LEFT OUTER JOIN (
	SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
	INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
	WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
) AS EIP ON SI.ItemID = EIP.ItemID
LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
'

--print @sql

exec sp_executesql @sql, N'@PackageID int, @StartRow int, @MaximumRows int, @Recursive bit',
@PackageID, @StartRow, @MaximumRows, @Recursive

RETURN 
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var externalIpAddresses = PackageIpAddresses
					.Where(pip => pip.IsPrimary == true)
					.Join(IpAddresses.Where(ip => ip.PoolId == 3), pip => pip.AddressId, ip => ip.AddressId, (pip, ip) => new
					{
						pip.ItemId,
						ip.ExternalIp
					});
				IQueryable<Data.Entities.Package> packages;
				TempIdSet childPackages = null;
				try
				{
					if (!recursive) packages = Packages.Where(p => p.PackageId == packageId);
					else
					{
						childPackages = PackagesTree(packageId, true);
						packages = Packages.Join(childPackages, p => p.PackageId, ch => ch, (p, ch) => p);
					}
					var items = packages
						.Join(ServiceItems.Where(si => si.ItemTypeId == 143 /* Proxmox */),
							p => p.PackageId, i => i.PackageId, (p, i) => new { Package = p, Item = i })
						.GroupJoin(PrivateIpAddresses.Where(ip => ip.IsPrimary), p => p.Item.ItemId, pip => pip.ItemId, (p, pip) => new
						{
							p.Package,
							p.Item,
							IpAdresses = pip
						})
						.SelectMany(p => p.IpAdresses.DefaultIfEmpty(), (p, pip) => new
						{
							p.Package,
							p.Item,
							IpAddress = pip != null ? pip.IpAddress : null
						})
						.GroupJoin(externalIpAddresses, p => p.Item.ItemId, eip => eip.ItemId, (p, eip) => new
						{
							p.Package,
							p.Item,
							p.IpAddress,
							ExternalIps = eip
						})
						.SelectMany(p => p.ExternalIps.DefaultIfEmpty(), (p, eip) => new
						{
							p.Item.ItemId,
							p.Item.ItemName,
							p.Item.PackageId,
							p.Package.PackageName,
							p.Package.UserId,
							p.Package.User.Username,
							ExternalIp = eip != null ? eip.ExternalIp : null,
							p.IpAddress
						});

					if (!string.IsNullOrEmpty(filterValue))
					{
						if (!string.IsNullOrEmpty(filterColumn)) items = items.Where(DynamicFunctions.ColumnLike(items, filterColumn, filterValue));
						else
						{
#if NETFRAMEWORK
							items = items.Where(i => DbFunctions.Like(i.ItemName, filterValue) ||
								DbFunctions.Like(i.Username, filterValue) || DbFunctions.Like(i.ExternalIp, filterValue) ||
								DbFunctions.Like(i.IpAddress, filterValue));
#else
						items = items.Where(i => EF.Functions.Like(i.ItemName, filterValue) ||
							EF.Functions.Like(i.Username, filterValue) || EF.Functions.Like(i.ExternalIp, filterValue) ||
							EF.Functions.Like(i.IpAddress, filterValue));
#endif
						}
					}

					var count = items.Count();

					if (string.IsNullOrEmpty(sortColumn)) items = items.OrderBy(sortColumn);
					else items = items.OrderBy(i => i.ItemName);

					items = items.Skip(startRow).Take(maximumRows);

					return EntityDataReader(count, items);
				}
				finally
				{
					childPackages?.Dispose();
				}
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetVirtualMachinesPagedProxmox",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("@MaximumRows", maximumRows),
					new SqlParameter("@Recursive", recursive));
				return reader;
			}
		}

		public IDataReader GetVirtualMachinesForPCPaged(int actorId, int packageId, string filterColumn, string filterValue,
			 string sortColumn, int startRow, int maximumRows, bool recursive)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetVirtualMachinesPagedForPC]
(
	@ActorID int,
	@PackageID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int,
	@Recursive bit
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
BEGIN
	RAISERROR('You are not allowed to access this package', 16, 1)
	RETURN
END

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
SI.ItemTypeID = 35 -- VPS
AND ((@Recursive = 0 AND P.PackageID = @PackageID)
OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, P.PackageID) = 1))
'

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
	IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
		SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
	ELSE
		SET @condition = @condition + '
			AND (ItemName LIKE ''' + @FilterValue + '''
			OR Username LIKE ''' + @FilterValue + '''
			OR ExternalIP LIKE ''' + @FilterValue + '''
			OR IPAddress LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'SI.ItemName ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(SI.ItemID) FROM Packages AS P
INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
INNER JOIN Users AS U ON P.UserID = U.UserID
LEFT OUTER JOIN (
	SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
	INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
	WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
) AS EIP ON SI.ItemID = EIP.ItemID
LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
WHERE ' + @condition + '

DECLARE @Items AS TABLE
(
	ItemID int
);

WITH TempItems AS (
	SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
		SI.ItemID
	FROM Packages AS P
	INNER JOIN ServiceItems AS SI ON P.PackageID = SI.PackageID
	INNER JOIN Users AS U ON P.UserID = U.UserID
	LEFT OUTER JOIN (
		SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
		INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
		WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
	) AS EIP ON SI.ItemID = EIP.ItemID
	LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
	WHERE ' + @condition + '
)

INSERT INTO @Items
SELECT ItemID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
	SI.ItemID,
	SI.ItemName,
	SI.PackageID,
	P.PackageName,
	P.UserID,
	U.Username,

	EIP.ExternalIP,
	PIP.IPAddress
FROM @Items AS TSI
INNER JOIN ServiceItems AS SI ON TSI.ItemID = SI.ItemID
INNER JOIN Packages AS P ON SI.PackageID = P.PackageID
INNER JOIN Users AS U ON P.UserID = U.UserID
LEFT OUTER JOIN (
	SELECT PIP.ItemID, IP.ExternalIP FROM PackageIPAddresses AS PIP
	INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
	WHERE PIP.IsPrimary = 1 AND IP.PoolID = 3 -- external IP addresses
) AS EIP ON SI.ItemID = EIP.ItemID
LEFT OUTER JOIN PrivateIPAddresses AS PIP ON PIP.ItemID = SI.ItemID AND PIP.IsPrimary = 1
'

--print @sql

exec sp_executesql @sql, N'@PackageID int, @StartRow int, @MaximumRows int, @Recursive bit',
@PackageID, @StartRow, @MaximumRows, @Recursive

RETURN
				*/
				#endregion

				// check rights
				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var externalIpAddresses = PackageIpAddresses
					.Where(pip => pip.IsPrimary == true)
					.Join(IpAddresses.Where(ip => ip.PoolId == 3), pip => pip.AddressId, ip => ip.AddressId, (pip, ip) => new
					{
						pip.ItemId,
						ip.ExternalIp
					});
				IQueryable<Data.Entities.Package> packages;
				TempIdSet childPackages = null;
				try
				{
					if (!recursive) packages = Packages.Where(p => p.PackageId == packageId);
					else
					{
						childPackages = PackagesTree(packageId, true);
						packages = Packages.Join(childPackages, p => p.PackageId, ch => ch, (p, ch) => p);
					}

					var items = packages
						.Join(ServiceItems.Where(si => si.ItemTypeId == 35 /* VPS for PC */),
							p => p.PackageId, i => i.PackageId, (p, i) => new { Package = p, Item = i })
						.GroupJoin(PrivateIpAddresses.Where(ip => ip.IsPrimary), p => p.Item.ItemId, pip => pip.ItemId, (p, pip) => new
						{
							p.Package,
							p.Item,
							IpAddresses = pip
							//IpAddress = pip.Any() ? pip.Single().IpAddress : null
						})
						.SelectMany(p => p.IpAddresses.DefaultIfEmpty(), (p, pip) => new 
						{
							p.Package,
							p.Item,
							IpAddress = pip != null ? pip.IpAddress : null
						})
						.GroupJoin(externalIpAddresses, p => p.Item.ItemId, eip => eip.ItemId, (p, eip) => new
						{
							p.Package,
							p.Item,
							p.IpAddress,
							ExternalIps = eip
						})
						.SelectMany(p => p.ExternalIps.DefaultIfEmpty(), (p, eip) => new
						{
							p.Item.ItemId,
							p.Item.ItemName,
							p.Item.PackageId,
							p.Package.PackageName,
							p.Package.UserId,
							p.Package.User.Username,
							ExternalIp = eip != null ? eip.ExternalIp : null,
							p.IpAddress
						});

					if (!string.IsNullOrEmpty(filterValue))
					{
						if (!string.IsNullOrEmpty(filterColumn)) items = items.Where(DynamicFunctions.ColumnLike(items, filterColumn, filterValue));
						else
						{
#if NETFRAMEWORK
							items = items.Where(i => DbFunctions.Like(i.ItemName, filterValue) ||
								DbFunctions.Like(i.Username, filterValue) || DbFunctions.Like(i.ExternalIp, filterValue) ||
								DbFunctions.Like(i.IpAddress, filterValue));
#else
						items = items.Where(i => EF.Functions.Like(i.ItemName, filterValue) ||
							EF.Functions.Like(i.Username, filterValue) || EF.Functions.Like(i.ExternalIp, filterValue) ||
							EF.Functions.Like(i.IpAddress, filterValue));
#endif
						}
					}

					var count = items.Count();

					if (string.IsNullOrEmpty(sortColumn)) items = items.OrderBy(sortColumn);
					else items = items.OrderBy(i => i.ItemName);

					items = items.Skip(startRow).Take(maximumRows);

					return EntityDataReader(count, items);
				}
				finally
				{
					childPackages?.Dispose();
				}
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetVirtualMachinesPagedForPC",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("@MaximumRows", maximumRows),
					new SqlParameter("@Recursive", recursive));
				return reader;
			}
		}
#endregion

		#region VPS - External Network

		public IDataReader GetUnallottedIPAddresses(int packageId, int serviceId, int poolId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUnallottedIPAddresses]
 @PackageID int,
 @ServiceID int,
 @PoolID int = 0
AS
BEGIN
 DECLARE @ParentPackageID int
 DECLARE @ServerID int
IF (@PackageID = -1) -- NO PackageID defined, use ServerID from ServiceID (VPS Import)
BEGIN
 SELECT
  @ServerID = ServerID,
  @ParentPackageID = 1
 FROM Services
 WHERE ServiceID = @ServiceID
END
ELSE
BEGIN
 SELECT
  @ParentPackageID = ParentPackageID,
  @ServerID = ServerID
 FROM Packages
 WHERE PackageID = @PackageId
END

IF (@ParentPackageID = 1 OR @PoolID = 4 /* management network *//*) --"System" space
BEGIN
  --check if server is physical
  IF EXISTS(SELECT * FROM Servers WHERE ServerID = @ServerID AND VirtualServer = 0)
  BEGIN
   -- physical server
   SELECT

	IP.AddressID,
    IP.ExternalIP,
    IP.InternalIP,
    IP.ServerID,
    IP.PoolID,
    IP.SubnetMask,
    IP.DefaultGateway,
    IP.VLAN
   FROM dbo.IPAddresses AS IP
   WHERE
	(IP.ServerID = @ServerID OR IP.ServerID IS NULL)

	AND IP.AddressID NOT IN(SELECT PIP.AddressID FROM dbo.PackageIPAddresses AS PIP)

	AND(@PoolID = 0 OR @PoolID<> 0 AND IP.PoolID = @PoolID)
   ORDER BY IP.ServerID DESC, IP.DefaultGateway, IP.ExternalIP
  END
  ELSE
  BEGIN
   -- virtual server
   -- get resource group by service
   DECLARE @GroupID int
   SELECT @GroupID = P.GroupID FROM Services AS S
   INNER JOIN Providers AS P ON S.ProviderID = P.ProviderID
   WHERE S.ServiceID = @ServiceID
   SELECT
	IP.AddressID,
	IP.ExternalIP,
	IP.InternalIP,
	IP.ServerID,
	IP.PoolID,
	IP.SubnetMask,
	IP.DefaultGateway,
	IP.VLAN
   FROM dbo.IPAddresses AS IP
   WHERE

	(IP.ServerID IN (
	 SELECT SVC.ServerID FROM [dbo].[Services] AS SVC

	 INNER JOIN [dbo].[Providers] AS P ON SVC.ProviderID = P.ProviderID

	 WHERE[SVC].[ServiceID] = @ServiceId AND P.GroupID = @GroupID
	) OR IP.ServerID IS NULL)

	AND IP.AddressID NOT IN (SELECT PIP.AddressID FROM dbo.PackageIPAddresses AS PIP)

	AND(@PoolID = 0 OR @PoolID <> 0 AND IP.PoolID = @PoolID)
   ORDER BY IP.ServerID DESC, IP.DefaultGateway, IP.ExternalIP
  END
 END
 ELSE -- 2rd level space and below
 BEGIN
  -- get service location
  SELECT @ServerID = S.ServerID FROM Services AS S
  WHERE S.ServiceID = @ServiceID
  SELECT
   IP.AddressID,
   IP.ExternalIP,
   IP.InternalIP,
   IP.ServerID,
   IP.PoolID,
   IP.SubnetMask,
   IP.DefaultGateway,
   IP.VLAN
  FROM dbo.PackageIPAddresses AS PIP
  INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
  WHERE
   PIP.PackageID = @ParentPackageID
   AND PIP.ItemID IS NULL
   AND (@PoolID = 0 OR @PoolID <> 0 AND IP.PoolID = @PoolID)
   AND(IP.ServerID = @ServerID OR IP.ServerID IS NULL)
  ORDER BY IP.ServerID DESC, IP.DefaultGateway, IP.ExternalIP
 END
END
				*/
				#endregion

				int? serverId, parentPackageId;

				if (packageId == -1) // NO PackageID defined, use ServerID from ServiceID (VPS Import)
				{
					serverId = Services
						.Where(s => s.ServiceId == serviceId)
						.Select(s => s.ServerId)
						.FirstOrDefault();
					parentPackageId = 1;
				} else
				{
					var package = Packages
						.Where(p => p.PackageId == packageId)
						.Select(p => new { p.ParentPackageId, p.ServerId })
						.FirstOrDefault();
					serverId = package.ServerId;
					parentPackageId = package.ParentPackageId;
				}

				if (parentPackageId == 1 || poolId == 4 /* management network */) // "System" space
				{
					// check if server is physical
					if (Servers.Any(s => s.ServerId == serverId && !s.VirtualServer))
					{
						// physical server
						var packageIps = PackageIpAddresses
							.Select(pip => pip.AddressId)
							.ToArray();
						var addresses = IpAddresses
							.Where(ip => (ip.ServerId == serverId || ip.ServerId == null) &&
								(poolId == 0 || ip.PoolId == poolId) &&
								!packageIps.Any(pip => pip == ip.AddressId))
							.OrderByDescending(ip => ip.ServerId)
							.ThenBy(ip => ip.DefaultGateway)
							.ThenBy(ip => ip.ExternalIp)
							.Select(ip => new
							{
								ip.AddressId,
								ip.ExternalIp,
								ip.InternalIp,
								ip.ServerId,
								ip.PoolId,
								ip.SubnetMask,
								ip.DefaultGateway,
								ip.Vlan
							});
						return EntityDataReader(addresses);
					}
					else
					{
						// virtual server
						// get resource group by service
						serverId = Services
							.Where(s => s.ServiceId == serviceId)
							.Select(s => s.ServerId)
							.FirstOrDefault();
						var packageIps = PackageIpAddresses
							.Select(pip => pip.AddressId)
							.ToArray();
						var addresses = IpAddresses
							.Where(ip => (ip.ServerId == null || ip.ServerId == serverId) &&
								(poolId == 0 || ip.PoolId == poolId) &&
								!packageIps.Any(pip => pip == ip.AddressId))
							.OrderByDescending(ip => ip.ServerId)
							.ThenBy(ip => ip.DefaultGateway)
							.ThenBy(ip => ip.ExternalIp)
							.Select(ip => new
							{
								ip.AddressId,
								ip.ExternalIp,
								ip.InternalIp,
								ip.ServerId,
								ip.PoolId,
								ip.SubnetMask,
								ip.DefaultGateway,
								ip.Vlan
							});
						return EntityDataReader(addresses);
					}
				} else
				{
					// 2rd level space and below
					// get service location
					serverId = Services
						.Where(s => s.ServiceId == serviceId)
						.Select(s => s.ServerId)
						.FirstOrDefault();
					var addresses = PackageIpAddresses
						.Where(pip => pip.PackageId == parentPackageId && pip.ItemId == null)
						.Join(IpAddresses, pip => pip.AddressId, ip => ip.AddressId, (pip, ip) => ip)
						.Where(ip => (poolId == 0 || ip.PoolId == poolId) &&
							(ip.ServerId == serverId || ip.ServerId == null))
						.OrderByDescending(ip => ip.ServerId)
						.ThenBy(ip => ip.DefaultGateway)
						.ThenBy(ip => ip.ExternalIp)
						.Select(ip => new
							{
								ip.AddressId,
								ip.ExternalIp,
								ip.InternalIp,
								ip.ServerId,
								ip.PoolId,
								ip.SubnetMask,
								ip.DefaultGateway,
								ip.Vlan
							});
					return EntityDataReader(addresses);
				}
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetUnallottedIPAddresses",
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@ServiceId", serviceId),
					new SqlParameter("@PoolId", poolId));
			}
		}

		public void AllocatePackageIPAddresses(int packageId, int orgId, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AllocatePackageIPAddresses]
(
	@PackageID int,
	@OrgID int,
	@xml ntext
)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @idoc int
	--Create an internal representation of the XML document.
	EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

	-- delete
	DELETE FROM PackageIPAddresses
	FROM PackageIPAddresses AS PIP
	INNER JOIN OPENXML(@idoc, '/items/item', 1) WITH 
	(
		AddressID int '@id'
	) as PV ON PIP.AddressID = PV.AddressID

	-- insert
	INSERT INTO dbo.PackageIPAddresses
	(		
		PackageID,
		OrgID,
		AddressID	
	)
	SELECT		
		@PackageID,
		@OrgID,
		AddressID

	FROM OPENXML(@idoc, '/items/item', 1) WITH 
	(
		AddressID int '@id'
	) as PV

	-- remove document
	exec sp_xml_removedocument @idoc

END
				*/
				#endregion

				var addressIds = XElement.Parse(xml)
					.Elements()
					.Select(e => (int)e.Attribute("id"));
				PackageIpAddresses
					.Join(addressIds, ip => ip.AddressId, id => id, (ip, id) => ip)
					.ExecuteDelete();
				var newIps = addressIds
					.Select(id => new Data.Entities.PackageIpAddress
					{
						PackageId = packageId,
						OrgId = orgId,
						AddressId = id
					});
				PackageIpAddresses.AddRange(newIps);
				SaveChanges();
			}
			else
			{
				SqlParameter[] param = new[] {
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@OrgID", orgId),
					new SqlParameter("@xml", xml)
				};

				ExecuteLongNonQuery("AllocatePackageIPAddresses", param);
			}
		}

		public IDataReader GetPackageIPAddresses(int packageId, int orgId, int poolId, string filterColumn, string filterValue,
			 string sortColumn, int startRow, int maximumRows, bool recursive)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageIPAddresses]
(
 @PackageID int,
 @OrgID int,
 @FilterColumn nvarchar(50) = '',
 @FilterValue nvarchar(50) = '',
 @SortColumn nvarchar(50),
 @StartRow int,
 @MaximumRows int,
 @PoolID int = 0,
 @Recursive bit = 0
)
AS
BEGIN
-- start
DECLARE @condition nvarchar(700)
SET @condition = '
((@Recursive = 0 AND PA.PackageID = @PackageID)
OR (@Recursive = 1 AND dbo.CheckPackageParent(@PackageID, PA.PackageID) = 1))
AND (@PoolID = 0 OR @PoolID <> 0 AND IP.PoolID = @PoolID)
AND (@OrgID = 0 OR @OrgID <> 0 AND PA.OrgID = @OrgID)
'

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
 IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
  SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
 ELSE
  SET @condition = @condition + '
   AND (ExternalIP LIKE ''' + @FilterValue + '''
   OR InternalIP LIKE ''' + @FilterValue + '''
   OR DefaultGateway LIKE ''' + @FilterValue + '''
   OR ItemName LIKE ''' + @FilterValue + '''
   OR Username LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'IP.ExternalIP ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(PA.PackageAddressID)
FROM dbo.PackageIPAddresses PA
INNER JOIN dbo.IPAddresses AS IP ON PA.AddressID = IP.AddressID
INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
INNER JOIN dbo.Users U ON U.UserID = P.UserID
LEFT JOIN ServiceItems SI ON PA.ItemId = SI.ItemID
WHERE ' + @condition + '

DECLARE @Addresses AS TABLE
(	
	PackageAddressID int
);

WITH TempItems AS (
 SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
  PA.PackageAddressID
 FROM dbo.PackageIPAddresses PA
 INNER JOIN dbo.IPAddresses AS IP ON PA.AddressID = IP.AddressID
 INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
 INNER JOIN dbo.Users U ON U.UserID = P.UserID
 LEFT JOIN ServiceItems SI ON PA.ItemId = SI.ItemID
 WHERE ' + @condition + '
)

INSERT INTO @Addresses
SELECT PackageAddressID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
 PA.PackageAddressID,
 PA.AddressID,
 IP.ExternalIP,
 IP.InternalIP,
 IP.SubnetMask,
 IP.DefaultGateway,
 IP.VLAN,
 PA.ItemID,
 SI.ItemName,
 PA.PackageID,
 P.PackageName,
 P.UserID,
 U.UserName,
 PA.IsPrimary
FROM @Addresses AS TA
INNER JOIN dbo.PackageIPAddresses AS PA ON TA.PackageAddressID = PA.PackageAddressID
INNER JOIN dbo.IPAddresses AS IP ON PA.AddressID = IP.AddressID
INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
INNER JOIN dbo.Users U ON U.UserID = P.UserID
LEFT JOIN ServiceItems SI ON PA.ItemId = SI.ItemID
'

print @sql

exec sp_executesql @sql, N'@PackageID int, @OrgID int, @StartRow int, @MaximumRows int, @Recursive bit, @PoolID int',
@PackageID, @OrgID, @StartRow, @MaximumRows, @Recursive, @PoolID

END
				*/
				#endregion

				IQueryable<Data.Entities.PackageIpAddress> addressesFiltered;
				TempIdSet childPackages = null;
				try
				{
					if (!recursive) addressesFiltered = PackageIpAddresses.Where(pa => pa.PackageId == packageId);
					else
					{
						childPackages = PackagesTree(packageId, true);
						addressesFiltered = PackageIpAddresses.Join(childPackages, pa => pa.PackageId, ch => ch, (pa, ch) => pa);
					}

					var addresses = addressesFiltered
						.Where(pa => (orgId == 0 || pa.OrgId == orgId) &&
							(poolId == 0 || pa.Address.PoolId == poolId))
						.Select(pa => new
						{
							pa.PackageAddressId,
							pa.AddressId,
							pa.Address.ExternalIp,
							pa.Address.InternalIp,
							pa.Address.SubnetMask,
							pa.Address.DefaultGateway,
							pa.Address.Vlan,
							pa.ItemId,
							pa.Item.ItemName,
							pa.PackageId,
							pa.Package.PackageName,
							pa.Package.UserId,
							pa.Package.User.Username,
							pa.IsPrimary
						});
					if (!string.IsNullOrEmpty(filterValue))
					{
						if (!string.IsNullOrEmpty(filterColumn))
						{
							addresses = addresses.Where(DynamicFunctions.ColumnLike(addresses, filterColumn, filterValue));
						}
						else
						{
							addresses = addresses
#if NETFRAMEWORK
								.Where(a => DbFunctions.Like(a.ExternalIp, filterValue) ||
									DbFunctions.Like(a.InternalIp, filterValue) ||
									DbFunctions.Like(a.DefaultGateway, filterValue) ||
									DbFunctions.Like(a.ItemName, filterValue) ||
									DbFunctions.Like(a.Username, filterValue));
#else
								.Where(a => EF.Functions.Like(a.ExternalIp, filterValue) ||
									EF.Functions.Like(a.InternalIp, filterValue) ||
									EF.Functions.Like(a.DefaultGateway, filterValue) ||
									EF.Functions.Like(a.ItemName, filterValue) ||
									EF.Functions.Like(a.Username, filterValue));
#endif
						}
					}

					var count = addresses.Count();

					if (string.IsNullOrEmpty(sortColumn)) addresses = addresses.OrderBy(a => a.ExternalIp);
					else addresses = addresses.OrderBy(sortColumn);

					addresses = addresses.Skip(startRow).Take(maximumRows);
					return EntityDataReader(count, addresses);
				} finally
				{
					childPackages?.Dispose();
				}
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetPackageIPAddresses",
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@OrgID", orgId),
					new SqlParameter("@PoolId", poolId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows),
					new SqlParameter("@Recursive", recursive));
				return reader;
			}
		}

		public int GetPackageIPAddressesCount(int packageId, int orgId, int poolId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageIPAddressesCount]
(
	@PackageID int,
	@OrgID int,
	@PoolID int = 0
)
AS
BEGIN

SELECT 
	COUNT(PA.PackageAddressID)
FROM 
	dbo.PackageIPAddresses PA
INNER JOIN 
	dbo.IPAddresses AS IP ON PA.AddressID = IP.AddressID
INNER JOIN
	dbo.Packages P ON PA.PackageID = P.PackageID
INNER JOIN 
	dbo.Users U ON U.UserID = P.UserID
LEFT JOIN 
	ServiceItems SI ON PA.ItemId = SI.ItemID
WHERE
	(@PoolID = 0 OR @PoolID <> 0 AND IP.PoolID = @PoolID)
AND (@OrgID = 0 OR @OrgID <> 0 AND PA.OrgID = @OrgID)

END
				*/
				#endregion

				return PackageIpAddresses
					.Join(IpAddresses, pip => pip.AddressId, ip => ip.AddressId, (pip, ip) => new
					{
						pip.OrgId,
						ip.PoolId
					})
					.Count(ip => (poolId == 0 || poolId == ip.PoolId) &&
						(orgId == 0 || orgId == ip.OrgId));
			}
			else
			{
				object obj = SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure,
					"GetPackageIPAddressesCount",
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@OrgID", orgId),
					new SqlParameter("@PoolId", poolId));
				int res = 0;
				int.TryParse(obj.ToString(), out res);
				return res;
			}
		}

		public void DeallocatePackageIPAddress(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeallocatePackageIPAddress]
	@PackageAddressID int
AS
BEGIN

	SET NOCOUNT ON;

	-- check parent package
	DECLARE @ParentPackageID int

	SELECT @ParentPackageID = P.ParentPackageID
	FROM PackageIPAddresses AS PIP
	INNER JOIN Packages AS P ON PIP.PackageID = P.PackageId
	WHERE PIP.PackageAddressID = @PackageAddressID

	IF (@ParentPackageID = 1) -- ""System"" space
	BEGIN
		DELETE FROM dbo.PackageIPAddresses
		WHERE PackageAddressID = @PackageAddressID
	END
	ELSE -- 2rd level space and below
	BEGIN
		UPDATE PackageIPAddresses
		SET PackageID = @ParentPackageID
		WHERE PackageAddressID = @PackageAddressID
	END

END
				*/
				#endregion

				var parentPackageId = PackageIpAddresses
					.Where(pa => pa.PackageAddressId == id)
					.Select(pa => pa.Package.ParentPackageId)
					.FirstOrDefault();
				if (parentPackageId == 1) // System space
				{
					PackageIpAddresses
						.Where(pa => pa.PackageAddressId == id)
						.ExecuteDelete();
				}
				else // 2rd level space and below
				{
#if NETFRAMEWORK
					var packageIp = PackageIpAddresses
						.FirstOrDefault(pa => pa.PackageAddressId == id);
					if (packageIp != null)
					{
						packageIp.PackageId = parentPackageId.Value;
						SaveChanges();
					}
#else
					PackageIpAddresses
						.Where(pa => pa.PackageAddressId == id)
						.ExecuteUpdate(set => set
							.SetProperty(pa => pa.PackageId, parentPackageId.Value));
#endif
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure, "DeallocatePackageIPAddress",
					new SqlParameter("@PackageAddressID", id));
			}
		}
#endregion

		#region VPS - Private Network

		public IDataReader GetPackagePrivateIPAddressesPaged(int packageId, string filterColumn, string filterValue,
			string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackagePrivateIPAddressesPaged]
	@PackageID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
AS
BEGIN

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
SI.PackageID = @PackageID
'

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
	IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
		SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
	ELSE
		SET @condition = @condition + '
			AND (IPAddress LIKE ''' + @FilterValue + '''
			OR ItemName LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'PA.IPAddress ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(PA.PrivateAddressID)
FROM dbo.PrivateIPAddresses AS PA
INNER JOIN dbo.ServiceItems AS SI ON PA.ItemID = SI.ItemID
WHERE ' + @condition + '

DECLARE @Addresses AS TABLE
(
	PrivateAddressID int
);

WITH TempItems AS (
	SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
		PA.PrivateAddressID
	FROM dbo.PrivateIPAddresses AS PA
	INNER JOIN dbo.ServiceItems AS SI ON PA.ItemID = SI.ItemID
	WHERE ' + @condition + '
)

INSERT INTO @Addresses
SELECT PrivateAddressID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
	PA.PrivateAddressID,
	PA.IPAddress,
	PA.ItemID,
	SI.ItemName,
	PA.IsPrimary
FROM @Addresses AS TA
INNER JOIN dbo.PrivateIPAddresses AS PA ON TA.PrivateAddressID = PA.PrivateAddressID
INNER JOIN dbo.ServiceItems AS SI ON PA.ItemID = SI.ItemID
'

print @sql

exec sp_executesql @sql, N'@PackageID int, @StartRow int, @MaximumRows int',
@PackageID, @StartRow, @MaximumRows

END
				*/
				#endregion

				var addresses = PrivateIpAddresses
					.Where(a => a.Item.PackageId == packageId)
					.Select(a => new
					{
						a.PrivateAddressId,
						a.IpAddress,
						a.ItemId,
						a.Item.ItemName,
						a.IsPrimary
					});
				
				if (!string.IsNullOrEmpty(filterValue))
				{
					if (!string.IsNullOrEmpty(filterColumn))
					{
						addresses = addresses.Where(DynamicFunctions.ColumnLike(addresses, filterColumn, filterValue));
					} else
					{
						addresses = addresses
#if NETFRAMEWORK
							.Where(a => DbFunctions.Like(a.IpAddress, filterValue) ||
								DbFunctions.Like(a.ItemName, filterValue));
#else
							.Where(a => EF.Functions.Like(a.IpAddress, filterValue) ||
								EF.Functions.Like(a.ItemName, filterValue));
#endif
					}
				}

				var count = addresses.Count();

				if (string.IsNullOrEmpty(sortColumn)) addresses = addresses.OrderBy(pa => pa.IpAddress);
				else addresses = addresses.OrderBy(sortColumn);

				addresses = addresses.Skip(startRow).Take(maximumRows);
				return EntityDataReader(count, addresses);
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetPackagePrivateIPAddressesPaged",
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
				return reader;
			}
		}

		public IDataReader GetPackagePrivateIPAddresses(int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackagePrivateIPAddresses]
	@PackageID int
AS
BEGIN

	SELECT
		PA.PrivateAddressID,
		PA.IPAddress,
		PA.ItemID,
		SI.ItemName,
		PA.IsPrimary
	FROM PrivateIPAddresses AS PA
	INNER JOIN ServiceItems AS SI ON PA.ItemID = SI.ItemID
	WHERE SI.PackageID = @PackageID

END
				*/
				#endregion

				var addresses = PrivateIpAddresses
					.Where(a => a.Item.PackageId == packageId)
					.Select(a => new
					{
						a.PrivateAddressId,
						a.IpAddress,
						a.ItemId,
						a.Item.ItemName,
						a.IsPrimary
					});
				return EntityDataReader(addresses);
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetPackagePrivateIPAddresses",
					new SqlParameter("@PackageID", packageId));
				return reader;
			}
		}
		#endregion

		#region VPS - DMZ Network

		public IDataReader GetPackageDmzIPAddressesPaged(int packageId, string filterColumn, string filterValue,
			string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageDmzIPAddressesPaged]
	@PackageID int,
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
AS
BEGIN

-- start
DECLARE @condition nvarchar(700)
SET @condition = '
SI.PackageID = @PackageID
'

IF @FilterValue <> '' AND @FilterValue IS NOT NULL
BEGIN
	IF @FilterColumn <> '' AND @FilterColumn IS NOT NULL
		SET @condition = @condition + ' AND ' + @FilterColumn + ' LIKE ''' + @FilterValue + ''''
	ELSE
		SET @condition = @condition + '
			AND (IPAddress LIKE ''' + @FilterValue + '''
			OR ItemName LIKE ''' + @FilterValue + ''')'
END

IF @SortColumn IS NULL OR @SortColumn = ''
SET @SortColumn = 'DA.IPAddress ASC'

DECLARE @sql nvarchar(3500)

set @sql = '
SELECT COUNT(DA.DmzAddressID)
FROM dbo.DmzIPAddresses AS DA
INNER JOIN dbo.ServiceItems AS SI ON DA.ItemID = SI.ItemID
WHERE ' + @condition + '

DECLARE @Addresses AS TABLE
(
	DmzAddressID int
);

WITH TempItems AS (
	SELECT ROW_NUMBER() OVER (ORDER BY ' + @SortColumn + ') as Row,
		DA.DmzAddressID
	FROM dbo.DmzIPAddresses AS DA
	INNER JOIN dbo.ServiceItems AS SI ON DA.ItemID = SI.ItemID
	WHERE ' + @condition + '
)

INSERT INTO @Addresses
SELECT DmzAddressID FROM TempItems
WHERE TempItems.Row BETWEEN @StartRow + 1 and @StartRow + @MaximumRows

SELECT
	DA.DmzAddressID,
	DA.IPAddress,
	DA.ItemID,
	SI.ItemName,
	DA.IsPrimary
FROM @Addresses AS TA
INNER JOIN dbo.DmzIPAddresses AS DA ON TA.DmzAddressID = DA.DmzAddressID
INNER JOIN dbo.ServiceItems AS SI ON DA.ItemID = SI.ItemID
'

print @sql

exec sp_executesql @sql, N'@PackageID int, @StartRow int, @MaximumRows int',
@PackageID, @StartRow, @MaximumRows

END
				*/
				#endregion

				var addresses = DmzIpAddresses
					.Where(a => a.Item.PackageId == packageId)
					.Select(a => new
					{
						a.DmzAddressId,
						a.IpAddress,
						a.ItemId,
						a.Item.ItemName,
						a.IsPrimary
					});

				if (!string.IsNullOrEmpty(filterValue))
				{
					if (!string.IsNullOrEmpty(filterColumn))
					{
						addresses = addresses.Where(DynamicFunctions.ColumnLike(addresses, filterColumn, filterValue));
					}
					else
					{
						addresses = addresses
#if NETFRAMEWORK
							.Where(a => DbFunctions.Like(a.IpAddress, filterValue) ||
								DbFunctions.Like(a.ItemName, filterValue));
#else
							.Where(a => EF.Functions.Like(a.IpAddress, filterValue) ||
								EF.Functions.Like(a.ItemName, filterValue));
#endif
					}
				}

				var count = addresses.Count();

				if (string.IsNullOrEmpty(sortColumn)) addresses = addresses.OrderBy(pa => pa.IpAddress);
				else addresses = addresses.OrderBy(sortColumn);

				addresses = addresses.Skip(startRow).Take(maximumRows);
				return EntityDataReader(count, addresses);
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
										 "GetPackageDmzIPAddressesPaged",
											new SqlParameter("@PackageID", packageId),
											new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
											new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
											new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
											new SqlParameter("@startRow", startRow),
											new SqlParameter("@maximumRows", maximumRows));
				return reader;
			}
		}

		public IDataReader GetPackageDmzIPAddresses(int packageId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
	CREATE PROCEDURE [dbo].[GetPackageDmzIPAddresses]
		@PackageID int
	AS
	BEGIN

		SELECT
			DA.DmzAddressID,
			DA.IPAddress,
			DA.ItemID,
			SI.ItemName,
			DA.IsPrimary
		FROM DmzIPAddresses AS DA
		INNER JOIN ServiceItems AS SI ON DA.ItemID = SI.ItemID
		WHERE SI.PackageID = @PackageID

	END
				*/
				#endregion

				var addresses = DmzIpAddresses
					.Where(a => a.Item.PackageId == packageId)
					.Select(a => new
					{
						a.DmzAddressId,
						a.IpAddress,
						a.ItemId,
						a.Item.ItemName,
						a.IsPrimary
					});
				return EntityDataReader(addresses);
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
									 "GetPackageDmzIPAddresses",
										new SqlParameter("@PackageID", packageId));
				return reader;
			}
		}

		public int AddItemDmzIPAddress(int actorId, int itemId, string ipAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
	CREATE PROCEDURE [dbo].[AddItemDmzIPAddress]
	(
		@ActorID int,
		@ItemID int,
		@IPAddress varchar(15)
	)
	AS
	BEGIN

		IF EXISTS (SELECT ItemID FROM ServiceItems AS SI WHERE ItemID = @ItemID AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1)
		BEGIN

			INSERT INTO DmzIPAddresses
			(
				ItemID,
				IPAddress,
				IsPrimary
			)
			VALUES
			(
				@ItemID,
				@IPAddress,
				0 -- not primary
			)

		END
	END
				*/
				#endregion

				if (ServiceItems
					//TODO .Where(i => i.ItemId == itemId) or not?
					.Where(i => i.ItemId == itemId) // bugfix added by Simon Egli, 27.6.2024 
					.Select(i => i.PackageId)
					.AsEnumerable()
					.Any(packageId => CheckActorPackageRights(actorId, packageId)))
				{
					var ip = new Data.Entities.DmzIpAddress()
					{
						ItemId = itemId,
						IpAddress = ipAddress,
						IsPrimary = false
					};
					DmzIpAddresses.Add(ip);
					return SaveChanges();
				}
				return 0;
			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
								"AddItemDmzIPAddress",
								new SqlParameter("@ActorID", actorId),
								new SqlParameter("@ItemID", itemId),
								new SqlParameter("@IPAddress", ipAddress));
			}
		}

		public int SetItemDmzPrimaryIPAddress(int actorId, int itemId, int dmzAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetItemDmzPrimaryIPAddress]
(
	@ActorID int,
	@ItemID int,
	@DmzAddressID int
)
AS
BEGIN
	UPDATE DmzIPAddresses
	SET IsPrimary = CASE DIP.DmzAddressID WHEN @DmzAddressID THEN 1 ELSE 0 END
	FROM DmzIPAddresses AS DIP
	INNER JOIN ServiceItems AS SI ON DIP.ItemID = SI.ItemID
	WHERE DIP.ItemID = @ItemID
	AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1
END
				*/
				#endregion

				var addresses = DmzIpAddresses
					.Where(ip => ip.ItemId == itemId)
					.Include(ip => ip.Item)
					.AsEnumerable()
					.Where(ip => Local.CheckActorPackageRights(actorId, ip.Item.PackageId));

				foreach (var ip in addresses) ip.IsPrimary = ip.DmzAddressId == dmzAddressId;

				return SaveChanges();
			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
								"SetItemDmzPrimaryIPAddress",
								new SqlParameter("@ActorID", actorId),
								new SqlParameter("@ItemID", itemId),
								new SqlParameter("@DmzAddressID", dmzAddressId));
			}
		}

        public int DeleteItemDmzIPAddress(int actorId, int itemId, int dmzAddressId)
        {
			if (UseEntityFramework) {

				#region Stored Procedure
				/*
	CREATE PROCEDURE DeleteItemDmzIPAddress
	(
		@ActorID int,
		@ItemID int,
		@DmzAddressID int
	)
	AS
	BEGIN
		DELETE FROM DmzIPAddresses
		FROM DmzIPAddresses AS DIP
		INNER JOIN ServiceItems AS SI ON DIP.ItemID = SI.ItemID
		WHERE DIP.DmzAddressID = @DmzAddressID
		AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1
	END
				*/
				#endregion

				var addresses = DmzIpAddresses
					.Where(ip => ip.DmzAddressId == dmzAddressId)
					.Include(ip => ip.Item)
					.AsEnumerable()
					.Where(ip => Local.CheckActorPackageRights(actorId, ip.Item.PackageId));

				DmzIpAddresses.RemoveRange(addresses);

				return SaveChanges();

			} else {
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
									"DeleteItemDmzIPAddress",
									new SqlParameter("@ActorID", actorId),
									new SqlParameter("@ItemID", itemId),
									new SqlParameter("@DmzAddressID", dmzAddressId));
        	}
		}

		public IDataReader GetItemDmzIPAddresses(int actorId, int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
	CREATE PROCEDURE [dbo].[GetItemDmzIPAddresses]
	(
		@ActorID int,
		@ItemID int
	)
	AS
	BEGIN
	SELECT
		DIP.DmzAddressID AS AddressID,
		DIP.IPAddress,
		DIP.IsPrimary
	FROM DmzIPAddresses AS DIP
	INNER JOIN ServiceItems AS SI ON DIP.ItemID = SI.ItemID
	WHERE DIP.ItemID = @ItemID
	AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1
	ORDER BY DIP.IsPrimary DESC
	END
				*/
				#endregion

				var addresses = DmzIpAddresses
					.Where(ip => ip.ItemId == itemId)
					.Select(ip => new
					{
						AddressId = ip.DmzAddressId,
						ip.IpAddress,
						ip.IsPrimary,
						ip.Item.PackageId
					})
					.OrderBy(ip => ip.IsPrimary)
					.AsEnumerable()
					.Where(ip => Local.CheckActorPackageRights(actorId, ip.PackageId))
					.Select(ip => new
					{
						ip.AddressId,
						ip.IpAddress,
						ip.IsPrimary
					});

				return EntityDataReader(addresses);
			}
			else
			{

				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
									"GetItemDmzIPAddresses",
									new SqlParameter("@ActorID", actorId),
									new SqlParameter("@ItemID", itemId));
			}
		}

		public int DeleteItemDmzIPAddresses(int actorId, int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedured
				/*
	CREATE PROCEDURE DeleteItemDmzIPAddresses
	(
		@ActorID int,
		@ItemID int
	)
	AS
	BEGIN
		DELETE FROM DmzIPAddresses
		FROM DmzIPAddresses AS DIP
		INNER JOIN ServiceItems AS SI ON DIP.ItemID = SI.ItemID
		WHERE DIP.ItemID = @ItemID
		AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1
	END
				*/
				#endregion

				var addresses = DmzIpAddresses
					.Where(ip => ip.ItemId == itemId)
					.Include(ip => ip.Item)
					.AsEnumerable()
					.Where(ip => Local.CheckActorPackageRights(actorId, ip.Item.PackageId));

				DmzIpAddresses.RemoveRange(addresses);

				return SaveChanges();

			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
								"DeleteItemDmzIPAddresses",
								new SqlParameter("@ActorID", actorId),
								new SqlParameter("@ItemID", itemId));
			}
		}
        #endregion

		#region VPS - External Network Adapter
		public IDataReader GetPackageUnassignedIPAddresses(int actorId, int packageId, int orgId, int poolId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageUnassignedIPAddresses]
(
 @ActorID int,
 @PackageID int,
 @OrgID int,
 @PoolID int = 0
)
AS
BEGIN
 SELECT
  PIP.PackageAddressID,
  IP.AddressID,
  IP.ExternalIP,
  IP.InternalIP,
  IP.ServerID,
  IP.PoolID,
  PIP.IsPrimary,
  IP.SubnetMask,
  IP.DefaultGateway,
  IP.VLAN
 FROM PackageIPAddresses AS PIP
 INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
 WHERE
  PIP.ItemID IS NULL
  AND PIP.PackageID = @PackageID
  AND (@PoolID = 0 OR @PoolID <> 0 AND IP.PoolID = @PoolID)
  AND (@OrgID = 0 OR @OrgID <> 0 AND PIP.OrgID = @OrgID)
  AND dbo.CheckActorPackageRights(@ActorID, PIP.PackageID) = 1
 ORDER BY IP.DefaultGateway, IP.ExternalIP
END
				*/
				#endregion

				var addresses = PackageIpAddresses
					.Include(a => a.Address)
					.Where(a => a.ItemId == null && a.PackageId == packageId &&
						(orgId == 0 || a.OrgId == orgId) &&
						(poolId == 0 || a.Address.PoolId == poolId))
					.OrderBy(a => a.Address.DefaultGateway)
					.ThenBy(a => a.Address.ExternalIp)
					.AsEnumerable()
					.Where(a => Local.CheckActorPackageRights(actorId, a.PackageId))
					.Select(a => new
					{
						a.PackageAddressId,
						a.Address.AddressId,
						a.Address.ExternalIp,
						a.Address.InternalIp,
						a.Address.ServerId,
						a.Address.PoolId,
						a.IsPrimary,
						a.Address.SubnetMask,
						a.Address.DefaultGateway,
						a.Address.Vlan
					});
				return EntityDataReader(addresses);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetPackageUnassignedIPAddresses",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@OrgID", orgId),
					new SqlParameter("@PoolId", poolId));
			}
		}

		public IDataReader GetPackageIPAddress(int packageAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPackageIPAddress]
 @PackageAddressID int
AS
BEGIN
SELECT
 PA.PackageAddressID,
 PA.AddressID,
 IP.ExternalIP,
 IP.InternalIP,
 IP.SubnetMask,
 IP.DefaultGateway,
 IP.VLAN,
 PA.ItemID,
 SI.ItemName,
 PA.PackageID,
 P.PackageName,
 P.UserID,
 U.UserName,
 PA.IsPrimary
FROM dbo.PackageIPAddresses AS PA
INNER JOIN dbo.IPAddresses AS IP ON PA.AddressID = IP.AddressID
INNER JOIN dbo.Packages P ON PA.PackageID = P.PackageID
INNER JOIN dbo.Users U ON U.UserID = P.UserID
LEFT JOIN ServiceItems SI ON PA.ItemId = SI.ItemID
WHERE PA.PackageAddressID = @PackageAddressID
END
				*/
				#endregion

				var address = PackageIpAddresses
					.Where(a => a.PackageAddressId == packageAddressId)
					.Select(a => new
					{
						a.PackageAddressId,
						a.AddressId,
						a.Address.ExternalIp,
						a.Address.InternalIp,
						a.Address.SubnetMask,
						a.Address.DefaultGateway,
						a.Address.Vlan,
						a.ItemId,
						a.Item.ItemName,
						a.PackageId,
						a.Package.PackageName,
						a.Package.UserId,
						a.Package.User.Username,
						a.IsPrimary
					});
				return EntityDataReader(address);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetPackageIPAddress",
					new SqlParameter("@PackageAddressId", packageAddressId));
			}
		}

		public IDataReader GetItemIPAddresses(int actorId, int itemId, int poolId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetItemIPAddresses]
(
	@ActorID int,
	@ItemID int,
	@PoolID int
)
AS

SELECT
	PIP.PackageAddressID AS AddressID,
	IP.ExternalIP AS IPAddress,
	IP.InternalIP AS NATAddress,
	IP.SubnetMask,
	IP.DefaultGateway,
	PIP.IsPrimary
FROM PackageIPAddresses AS PIP
INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
INNER JOIN ServiceItems AS SI ON PIP.ItemID = SI.ItemID
WHERE PIP.ItemID = @ItemID
AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1
AND (@PoolID = 0 OR @PoolID <> 0 AND IP.PoolID = @PoolID)
ORDER BY PIP.IsPrimary DESC

RETURN
				*/
				#endregion

				var addresses = PackageIpAddresses
					.Where(a => a.ItemId == itemId && (poolId == 0 || a.Address.PoolId == poolId))
					.Select(a => new
					{
						AddressId = a.PackageAddressId,
						IpAddress = a.Address.ExternalIp,
						NatAddress = a.Address.InternalIp,
						a.Address.SubnetMask,
						a.Address.DefaultGateway,
						a.IsPrimary,
						a.Item.PackageId
					})
					.OrderByDescending(a => a.IsPrimary)
					.AsEnumerable()
					.Where(a => Local.CheckActorPackageRights(actorId, a.PackageId));
				return EntityDataReader(addresses);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetItemIPAddresses",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@PoolID", poolId));
			}
		}

		public int AddItemIPAddress(int actorId, int itemId, int packageAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddItemIPAddress]
(
	@ActorID int,
	@ItemID int,
	@PackageAddressID int
)
AS
BEGIN
	UPDATE PackageIPAddresses
	SET
		ItemID = @ItemID,
		IsPrimary = 0
	FROM PackageIPAddresses AS PIP
	WHERE
		PIP.PackageAddressID = @PackageAddressID
		AND dbo.CheckActorPackageRights(@ActorID, PIP.PackageID) = 1
END
				*/
				#endregion

				var address = PackageIpAddresses
					.Where(a => a.PackageAddressId == packageAddressId)
					.AsEnumerable()
					.Where(a => Local.CheckActorPackageRights(actorId, a.PackageId))
					.FirstOrDefault();
				if (address != null)
				{
					address.ItemId = itemId;
					address.IsPrimary = false;
					return SaveChanges();
				}
				return 0;
			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					"AddItemIPAddress",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@PackageAddressID", packageAddressId));
			}
		}

		public int SetItemPrimaryIPAddress(int actorId, int itemId, int packageAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetItemPrimaryIPAddress]
(
	@ActorID int,
	@ItemID int,
	@PackageAddressID int
)
AS
BEGIN

	-- read item pool
	DECLARE @PoolID int
	SELECT @PoolID = IP.PoolID FROM PackageIPAddresses AS PIP
	INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
	WHERE PIP.PackageAddressID = @PackageAddressID

	-- update all IP addresses of the specified pool
	UPDATE PackageIPAddresses
	SET IsPrimary = CASE PIP.PackageAddressID WHEN @PackageAddressID THEN 1 ELSE 0 END
	FROM PackageIPAddresses AS PIP
	INNER JOIN IPAddresses AS IP ON PIP.AddressID = IP.AddressID
	WHERE PIP.ItemID = @ItemID
	AND IP.PoolID = @PoolID
	AND dbo.CheckActorPackageRights(@ActorID, PIP.PackageID) = 1
END
				*/
				#endregion

				// read item pool
				var poolId = PackageIpAddresses
					.Where(a => a.PackageAddressId == packageAddressId)
					.Select(a => a.Address.PoolId)
					.FirstOrDefault();
				// update all IP addresses of the specified pool
				foreach (var ip in PackageIpAddresses
					.Where(a => a.ItemId == itemId && a.Address.PoolId == poolId))
				{
					if (CheckActorPackageRights(actorId, ip.PackageId))
					{
						ip.IsPrimary = ip.PackageAddressId == packageAddressId;
					}
				}
				return SaveChanges();
			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					"SetItemPrimaryIPAddress",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@PackageAddressID", packageAddressId));
			}
		}

		public int DeleteItemIPAddress(int actorId, int itemId, int packageAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteItemIPAddress]
(
	@ActorID int,
	@ItemID int,
	@PackageAddressID int
)
AS
BEGIN
	UPDATE PackageIPAddresses
	SET
		ItemID = NULL,
		IsPrimary = 0
	FROM PackageIPAddresses AS PIP
	WHERE
		PIP.PackageAddressID = @PackageAddressID
		AND dbo.CheckActorPackageRights(@ActorID, PIP.PackageID) = 1
END
				*/
				#endregion

				foreach (var ip in PackageIpAddresses
					.Where(a => a.PackageAddressId == packageAddressId))
				{
					if (CheckActorPackageRights(actorId, ip.PackageId))
					{
						ip.ItemId = null;
						ip.IsPrimary = false;
					}
				}
				return SaveChanges();
			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					"DeleteItemIPAddress",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@PackageAddressID", packageAddressId));
			}
		}

		public int DeleteItemIPAddresses(int actorId, int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteItemIPAddresses]
(
	@ActorID int,
	@ItemID int
)
AS
BEGIN
	UPDATE PackageIPAddresses
	SET
		ItemID = NULL,
		IsPrimary = 0
	FROM PackageIPAddresses AS PIP
	WHERE
		PIP.ItemID = @ItemID
		AND dbo.CheckActorPackageRights(@ActorID, PIP.PackageID) = 1
END
				*/
				#endregion

				foreach (var ip in PackageIpAddresses
					.Where(a => a.ItemId == itemId))
				{
					if (CheckActorPackageRights(actorId, ip.PackageId))
					{
						ip.ItemId = null;
						ip.IsPrimary = false;
					}
				}
				return SaveChanges();
			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					"DeleteItemIPAddresses",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId));
			}
		}
		#endregion

		#region VPS - Private Network Adapter
		public IDataReader GetItemPrivateIPAddresses(int actorId, int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetItemPrivateIPAddresses]
(
	@ActorID int,
	@ItemID int
)
AS

SELECT
	PIP.PrivateAddressID AS AddressID,
	PIP.IPAddress,
	PIP.IsPrimary
FROM PrivateIPAddresses AS PIP
INNER JOIN ServiceItems AS SI ON PIP.ItemID = SI.ItemID
WHERE PIP.ItemID = @ItemID
AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1
ORDER BY PIP.IsPrimary DESC

RETURN
				*/
				#endregion

				var addresses = PrivateIpAddresses
					.Include(a => a.Item)
					.Where(a => a.ItemId == itemId)
					.OrderByDescending(a => a.IsPrimary)
					.AsEnumerable()
					.Where(a => Local.CheckActorPackageRights(actorId, a.Item.PackageId))
					.Select(a => new
					{
						AddressId = a.PrivateAddressId,
						a.IpAddress,
						a.IsPrimary
					});
				return EntityDataReader(addresses);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					"GetItemPrivateIPAddresses",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId));
			}
		}

		public int AddItemPrivateIPAddress(int actorId, int itemId, string ipAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddItemPrivateIPAddress]
(
	@ActorID int,
	@ItemID int,
	@IPAddress varchar(15)
)
AS

IF EXISTS (SELECT ItemID FROM ServiceItems AS SI WHERE
	ItemID = @ItemID AND -- bugfix added by Simon Egli, 27.6.2024
	dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1)
BEGIN

	INSERT INTO PrivateIPAddresses
	(
		ItemID,
		IPAddress,
		IsPrimary
	)
	VALUES
	(
		@ItemID,
		@IPAddress,
		0 -- not primary
	)

END

RETURN
				*/
				#endregion

				if (ServiceItems
					//TODO .Where(i => i.ItemId == itemId) or not?
					.Where(i => i.ItemId == itemId) // bugfix added by Simon Egli, 27.6.2024 
					.Select(i => i.PackageId)
					.AsEnumerable()
					.Any(packageId => CheckActorPackageRights(actorId, packageId)))
				{
					var ip = new Data.Entities.PrivateIpAddress()
					{
						ItemId = itemId,
						IpAddress = ipAddress,
						IsPrimary = false
					};
					PrivateIpAddresses.Add(ip);
					return SaveChanges();
				}
				return 0;
			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					"AddItemPrivateIPAddress",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@IPAddress", ipAddress));
			}
		}

		public int SetItemPrivatePrimaryIPAddress(int actorId, int itemId, int privateAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetItemPrivatePrimaryIPAddress]
(
	@ActorID int,
	@ItemID int,
	@PrivateAddressID int
)
AS
BEGIN
	UPDATE PrivateIPAddresses
	SET IsPrimary = CASE PIP.PrivateAddressID WHEN @PrivateAddressID THEN 1 ELSE 0 END
	FROM PrivateIPAddresses AS PIP
	INNER JOIN ServiceItems AS SI ON PIP.ItemID = SI.ItemID
	WHERE PIP.ItemID = @ItemID
	AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1
END
				*/
				#endregion

				var addresses = PrivateIpAddresses
					.Where(ip => ip.ItemId == itemId)
					.Include(ip => ip.Item)
					.AsEnumerable()
					.Where(ip => CheckActorPackageRights(actorId, ip.Item.PackageId));

				foreach (var ip in addresses) ip.IsPrimary = ip.PrivateAddressId == privateAddressId;
			
				return SaveChanges();

			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					"SetItemPrivatePrimaryIPAddress",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@PrivateAddressID", privateAddressId));
			}
		}

		public int DeleteItemPrivateIPAddress(int actorId, int itemId, int privateAddressId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteItemPrivateIPAddress]
(
	@ActorID int,
	@ItemID int,
	@PrivateAddressID int
)
AS
BEGIN
	DELETE FROM PrivateIPAddresses
	FROM PrivateIPAddresses AS PIP
	INNER JOIN ServiceItems AS SI ON PIP.ItemID = SI.ItemID
	WHERE PIP.PrivateAddressID = @PrivateAddressID
	AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1
END
				*/
				#endregion

				PrivateIpAddresses
					.RemoveRange(PrivateIpAddresses
						.Include(a => a.Item)
						.Where(pa => pa.PrivateAddressId == privateAddressId)
						.AsEnumerable()
						.Where(pa => Local.CheckActorPackageRights(actorId, pa.Item.PackageId)));
				return SaveChanges();
			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					"DeleteItemPrivateIPAddress",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@PrivateAddressID", privateAddressId));
			}
		}

		public int DeleteItemPrivateIPAddresses(int actorId, int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteItemPrivateIPAddresses]
(
	@ActorID int,
	@ItemID int
)
AS
BEGIN
	DELETE FROM PrivateIPAddresses
	FROM PrivateIPAddresses AS PIP
	INNER JOIN ServiceItems AS SI ON PIP.ItemID = SI.ItemID
	WHERE PIP.ItemID = @ItemID
	AND dbo.CheckActorPackageRights(@ActorID, SI.PackageID) = 1
END
				*/
				#endregion

				PrivateIpAddresses
					.RemoveRange(PrivateIpAddresses
						.Include(a => a.Item)
						.Where(pa => pa.ItemId == itemId)
						.AsEnumerable()
						.Where(pa => Local.CheckActorPackageRights(actorId, pa.Item.PackageId)));
				return SaveChanges();
			}
			else
			{
				return SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					"DeleteItemPrivateIPAddresses",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@ItemID", itemId));
			}
		}
		#endregion

		#region BlackBerry

		public void AddBlackBerryUser(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddBlackBerryUser]
	@AccountID int
AS
BEGIN
	SET NOCOUNT ON;

INSERT INTO
	dbo.BlackBerryUsers
	(

	 AccountID,
	 CreatedDate,
	 ModifiedDate)
VALUES
(
	@AccountID,
	getdate(),
	getdate()
)
END
				*/
				#endregion

				var now = DateTime.Now;
				var user = new Data.Entities.BlackBerryUser()
				{
					AccountId = accountId,
					CreatedDate = now,
					ModifiedDate = now
				};
				BlackBerryUsers.Add(user);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"AddBlackBerryUser",
					new[] { new SqlParameter("@AccountID", accountId) });
			}
		}

		public bool CheckBlackBerryUserExists(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckBlackBerryUserExists]
	@AccountID int
AS
BEGIN
	SELECT
		COUNT(AccountID)
	FROM
		dbo.BlackBerryUsers
	WHERE AccountID = @AccountID
END
		*/
				#endregion

				return BlackBerryUsers.Any(u => u.AccountId == accountId);
			}
			else
			{
				int res = (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "CheckBlackBerryUserExists",
					new SqlParameter("@AccountID", accountId));
				return res > 0;
			}
		}

		public IDataReader GetBlackBerryUsers(int itemId, string sortColumn, string sortDirection, string name, string email, int startRow, int count)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetBlackBerryUsers]
(
	@ItemID int,
	@SortColumn nvarchar(40),
	@SortDirection nvarchar(20),
	@Name nvarchar(400),
	@Email nvarchar(400),
	@StartRow int,
	@Count int
)
AS

IF (@Name IS NULL)
BEGIN
	SET @Name = '%'
END

IF (@Email IS NULL)
BEGIN
	SET @Email = '%'
END

CREATE TABLE #TempBlackBerryUsers
(
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[AccountID] [int],
	[ItemID] [int] NOT NULL,
	[AccountName] [nvarchar](300) NOT NULL,
	[DisplayName] [nvarchar](300) NOT NULL,
	[PrimaryEmailAddress] [nvarchar](300) NULL,
	[SamAccountName] [nvarchar](100) NULL
)

IF (@SortColumn = 'DisplayName')
BEGIN
	INSERT INTO
# TempBlackBerryUsers
	SELECT
		ea.AccountID,
		ea.ItemID,
		ea.AccountName,
		ea.DisplayName,
		ea.PrimaryEmailAddress,
		ea.SamAccountName
	FROM
		ExchangeAccounts ea
	INNER JOIN
		BlackBerryUsers bu
	ON
		ea.AccountID = bu.AccountID
	WHERE
		ea.ItemID = @ItemID AND ea.DisplayName LIKE @Name AND ea.PrimaryEmailAddress LIKE @Email
	ORDER BY
		ea.DisplayName
END
ELSE
BEGIN
	INSERT INTO
# TempBlackBerryUsers
	SELECT
		ea.AccountID,
		ea.ItemID,
		ea.AccountName,
		ea.DisplayName,
		ea.PrimaryEmailAddress,
		ea.SamAccountName
	FROM
		ExchangeAccounts ea
	INNER JOIN
		BlackBerryUsers bu
	ON
		ea.AccountID = bu.AccountID
	WHERE
		ea.ItemID = @ItemID AND ea.DisplayName LIKE @Name AND ea.PrimaryEmailAddress LIKE @Email
	ORDER BY
		ea.PrimaryEmailAddress
END

DECLARE @RetCount int
SELECT @RetCount = COUNT(ID) FROM #TempBlackBerryUsers

IF (@SortDirection = 'ASC')
BEGIN
	SELECT * FROM #TempBlackBerryUsers
	WHERE ID > @StartRow AND ID <= (@StartRow + @Count)
END
ELSE
BEGIN
	IF (@SortColumn = 'DisplayName')
	BEGIN
		SELECT * FROM #TempBlackBerryUsers
			WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY DisplayName DESC
	END
	ELSE
	BEGIN
		SELECT * FROM #TempBlackBerryUsers
			WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY PrimaryEmailAddress DESC
	END

END

DROP TABLE #TempBlackBerryUsers
				*/
				#endregion

				if (string.IsNullOrEmpty(name)) name = "%";
				if (string.IsNullOrEmpty(email)) email = "%";
				var users = ExchangeAccounts
					.Where(ea => ea.ItemId == itemId &&
#if NETFRAMEWORK
						DbFunctions.Like(ea.DisplayName, name) &&
						DbFunctions.Like(ea.PrimaryEmailAddress, email))
#else
						EF.Functions.Like(ea.DisplayName, name) &&
						EF.Functions.Like(ea.PrimaryEmailAddress, email))
#endif
					.Join(BlackBerryUsers, ea => ea.AccountId, bb => bb.AccountId, (ea, bb) => new
					{
						ea.AccountId,
						ea.ItemId,
						ea.AccountName,
						ea.DisplayName,
						ea.PrimaryEmailAddress,
						ea.SamAccountName
					});

				var usersCount = users.Count();

				if (sortColumn == "DisplayName")
				{
					if (string.Equals(sortDirection, "ASC", StringComparison.OrdinalIgnoreCase))
					{
						users = users.OrderBy(ea => ea.DisplayName);
					} else users = users.OrderByDescending(ea => ea.DisplayName);
				} else
				{
					if (string.Equals(sortDirection, "ASC", StringComparison.OrdinalIgnoreCase))
					{
						users = users.OrderBy(ea => ea.PrimaryEmailAddress);
					}
					else users = users.OrderByDescending(ea => ea.PrimaryEmailAddress);
				}

				users = users.Skip(startRow).Take(count);

				// TODO bug not returning usersCount?
				//return EntityDataReader(usersCount, users);
				return EntityDataReader(users);
			}
			else
			{
				SqlParameter[] sqlParams = new SqlParameter[]
				{
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@SortColumn", sortColumn),
					new SqlParameter("@SortDirection", sortDirection),
					GetFilterSqlParam("@Name", name),
					GetFilterSqlParam("@Email", email),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("Count", count)
				};


				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetBlackBerryUsers", sqlParams);
			}
		}

		public int GetBlackBerryUsersCount(int itemId, string name, string email)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetBlackBerryUsersCount]
(
	@ItemID int,
	@Name nvarchar(400),
	@Email nvarchar(400)

)
AS

IF (@Name IS NULL)
BEGIN
	SET @Name = '%'
END

IF (@Email IS NULL)
BEGIN
	SET @Email = '%'
END

SELECT
	COUNT(ea.AccountID)
FROM
	ExchangeAccounts ea
INNER JOIN
	BlackBerryUsers bu
ON
	ea.AccountID = bu.AccountID
WHERE
	ea.ItemID = @ItemID AND ea.DisplayName LIKE @Name AND ea.PrimaryEmailAddress LIKE @Email
				*/
				#endregion

				if (string.IsNullOrEmpty(name)) name = "%";
				if (string.IsNullOrEmpty(email)) email = "%";
				var users = ExchangeAccounts
					.Where(ea => ea.ItemId == itemId &&
#if NETFRAMEWORK
						DbFunctions.Like(ea.DisplayName, name) &&
						DbFunctions.Like(ea.PrimaryEmailAddress, email))
#else
						EF.Functions.Like(ea.DisplayName, name) &&
						EF.Functions.Like(ea.PrimaryEmailAddress, email))
#endif
					.Join(BlackBerryUsers, ea => ea.AccountId, bb => bb.AccountId, (ea, bb) => ea);

				return users.Count();
			}
			else
			{
				SqlParameter[] sqlParams = new SqlParameter[]
				{
					new SqlParameter("@ItemID", itemId),
					GetFilterSqlParam("@Name", name),
					GetFilterSqlParam("@Email", email),
				};

				return (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "GetBlackBerryUsersCount", sqlParams);
			}
		}
		public void DeleteBlackBerryUser(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteBlackBerryUser]
(
	@AccountID int
)
AS

DELETE FROM
	BlackBerryUsers
WHERE
	AccountID = @AccountID

RETURN
				*/
				#endregion

				BlackBerryUsers.Where(u => u.AccountId == accountId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"DeleteBlackBerryUser",
					new[] { new SqlParameter("@AccountID", accountId) });
			}
		}
#endregion

		#region OCS

		public void AddOCSUser(int accountId, string instanceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddOCSUser]
	@AccountID int,
	@InstanceID nvarchar(50)
AS
BEGIN
	SET NOCOUNT ON;

INSERT INTO
	dbo.OCSUsers
	(

	 AccountID,
     InstanceID,
	 CreatedDate,
	 ModifiedDate)
VALUES
(
	@AccountID,
	@InstanceID,
	getdate(),
	getdate()
)
END				*/
				#endregion

				var now = DateTime.Now;
				var user = new Data.Entities.OcsUser()
				{
					AccountId = accountId,
					InstanceId = instanceId,
					CreatedDate = now,
					ModifiedDate = now
				};
				OcsUsers.Add(user);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"AddOCSUser",
					new[] {
						new SqlParameter("@AccountID", accountId),
						new SqlParameter("@InstanceID", instanceId)
					});
			}
		}

		public bool CheckOCSUserExists(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckOCSUserExists]
	@AccountID int
AS
BEGIN
	SELECT
		COUNT(AccountID)
	FROM
		dbo.OCSUsers
	WHERE AccountID = @AccountID
END
				*/
				#endregion

				return OcsUsers.Any(u => u.AccountId == accountId);
			}
			else
			{
				int res = (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "CheckOCSUserExists",
					new SqlParameter("@AccountID", accountId));
				return res > 0;
			}
		}

		public IDataReader GetOCSUsers(int itemId, string sortColumn, string sortDirection, string name, string email, int startRow, int count)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOCSUsers]
(
	@ItemID int,
	@SortColumn nvarchar(40),
	@SortDirection nvarchar(20),
	@Name nvarchar(400),
	@Email nvarchar(400),
	@StartRow int,
	@Count int
)
AS

IF (@Name IS NULL)
BEGIN
	SET @Name = '%'
END

IF (@Email IS NULL)
BEGIN
	SET @Email = '%'
END

CREATE TABLE #TempOCSUsers
(
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[AccountID] [int],
	[ItemID] [int] NOT NULL,
	[AccountName] [nvarchar](300)  NOT NULL,
	[DisplayName] [nvarchar](300)  NOT NULL,
	[InstanceID] [nvarchar](50)  NOT NULL,
	[PrimaryEmailAddress] [nvarchar](300) NULL,
	[SamAccountName] [nvarchar](100) NULL
)

IF (@SortColumn = 'DisplayName')
BEGIN
	INSERT INTO
# TempOCSUsers
	SELECT
		ea.AccountID,
		ea.ItemID,
		ea.AccountName,
		ea.DisplayName,
		ou.InstanceID,
		ea.PrimaryEmailAddress,
		ea.SamAccountName
	FROM
		ExchangeAccounts ea
	INNER JOIN
		OCSUsers ou
	ON
		ea.AccountID = ou.AccountID
	WHERE
		ea.ItemID = @ItemID AND ea.DisplayName LIKE @Name AND ea.PrimaryEmailAddress LIKE @Email
	ORDER BY
		ea.DisplayName
END
ELSE
BEGIN
	INSERT INTO
# TempOCSUsers
	SELECT
		ea.AccountID,
		ea.ItemID,
		ea.AccountName,
		ea.DisplayName,
		ou.InstanceID,
		ea.PrimaryEmailAddress,
		ea.SamAccountName
	FROM
		ExchangeAccounts ea
	INNER JOIN
		OCSUsers ou
	ON
		ea.AccountID = ou.AccountID
	WHERE
		ea.ItemID = @ItemID AND ea.DisplayName LIKE @Name AND ea.PrimaryEmailAddress LIKE @Email
	ORDER BY
		ea.PrimaryEmailAddress
END

DECLARE @RetCount int
SELECT @RetCount = COUNT(ID) FROM #TempOCSUsers

IF (@SortDirection = 'ASC')
BEGIN
	SELECT * FROM #TempOCSUsers
	WHERE ID > @StartRow AND ID <= (@StartRow + @Count)
END
ELSE
BEGIN
	IF (@SortColumn = 'DisplayName')
	BEGIN
		SELECT * FROM #TempOCSUsers
			WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY DisplayName DESC
	END
	ELSE
	BEGIN
		SELECT * FROM #TempOCSUsers
			WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY PrimaryEmailAddress DESC
	END

END

DROP TABLE #TempOCSUsers
				*/
				#endregion

				if (string.IsNullOrEmpty(name)) name = "%";
				if (string.IsNullOrEmpty(email)) email = "%";
				var users = ExchangeAccounts
					.Where(ea => ea.ItemId == itemId &&
#if NETFRAMEWORK
						DbFunctions.Like(ea.DisplayName, name) &&
						DbFunctions.Like(ea.PrimaryEmailAddress, email))
#else
						EF.Functions.Like(ea.DisplayName, name) &&
						EF.Functions.Like(ea.PrimaryEmailAddress, email))
#endif
					.Join(OcsUsers, ea => ea.AccountId, ou => ou.AccountId, (ea, ou) => new
					{
						ea.AccountId,
						ea.ItemId,
						ea.AccountName,
						ea.DisplayName,
						ou.InstanceId,
						ea.PrimaryEmailAddress,
						ea.SamAccountName
					});

				var usersCount = users.Count();

				if (sortColumn == "DisplayName")
				{
					if (string.Equals(sortDirection, "ASC", StringComparison.OrdinalIgnoreCase))
					{
						users = users.OrderBy(ea => ea.DisplayName);
					}
					else users = users.OrderByDescending(ea => ea.DisplayName);
				}
				else
				{
					if (string.Equals(sortDirection, "ASC", StringComparison.OrdinalIgnoreCase))
					{
						users = users.OrderBy(ea => ea.PrimaryEmailAddress);
					}
					else users = users.OrderByDescending(ea => ea.PrimaryEmailAddress);
				}

				users = users.Skip(startRow).Take(count);

				return EntityDataReader(usersCount, users);
			}
			else
			{
				SqlParameter[] sqlParams = new SqlParameter[]
				{
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@SortColumn", sortColumn),
					new SqlParameter("@SortDirection", sortDirection),
					GetFilterSqlParam("@Name", name),
					GetFilterSqlParam("@Email", email),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("Count", count)
				};

				return SqlHelper.ExecuteReader(
					 ConnectionString,
					 CommandType.StoredProcedure,
					 "GetOCSUsers", sqlParams);
			}
		}
		public int GetOCSUsersCount(int itemId, string name, string email)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOCSUsersCount]
(
	@ItemID int,
	@Name nvarchar(400),
	@Email nvarchar(400)

)
AS

IF (@Name IS NULL)
BEGIN
	SET @Name = '%'
END

IF (@Email IS NULL)
BEGIN
	SET @Email = '%'
END

SELECT
	COUNT(ea.AccountID)
FROM
	ExchangeAccounts ea
INNER JOIN
	OCSUsers ou
ON
	ea.AccountID = ou.AccountID
WHERE
	ea.ItemID = @ItemID AND ea.DisplayName LIKE @Name AND ea.PrimaryEmailAddress LIKE @Email
				*/
				#endregion

				if (string.IsNullOrEmpty(name)) name = "%";
				if (string.IsNullOrEmpty(email)) email = "%";
				var users = ExchangeAccounts
					.Where(ea => ea.ItemId == itemId &&
#if NETFRAMEWORK
						DbFunctions.Like(ea.DisplayName, name) &&
						DbFunctions.Like(ea.PrimaryEmailAddress, email))
#else
						EF.Functions.Like(ea.DisplayName, name) &&
						EF.Functions.Like(ea.PrimaryEmailAddress, email))
#endif
					.Join(OcsUsers, ea => ea.AccountId, bb => bb.AccountId, (ea, bb) => ea);

				return users.Count();
			}
			else
			{
				SqlParameter[] sqlParams = new SqlParameter[]
				{
					new SqlParameter("@ItemID", itemId),
					GetFilterSqlParam("@Name", name),
					GetFilterSqlParam("@Email", email),
				};

				return (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "GetOCSUsersCount", sqlParams);
			}
		}

		public void DeleteOCSUser(string instanceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteOCSUser]
(
	@InstanceId nvarchar(50)
)
AS

DELETE FROM
	OCSUsers
WHERE
	InstanceId = @InstanceId

RETURN
				*/
				#endregion

				OcsUsers.Where(u => u.InstanceId == instanceId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"DeleteOCSUser",
					new[] { new SqlParameter("@InstanceId", instanceId) });

			}
		}

		public string GetOCSUserInstanceID(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetInstanceID]
	 @AccountID int
AS
BEGIN
	SET NOCOUNT ON;

	SELECT InstanceID FROM OCSUsers WHERE AccountID = @AccountID
END
				*/
				#endregion

				var instanceId = OcsUsers
					.Where(u => u.AccountId == accountId)
					.Select(u => u.InstanceId)
					.FirstOrDefault();
				return instanceId;
			}
			else
			{
				return (string)SqlHelper.ExecuteScalar(ConnectionString,
					CommandType.StoredProcedure,
					"GetInstanceID",
					new[] { new SqlParameter("@AccountID", accountId) });
			}
		}

		#endregion

		#region SSL
		public int AddSSLRequest(int actorId, int packageId, int siteID, int userID, string friendlyname, string hostname, string csr, int csrLength, string distinguishedName, bool isRenewal, int previousID)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddSSLRequest]
(
	@SSLID int OUTPUT,
	@ActorID int,
	@PackageID int,
	@UserID int,
	@WebSiteID int,
	@FriendlyName nvarchar(255),
	@HostName nvarchar(255),
	@CSR ntext,
	@CSRLength int,
	@DistinguishedName nvarchar(500),
	@IsRenewal bit = 0,
	@PreviousId int = NULL

)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
BEGIN
	RAISERROR('You are not allowed to access this package', 16, 1)
	RETURN
END

-- insert record
INSERT INTO [dbo].[SSLCertificates]
	([UserID], [SiteID], [FriendlyName], [Hostname], [DistinguishedName], [CSR], [CSRLength], [IsRenewal], [PreviousId])
VALUES
	(@UserID, @WebSiteID, @FriendlyName, @HostName, @DistinguishedName, @CSR, @CSRLength, @IsRenewal, @PreviousId)

SET @SSLID = SCOPE_IDENTITY()
RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");
				var cert = new Data.Entities.SslCertificate()
				{
					UserId = userID,
					SiteId = siteID,
					FriendlyName = friendlyname,
					Hostname = hostname,
					DistinguishedName = distinguishedName,
					Csr = csr,
					CsrLength = csrLength,
					IsRenewal = isRenewal,
					PreviousId = previousID
				};
				SslCertificates.Add(cert);
				SaveChanges();
				return cert.Id;
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@SSLID", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddSSLRequest", prmId,
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@UserID", userID),
					new SqlParameter("@WebSiteID", siteID),
					new SqlParameter("@FriendlyName", friendlyname),
					new SqlParameter("@HostName", hostname),
					new SqlParameter("@CSR", csr),
					new SqlParameter("@CSRLength", csrLength),
					new SqlParameter("@DistinguishedName", distinguishedName),
					new SqlParameter("@IsRenewal", isRenewal),
					new SqlParameter("@PreviousId", previousID));

				return Convert.ToInt32(prmId.Value);
			}
		}

		public void CompleteSSLRequest(int actorId, int packageId, int id, string certificate, string distinguishedName, string serialNumber, byte[] hash, DateTime validFrom, DateTime expiryDate)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CompleteSSLRequest]
(
	@ActorID int,
	@PackageID int,
	@ID int,
	@Certificate ntext,
	@SerialNumber nvarchar(250),
	@Hash ntext,
	@DistinguishedName nvarchar(500),
	@ValidFrom datetime,
	@ExpiryDate datetime

)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
BEGIN
	RAISERROR('You are not allowed to access this package', 16, 1)
	RETURN
END

-- insert record
UPDATE
	[dbo].[SSLCertificates]
SET
	[Certificate] = @Certificate,
	[Installed] = 1,
	[SerialNumber] = @SerialNumber,
	[DistinguishedName] = @DistinguishedName,
	[Hash] = @Hash,
	[ValidFrom] = @ValidFrom,
	[ExpiryDate] = @ExpiryDate
WHERE
	[ID] = @ID;
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");

				var cert = SslCertificates
					.FirstOrDefault(c => c.Id == id);
				if (cert != null)
				{
					cert.Certificate = certificate;
					cert.Installed = true;
					cert.SerialNumber = serialNumber;
					cert.DistinguishedName = distinguishedName;
					cert.Hash = Convert.ToBase64String(hash);
					cert.ValidFrom = validFrom;
					cert.ExpiryDate = expiryDate;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "CompleteSSLRequest",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@ID", id),
					new SqlParameter("@DistinguishedName", distinguishedName),
					new SqlParameter("@Certificate", certificate),
					new SqlParameter("@SerialNumber", serialNumber),
					new SqlParameter("@Hash", Convert.ToBase64String(hash)),
					new SqlParameter("@ValidFrom", validFrom),
					new SqlParameter("@ExpiryDate", expiryDate));
			}
		}

		public void AddPFX(int actorId, int packageId, int siteID, int userID, string hostname, string friendlyName, string distinguishedName, int csrLength, string serialNumber, DateTime validFrom, DateTime expiryDate)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddPFX]
(
	@ActorID int,
	@PackageID int,
	@UserID int,
	@WebSiteID int,
	@FriendlyName nvarchar(255),
	@HostName nvarchar(255),
	@CSRLength int,
	@DistinguishedName nvarchar(500),
	@SerialNumber nvarchar(250),
	@ValidFrom datetime,
	@ExpiryDate datetime

)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
BEGIN
	RAISERROR('You are not allowed to access this package', 16, 1)
	RETURN
END

-- insert record
INSERT INTO [dbo].[SSLCertificates]
	([UserID], [SiteID], [FriendlyName], [Hostname], [DistinguishedName], [CSRLength], [SerialNumber], [ValidFrom], [ExpiryDate], [Installed])
VALUES
	(@UserID, @WebSiteID, @FriendlyName, @HostName, @DistinguishedName, @CSRLength, @SerialNumber, @ValidFrom, @ExpiryDate, 1)

RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");
				var cert = new Data.Entities.SslCertificate()
				{
					UserId = userID,
					SiteId = siteID,
					FriendlyName = friendlyName,
					Hostname = hostname,
					DistinguishedName = distinguishedName,
					CsrLength = csrLength,
					SerialNumber = serialNumber,
					ValidFrom = validFrom,
					ExpiryDate = expiryDate,
					Installed = true
				};
				SslCertificates.Add(cert);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "AddPFX",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@UserID", userID),
					new SqlParameter("@WebSiteID", siteID),
					new SqlParameter("@FriendlyName", friendlyName),
					new SqlParameter("@HostName", hostname),
					new SqlParameter("@CSRLength", csrLength),
					new SqlParameter("@DistinguishedName", distinguishedName),
					new SqlParameter("@SerialNumber", serialNumber),
					new SqlParameter("@ValidFrom", validFrom),
					new SqlParameter("@ExpiryDate", expiryDate));
			}
		}

		// Does not exist in stored procedures
		/*public DataSet GetSSL(int actorId, int packageId, int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
				*//*
				#endregion

			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetSSL",
					new SqlParameter("@SSLID", id));
			}
		}*/
		
		public DataSet GetCertificatesForSite(int actorId, int packageId, int siteId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetCertificatesForSite]
(
	@ActorID int,
	@PackageID int,
	@websiteid int
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
BEGIN
	RAISERROR('You are not allowed to access this package', 16, 1)
	RETURN
END

SELECT
	[ID], [UserID], [SiteID], [FriendlyName], [Hostname], [DistinguishedName],
	[CSR], [CSRLength], [ValidFrom], [ExpiryDate], [Installed], [IsRenewal],
	[PreviousId], [SerialNumber]
FROM
	[dbo].[SSLCertificates]
WHERE
	[SiteID] = @websiteid
RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");
				var cert = SslCertificates
					.Where(c => c.SiteId == siteId)
					.Select(c => new
					{
						c.Id,
						c.UserId,
						c.SiteId,
						c.FriendlyName,
						c.Hostname,
						c.DistinguishedName,
						c.Csr,
						c.CsrLength,
						c.ValidFrom,
						c.ExpiryDate,
						c.Installed,
						c.IsRenewal,
						c.PreviousId,
						c.SerialNumber
					});
				return EntityDataSet(cert);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetCertificatesForSite",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@websiteid", siteId));
			}
		}

		public DataSet GetPendingCertificates(int actorId, int packageId, int id, bool recursive)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetPendingSSLForWebsite]
(
	@ActorID int,
	@PackageID int,
	@websiteid int,
	@Recursive bit = 1
)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
BEGIN
	RAISERROR('You are not allowed to access this package', 16, 1)
	RETURN
END

SELECT
	[ID], [UserID], [SiteID], [Hostname], [CSR], [Certificate], [Hash], [Installed]
FROM
	[dbo].[SSLCertificates]
WHERE
	@websiteid = [SiteID] AND [Installed] = 0 AND [IsRenewal] = 0 -- bugfix Simon Egli, 27.6.2024

RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");
				var certs = SslCertificates
					.Where(c => id == c.SiteId && c.Installed == false && c.IsRenewal == false)
					.Select(c => new
					{
						c.Id,
						c.UserId,
						c.SiteId,
						c.Hostname,
						c.Csr,
						c.Certificate,
						c.Hash,
						c.Installed
					});
				return EntityDataSet(certs);
			}
			else
			{
				return SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetPendingSSLForWebsite",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@PackageId", packageId),
					new SqlParameter("@websiteid", id),
					new SqlParameter("@Recursive", recursive));
			}
		}

		public IDataReader GetSSLCertificateByID(int actorId, int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSSLCertificateByID]
(
	@ActorID int,
	@ID int
)
AS

SELECT
	[ID], [UserID], [SiteID], [Hostname], [FriendlyName], [CSR], [Certificate], [Hash], [Installed], [IsRenewal], [PreviousId]
FROM
	[dbo].[SSLCertificates]
INNER JOIN
	[dbo].[ServiceItems] AS [SI] ON [SSLCertificates].[SiteID] = [SI].[ItemID]
WHERE
	[ID] = @ID AND [dbo].CheckActorPackageRights(@ActorID, [SI].[PackageID]) = 1

RETURN
				*/
				#endregion

				var cert = SslCertificates
					.Where(c => c.Id == id)
					.Join(ServiceItems, c => c.SiteId, i => i.ItemId, (c, i) => new
					{
						c.Id,
						c.UserId,
						c.SiteId,
						c.Hostname,
						c.FriendlyName,
						c.Csr,
						c.Certificate,
						c.Hash,
						c.Installed,
						c.IsRenewal,
						c.PreviousId,
						i.PackageId
					})
					.AsEnumerable()
					.Where(c => Local.CheckActorPackageRights(actorId, c.PackageId));
				return EntityDataReader(cert);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetSSLCertificateByID",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@ID", id));
			}
		}

		public int CheckSSL(int siteID, bool renewal)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckSSL]
(
	@siteID int,
	@Renewal bit = 0,
	@Result int OUTPUT
)
AS

/*
@Result values:
	0 - OK
	-1 - already exists
*//*

SET @Result = 0 -- OK

-- check if a SSL Certificate is installed for domain
IF EXISTS(SELECT [ID] FROM [dbo].[SSLCertificates] WHERE [SiteID] = @siteID)
BEGIN
	SET @Result = -1
	RETURN
END

--To Do add renewal stuff

RETURN
				*/
				#endregion

				//TODO add renewal stuff
				return SslCertificates.Any(c => c.SiteId == siteID) ? -1 : 0;
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@Result", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "CheckSSL",
					prmId,
					new SqlParameter("@siteID", siteID),
					new SqlParameter("@Renewal", renewal));

				return Convert.ToInt32(prmId.Value);
			}
		}

		// TODO this is a duplicate of GetSSLCertificateByID
		public IDataReader GetSiteCert(int actorId, int siteID)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
				*/
				#endregion

				return GetSSLCertificateByID(actorId, siteID);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetSSLCertificateByID",
					new SqlParameter("@ActorId", actorId),
					new SqlParameter("@ID", siteID));
			}
		}

		public void DeleteCertificate(int actorId, int packageId, int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteCertificate]
(
	@ActorID int,
	@PackageID int,
	@id int

)
AS

-- check rights
IF dbo.CheckActorPackageRights(@ActorID, @PackageID) = 0
BEGIN
	RAISERROR('You are not allowed to access this package', 16, 1)
	RETURN
END

-- insert record
DELETE FROM
	[dbo].[SSLCertificates]
WHERE
	[ID] = @id

RETURN
				*/
				#endregion

				if (!CheckActorPackageRights(actorId, packageId))
					throw new AccessViolationException("You are not allowed to access this package");
				SslCertificates.Where(c => c.Id == id).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "DeleteCertificate",
					new SqlParameter("@ActorID", actorId),
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@id", id));
			}
		}

		public bool CheckSSLExistsForWebsite(int siteId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckSSLExistsForWebsite]
(
	@siteID int,
	@SerialNumber nvarchar(250),
	@Result bit OUTPUT
)
AS

/*
@Result values:
	0 - OK
	-1 - already exists
*//*

SET @Result = 0 -- OK

-- check if a SSL Certificate is installed for domain
IF EXISTS(SELECT [ID] FROM [dbo].[SSLCertificates] WHERE [SiteID] = @siteID
--AND SerialNumber=@SerialNumber
)
BEGIN
	SET @Result = 1
	RETURN
END

RETURN
				*/
				#endregion

				return SslCertificates.Any(c => c.SiteId == siteId);
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@Result", SqlDbType.Bit);
				prmId.Direction = ParameterDirection.Output;
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "CheckSSLExistsForWebsite", prmId,
					new SqlParameter("@siteID", siteId),
					new SqlParameter("@SerialNumber", ""));
				return Convert.ToBoolean(prmId.Value);
			}
		}
		#endregion

		#region Lync

		public void AddLyncUser(int accountId, int lyncUserPlanId, string sipAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddLyncUser]
	@AccountID int,
	@LyncUserPlanID int,
	@SipAddress nvarchar(300)
AS
INSERT INTO
	dbo.LyncUsers
	(AccountID,
	 LyncUserPlanID,
	 CreatedDate,
	 ModifiedDate,
	 SipAddress)
VALUES
(
	@AccountID,
	@LyncUserPlanID,
	getdate(),
	getdate(),
	@SipAddress
)
				*/
				#endregion

				var now = DateTime.Now;
				var user = new Data.Entities.LyncUser()
				{
					AccountId = accountId,
					LyncUserPlanId = lyncUserPlanId,
					CreatedDate = now,
					ModifiedDate = now,
					SipAddress = sipAddress
				};
				LyncUsers.Add(user);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"AddLyncUser",
					new[] {
						new SqlParameter("@AccountID", accountId),
						new SqlParameter("@LyncUserPlanID", lyncUserPlanId),
						new SqlParameter("@SipAddress", sipAddress)
					});
			}
		}

		public void UpdateLyncUser(int accountId, string sipAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateLyncUser]
(
	@AccountID int,
	@SipAddress nvarchar(300)
)
AS

UPDATE LyncUsers SET
	SipAddress = @SipAddress
WHERE
	AccountID = @AccountID

RETURN
				*/
				#endregion
#if NETFRAMEWORK
				var user = LyncUsers
					.FirstOrDefault(u => u.AccountId == accountId);
				if (user != null)
				{
					user.SipAddress = sipAddress;
					SaveChanges();
				}
#else
				LyncUsers
					.Where(u => u.AccountId == accountId)
					.ExecuteUpdate(set => set
						.SetProperty(u => u.SipAddress, sipAddress));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"UpdateLyncUser",
					new[] {
						new SqlParameter("@AccountID", accountId),
						new SqlParameter("@SipAddress", sipAddress)
					});
			}
		}


		public bool CheckLyncUserExists(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckLyncUserExists]
	@AccountID int
AS
BEGIN
	SELECT
		COUNT(AccountID)
	FROM
		dbo.LyncUsers
	WHERE AccountID = @AccountID
END
				*/
				#endregion

				return LyncUsers.Any(u => u.AccountId == accountId);
			}
			else
			{
				int res = (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "CheckLyncUserExists",
					new SqlParameter("@AccountID", accountId));
				return res > 0;
			}
		}

		public bool LyncUserExists(int accountId, string sipAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[LyncUserExists]
(
	@AccountID int,
	@SipAddress nvarchar(300),
	@Exists bit OUTPUT
)
AS

	SET @Exists = 0
	IF EXISTS(SELECT * FROM [dbo].[ExchangeAccountEmailAddresses] WHERE [EmailAddress] = @SipAddress AND [AccountID] <> @AccountID)
		BEGIN
			SET @Exists = 1
		END
	ELSE IF EXISTS(SELECT * FROM [dbo].[ExchangeAccounts] WHERE [PrimaryEmailAddress] = @SipAddress AND [AccountID] <> @AccountID)
		BEGIN
			SET @Exists = 1
		END
	ELSE IF EXISTS(SELECT * FROM [dbo].[ExchangeAccounts] WHERE [UserPrincipalName] = @SipAddress AND [AccountID] <> @AccountID)
		BEGIN
			SET @Exists = 1
		END
	ELSE IF EXISTS(SELECT * FROM [dbo].[ExchangeAccounts] WHERE [AccountName] = @SipAddress AND [AccountID] <> @AccountID)
		BEGIN
			SET @Exists = 1
		END
	ELSE IF EXISTS(SELECT * FROM [dbo].[LyncUsers] WHERE [SipAddress] = @SipAddress)
		BEGIN
			SET @Exists = 1
		END

	RETURN
				*/
				#endregion

				return ExchangeAccountEmailAddresses.Any(a => a.EmailAddress == sipAddress && a.AccountId != accountId) ||
					ExchangeAccounts.Any(a => a.AccountId != accountId &&
						(a.PrimaryEmailAddress == sipAddress ||
						a.UserPrincipalName == sipAddress ||
						a.AccountName == sipAddress)) ||
					LyncUsers.Any((u => u.SipAddress == sipAddress));
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@Exists", SqlDbType.Bit);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"LyncUserExists",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@SipAddress", sipAddress),
					outParam);

				return Convert.ToBoolean(outParam.Value);
			}
		}

		public IDataReader GetLyncUsers(int itemId, string sortColumn, string sortDirection, int startRow, int count)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetLyncUsers]
(
	@ItemID int,
	@SortColumn nvarchar(40),
	@SortDirection nvarchar(20),
	@StartRow int,
	@Count int	
)
AS
BEGIN
	CREATE TABLE #TempLyncUsers 
	(	
		[ID] [int] IDENTITY(1,1) NOT NULL,
		[AccountID] [int],	
		[ItemID] [int] NOT NULL,
		[AccountName] [nvarchar](300)  NOT NULL,
		[DisplayName] [nvarchar](300)  NOT NULL,
		[UserPrincipalName] [nvarchar](300) NULL,
		[SipAddress] [nvarchar](300) NULL,
		[SamAccountName] [nvarchar](100) NULL,
		[LyncUserPlanId] [int] NOT NULL,		
		[LyncUserPlanName] [nvarchar] (300) NOT NULL,		
	)

	DECLARE @condition nvarchar(700)
	SET @condition = ''

	IF (@SortColumn = 'DisplayName')
	BEGIN
		SET @condition = 'ORDER BY ea.DisplayName'
	END

	IF (@SortColumn = 'UserPrincipalName')
	BEGIN
		SET @condition = 'ORDER BY ea.UserPrincipalName'
	END

	IF (@SortColumn = 'SipAddress')
	BEGIN
		SET @condition = 'ORDER BY ou.SipAddress'
	END

	IF (@SortColumn = 'LyncUserPlanName')
	BEGIN
		SET @condition = 'ORDER BY lp.LyncUserPlanName'
	END

	DECLARE @sql nvarchar(3500)

	set @sql = '
		INSERT INTO 
# TempLyncUsers
		SELECT 
			ea.AccountID,
			ea.ItemID,
			ea.AccountName,
			ea.DisplayName,
			ea.UserPrincipalName,
			ou.SipAddress,
			ea.SamAccountName,
			ou.LyncUserPlanId,
			lp.LyncUserPlanName				
		FROM 
			ExchangeAccounts ea 
		INNER JOIN 
			LyncUsers ou
		INNER JOIN
			LyncUserPlans lp 
		ON
			ou.LyncUserPlanId = lp.LyncUserPlanId				
		ON 
			ea.AccountID = ou.AccountID
		WHERE 
			ea.ItemID = @ItemID ' + @condition

	exec sp_executesql @sql, N'@ItemID int',@ItemID

	DECLARE @RetCount int
	SELECT @RetCount = COUNT(ID) FROM #TempLyncUsers 

	IF (@SortDirection = 'ASC')
	BEGIN
		SELECT * FROM #TempLyncUsers 
		WHERE ID > @StartRow AND ID <= (@StartRow + @Count) 
	END
	ELSE
	BEGIN
		IF @SortColumn <> '' AND @SortColumn IS NOT NULL
		BEGIN
			IF (@SortColumn = 'DisplayName')
			BEGIN
				SELECT * FROM #TempLyncUsers 
					WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY DisplayName DESC
			END
			IF (@SortColumn = 'UserPrincipalName')
			BEGIN
				SELECT * FROM #TempLyncUsers 
					WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY UserPrincipalName DESC
			END

			IF (@SortColumn = 'SipAddress')
			BEGIN
				SELECT * FROM #TempLyncUsers 
					WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY SipAddress DESC
			END

			IF (@SortColumn = 'LyncUserPlanName')
			BEGIN
				SELECT * FROM #TempLyncUsers 
					WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY LyncUserPlanName DESC
			END
		END
		ELSE
		BEGIN
			SELECT * FROM #TempLyncUsers 
				WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY UserPrincipalName DESC
		END	
	END

	DROP TABLE #TempLyncUsers
END
				*/
				#endregion

				var users = ExchangeAccounts
					.Where(ea => ea.ItemId == itemId)
					.Join(LyncUsers, ea => ea.AccountId, lu => lu.AccountId, (ea, lu) => new
					{
						ea.AccountId,
						ea.ItemId,
						ea.AccountName,
						ea.DisplayName,
						ea.UserPrincipalName,
						lu.SipAddress,
						ea.SamAccountName,
						lu.LyncUserPlanId,
						lu.LyncUserPlan.LyncUserPlanName
					});

				var countUsers = users.Count();

				if (string.Equals(sortDirection, "ASC", StringComparison.OrdinalIgnoreCase))
				{
					users = users.OrderBy(sortColumn);
				} else
				{
					users = users.OrderBy($"{sortColumn} desc");
				}

				users = users.Skip(startRow).Take(count);

				return EntityDataReader(countUsers, users);
			}
			else
			{
				SqlParameter[] sqlParams = new SqlParameter[] {
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@SortColumn", sortColumn),
					new SqlParameter("@SortDirection", sortDirection),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("Count", count)
				};


				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetLyncUsers", sqlParams);
			}
		}


		public IDataReader GetLyncUsersByPlanId(int itemId, int planId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetLyncUsersByPlanId]
(
	@ItemID int,
	@PlanId int
)
AS

	SELECT
		ea.AccountID,
		ea.ItemID,
		ea.AccountName,
		ea.DisplayName,
		ea.UserPrincipalName,
		ea.SamAccountName,
		ou.LyncUserPlanId,
		lp.LyncUserPlanName
	FROM
		ExchangeAccounts ea
	INNER JOIN
		LyncUsers ou
	INNER JOIN
		LyncUserPlans lp
	ON
		ou.LyncUserPlanId = lp.LyncUserPlanId
	ON
		ea.AccountID = ou.AccountID
	WHERE
		ea.ItemID = @ItemID AND
		ou.LyncUserPlanId = @PlanId
				*/
				#endregion

				var users = ExchangeAccounts
					.Where(ea => ea.ItemId == itemId)
					.Join(LyncUsers, ea => ea.AccountId, lu => lu.AccountId, (ea, lu) => new
					{
						ea.AccountId,
						ea.ItemId,
						ea.AccountName,
						ea.DisplayName,
						ea.UserPrincipalName,
						ea.SamAccountName,
						lu.LyncUserPlanId,
						lu.LyncUserPlan.LyncUserPlanName
					})
					.Where(u => u.LyncUserPlanId == planId);
				return EntityDataReader(users);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetLyncUsersByPlanId",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@PlanId", planId));
			}
		}

		public int GetLyncUsersCount(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetLyncUsersCount]
(
	@ItemID int
)
AS

SELECT
	COUNT(ea.AccountID)
FROM
	ExchangeAccounts ea
INNER JOIN
	LyncUsers ou
ON
	ea.AccountID = ou.AccountID
WHERE
	ea.ItemID = @ItemID
				*/
				#endregion

				return ExchangeAccounts
					.Where(ea => ea.ItemId == itemId)
					.Join(LyncUsers, ea => ea.AccountId, l => l.AccountId, (ea, l) => null as object)
					.Count();
			}
			else
			{
				SqlParameter[] sqlParams = new[] { new SqlParameter("@ItemID", itemId) };

				return (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "GetLyncUsersCount", sqlParams);
			}
		}

		public void DeleteLyncUser(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteLyncUser]
(
	@AccountId int
)
AS

DELETE FROM
	LyncUsers
WHERE
	AccountId = @AccountId

RETURN
				*/
				#endregion

				LyncUsers.Where(u => u.AccountId == accountId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"DeleteLyncUser",
					new[] { new SqlParameter("@AccountId", accountId) });

			}
		}

		public int AddLyncUserPlan(int itemID, LyncUserPlan lyncUserPlan)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddLyncUserPlan] 
(
	@LyncUserPlanId int OUTPUT,
	@ItemID int,
	@LyncUserPlanName	nvarchar(300),
	@LyncUserPlanType int,
	@IM bit,
	@Mobility bit,
	@MobilityEnableOutsideVoice bit,
	@Federation bit,
	@Conferencing bit,
	@EnterpriseVoice bit,
	@VoicePolicy int,
	@IsDefault bit,

	@RemoteUserAccess bit,
	@PublicIMConnectivity bit,

	@AllowOrganizeMeetingsWithExternalAnonymous bit,

	@Telephony int,

	@ServerURI nvarchar(300),

	@ArchivePolicy  nvarchar(300),
	@TelephonyDialPlanPolicy nvarchar(300),
	@TelephonyVoicePolicy nvarchar(300)

)
AS

IF (((SELECT Count(*) FROM LyncUserPlans WHERE ItemId = @ItemID) = 0) AND (@LyncUserPlanType=0))
BEGIN
	SET @IsDefault = 1
END
ELSE
BEGIN
	IF ((@IsDefault = 1) AND (@LyncUserPlanType=0))
	BEGIN
		UPDATE LyncUserPlans SET IsDefault = 0 WHERE ItemID = @ItemID
	END
END

INSERT INTO LyncUserPlans
(
	ItemID,
	LyncUserPlanName,
	LyncUserPlanType,
	IM,
	Mobility,
	MobilityEnableOutsideVoice,
	Federation,
	Conferencing,
	EnterpriseVoice,
	VoicePolicy,
	IsDefault,

	RemoteUserAccess,
	PublicIMConnectivity,

	AllowOrganizeMeetingsWithExternalAnonymous,

	Telephony,

	ServerURI,

	ArchivePolicy,
	TelephonyDialPlanPolicy,
	TelephonyVoicePolicy

)
VALUES
(
	@ItemID,
	@LyncUserPlanName,
	@LyncUserPlanType,
	@IM,
	@Mobility,
	@MobilityEnableOutsideVoice,
	@Federation,
	@Conferencing,
	@EnterpriseVoice,
	@VoicePolicy,
	@IsDefault,

	@RemoteUserAccess,
	@PublicIMConnectivity,

	@AllowOrganizeMeetingsWithExternalAnonymous,

	@Telephony,

	@ServerURI,

	@ArchivePolicy,
	@TelephonyDialPlanPolicy,
	@TelephonyVoicePolicy

)

SET @LyncUserPlanId = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var isDefault = lyncUserPlan.IsDefault;
				var plans = LyncUserPlans.Where(p => p.ItemId == itemID);
				if (!plans.Any() && lyncUserPlan.LyncUserPlanType == 0)
				{
					isDefault = true;
				} else
				{
					if (isDefault && lyncUserPlan.LyncUserPlanType == 0)
					{
						foreach (var pl in plans) pl.IsDefault = false;
					}
				}

				var plan = new Data.Entities.LyncUserPlan()
				{
					ItemId = itemID,
					LyncUserPlanName = lyncUserPlan.LyncUserPlanName,
					LyncUserPlanType = lyncUserPlan.LyncUserPlanType,
					IM = lyncUserPlan.IM,
					Mobility = lyncUserPlan.Mobility,
					MobilityEnableOutsideVoice = lyncUserPlan.MobilityEnableOutsideVoice,
					Federation = lyncUserPlan.Federation,
					Conferencing = lyncUserPlan.Conferencing,
					EnterpriseVoice = lyncUserPlan.EnterpriseVoice,
					VoicePolicy = lyncUserPlan.VoicePolicy,
					IsDefault = lyncUserPlan.IsDefault,
					RemoteUserAccess = lyncUserPlan.RemoteUserAccess,
					PublicIMConnectivity = lyncUserPlan.PublicIMConnectivity,
					AllowOrganizeMeetingsWithExternalAnonymous = lyncUserPlan.AllowOrganizeMeetingsWithExternalAnonymous,
					Telephony = lyncUserPlan.Telephony,
					ServerUri = lyncUserPlan.ServerURI,
					ArchivePolicy = lyncUserPlan.ArchivePolicy,
					TelephonyDialPlanPolicy = lyncUserPlan.TelephonyDialPlanPolicy,
					TelephonyVoicePolicy = lyncUserPlan.TelephonyVoicePolicy
				};
				LyncUserPlans.Add(plan);
				SaveChanges();
				return plan.LyncUserPlanId;
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@LyncUserPlanId", SqlDbType.Int);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddLyncUserPlan",
					outParam,
					new SqlParameter("@ItemID", itemID),
					new SqlParameter("@LyncUserPlanName", lyncUserPlan.LyncUserPlanName),
					new SqlParameter("@LyncUserPlanType", lyncUserPlan.LyncUserPlanType),
					new SqlParameter("@IM", lyncUserPlan.IM),
					new SqlParameter("@Mobility", lyncUserPlan.Mobility),
					new SqlParameter("@MobilityEnableOutsideVoice", lyncUserPlan.MobilityEnableOutsideVoice),
					new SqlParameter("@Federation", lyncUserPlan.Federation),
					new SqlParameter("@Conferencing", lyncUserPlan.Conferencing),
					new SqlParameter("@EnterpriseVoice", lyncUserPlan.EnterpriseVoice),
					new SqlParameter("@VoicePolicy", lyncUserPlan.VoicePolicy),
					new SqlParameter("@IsDefault", lyncUserPlan.IsDefault),
					new SqlParameter("@RemoteUserAccess", lyncUserPlan.RemoteUserAccess),
					new SqlParameter("@PublicIMConnectivity", lyncUserPlan.PublicIMConnectivity),
					new SqlParameter("@AllowOrganizeMeetingsWithExternalAnonymous", lyncUserPlan.AllowOrganizeMeetingsWithExternalAnonymous),
					new SqlParameter("@Telephony", lyncUserPlan.Telephony),
					new SqlParameter("@ServerURI", lyncUserPlan.ServerURI),
					new SqlParameter("@ArchivePolicy", lyncUserPlan.ArchivePolicy),
					new SqlParameter("@TelephonyDialPlanPolicy", lyncUserPlan.TelephonyDialPlanPolicy),
					new SqlParameter("@TelephonyVoicePolicy", lyncUserPlan.TelephonyVoicePolicy));

				return Convert.ToInt32(outParam.Value);
			}
		}


		public void UpdateLyncUserPlan(int itemID, LyncUserPlan lyncUserPlan)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
 CREATE PROCEDURE [dbo].[UpdateLyncUserPlan] 
(
	@LyncUserPlanId int,
	@LyncUserPlanName	nvarchar(300),
	@LyncUserPlanType int,
	@IM bit,
	@Mobility bit,
	@MobilityEnableOutsideVoice bit,
	@Federation bit,
	@Conferencing bit,
	@EnterpriseVoice bit,
	@VoicePolicy int,
	@IsDefault bit,

	@RemoteUserAccess bit,
	@PublicIMConnectivity bit,

	@AllowOrganizeMeetingsWithExternalAnonymous bit,

	@Telephony int,

	@ServerURI nvarchar(300),

	@ArchivePolicy nvarchar(300),

	@TelephonyDialPlanPolicy nvarchar(300),
	@TelephonyVoicePolicy nvarchar(300)
)
AS

UPDATE LyncUserPlans SET
	LyncUserPlanName = @LyncUserPlanName,
	LyncUserPlanType = @LyncUserPlanType,
	IM = @IM,
	Mobility = @Mobility,
	MobilityEnableOutsideVoice = @MobilityEnableOutsideVoice,
	Federation = @Federation,
	Conferencing =@Conferencing,
	EnterpriseVoice = @EnterpriseVoice,
	VoicePolicy = @VoicePolicy,
	IsDefault = @IsDefault,

	RemoteUserAccess = @RemoteUserAccess,
	PublicIMConnectivity = @PublicIMConnectivity,

	AllowOrganizeMeetingsWithExternalAnonymous = @AllowOrganizeMeetingsWithExternalAnonymous,

	Telephony = @Telephony,

	ServerURI = @ServerURI,

	ArchivePolicy = @ArchivePolicy,
	TelephonyDialPlanPolicy = @TelephonyDialPlanPolicy,
	TelephonyVoicePolicy = @TelephonyVoicePolicy

WHERE LyncUserPlanId = @LyncUserPlanId

RETURN
				*/
				#endregion

				var plan = LyncUserPlans
					.FirstOrDefault(p => p.LyncUserPlanId == lyncUserPlan.LyncUserPlanId);
				if (plan != null)
				{
					plan.LyncUserPlanName = lyncUserPlan.LyncUserPlanName;
					plan.LyncUserPlanType = lyncUserPlan.LyncUserPlanType;
					plan.IM = lyncUserPlan.IM;
					plan.Mobility = lyncUserPlan.Mobility;
					plan.MobilityEnableOutsideVoice = lyncUserPlan.MobilityEnableOutsideVoice;
					plan.Federation = lyncUserPlan.Federation;
					plan.Conferencing = lyncUserPlan.Conferencing;
					plan.EnterpriseVoice = lyncUserPlan.EnterpriseVoice;
					plan.VoicePolicy = lyncUserPlan.VoicePolicy;
					plan.IsDefault = lyncUserPlan.IsDefault;
					plan.RemoteUserAccess = lyncUserPlan.RemoteUserAccess;
					plan.PublicIMConnectivity = lyncUserPlan.PublicIMConnectivity;
					plan.AllowOrganizeMeetingsWithExternalAnonymous = lyncUserPlan.AllowOrganizeMeetingsWithExternalAnonymous;
					plan.Telephony = lyncUserPlan.Telephony;
					plan.ServerUri= lyncUserPlan.ServerURI;
					plan.ArchivePolicy = lyncUserPlan.ArchivePolicy;
					plan.TelephonyDialPlanPolicy = lyncUserPlan.TelephonyDialPlanPolicy;
					plan.TelephonyVoicePolicy = lyncUserPlan.TelephonyVoicePolicy;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateLyncUserPlan",
					new SqlParameter("@LyncUserPlanId", lyncUserPlan.LyncUserPlanId),
					new SqlParameter("@LyncUserPlanName", lyncUserPlan.LyncUserPlanName),
					new SqlParameter("@LyncUserPlanType", lyncUserPlan.LyncUserPlanType),
					new SqlParameter("@IM", lyncUserPlan.IM),
					new SqlParameter("@Mobility", lyncUserPlan.Mobility),
					new SqlParameter("@MobilityEnableOutsideVoice", lyncUserPlan.MobilityEnableOutsideVoice),
					new SqlParameter("@Federation", lyncUserPlan.Federation),
					new SqlParameter("@Conferencing", lyncUserPlan.Conferencing),
					new SqlParameter("@EnterpriseVoice", lyncUserPlan.EnterpriseVoice),
					new SqlParameter("@VoicePolicy", lyncUserPlan.VoicePolicy),
					new SqlParameter("@IsDefault", lyncUserPlan.IsDefault),
					new SqlParameter("@RemoteUserAccess", lyncUserPlan.RemoteUserAccess),
					new SqlParameter("@PublicIMConnectivity", lyncUserPlan.PublicIMConnectivity),
					new SqlParameter("@AllowOrganizeMeetingsWithExternalAnonymous", lyncUserPlan.AllowOrganizeMeetingsWithExternalAnonymous),
					new SqlParameter("@Telephony", lyncUserPlan.Telephony),
					new SqlParameter("@ServerURI", lyncUserPlan.ServerURI),
					new SqlParameter("@ArchivePolicy", lyncUserPlan.ArchivePolicy),
					new SqlParameter("@TelephonyDialPlanPolicy", lyncUserPlan.TelephonyDialPlanPolicy),
					new SqlParameter("@TelephonyVoicePolicy", lyncUserPlan.TelephonyVoicePolicy));
			}
		}

		public void DeleteLyncUserPlan(int lyncUserPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteLyncUserPlan]
(
	@LyncUserPlanId int
)
AS

-- delete lyncuserplan
DELETE FROM LyncUserPlans
WHERE LyncUserPlanId = @LyncUserPlanId

RETURN
				*/
				#endregion

				LyncUserPlans.Where(p => p.LyncUserPlanId == lyncUserPlanId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteLyncUserPlan",
					new SqlParameter("@LyncUserPlanId", lyncUserPlanId));
			}
		}

		public IDataReader GetLyncUserPlan(int lyncUserPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetLyncUserPlan] 
(
	@LyncUserPlanId int
)
AS
SELECT
	LyncUserPlanId,
	ItemID,
	LyncUserPlanName,
	LyncUserPlanType,
	IM,
	Mobility,
	MobilityEnableOutsideVoice,
	Federation,
	Conferencing,
	EnterpriseVoice,
	VoicePolicy,
	IsDefault,

	RemoteUserAccess,
	PublicIMConnectivity,

	AllowOrganizeMeetingsWithExternalAnonymous,

	Telephony,

	ServerURI,

	ArchivePolicy,
	TelephonyDialPlanPolicy,
	TelephonyVoicePolicy

FROM
	LyncUserPlans
WHERE
	LyncUserPlanId = @LyncUserPlanId
RETURN
				*/
				#endregion

				var plan = LyncUserPlans
					.Where(p => p.LyncUserPlanId == lyncUserPlanId)
					.Select(p => new
					{
						p.LyncUserPlanId,
						p.ItemId,
						p.LyncUserPlanName,
						p.LyncUserPlanType,
						p.IM,
						p.Mobility,
						p.MobilityEnableOutsideVoice,
						p.Federation,
						p.Conferencing,
						p.EnterpriseVoice,
						p.VoicePolicy,
						p.IsDefault,
						p.RemoteUserAccess,
						p.PublicIMConnectivity,
						p.AllowOrganizeMeetingsWithExternalAnonymous,
						p.Telephony,
						p.ServerUri,
						p.ArchivePolicy,
						p.TelephonyDialPlanPolicy,
						p.TelephonyVoicePolicy
					});
				return EntityDataReader(plan);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetLyncUserPlan",
					new SqlParameter("@LyncUserPlanId", lyncUserPlanId));
			}
		}


		public IDataReader GetLyncUserPlans(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetLyncUserPlans]
(
	@ItemID int
)
AS
SELECT
	LyncUserPlanId,
	ItemID,
	LyncUserPlanName,
	LyncUserPlanType,
	IM,
	Mobility,
	MobilityEnableOutsideVoice,
	Federation,
	Conferencing,
	EnterpriseVoice,
	VoicePolicy,
	IsDefault
FROM
	LyncUserPlans
WHERE
	ItemID = @ItemID
ORDER BY LyncUserPlanName
RETURN
				*/
				#endregion

				var plans = LyncUserPlans
					.Where(p => p.ItemId == itemId)
					.OrderBy(p => p.LyncUserPlanName)
					.Select(p => new
					{
						p.LyncUserPlanId,
						p.ItemId,
						p.LyncUserPlanName,
						p.LyncUserPlanType,
						p.IM,
						p.Mobility,
						p.MobilityEnableOutsideVoice,
						p.Federation,
						p.Conferencing,
						p.EnterpriseVoice,
						p.VoicePolicy,
						p.IsDefault
					});
				return EntityDataReader(plans);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetLyncUserPlans",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public void SetOrganizationDefaultLyncUserPlan(int itemId, int lyncUserPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetOrganizationDefaultLyncUserPlan]
(
	@ItemID int,
	@LyncUserPlanId int
)
AS

UPDATE ExchangeOrganizations SET
	LyncUserPlanID = @LyncUserPlanId
WHERE
	ItemID = @ItemID

RETURN
				*/
				#endregion

#if NETFRAMEWORK
				var plan = ExchangeOrganizations
					.FirstOrDefault(o => o.ItemId == itemId);
				if (plan != null) {
					plan.LyncUserPlanId = lyncUserPlanId;
					SaveChanges();
				}
#else
				ExchangeOrganizations
					.Where(o => o.ItemId == itemId)
					.ExecuteUpdate(set => set
						.SetProperty(p => p.LyncUserPlanId, lyncUserPlanId));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"SetOrganizationDefaultLyncUserPlan",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@LyncUserPlanId", lyncUserPlanId));
			}
		}

		public IDataReader GetLyncUserPlanByAccountId(int AccountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetLyncUserPlanByAccountId]
(
	@AccountID int
)
AS
SELECT
	LyncUserPlanId,
	ItemID,
	LyncUserPlanName,
	LyncUserPlanType,
	IM,
	Mobility,
	MobilityEnableOutsideVoice,
	Federation,
	Conferencing,
	EnterpriseVoice,
	VoicePolicy,
	IsDefault
FROM
	LyncUserPlans
WHERE
	LyncUserPlanId IN (SELECT LyncUserPlanId FROM LyncUsers WHERE AccountID = @AccountID)
RETURN
				*/
				#endregion

				var plan = LyncUserPlans
					.Join(LyncUsers
						.Where(u => u.AccountId == AccountId),
						p => p.LyncUserPlanId, u => u.LyncUserPlanId, (p, u) => new
					{
						p.LyncUserPlanId,
						p.ItemId,
						p.LyncUserPlanName,
						p.LyncUserPlanType,
						p.IM,
						p.Mobility,
						p.MobilityEnableOutsideVoice,
						p.Federation,
						p.Conferencing,
						p.EnterpriseVoice,
						p.VoicePolicy,
						p.IsDefault
					});
				return EntityDataReader(plan);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetLyncUserPlanByAccountId",
					new SqlParameter("@AccountID", AccountId));
			}
		}

		public void SetLyncUserLyncUserplan(int accountId, int lyncUserPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetLyncUserLyncUserPlan]
(
	@AccountID int,
	@LyncUserPlanId int
)
AS

UPDATE LyncUsers SET
	LyncUserPlanId = @LyncUserPlanId
WHERE
	AccountID = @AccountID

RETURN
				*/
				#endregion

#if NETFRAMEWORK
				var user = LyncUsers.FirstOrDefault(u => u.AccountId == accountId);
				if (user != null)
				{
					user.LyncUserPlanId = lyncUserPlanId;
					SaveChanges();
				}
#else
				LyncUsers
					.Where(u => u.AccountId == accountId)
					.ExecuteUpdate(set => set
						.SetProperty(u => u.LyncUserPlanId, lyncUserPlanId));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"SetLyncUserLyncUserplan",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@LyncUserPlanId", (lyncUserPlanId == 0) ? (object)DBNull.Value : (object)lyncUserPlanId));
			}
		}
#endregion

		#region SfB

		public void AddSfBUser(int accountId, int sfbUserPlanId, string sipAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddSfBUser]
	@AccountID int,
	@SfBUserPlanID int,
	@SipAddress nvarchar(300)
AS
INSERT INTO
	dbo.SfBUsers
	(AccountID,
	 SfBUserPlanID,
	 CreatedDate,
	 ModifiedDate,
	 SipAddress)
VALUES
(
	@AccountID,
	@SfBUserPlanID,
	getdate(),
	getdate(),
	@SipAddress
)
				*/
				#endregion

				var now = DateTime.Now;
				var user = new Data.Entities.SfBUser()
				{
					AccountId = accountId,
					SfBUserPlanId = sfbUserPlanId,
					SipAddress = sipAddress,
					CreatedDate = now,
					ModifiedDate = now
				};
				SfBUsers.Add(user);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"AddSfBUser",
					new[] {
						new SqlParameter("@AccountID", accountId),
						new SqlParameter("@SfBUserPlanID", sfbUserPlanId),
						new SqlParameter("@SipAddress", sipAddress)
					});
			}
		}

		public void UpdateSfBUser(int accountId, string sipAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateSfBUser]
(
	@AccountID int,
	@SipAddress nvarchar(300)
)
AS

UPDATE SfBUsers SET
	SipAddress = @SipAddress
WHERE
	AccountID = @AccountID

RETURN
				*/
				#endregion

#if NETFRAMEWORK
				var user = SfBUsers.FirstOrDefault(u => u.AccountId == accountId);
				if (user != null)
				{
					user.SipAddress = sipAddress;
					SaveChanges();
				}
#else
				SfBUsers
					.Where(u => u.AccountId == accountId)
					.ExecuteUpdate(set => set
						.SetProperty(u => u.SipAddress, sipAddress));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"UpdateSfBUser",
					new[] {
						new SqlParameter("@AccountID", accountId),
						new SqlParameter("@SipAddress", sipAddress)
					});
			}
		}

		public bool CheckSfBUserExists(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckSfBUserExists]
	@AccountID int
AS
BEGIN
	SELECT
		COUNT(AccountID)
	FROM
		dbo.SfBUsers
	WHERE AccountID = @AccountID
END
				*/
				#endregion

				return SfBUsers.Any(u => u.AccountId == accountId);
			}
			else
			{
				int res = (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "CheckSfBUserExists",
				new SqlParameter("@AccountID", accountId));
				return res > 0;
			}
		}

		public bool SfBUserExists(int accountId, string sipAddress)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SfBUserExists]
(
	@AccountID int,
	@SipAddress nvarchar(300),
	@Exists bit OUTPUT
)
AS

	SET @Exists = 0
	IF EXISTS(SELECT * FROM [dbo].[ExchangeAccountEmailAddresses] WHERE [EmailAddress] = @SipAddress AND [AccountID] <> @AccountID)
		BEGIN
			SET @Exists = 1
		END
	ELSE IF EXISTS(SELECT * FROM [dbo].[ExchangeAccounts] WHERE [PrimaryEmailAddress] = @SipAddress AND [AccountID] <> @AccountID)
		BEGIN
			SET @Exists = 1
		END
	ELSE IF EXISTS(SELECT * FROM [dbo].[ExchangeAccounts] WHERE [UserPrincipalName] = @SipAddress AND [AccountID] <> @AccountID)
		BEGIN
			SET @Exists = 1
		END
	ELSE IF EXISTS(SELECT * FROM [dbo].[ExchangeAccounts] WHERE [AccountName] = @SipAddress AND [AccountID] <> @AccountID)
		BEGIN
			SET @Exists = 1
		END
	ELSE IF EXISTS(SELECT * FROM [dbo].[SfBUsers] WHERE [SipAddress] = @SipAddress)
		BEGIN
			SET @Exists = 1
		END

	RETURN
				*/
				#endregion

				return ExchangeAccountEmailAddresses.Any(a => a.EmailAddress == sipAddress && a.AccountId != accountId) ||
					ExchangeAccounts.Any(a => (a.PrimaryEmailAddress == sipAddress ||
						a.UserPrincipalName == sipAddress || a.AccountName == sipAddress) && a.AccountId != accountId) ||
					SfBUsers.Any(u => u.SipAddress == sipAddress);
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@Exists", SqlDbType.Bit);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"SfBUserExists",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@SipAddress", sipAddress),
					outParam);

				return Convert.ToBoolean(outParam.Value);
			}
		}

		public IDataReader GetSfBUsers(int itemId, string sortColumn, string sortDirection, int startRow, int count)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSfBUsers]
(
	@ItemID int,
	@SortColumn nvarchar(40),
	@SortDirection nvarchar(20),
	@StartRow int,
	@Count int	
)
AS
BEGIN
	CREATE TABLE #TempSfBUsers 
	(	
		[ID] [int] IDENTITY(1,1) NOT NULL,
		[AccountID] [int],	
		[ItemID] [int] NOT NULL,
		[AccountName] [nvarchar](300)  NOT NULL,
		[DisplayName] [nvarchar](300)  NOT NULL,
		[UserPrincipalName] [nvarchar](300) NULL,
		[SipAddress] [nvarchar](300) NULL,
		[SamAccountName] [nvarchar](100) NULL,
		[SfBUserPlanId] [int] NOT NULL,		
		[SfBUserPlanName] [nvarchar] (300) NOT NULL,		
	)

	DECLARE @condition nvarchar(700)
	SET @condition = ''

	IF (@SortColumn = 'DisplayName')
	BEGIN
		SET @condition = 'ORDER BY ea.DisplayName'
	END

	IF (@SortColumn = 'UserPrincipalName')
	BEGIN
		SET @condition = 'ORDER BY ea.UserPrincipalName'
	END

	IF (@SortColumn = 'SipAddress')
	BEGIN
		SET @condition = 'ORDER B*Y ou.SipAddress'
	END

	IF (@SortColumn = 'SfBUserPlanName')
	BEGIN
		SET @condition = 'ORDER BY lp.SfBUserPlanName'
	END

	DECLARE @sql nvarchar(3500)

	set @sql = '
		INSERT INTO 
# TempSfBUsers
		SELECT 
			ea.AccountID,
			ea.ItemID,
			ea.AccountName,
			ea.DisplayName,
			ea.UserPrincipalName,
			ou.SipAddress,
			ea.SamAccountName,
			ou.SfBUserPlanId,
			lp.SfBUserPlanName				
		FROM 
			ExchangeAccounts ea 
		INNER JOIN 
			SfBUsers ou
		INNER JOIN
			SfBUserPlans lp 
		ON
			ou.SfBUserPlanId = lp.SfBUserPlanId				
		ON 
			ea.AccountID = ou.AccountID
		WHERE 
			ea.ItemID = @ItemID ' + @condition

	exec sp_executesql @sql, N'@ItemID int',@ItemID

	DECLARE @RetCount int
	SELECT @RetCount = COUNT(ID) FROM #TempSfBUsers 

	IF (@SortDirection = 'ASC')
	BEGIN
		SELECT * FROM #TempSfBUsers 
		WHERE ID > @StartRow AND ID <= (@StartRow + @Count) 
	END
	ELSE
	BEGIN
		IF @SortColumn <> '' AND @SortColumn IS NOT NULL
		BEGIN
			IF (@SortColumn = 'DisplayName')
			BEGIN
				SELECT * FROM #TempSfBUsers 
					WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY DisplayName DESC
			END
			IF (@SortColumn = 'UserPrincipalName')
			BEGIN
				SELECT * FROM #TempSfBUsers 
					WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY UserPrincipalName DESC
			END

			IF (@SortColumn = 'SipAddress')
			BEGIN
				SELECT * FROM #TempSfBUsers 
					WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY SipAddress DESC
			END

			IF (@SortColumn = 'SfBUserPlanName')
			BEGIN
				SELECT * FROM #TempSfBUsers 
					WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY SfBUserPlanName DESC
			END
		END
		ELSE
		BEGIN
			SELECT * FROM #TempSfBUsers 
				WHERE ID >@RetCount - @Count - @StartRow AND ID <= @RetCount- @StartRow  ORDER BY UserPrincipalName DESC
		END	
	END
	DROP TABLE #TempSfBUsers
END
				*/
				#endregion

				var users = ExchangeAccounts
					.Where(ea => ea.ItemId == itemId)
					.Join(SfBUsers, ea => ea.AccountId, u => u.AccountId, (ea, u) => new
					{
						Account = ea,
						User = u
					})
					.Join(SfBUserPlans, u => u.User.SfBUserPlanId, p => p.SfBUserPlanId, (u, p) => new
					{
						u.Account.AccountId,
						u.Account.ItemId,
						u.Account.AccountName,
						u.Account.DisplayName,
						u.Account.UserPrincipalName,
						u.User.SipAddress,
						u.Account.SamAccountName,
						u.User.SfBUserPlanId,
						p.SfBUserPlanName
					});
				
				var countUsers = users.Count();

				if (string.Equals(sortDirection, "ASC", StringComparison.OrdinalIgnoreCase))
				{
					users = users.OrderBy(sortColumn);
				}
				else
				{
					users = users.OrderBy($"{sortColumn} desc");
				}

				users = users.Skip(startRow).Take(count);

				return EntityDataReader(countUsers, users);
			}
			else
			{
				SqlParameter[] sqlParams = new[]
				{
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@SortColumn", sortColumn),
					new SqlParameter("@SortDirection", sortDirection),
					new SqlParameter("@StartRow", startRow),
					new SqlParameter("Count", count)
				};

				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetSfBUsers", sqlParams);
			}
		}

		public IDataReader GetSfBUsersByPlanId(int itemId, int planId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSfBUsersByPlanId]
(
	@ItemID int,
	@PlanId int
)
AS

	SELECT
		ea.AccountID,
		ea.ItemID,
		ea.AccountName,
		ea.DisplayName,
		ea.UserPrincipalName,
		ea.SamAccountName,
		ou.SfBUserPlanId,
		lp.SfBUserPlanName
	FROM
		ExchangeAccounts ea
	INNER JOIN
		SfBUsers ou
	INNER JOIN
		SfBUserPlans lp
	ON
		ou.SfBUserPlanId = lp.SfBUserPlanId
	ON
		ea.AccountID = ou.AccountID
	WHERE
		ea.ItemID = @ItemID AND
		ou.SfBUserPlanId = @PlanId
				*/
				#endregion

				var users = ExchangeAccounts
					.Where(ea => ea.ItemId == itemId)
					.Join(SfBUsers, ea => ea.AccountId, u => u.AccountId, (ea, u) => new
					{
						Account = ea,
						User = u
					})
					.Where(u => u.User.SfBUserPlanId == planId)
					.Join(SfBUserPlans, u => u.User.SfBUserPlanId, p => p.SfBUserPlanId, (u, p) => new
					{
						u.Account.AccountId,
						u.Account.ItemId,
						u.Account.AccountName,
						u.Account.DisplayName,
						u.Account.UserPrincipalName,
						u.User.SipAddress,
						u.Account.SamAccountName,
						u.User.SfBUserPlanId,
						p.SfBUserPlanName
					});
				return EntityDataReader(users);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetSfBUsersByPlanId",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@PlanId", planId));
			}
		}

		public int GetSfBUsersCount(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSfBUsersCount]
(
	@ItemID int
)
AS

SELECT
	COUNT(ea.AccountID)
FROM
	ExchangeAccounts ea
INNER JOIN
	SfBUsers ou
ON
	ea.AccountID = ou.AccountID
WHERE
	ea.ItemID = @ItemID
				*/
				#endregion

				return ExchangeAccounts
					.Where(ea => ea.ItemId == itemId)
					.Join(SfBUsers, ea => ea.AccountId, u => u.AccountId, (ea, u) => ea)
					.Count();
			}
			else
			{
				SqlParameter[] sqlParams = new[] { new SqlParameter("@ItemID", itemId) };

				return (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "GetSfBUsersCount", sqlParams);
			}
		}

		public void DeleteSfBUser(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteSfBUser]
(
	@AccountId int
)
AS

DELETE FROM
	LyncUsers
WHERE
	AccountId = @AccountId

RETURN
				*/
				#endregion

				LyncUsers.Where(u => u.AccountId == accountId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"DeleteSfBUser",
					new[] { new SqlParameter("@AccountId", accountId) });
			}
		}

		public int AddSfBUserPlan(int itemID, SfBUserPlan sfbUserPlan)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddSfBUserPlan]
(
	@SfBUserPlanId int OUTPUT,
	@ItemID int,
	@SfBUserPlanName	nvarchar(300),
	@SfBUserPlanType int,
	@IM bit,
	@Mobility bit,
	@MobilityEnableOutsideVoice bit,
	@Federation bit,
	@Conferencing bit,
	@EnterpriseVoice bit,
	@VoicePolicy int,
	@IsDefault bit,
	@RemoteUserAccess bit,
	@PublicIMConnectivity bit,
	@AllowOrganizeMeetingsWithExternalAnonymous bit,
	@Telephony int,
	@ServerURI nvarchar(300),
	@ArchivePolicy  nvarchar(300),
	@TelephonyDialPlanPolicy nvarchar(300),
	@TelephonyVoicePolicy nvarchar(300)

)
AS

IF (((SELECT Count(*) FROM SfBUserPlans WHERE ItemId = @ItemID) = 0) AND (@SfBUserPlanType=0))
BEGIN
	SET @IsDefault = 1
END
ELSE
BEGIN
	IF ((@IsDefault = 1) AND (@SfBUserPlanType=0))
	BEGIN
		UPDATE SfBUserPlans SET IsDefault = 0 WHERE ItemID = @ItemID
	END
END

INSERT INTO SfBUserPlans
(
	ItemID,
	SfBUserPlanName,
	SfBUserPlanType,
	IM,
	Mobility,
	MobilityEnableOutsideVoice,
	Federation,
	Conferencing,
	EnterpriseVoice,
	VoicePolicy,
	IsDefault,
	RemoteUserAccess,
	PublicIMConnectivity,
	AllowOrganizeMeetingsWithExternalAnonymous,
	Telephony,
	ServerURI,
	ArchivePolicy,
	TelephonyDialPlanPolicy,
	TelephonyVoicePolicy

)
VALUES
(
	@ItemID,
	@SfBUserPlanName,
	@SfBUserPlanType,
	@IM,
	@Mobility,
	@MobilityEnableOutsideVoice,
	@Federation,
	@Conferencing,
	@EnterpriseVoice,
	@VoicePolicy,
	@IsDefault,
	@RemoteUserAccess,
	@PublicIMConnectivity,
	@AllowOrganizeMeetingsWithExternalAnonymous,
	@Telephony,
	@ServerURI,
	@ArchivePolicy,
	@TelephonyDialPlanPolicy,
	@TelephonyVoicePolicy
)

SET @SfBUserPlanId = SCOPE_IDENTITY()
RETURN
				*/
				#endregion

				var isDefault = sfbUserPlan.IsDefault;
				var plans = SfBUserPlans.Where(p => p.ItemId == itemID);
				if (!plans.Any() && sfbUserPlan.SfBUserPlanType == 0)
				{
					isDefault = true;
				}
				else
				{
					if (isDefault && sfbUserPlan.SfBUserPlanType == 0)
					{
						foreach (var pl in plans) pl.IsDefault = false;
					}
				}

				var plan = new Data.Entities.SfBUserPlan()
				{
					ItemId = itemID,
					SfBUserPlanName = sfbUserPlan.SfBUserPlanName,
					SfBUserPlanType = sfbUserPlan.SfBUserPlanType,
					IM = sfbUserPlan.IM,
					Mobility = sfbUserPlan.Mobility,
					MobilityEnableOutsideVoice = sfbUserPlan.MobilityEnableOutsideVoice,
					Federation = sfbUserPlan.Federation,
					Conferencing = sfbUserPlan.Conferencing,
					EnterpriseVoice = sfbUserPlan.EnterpriseVoice,
					VoicePolicy = sfbUserPlan.VoicePolicy,
					IsDefault = sfbUserPlan.IsDefault,
					RemoteUserAccess = sfbUserPlan.RemoteUserAccess,
					PublicIMConnectivity = sfbUserPlan.PublicIMConnectivity,
					AllowOrganizeMeetingsWithExternalAnonymous = sfbUserPlan.AllowOrganizeMeetingsWithExternalAnonymous,
					Telephony = sfbUserPlan.Telephony,
					ServerUri = sfbUserPlan.ServerURI,
					ArchivePolicy = sfbUserPlan.ArchivePolicy,
					TelephonyDialPlanPolicy = sfbUserPlan.TelephonyDialPlanPolicy,
					TelephonyVoicePolicy = sfbUserPlan.TelephonyVoicePolicy
				};
				SfBUserPlans.Add(plan);
				SaveChanges();
				return plan.SfBUserPlanId;
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@SfBUserPlanId", SqlDbType.Int);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddSfBUserPlan",
					outParam,
					new SqlParameter("@ItemID", itemID),
					new SqlParameter("@SfBUserPlanName", sfbUserPlan.SfBUserPlanName),
					new SqlParameter("@SfBUserPlanType", sfbUserPlan.SfBUserPlanType),
					new SqlParameter("@IM", sfbUserPlan.IM),
					new SqlParameter("@Mobility", sfbUserPlan.Mobility),
					new SqlParameter("@MobilityEnableOutsideVoice", sfbUserPlan.MobilityEnableOutsideVoice),
					new SqlParameter("@Federation", sfbUserPlan.Federation),
					new SqlParameter("@Conferencing", sfbUserPlan.Conferencing),
					new SqlParameter("@EnterpriseVoice", sfbUserPlan.EnterpriseVoice),
					new SqlParameter("@VoicePolicy", sfbUserPlan.VoicePolicy),
					new SqlParameter("@IsDefault", sfbUserPlan.IsDefault),
					new SqlParameter("@RemoteUserAccess", sfbUserPlan.RemoteUserAccess),
					new SqlParameter("@PublicIMConnectivity", sfbUserPlan.PublicIMConnectivity),
					new SqlParameter("@AllowOrganizeMeetingsWithExternalAnonymous", sfbUserPlan.AllowOrganizeMeetingsWithExternalAnonymous),
					new SqlParameter("@Telephony", sfbUserPlan.Telephony),
					new SqlParameter("@ServerURI", sfbUserPlan.ServerURI),
					new SqlParameter("@ArchivePolicy", sfbUserPlan.ArchivePolicy),
					new SqlParameter("@TelephonyDialPlanPolicy", sfbUserPlan.TelephonyDialPlanPolicy),
					new SqlParameter("@TelephonyVoicePolicy", sfbUserPlan.TelephonyVoicePolicy));

				return Convert.ToInt32(outParam.Value);
			}
		}


		public void UpdateSfBUserPlan(int itemID, SfBUserPlan sfbUserPlan)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateSfBUserPlan]
(
	@SfBUserPlanId int,
	@SfBUserPlanName	nvarchar(300),
	@SfBUserPlanType int,
	@IM bit,
	@Mobility bit,
	@MobilityEnableOutsideVoice bit,
	@Federation bit,
	@Conferencing bit,
	@EnterpriseVoice bit,
	@VoicePolicy int,
	@IsDefault bit
)
AS

UPDATE SfBUserPlans SET
	SfBUserPlanName = @SfBUserPlanName,
	SfBUserPlanType = @SfBUserPlanType,
	IM = @IM,
	Mobility = @Mobility,
	MobilityEnableOutsideVoice = @MobilityEnableOutsideVoice,
	Federation = @Federation,
	Conferencing =@Conferencing,
	EnterpriseVoice = @EnterpriseVoice,
	VoicePolicy = @VoicePolicy,
	IsDefault = @IsDefault
WHERE SfBUserPlanId = @SfBUserPlanId

RETURN
				*/
				#endregion

				var plan = SfBUserPlans.FirstOrDefault(u => u.SfBUserPlanId == sfbUserPlan.SfBUserPlanId);
				if (plan != null)
				{
					plan.SfBUserPlanName = sfbUserPlan.SfBUserPlanName;
					plan.SfBUserPlanType = sfbUserPlan.SfBUserPlanType;
					plan.IM = sfbUserPlan.IM;
					plan.Mobility = sfbUserPlan.Mobility;
					plan.MobilityEnableOutsideVoice = sfbUserPlan.MobilityEnableOutsideVoice;
					plan.Federation = sfbUserPlan.Federation;
					plan.Conferencing = sfbUserPlan.Conferencing;
					plan.EnterpriseVoice = sfbUserPlan.EnterpriseVoice;
					plan.VoicePolicy = sfbUserPlan.VoicePolicy;
					plan.IsDefault = sfbUserPlan.IsDefault;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateSfBUserPlan",
					new SqlParameter("@SfBUserPlanId", sfbUserPlan.SfBUserPlanId),
					new SqlParameter("@SfBUserPlanName", sfbUserPlan.SfBUserPlanName),
					new SqlParameter("@SfBUserPlanType", sfbUserPlan.SfBUserPlanType),
					new SqlParameter("@IM", sfbUserPlan.IM),
					new SqlParameter("@Mobility", sfbUserPlan.Mobility),
					new SqlParameter("@MobilityEnableOutsideVoice", sfbUserPlan.MobilityEnableOutsideVoice),
					new SqlParameter("@Federation", sfbUserPlan.Federation),
					new SqlParameter("@Conferencing", sfbUserPlan.Conferencing),
					new SqlParameter("@EnterpriseVoice", sfbUserPlan.EnterpriseVoice),
					new SqlParameter("@VoicePolicy", sfbUserPlan.VoicePolicy),
					new SqlParameter("@IsDefault", sfbUserPlan.IsDefault),
					new SqlParameter("@RemoteUserAccess", sfbUserPlan.RemoteUserAccess),
					new SqlParameter("@PublicIMConnectivity", sfbUserPlan.PublicIMConnectivity),
					new SqlParameter("@AllowOrganizeMeetingsWithExternalAnonymous", sfbUserPlan.AllowOrganizeMeetingsWithExternalAnonymous),
					new SqlParameter("@Telephony", sfbUserPlan.Telephony),
					new SqlParameter("@ServerURI", sfbUserPlan.ServerURI),
					new SqlParameter("@ArchivePolicy", sfbUserPlan.ArchivePolicy),
					new SqlParameter("@TelephonyDialPlanPolicy", sfbUserPlan.TelephonyDialPlanPolicy),
					new SqlParameter("@TelephonyVoicePolicy", sfbUserPlan.TelephonyVoicePolicy));
			}
		}

		public void DeleteSfBUserPlan(int sfbUserPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteSfBUserPlan]
(
	@SfBUserPlanId int
)
AS

-- delete sfbuserplan
DELETE FROM SfBUserPlans
WHERE SfBUserPlanId = @SfBUserPlanId

RETURN
				*/
				#endregion

				SfBUserPlans.Where(p => p.SfBUserPlanId == sfbUserPlanId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteSfBUserPlan",
					new SqlParameter("@SfBUserPlanId", sfbUserPlanId));
			}
		}

		public IDataReader GetSfBUserPlan(int sfbUserPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSfBUserPlan] 
(
	@SfBUserPlanId int
)
AS
SELECT
	SfBUserPlanId,
	ItemID,
	SfBUserPlanName,
	SfBUserPlanType,
	IM,
	Mobility,
	MobilityEnableOutsideVoice,
	Federation,
	Conferencing,
	EnterpriseVoice,
	VoicePolicy,
	IsDefault,
	RemoteUserAccess,
	PublicIMConnectivity,
	AllowOrganizeMeetingsWithExternalAnonymous,
	Telephony,
	ServerURI,
	ArchivePolicy,
	TelephonyDialPlanPolicy,
	TelephonyVoicePolicy

FROM
	SfBUserPlans
WHERE
	SfBUserPlanId = @SfBUserPlanId
RETURN
				*/
				#endregion

				var plan = SfBUserPlans
					.Where(p => p.SfBUserPlanId == sfbUserPlanId)
					.Select(p => new
					{
						p.SfBUserPlanId,
						p.ItemId,
						p.SfBUserPlanName,
						p.SfBUserPlanType,
						p.IM,
						p.Mobility,
						p.MobilityEnableOutsideVoice,
						p.Federation,
						p.Conferencing,
						p.EnterpriseVoice,
						p.VoicePolicy,
						p.IsDefault,
						p.RemoteUserAccess,
						p.PublicIMConnectivity,
						p.AllowOrganizeMeetingsWithExternalAnonymous,
						p.Telephony,
						p.ServerUri,
						p.ArchivePolicy,
						p.TelephonyDialPlanPolicy,
						p.TelephonyVoicePolicy
					});
				return EntityDataReader(plan);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetSfBUserPlan",
					new SqlParameter("@SfBUserPlanId", sfbUserPlanId));
			}
		}


		public IDataReader GetSfBUserPlans(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSfBUserPlans]
(
	@ItemID int
)
AS
SELECT
	SfBUserPlanId,
	ItemID,
	SfBUserPlanName,
	SfBUserPlanType,
	IM,
	Mobility,
	MobilityEnableOutsideVoice,
	Federation,
	Conferencing,
	EnterpriseVoice,
	VoicePolicy,
	IsDefault
FROM
	SfBUserPlans
WHERE
	ItemID = @ItemID
ORDER BY SfBUserPlanName
RETURN
				*/
				#endregion

				var plans = SfBUserPlans
					.Where(p => p.ItemId == itemId)
					.OrderBy(p => p.SfBUserPlanName)
					.Select(p => new
					{
						p.SfBUserPlanId,
						p.ItemId,
						p.SfBUserPlanName,
						p.SfBUserPlanType,
						p.IM,
						p.Mobility,
						p.MobilityEnableOutsideVoice,
						p.Federation,
						p.Conferencing,
						p.EnterpriseVoice,
						p.VoicePolicy,
						p.IsDefault
					});
				return EntityDataReader(plans);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetSfBUserPlans",
					new SqlParameter("@ItemID", itemId));
			}
		}


		public void SetOrganizationDefaultSfBUserPlan(int itemId, int sfbUserPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetOrganizationDefaultSfBUserPlan]
(
	@ItemID int,
	@SfBUserPlanId int
)
AS

UPDATE ExchangeOrganizations SET
	SfBUserPlanID = @SfBUserPlanId
WHERE
	ItemID = @ItemID

RETURN
				*/
				#endregion

#if NETFRAMEWORK
				var org = ExchangeOrganizations.FirstOrDefault(o => o.ItemId == itemId);
				if (org != null)
				{
					org.SfBuserPlanId = sfbUserPlanId;
					SaveChanges();
				}
#else
				ExchangeOrganizations
					.Where(o => o.ItemId == itemId)
					.ExecuteUpdate(set => set
						.SetProperty(o => o.SfBuserPlanId, sfbUserPlanId));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"SetOrganizationDefaultSfBUserPlan",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@SfBUserPlanId", sfbUserPlanId));
			}
		}

		public IDataReader GetSfBUserPlanByAccountId(int AccountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSfBUserPlanByAccountId]
(
	@AccountID int
)
AS
SELECT
	SfBUserPlanId,
	ItemID,
	SfBUserPlanName,
	SfBUserPlanType,
	IM,
	Mobility,
	MobilityEnableOutsideVoice,
	Federation,
	Conferencing,
	EnterpriseVoice,
	VoicePolicy,
	IsDefault
FROM
	SfBUserPlans
WHERE
	SfBUserPlanId IN (SELECT SfBUserPlanId FROM SfBUsers WHERE AccountID = @AccountID)
RETURN
				*/
				#endregion

				var plans = SfBUserPlans
					.Join(SfBUsers
						.Where(u => u.AccountId == AccountId),
						p => p.SfBUserPlanId, u => u.SfBUserPlanId, (p, u) => p)
					.OrderBy(p => p.SfBUserPlanName)
					.Select(p => new
					{
						p.SfBUserPlanId,
						p.ItemId,
						p.SfBUserPlanName,
						p.SfBUserPlanType,
						p.IM,
						p.Mobility,
						p.MobilityEnableOutsideVoice,
						p.Federation,
						p.Conferencing,
						p.EnterpriseVoice,
						p.VoicePolicy,
						p.IsDefault
					});
				return EntityDataReader(plans);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetSfBUserPlanByAccountId",
					new SqlParameter("@AccountID", AccountId));
			}
		}


		public void SetSfBUserSfBUserPlan(int accountId, int sfbUserPlanId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[SetSfBUserSfBUserPlan]
(
	@AccountID int,
	@SfBUserPlanId int
)
AS

UPDATE SfBUsers SET
	SfBUserPlanId = @SfBUserPlanId
WHERE
	AccountID = @AccountID

RETURN
				*/
				#endregion

#if NETFRAMEWORK
				var user = SfBUsers.FirstOrDefault(u => u.AccountId == accountId);
				if (user != null)
				{
					user.SfBUserPlanId = sfbUserPlanId;
					SaveChanges();
				}
#else
				SfBUsers
					.Where(u => u.AccountId == accountId)
					.ExecuteUpdate(set => set
						.SetProperty(u => u.SfBUserPlanId, sfbUserPlanId));
#endif
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"SetSfBUserSfBUserPlan",
					new SqlParameter("@AccountID", accountId),
					new SqlParameter("@SfBUserPlanId", (sfbUserPlanId == 0) ? (object)DBNull.Value : (object)sfbUserPlanId));
			}
		}
		#endregion

		#region Diverse Methods
		public int GetPackageIdByName(string Name)
		{
			const bool UseEntityFrameworkForGetPackageIdByName = true;

			int packageId = -1;

			if (UseEntityFrameworkForGetPackageIdByName || UseEntityFramework)
			{
				Name = Name.ToUpper();
				packageId = Packages
					.Where(p => Name == p.PackageName.ToUpper())
					.Select(p => (int?)p.PackageId)
					.FirstOrDefault() ?? -1;
				return packageId;
			}
			else
			{   // TODO is this a bug? Querying Providers instead of Packages? But this routine has no
				// references, so the bug does not show up
				List<ProviderInfo> providers = ServerController.GetProviders();
				foreach (ProviderInfo providerInfo in providers)
				{
					if (string.Equals(Name, providerInfo.ProviderName, StringComparison.OrdinalIgnoreCase))
					{
						packageId = providerInfo.ProviderId;
						break;
					}
				}

				//if (-1 == packageId)
				//{
				//    throw new Exception("Provider not found");
				//}

				return packageId;
			}
		}
		public int GetServiceIdByProviderForServer(int providerId, int packageId)
		{
			if (UseEntityFramework)
			{
				return PackageServices
					.Where(p => p.PackageId == packageId)
					.Join(Services.Where(s => s.ProviderId == providerId),
						p => p.ServiceId, s => s.ServiceId, (p, s) => (int?)p.ServiceId)
					.FirstOrDefault() ?? -1;
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.Text,
@"SELECT TOP 1
	PackageServices.ServiceID
FROM PackageServices
LEFT JOIN Services ON Services.ServiceID = PackageServices.ServiceID
WHERE PackageServices.PackageID = @PackageID AND Services.ProviderID = @ProviderID",
					new SqlParameter("@ProviderID", providerId),
					new SqlParameter("@PackageID", packageId));

				if (reader.Read())
				{
					return (int)reader["ServiceID"];
				}

				return -1;
			}
		}
		#endregion

		#region Helicon Zoo

		public void GetHeliconZooProviderAndGroup(string providerName, out int providerId, out int groupId)
		{
			if (UseEntityFramework)
			{
				var provider = Providers
					.Where(p => p.ProviderName == providerName)
					.Select(p => new { p.ProviderId, p.GroupId })
					.FirstOrDefault();
				providerId = provider?.ProviderId ?? 0;
				groupId = provider?.GroupId ?? 0;
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.Text,
@"SELECT TOP 1 
	ProviderID, GroupID
FROM Providers
WHERE ProviderName = @ProviderName",
					new SqlParameter("@ProviderName", providerName));

				reader.Read();

				providerId = (int)reader["ProviderID"];
				groupId = (int)reader["GroupID"];
			}
		}

		public IDataReader GetHeliconZooQuotas(int providerId)
		{
			if (UseEntityFramework)
			{
				var quota = Providers
					.Where(p => p.ProviderId == providerId)
					.Join(Quotas, p => p.GroupId, q => q.GroupId, (p, q) => new
					{
						q.QuotaId,
						q.GroupId,
						q.QuotaName,
						q.QuotaDescription,
						q.QuotaTypeId,
						q.ServiceQuota
					});
				return EntityDataReader(quota);
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.Text,
@"SELECT
	Q.QuotaID,
	Q.GroupID,
	Q.QuotaName,
	Q.QuotaDescription,
	Q.QuotaTypeID,
	Q.ServiceQuota
FROM Providers AS P
INNER JOIN Quotas AS Q ON P.GroupID = Q.GroupID
WHERE P.ProviderID = @ProviderID",
					new SqlParameter("@ProviderID", providerId));

				return reader;
			}
		}

		public void RemoveHeliconZooQuota(int groupId, string engineName)
		{
			if (UseEntityFramework)
			{
				var quotaId = Quotas
					.Where(q => q.QuotaName == engineName)
					.Select(q => q.QuotaId)
					.FirstOrDefault();
				HostingPlanQuotas.Where(q => q.QuotaId == quotaId).ExecuteDelete();
				Quotas.Where(q => q.QuotaId == quotaId).ExecuteDelete();
			}
			else
			{
				int quotaId;

				// find quota id
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.Text,
@"SELECT TOP 1 QuotaID
FROM Quotas
WHERE QuotaName = @QuotaName AND GroupID = @GroupID",
					new SqlParameter("@QuotaName", engineName),
					new SqlParameter("@GroupID", groupId));

				reader.Read();
				quotaId = (int)reader["QuotaID"];

				// delete references from HostingPlanQuotas
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.Text,
					"DELETE FROM HostingPlanQuotas WHERE QuotaID = @QuotaID",
					new SqlParameter("@QuotaID", quotaId));

				// delete from Quotas
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.Text,
					"DELETE FROM Quotas WHERE QuotaID = @QuotaID",
					new SqlParameter("@QuotaID", quotaId));
			}
		}

		public void AddHeliconZooQuota(int groupId, int quotaId, string engineName, string engineDescription, int quotaOrder)
		{
			if (UseEntityFramework)
			{
				var quota = new Data.Entities.Quota()
				{
					QuotaId = quotaId,
					GroupId = groupId,
					QuotaOrder = quotaOrder,
					QuotaName = engineName,
					QuotaDescription = engineDescription,
					QuotaTypeId = 1,
					ServiceQuota = false
				};
				Quotas.Add(quota);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.Text,
@"INSERT INTO Quotas (QuotaID, GroupID, QuotaOrder, QuotaName, QuotaDescription, QuotaTypeID, ServiceQuota)
VALUES (@QuotaID, @GroupID, @QuotaOrder, @QuotaName, @QuotaDescription, 1, 0)",
					new SqlParameter("@QuotaID", quotaId),
					new SqlParameter("@GroupID", groupId),
					new SqlParameter("@QuotaOrder", quotaOrder),
					new SqlParameter("@QuotaName", engineName),
					new SqlParameter("@QuotaDescription", engineDescription));
			}
		}

		public IDataReader GetEnabledHeliconZooQuotasForPackage(int packageId)
		{
			int providerId, groupId;

			GetHeliconZooProviderAndGroup("HeliconZoo", out providerId, out groupId);

			if (UseEntityFramework)
			{
				var quotas = HostingPlanQuotas
					.SelectMany(q => q.Plan.Packages.DefaultIfEmpty(), (q, p) => new
					{
						q.QuotaId,
						q.Quota.QuotaName,
						q.Quota.QuotaDescription,
						q.Quota.GroupId,
						q.QuotaValue,
						p.PackageId
					})
					.Where(q => q.PackageId == packageId && q.GroupId == groupId && q.QuotaValue == 1)
					.Select(q => new { q.QuotaId, q.QuotaName, q.QuotaDescription });
				return EntityDataReader(quotas);
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.Text,
@"SELECT HostingPlanQuotas.QuotaID, Quotas.QuotaName, Quotas.QuotaDescription
FROM HostingPlanQuotas 
INNER JOIN Packages ON HostingPlanQuotas.PlanID = Packages.PlanID 
INNER JOIN Quotas ON HostingPlanQuotas.QuotaID = Quotas.QuotaID
WHERE (Packages.PackageID = @PackageID) AND (Quotas.GroupID = @GroupID) AND (HostingPlanQuotas.QuotaValue = 1)",
					new SqlParameter("@PackageID", packageId),
					new SqlParameter("@GroupID", groupId));

				return reader;
			}
		}

		public int GetServiceIdForProviderIdAndPackageId(int providerId, int packageId)
		{
			if (UseEntityFramework)
			{
				var serviceId = Packages.Where(p => p.PackageId == packageId)
					.SelectMany(p => p.Services.Where(s => s.ProviderId == providerId))
					.Select(s => (int?)s.ServiceId)
					.FirstOrDefault() ?? -1;
				return serviceId;
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.Text,
@"SELECT PackageServices.ServiceID 
FROM PackageServices
INNER JOIN Services ON PackageServices.ServiceID = Services.ServiceID
WHERE Services.ProviderID = @ProviderID and PackageID = @PackageID",
					new SqlParameter("@ProviderID", providerId),
					new SqlParameter("@PackageID", packageId));

				if (reader.Read())
				{
					return (int)reader["ServiceID"];
				}

				return -1;
			}
		}

		public int GetServerIdForPackage(int packageId)
		{
			if (UseEntityFramework)
			{
				return Packages
					.Where(p => p.PackageId == packageId)
					.Select(p => p.ServerId)
					.FirstOrDefault() ?? -1;
			}
			else
			{
				IDataReader reader = SqlHelper.ExecuteReader(ConnectionString, CommandType.Text,
@"SELECT TOP 1 
ServerID
FROM Packages
WHERE PackageID = @PackageID",
					new SqlParameter("@PackageID", packageId));

				if (reader.Read())
				{
					return (int)reader["ServerID"];
				}

				return -1;
			}
		}
		#endregion

		#region Enterprise Storage

		public int AddWebDavAccessToken(Base.HostedSolution.WebDavAccessToken accessToken)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddWebDavAccessToken]
(
	@TokenID INT OUTPUT,
	@FilePath NVARCHAR(MAX),
	@AccessToken UNIQUEIDENTIFIER,
	@AuthData NVARCHAR(MAX),
	@ExpirationDate DATETIME,
	@AccountID INT,
	@ItemId INT
)
AS
INSERT INTO WebDavAccessTokens
(
	FilePath,
	AccessToken,
	AuthData,
	ExpirationDate,
	AccountID  ,
	ItemId
)
VALUES
(
	@FilePath ,
	@AccessToken  ,
	@AuthData,
	@ExpirationDate ,
	@AccountID,
	@ItemId
)

SET @TokenID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var token = new Data.Entities.WebDavAccessToken()
				{
					FilePath = accessToken.FilePath,
					AccessToken = accessToken.AccessToken,
					AuthData = accessToken.AuthData,
					ExpirationDate = accessToken.ExpirationDate,
					AccountId = accessToken.AccountId,
					ItemId = accessToken.ItemId
				};
				WebDavAccessTokens.Add(token);
				SaveChanges();
				return token.Id;
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@TokenID", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddWebDavAccessToken",
					prmId,
					new SqlParameter("@AccessToken", accessToken.AccessToken),
					new SqlParameter("@FilePath", accessToken.FilePath),
					new SqlParameter("@AuthData", accessToken.AuthData),
					new SqlParameter("@ExpirationDate", accessToken.ExpirationDate),
					new SqlParameter("@AccountID", accessToken.AccountId),
					new SqlParameter("@ItemId", accessToken.ItemId));

				// read identity
				return Convert.ToInt32(prmId.Value);
			}
		}

		public void DeleteExpiredWebDavAccessTokens()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteExpiredWebDavAccessTokens]
AS
DELETE FROM WebDavAccessTokens
WHERE ExpirationDate < getdate()
				*/
				#endregion

				var now = DateTime.Now;
				WebDavAccessTokens.Where(p => p.ExpirationDate < now).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteExpiredWebDavAccessTokens");
			}
		}

		public IDataReader GetWebDavAccessTokenById(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetWebDavAccessTokenById]
(
	@Id int
)
AS
SELECT 
	ID ,
	FilePath ,
	AuthData ,
	AccessToken,
	ExpirationDate,
	AccountID,
	ItemId
FROM WebDavAccessTokens 
WHERE ID = @Id AND ExpirationDate > getdate()
				*/
				#endregion

				var now = DateTime.Now;
				var tokens = WebDavAccessTokens
					.Where(t => t.Id == id && t.ExpirationDate > now);
				return EntityDataReader(tokens);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetWebDavAccessTokenById",
					new SqlParameter("@Id", id));
			}
		}

		public IDataReader GetWebDavAccessTokenByAccessToken(Guid accessToken)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetWebDavAccessTokenByAccessToken]
(
	@AccessToken UNIQUEIDENTIFIER
)
AS
SELECT 
	ID ,
	FilePath ,
	AuthData ,
	AccessToken,
	ExpirationDate,
	AccountID,
	ItemId
FROM WebDavAccessTokens 
WHERE AccessToken = @AccessToken AND ExpirationDate > getdate()
				*/
				#endregion

				var now = DateTime.Now;
				var tokens = WebDavAccessTokens
					.Where(t => t.AccessToken == accessToken && t.ExpirationDate > now);
				return EntityDataReader(tokens);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetWebDavAccessTokenByAccessToken",
					new SqlParameter("@AccessToken", accessToken));
			}
		}

		public int AddEnterpriseFolder(int itemId, string folderName, int folderQuota, string locationDrive, string homeFolder, string domain, int? storageSpaceFolderId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddEnterpriseFolder]
(
	@FolderID INT OUTPUT,
	@ItemID INT,
	@FolderName NVARCHAR(255),
	@FolderQuota INT,
	@LocationDrive NVARCHAR(255),
	@HomeFolder NVARCHAR(255),
	@Domain NVARCHAR(255),
	@StorageSpaceFolderId INT
)
AS

INSERT INTO EnterpriseFolders
(
	ItemID,
	FolderName,
	FolderQuota,
	LocationDrive,
	HomeFolder,
	Domain,
	StorageSpaceFolderId
)
VALUES
(
	@ItemID,
	@FolderName,
	@FolderQuota,
	@LocationDrive,
	@HomeFolder,
	@Domain,
	@StorageSpaceFolderId
)

SET @FolderID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var folder = new Data.Entities.EnterpriseFolder()
				{
					ItemId = itemId,
					FolderName = folderName,
					FolderQuota = folderQuota,
					LocationDrive = locationDrive,
					HomeFolder = homeFolder,
					Domain = domain,
					StorageSpaceFolderId = storageSpaceFolderId
				};
				EnterpriseFolders.Add(folder);
				SaveChanges();
				return folder.EnterpriseFolderId;
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@FolderID", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddEnterpriseFolder",
					prmId,
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@FolderName", folderName),
					new SqlParameter("@FolderQuota", folderQuota),
					new SqlParameter("@LocationDrive", locationDrive),
					new SqlParameter("@HomeFolder", homeFolder),
					new SqlParameter("@Domain", domain),
					new SqlParameter("@StorageSpaceFolderId", storageSpaceFolderId));

				// read identity
				return Convert.ToInt32(prmId.Value);
			}
		}

		public void UpdateEnterpriseFolderStorageSpaceFolder(int itemId, string folderName, int? storageSpaceFolderId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
				CREATE PROCEDURE [dbo].[UpdateEntepriseFolderStorageSpaceFolder]
				(
				@ItemID INT,
				@FolderName NVARCHAR(255),
				@StorageSpaceFolderId INT
				)
				AS

				UPDATE EnterpriseFolders
				SET StorageSpaceFolderId = @StorageSpaceFolderId
				WHERE ItemID = @ItemID AND FolderName = @FolderName
				*/
				#endregion

				EnterpriseFolders
					.Where(f => f.ItemId == itemId && f.FolderName == folderName)
					.ExecuteUpdate(e => new Data.Entities.EnterpriseFolder
					{
						StorageSpaceFolderId = storageSpaceFolderId
					});
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateEntepriseFolderStorageSpaceFolder",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@FolderName", folderName),
					new SqlParameter("@StorageSpaceFolderId", storageSpaceFolderId));
			}
		}

		public void DeleteEnterpriseFolder(int itemId, string folderName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteEnterpriseFolder]
(
	@ItemID INT,
	@FolderName NVARCHAR(255)
)
AS

DELETE FROM EnterpriseFolders
WHERE ItemID = @ItemID AND FolderName = @FolderName
				*/
				#endregion

				EnterpriseFolders.Where(f => f.ItemId == itemId && f.FolderName == folderName)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteEnterpriseFolder",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@FolderName", folderName));
			}
		}

		public void UpdateEnterpriseFolder(int itemId, string folderID, string folderName, int folderQuota)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateEnterpriseFolder]
(
	@ItemID INT,
	@FolderID NVARCHAR(255),
	@FolderName NVARCHAR(255),
	@FolderQuota INT
)
AS

UPDATE EnterpriseFolders SET
	FolderName = @FolderName,
	FolderQuota = @FolderQuota
WHERE ItemID = @ItemID AND FolderName = @FolderID
				*/
				#endregion

				EnterpriseFolders
					.Where(f => f.ItemId == itemId && f.FolderName == folderID)
					.ExecuteUpdate(e => new Data.Entities.EnterpriseFolder
					{
						FolderName = folderName,
						FolderQuota = folderQuota
					});
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateEnterpriseFolder",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@FolderID", folderID),
					new SqlParameter("@FolderName", folderName),
					new SqlParameter("@FolderQuota", folderQuota));
			}
		}

		public IDataReader GetEnterpriseFolders(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetEnterpriseFolders]
(
	@ItemID INT
)
AS

SELECT DISTINCT LocationDrive, HomeFolder, Domain FROM EnterpriseFolders
WHERE ItemID = @ItemID
				*/
				#endregion

				var folders = EnterpriseFolders
					.Where(f => f.ItemId == itemId)
					.Select(f => new { f.LocationDrive, f.HomeFolder, f.Domain })
					.Distinct();
				return EntityDataReader(folders);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetEnterpriseFolders",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public DataSet GetEnterpriseFoldersPaged(int itemId, string filterColumn, string filterValue, string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetEnterpriseFoldersPaged]
(
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@ItemID int,
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS
-- build query and run it to the temporary table
DECLARE @sql nvarchar(2000)

SET @sql = '
DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows

DECLARE @Folders TABLE
(
	ItemPosition int IDENTITY(1,1),
	Id int
)
INSERT INTO @Folders (Id)
SELECT
	S.EnterpriseFolderID
FROM EnterpriseFolders AS S
WHERE @ItemID = S.ItemID'

IF @FilterColumn <> '' AND @FilterValue <> ''
SET @sql = @sql + ' AND ' + @FilterColumn + ' LIKE @FilterValue '

IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + ' SELECT COUNT(Id) FROM @Folders;
SELECT
	ST.EnterpriseFolderID,
	ST.ItemID,
	ST.FolderName,
	ST.FolderQuota,
	ST.LocationDrive,
	ST.HomeFolder,
	ST.Domain,
	ST.StorageSpaceFolderId,
	ssf.Name,
	ssf.StorageSpaceId,
	ssf.Path,
	ssf.UncPath,
	ssf.IsShared,
	ssf.FsrmQuotaType,
	ssf.FsrmQuotaSizeBytes
FROM @Folders AS S
INNER JOIN EnterpriseFolders AS ST ON S.Id = ST.EnterpriseFolderID
LEFT OUTER JOIN StorageSpaceFolders as ssf on ssf.Id = ST.StorageSpaceFolderId
WHERE S.ItemPosition BETWEEN @StartRow AND @EndRow'

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int,  @FilterValue nvarchar(50),  @ItemID int',
@StartRow, @MaximumRows,  @FilterValue,  @ItemID

RETURN
				*/
				#endregion

				var folders = EnterpriseFolders
					.Where(f => f.ItemId == itemId)
					.Select(f => new
					{
						f.EnterpriseFolderId,
						f.ItemId,
						f.FolderName,
						f.FolderQuota,
						f.LocationDrive,
						f.HomeFolder,
						f.Domain,
						f.StorageSpaceFolderId,
						Name = f.StorageSpaceFolder != null ? f.StorageSpaceFolder.Name : null,
						StorageSpaceId = f.StorageSpaceFolder != null ? (int?)f.StorageSpaceFolder.StorageSpaceId : null,
						Path = f.StorageSpaceFolder != null ? f.StorageSpaceFolder.Path : null,
						UncPath = f.StorageSpaceFolder != null ? f.StorageSpaceFolder.UncPath : null,
						IsShared = f.StorageSpaceFolder != null ? (bool?)f.StorageSpaceFolder.IsShared : null,
						FsrmQuotaType = f.StorageSpaceFolder != null ? (QuotaType?)f.StorageSpaceFolder.FsrmQuotaType : null,
						FsrmQuotaSizeBytes = f.StorageSpaceFolder != null ? (long?)f.StorageSpaceFolder.FsrmQuotaSizeBytes : null
					});

				if (!string.IsNullOrEmpty(filterColumn) && !string.IsNullOrEmpty(filterValue))
				{
					folders = folders.Where(DynamicFunctions.ColumnLike(folders, filterColumn, filterValue));
				}

				var count = folders.Count();

				if (!string.IsNullOrEmpty(sortColumn))
				{
					folders = folders.OrderBy(sortColumn);
				}

				folders = folders.Skip(startRow).Take(maximumRows);

				return EntityDataSet(count, folders);
			}
			else
			{
				return SqlHelper.ExecuteDataset(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetEnterpriseFoldersPaged",
					new SqlParameter("@ItemId", itemId),
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public IDataReader GetEnterpriseFolder(int itemId, string folderName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetEnterpriseFolder]
(
	@ItemID INT,
	@FolderName NVARCHAR(255)
)
AS

SELECT TOP 1
	ST.EnterpriseFolderID,
	ST.ItemID,
	ST.FolderName,
	ST.FolderQuota,
	ST.LocationDrive,
	ST.HomeFolder,
	ST.Domain,
	ST.StorageSpaceFolderId,
	ssf.Name,
	ssf.StorageSpaceId,
	ssf.Path,
	ssf.UncPath,
	ssf.IsShared,
	ssf.FsrmQuotaType,
	ssf.FsrmQuotaSizeBytes
FROM EnterpriseFolders AS ST
LEFT OUTER JOIN StorageSpaceFolders as ssf on ssf.Id = ST.StorageSpaceFolderId
WHERE ItemID = @ItemID AND FolderName = @FolderName
				*/
				#endregion

				var folder = EnterpriseFolders
					.Where(f => f.ItemId == itemId && f.FolderName == folderName)
					.Select(f => new
					{
						f.EnterpriseFolderId,
						f.ItemId,
						f.FolderName,
						f.FolderQuota,
						f.LocationDrive,
						f.HomeFolder,
						f.Domain,
						f.StorageSpaceFolderId,
						Name = f.StorageSpaceFolder != null ? f.StorageSpaceFolder.Name : null,
						StorageSpaceId = f.StorageSpaceFolder != null ? (int?)f.StorageSpaceFolder.StorageSpaceId : null,
						Path = f.StorageSpaceFolder != null ? f.StorageSpaceFolder.Path : null,
						UncPath = f.StorageSpaceFolder != null ? f.StorageSpaceFolder.UncPath : null,
						IsShared = f.StorageSpaceFolder != null ? (bool?)f.StorageSpaceFolder.IsShared : null,
						FsrmQuotaType = f.StorageSpaceFolder != null ? (QuotaType?)f.StorageSpaceFolder.FsrmQuotaType : null,
						FsrmQuotaSizeBytes = f.StorageSpaceFolder != null ? (long?)f.StorageSpaceFolder.FsrmQuotaSizeBytes : null
					})
					.Take(1);

				return EntityDataReader(folder);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetEnterpriseFolder",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@FolderName", folderName));
			}
		}

		public IDataReader GetWebDavPortalUserSettingsByAccountId(int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetWebDavPortalUsersSettingsByAccountId]
(
	@AccountId INT
)
AS
SELECT TOP 1
	US.Id,
	US.AccountId,
	US.Settings
FROM WebDavPortalUsersSettings AS US
WHERE AccountId = @AccountId
				*/
				#endregion

				var setting = WebDavPortalUsersSettings
					.Where(s => s.AccountId == accountId)
					.Take(1);
				return EntityDataReader(setting);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetWebDavPortalUsersSettingsByAccountId",
					new SqlParameter("@AccountId", accountId));
			}
		}

		public int AddWebDavPortalUsersSettings(int accountId, string settings)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddWebDavPortalUsersSettings]
(
	@WebDavPortalUsersSettingsId INT OUTPUT,
	@AccountId INT,
	@Settings NVARCHAR(max)
)
AS

INSERT INTO WebDavPortalUsersSettings
(
	AccountId,
	Settings
)
VALUES
(
	@AccountId,
	@Settings
)

SET @WebDavPortalUsersSettingsId = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var setting = new Data.Entities.WebDavPortalUsersSetting()
				{
					AccountId = accountId,
					Settings = settings
				};
				WebDavPortalUsersSettings.Add(setting);
				SaveChanges();
				return setting.Id;
			}
			else
			{
				SqlParameter settingsId = new SqlParameter("@WebDavPortalUsersSettingsId", SqlDbType.Int);
				settingsId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddWebDavPortalUsersSettings",
					settingsId,
					new SqlParameter("@AccountId", accountId),
					new SqlParameter("@Settings", settings));

				// read identity
				return Convert.ToInt32(settingsId.Value);
			}
		}

		public void UpdateWebDavPortalUsersSettings(int accountId, string settings)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateWebDavPortalUsersSettings]
(
	@AccountId INT,
	@Settings NVARCHAR(max)
)
AS

UPDATE WebDavPortalUsersSettings
SET
	Settings = @Settings
WHERE AccountId = @AccountId
				*/
				#endregion

				WebDavPortalUsersSettings
					.Where(s => s.AccountId == accountId)
					.ExecuteUpdate(e => new Data.Entities.WebDavPortalUsersSetting {
						Settings = settings
					});
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateWebDavPortalUsersSettings",
					new SqlParameter("@AccountId", accountId),
					new SqlParameter("@Settings", settings));
			}
		}

		public void DeleteAllEnterpriseFolderOwaUsers(int itemId, int folderId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteAllEnterpriseFolderOwaUsers]
(
	@ItemID  int,
	@FolderID int
)
AS
DELETE FROM EnterpriseFoldersOwaPermissions
WHERE ItemId = @ItemID AND FolderID = @FolderID
				*/
				#endregion

				EnterpriseFoldersOwaPermissions.Where(p => p.ItemId == itemId && p.FolderId == folderId)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteAllEnterpriseFolderOwaUsers",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@FolderID", folderId));
			}
		}

		public int AddEnterpriseFolderOwaUser(int itemId, int folderId, int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddEnterpriseFolderOwaUser]
(
	@ESOwsaUserId INT OUTPUT,
	@ItemID INT,
	@FolderID INT, 
	@AccountID INT 
)
AS
INSERT INTO EnterpriseFoldersOwaPermissions
(
	ItemID ,
	FolderID, 
	AccountID
)
VALUES
(
	@ItemID,
	@FolderID, 
	@AccountID 
)

SET @ESOwsaUserId = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var permission = new Data.Entities.EnterpriseFoldersOwaPermission()
				{
					ItemId = itemId,
					FolderId = folderId,
					AccountId = accountId
				};
				EnterpriseFoldersOwaPermissions.Add(permission);
				SaveChanges();
				return permission.Id;
			}
			else
			{
				SqlParameter id = new SqlParameter("@ESOwsaUserId", SqlDbType.Int);
				id.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddEnterpriseFolderOwaUser",
					id,
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@FolderID", folderId),
					new SqlParameter("@AccountId", accountId));

				// read identity
				return Convert.ToInt32(id.Value);
			}
		}

		public IDataReader GetEnterpriseFolderOwaUsers(int itemId, int folderId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetEnterpriseFolderOwaUsers]
(
	@ItemID INT,
	@FolderID INT
)
AS
SELECT 
	EA.AccountID,
	EA.ItemID,
	EA.AccountType,
	EA.AccountName,
	EA.DisplayName,
	EA.PrimaryEmailAddress,
	EA.MailEnabledPublicFolder,
	EA.MailboxPlanId,
	EA.SubscriberNumber,
	EA.UserPrincipalName 
FROM EnterpriseFoldersOwaPermissions AS EFOP
LEFT JOIN  ExchangeAccounts AS EA ON EA.AccountID = EFOP.AccountID
WHERE EFOP.ItemID = @ItemID AND EFOP.FolderID = @FolderID
				*/
				#endregion

				var users = EnterpriseFoldersOwaPermissions
					.Where(p => p.ItemId == itemId && p.FolderId == folderId)
					.Select(p => new
					{
						p.Account.AccountId,
						p.Account.ItemId,
						p.Account.AccountType,
						p.Account.AccountName,
						p.Account.DisplayName,
						p.Account.PrimaryEmailAddress,
						p.Account.MailEnabledPublicFolder,
						p.Account.MailboxPlanId,
						p.Account.SubscriberNumber,
						p.Account.UserPrincipalName
					});
				return EntityDataReader(users);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetEnterpriseFolderOwaUsers",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@FolderID", folderId));
			}
		}

		public IDataReader GetEnterpriseFolderId(int itemId, string folderName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetEnterpriseFolderId]
(
	@ItemID INT,
	@FolderName varchar(max)
)
AS
SELECT TOP 1
	EnterpriseFolderID
	FROM EnterpriseFolders
	WHERE ItemId = @ItemID AND FolderName = @FolderName
				*/
				#endregion

				var folders = EnterpriseFolders
					.Where(f => f.ItemId == itemId && f.FolderName == folderName)
					.Select(f => new { f.EnterpriseFolderId })
					.Take(1);
				return EntityDataReader(folders);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetEnterpriseFolderId",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@FolderName", folderName));
			}
		}

		public IDataReader GetUserEnterpriseFolderWithOwaEditPermission(int itemId, int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetUserEnterpriseFolderWithOwaEditPermission]
(
	@ItemID INT,
	@AccountID INT
)
AS
SELECT 
	EF.FolderName
	FROM EnterpriseFoldersOwaPermissions AS EFOP
	LEFT JOIN  [dbo].[EnterpriseFolders] AS EF ON EF.EnterpriseFolderID = EFOP.FolderID
	WHERE EFOP.ItemID = @ItemID AND EFOP.AccountID = @AccountID
				*/
				#endregion

				var folder = EnterpriseFoldersOwaPermissions
					.Where(p => p.ItemId == itemId && p.AccountId == accountId)
					.Select(p => new { p.Folder.FolderName });
				return EntityDataReader(folder);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetUserEnterpriseFolderWithOwaEditPermission",
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@AccountID", accountId));
			}
		}
#endregion

		#region Support Service Levels

		public IDataReader GetSupportServiceLevels()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSupportServiceLevels]
AS
SELECT *
FROM SupportServiceLevels
RETURN
				*/
				#endregion

				return EntityDataReader(SupportServiceLevels);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetSupportServiceLevels");
			}
		}

		public int AddSupportServiceLevel(string levelName, string levelDescription)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddSupportServiceLevel]
(
	@LevelID int OUTPUT,
	@LevelName nvarchar(100),
	@LevelDescription nvarchar(1000)
)
AS
BEGIN

	IF EXISTS (SELECT * FROM SupportServiceLevels WHERE LevelName = @LevelName)
	BEGIN
		SET @LevelID = -1

		RETURN
	END

	INSERT INTO SupportServiceLevels
	(
		LevelName,
		LevelDescription
	)
	VALUES
	(
		@LevelName,
		@LevelDescription
	)

	SET @LevelID = SCOPE_IDENTITY()

	DECLARE @ResourseGroupID int

	IF EXISTS (SELECT * FROM ResourceGroups WHERE GroupName = 'Service Levels')
	BEGIN
		DECLARE @QuotaLastID int, @CurQuotaName nvarchar(100), 
			@CurQuotaDescription nvarchar(1000), @QuotaOrderInGroup int

		SET @CurQuotaName = N'ServiceLevel.' + @LevelName
		SET @CurQuotaDescription = @LevelName + N', users'

		SELECT @ResourseGroupID = GroupID FROM ResourceGroups WHERE GroupName = 'Service Levels'

		SELECT @QuotaLastID = MAX(QuotaID) FROM Quotas

		SELECT @QuotaOrderInGroup = MAX(QuotaOrder) FROM Quotas WHERE GroupID = @ResourseGroupID

		IF @QuotaOrderInGroup IS NULL SET @QuotaOrderInGroup = 0

		IF NOT EXISTS (SELECT * FROM Quotas WHERE QuotaName = @CurQuotaName)
		BEGIN
			INSERT Quotas 
				(QuotaID, 
				GroupID, 
				QuotaOrder, 
				QuotaName, 
				QuotaDescription, 
				QuotaTypeID, 
				ServiceQuota, 
				ItemTypeID) 
			VALUES 
				(@QuotaLastID + 1, 
				@ResourseGroupID, 
				@QuotaOrderInGroup + 1, 
				@CurQuotaName, 
				@CurQuotaDescription,
				2, 
				0, 
				NULL)
		END
	END

END

RETURN
				*/
				#endregion

				if (SupportServiceLevels.Any(l => l.LevelName == levelName)) return -1;

				var level = new Data.Entities.SupportServiceLevel()
				{
					LevelName = levelName,
					LevelDescription = levelDescription
				};
				SupportServiceLevels.Add(level);
				SaveChanges();
				var levelId = level.LevelId;

				var resourceGroupId = ResourceGroups
					.Where(g => g.GroupName == "Service Levels")
					.Select(g => (int?)g.GroupId)
					.FirstOrDefault();
				if (resourceGroupId != null)
				{
					var quotaLastId = Quotas
						.Max(q => q.QuotaId);
					var quotaOrderInGroup = Quotas
						.Where(q => q.GroupId == resourceGroupId)
						.Max(q => (int?)q.QuotaOrder) ?? 0;
					var curQuotaName = $"ServiceLevel.{levelName}";
					var curQuotaDescription = $"{levelName}, users";

					if (!Quotas.Any(q => q.QuotaName == curQuotaName))
					{
						var quota = new Data.Entities.Quota()
						{
							QuotaId = quotaLastId + 1,
							GroupId = resourceGroupId.Value,
							QuotaOrder = quotaOrderInGroup + 1,
							QuotaName = curQuotaName,
							QuotaDescription = curQuotaDescription,
							QuotaTypeId = 2,
							ServiceQuota = false,
							ItemTypeId = null
						};
						Quotas.Add(quota);
						SaveChanges();
					}
				}

				return levelId;
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@LevelID", SqlDbType.Int);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddSupportServiceLevel",
					outParam,
					new SqlParameter("@LevelName", levelName),
					new SqlParameter("@LevelDescription", levelDescription));

				return Convert.ToInt32(outParam.Value);
			}
		}

		public void UpdateSupportServiceLevel(int levelId, string levelName, string levelDescription)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateSupportServiceLevel]
(
	@LevelID int,
	@LevelName nvarchar(100),
	@LevelDescription nvarchar(1000)
)
AS
BEGIN

	DECLARE @PrevQuotaName nvarchar(100), @PrevLevelName nvarchar(100)

	SELECT @PrevLevelName = LevelName FROM SupportServiceLevels WHERE LevelID = @LevelID

	SET @PrevQuotaName = N'ServiceLevel.' + @PrevLevelName

	UPDATE SupportServiceLevels
	SET LevelName = @LevelName,
		LevelDescription = @LevelDescription
	WHERE LevelID = @LevelID

	IF EXISTS (SELECT * FROM Quotas WHERE QuotaName = @PrevQuotaName)
	BEGIN
		DECLARE @QuotaID INT

		SELECT @QuotaID = QuotaID FROM Quotas WHERE QuotaName = @PrevQuotaName

		UPDATE Quotas
		SET QuotaName = N'ServiceLevel.' + @LevelName,
			QuotaDescription = @LevelName + ', users'
		WHERE QuotaID = @QuotaID
	END

END

RETURN 
				*/
				#endregion

				var level = SupportServiceLevels
					.Where(l => l.LevelId == levelId)
					.FirstOrDefault();
				if (level != null)
				{
					var prevLevelName = level.LevelName;
					var prevQuotaName = $"ServiceLevel.{prevLevelName}";
					level.LevelName = levelName;
					level.LevelDescription = levelDescription;
					SaveChanges();

					var quota = Quotas
						.Where(q => q.QuotaName == prevQuotaName)
						.FirstOrDefault();
					if (quota != null)
					{
						quota.QuotaName = $"ServiceLevel.{levelName}";
						quota.QuotaDescription = $"{levelName}, users";
						SaveChanges();
					}
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateSupportServiceLevel",
					new SqlParameter("@LevelID", levelId),
					new SqlParameter("@LevelName", levelName),
					new SqlParameter("@LevelDescription", levelDescription));
			}
		}

		public void DeleteSupportServiceLevel(int levelId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteSupportServiceLevel]
(
	@LevelID int
)
AS
BEGIN

	DECLARE @LevelName nvarchar(100), @QuotaName nvarchar(100), @QuotaID int

	SELECT @LevelName = LevelName FROM SupportServiceLevels WHERE LevelID = @LevelID

	SET @QuotaName = N'ServiceLevel.' + @LevelName

	SELECT @QuotaID = QuotaID FROM Quotas WHERE QuotaName = @QuotaName

	IF @QuotaID IS NOT NULL
	BEGIN
		DELETE FROM HostingPlanQuotas WHERE QuotaID = @QuotaID
		DELETE FROM PackageQuotas WHERE QuotaID = @QuotaID
		DELETE FROM Quotas WHERE QuotaID = @QuotaID
	END

	IF EXISTS (SELECT * FROM ExchangeAccounts WHERE LevelID = @LevelID)
	UPDATE ExchangeAccounts
	   SET LevelID = NULL
	 WHERE LevelID = @LevelID

	DELETE FROM SupportServiceLevels WHERE LevelID = @LevelID

END

RETURN 
				*/
				#endregion

				var levelName = SupportServiceLevels
					.Where(l => l.LevelId == levelId)
					.Select(l => l.LevelName)
					.FirstOrDefault();
				if (levelName != null)
				{
					var quotaName = $"ServiceLevel.{levelName}";

					var quotaId = Quotas
						.Where(q => q.QuotaName == quotaName)
						.Select(q => (int?)q.QuotaId)
						.FirstOrDefault();
					if (quotaId != null)
					{
						HostingPlanQuotas.Where(q => q.QuotaId == quotaId).ExecuteDelete();
						PackageQuotas.Where(q => q.QuotaId == quotaId).ExecuteDelete();
						Quotas.Where(q => q.QuotaId == quotaId).ExecuteDelete();
					}

					var accounts = ExchangeAccounts
						.Where(a => a.LevelId == levelId);
					if (accounts.Any())
					{
						foreach (var account in accounts)
						{
							account.LevelId = null;
						}
						SaveChanges();
					}

					SupportServiceLevels.Where(l => l.LevelId == levelId).ExecuteDelete();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteSupportServiceLevel",
					new SqlParameter("@LevelID", levelId));
			}
		}

		public IDataReader GetSupportServiceLevel(int levelID)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetSupportServiceLevel]
(
	@LevelID int
)
AS
SELECT *
FROM SupportServiceLevels
WHERE LevelID = @LevelID
RETURN 
				*/
				#endregion

				return EntityDataReader(SupportServiceLevels.Where(l => l.LevelId == levelID));
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetSupportServiceLevel",
					new SqlParameter("@LevelID", levelID));
			}
		}

		public bool CheckServiceLevelUsage(int levelID)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckServiceLevelUsage]
(
	@LevelID int
)
AS
SELECT COUNT(EA.AccountID)
FROM SupportServiceLevels AS SL
INNER JOIN ExchangeAccounts AS EA ON SL.LevelID = EA.LevelID
WHERE EA.LevelID = @LevelID
RETURN 
			*/
				#endregion

				return SupportServiceLevels
					.Join(ExchangeAccounts, l => l.LevelId, ea => ea.LevelId, (l, ea) => ea)
					.Any(ea => ea.LevelId == levelID);
			}
			else
			{
				int res = (int)SqlHelper.ExecuteScalar(ConnectionString, CommandType.StoredProcedure, "CheckServiceLevelUsage",
					new SqlParameter("@LevelID", levelID));
				return res > 0;
			}
		}

		#endregion

		#region Storage Spaces 

		public DataSet GetStorageSpaceLevelsPaged(string filterColumn, string filterValue, string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetStorageSpaceLevelsPaged]
(
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS
-- build query and run it to the temporary table
DECLARE @sql nvarchar(2000)

SET @sql = '

DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows
DECLARE @SSLevels TABLE
(
	ItemPosition int IDENTITY(0,1),
	SSLevelId int
)
INSERT INTO @SSLevels (SSLevelId)
SELECT
	S.ID
FROM StorageSpaceLevels AS S'

IF @FilterColumn <> '' AND @FilterValue <> ''
SET @sql = @sql + ' WHERE ' + @FilterColumn + ' LIKE @FilterValue '

IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + ' SELECT COUNT(SSLevelId) FROM @SSLevels;
SELECT
	CR.ID,
	CR.Name,
	CR.Description
FROM @SSLevels AS C
INNER JOIN StorageSpaceLevels AS CR ON C.SSLevelId = CR.ID
WHERE C.ItemPosition BETWEEN @StartRow AND @EndRow'

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int,  @FilterValue nvarchar(50)',
@StartRow, @MaximumRows,  @FilterValue

RETURN
				*/
				#endregion

				var levels = StorageSpaceLevels
					.Select(l => new
					{
						l.Id,
						l.Name,
						l.Description
					});

				if (!string.IsNullOrEmpty(filterValue) && !string.IsNullOrEmpty(filterColumn))
				{
					levels = levels.Where(DynamicFunctions.ColumnLike(levels, filterColumn, filterValue));
				}

				var count = levels.Count();

				if (!string.IsNullOrEmpty(sortColumn))
				{
					levels = levels.OrderBy(sortColumn);
				}

				levels = levels.Skip(startRow).Take(maximumRows);

				return EntityDataSet(count, levels);
			}
			else
			{
				return SqlHelper.ExecuteDataset(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetStorageSpaceLevelsPaged",
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public IDataReader GetStorageSpaceLevelById(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetStorageSpaceLevelById] 
(
@ID INT
)
AS
SELECT TOP 1
	SL.Id,
	Sl.Name,
	SL.Description
FROM StorageSpaceLevels AS SL
WHERE SL.Id = @ID

				*/
				#endregion

				var levels = StorageSpaceLevels
					.Where(sl => sl.Id == id)
					.Select(sl => new { sl.Id, sl.Name, sl.Description });
				return EntityDataReader(levels);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetStorageSpaceLevelById",
					new SqlParameter("@ID", id));
			}
		}

		public int UpdateStorageSpaceLevel(StorageSpaceLevel level)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateStorageSpaceLevel]
(
	@ID INT,
	@Name nvarchar(300),
	@Description nvarchar(max)
)
AS
	UPDATE StorageSpaceLevels
	SET Name = @Name, Description = @Description
	WHERE ID = @ID
				*/
				#endregion

				return StorageSpaceLevels
					.Where(l => l.Id == level.Id)
					.ExecuteUpdate(l => new Data.Entities.StorageSpaceLevel
					{
						Name = level.Name,
						Description = level.Description
					});
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateStorageSpaceLevel",
					new SqlParameter("@ID", level.Id),
					new SqlParameter("@Name", level.Name),
					new SqlParameter("@Description", level.Description));

				return level.Id;
			}
		}

		public int InsertStorageSpaceLevel(StorageSpaceLevel level)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[InsertStorageSpaceLevel]
(
	@ID INT OUTPUT,
	@Name nvarchar(300),
	@Description nvarchar(max)
)
AS

INSERT INTO StorageSpaceLevels 
(
	Name, 
	Description
)
VALUES 
(
	@Name,
	@Description
)

SET @ID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var lev = new Data.Entities.StorageSpaceLevel()
				{
					Name = level.Name,
					Description = level.Description
				};
				StorageSpaceLevels.Add(lev);
				SaveChanges();
				return lev.Id;
			}
			else
			{
				SqlParameter id = new SqlParameter("@ID", SqlDbType.Int);
				id.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"InsertStorageSpaceLevel",
					id,
					new SqlParameter("@Name", level.Name),
					new SqlParameter("@Description", level.Description));

				// read identity
				return Convert.ToInt32(id.Value);
			}
		}

		public void RemoveStorageSpaceLevel(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[RemoveStorageSpaceLevel]
(
	@ID INT
)
AS
	DELETE FROM StorageSpaceLevels WHERE ID = @ID
				*/
				#endregion

				StorageSpaceLevels
					.Where(sl => sl.Id == id)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"RemoveStorageSpaceLevel",
					new SqlParameter("@ID", id));
			}
		}

		public IDataReader GetStorageSpaceLevelResourceGroups(int levelId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetLevelResourceGroups]
(
	@LevelId INT
)
AS
	SELECT 
	G.[GroupID],
	G.[GroupName],
	G.[GroupOrder],
	G.[GroupController],
	G.[ShowGroup]
	FROM [dbo].[StorageSpaceLevelResourceGroups] AS SG
	INNER JOIN [dbo].[ResourceGroups] AS G
	ON SG.GroupId = G.GroupId
	WHERE SG.LevelId = @LevelId
				*/
				#endregion

				var groups = StorageSpaceLevelResourceGroups
					.Where(g => g.LevelId == levelId)
					.Select(g => new
					{
						g.Group.GroupId,
						g.Group.GroupName,
						g.Group.GroupOrder,
						g.Group.GroupController,
						g.Group.ShowGroup
					});
				return EntityDataReader(groups);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetLevelResourceGroups",
					new SqlParameter("@LevelId", levelId));
			}
		}

		public void RemoveStorageSpaceLevelResourceGroups(int levelId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteLevelResourceGroups]
(
	@LevelId INT
)
AS
	DELETE 
	FROM [dbo].[StorageSpaceLevelResourceGroups]
	WHERE LevelId = @LevelId
				*/
				#endregion

				StorageSpaceLevelResourceGroups.Where(g => g.LevelId == levelId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteLevelResourceGroups",
					new SqlParameter("@LevelId", levelId));
			}
		}

		public void AddStorageSpaceLevelResourceGroup(int levelId, int groupId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
		CREATE PROCEDURE [dbo].[AddLevelResourceGroups]
(
	@LevelId INT,
	@GroupId INT
)
AS
	INSERT INTO [dbo].[StorageSpaceLevelResourceGroups] (LevelId, GroupId)
	VALUES (@LevelId, @GroupId)
		*/
				#endregion

				var group = new Data.Entities.StorageSpaceLevelResourceGroup()
				{
					LevelId = levelId,
					GroupId = groupId
				};
				StorageSpaceLevelResourceGroups.Add(group);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddLevelResourceGroups",
					new SqlParameter("@LevelId", levelId),
					new SqlParameter("@GroupId", groupId));
			}
		}

		public DataSet GetStorageSpacesPaged(string filterColumn, string filterValue, string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetStorageSpacesPaged]
(
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS
-- build query and run it to the temporary table
DECLARE @sql nvarchar(2500)

SET @sql = '

DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows
DECLARE @Spaces TABLE
(
	ItemPosition int IDENTITY(0,1),
	SpaceId int
)
INSERT INTO @Spaces (SpaceId)
SELECT
	S.Id
FROM StorageSpaces AS S'

IF @FilterColumn <> '' AND @FilterValue <> ''
SET @sql = @sql + ' WHERE ' + @FilterColumn + ' LIKE @FilterValue '

IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + ' SELECT COUNT(SpaceId) FROM @Spaces;
SELECT
		CR.Id,
		CR.Name ,
		CR.ServiceId ,
		CR.ServerId ,
		CR.LevelId,
		CR.Path,
		CR.FsrmQuotaType,
		CR.FsrmQuotaSizeBytes,
		CR.IsShared,
		CR.IsDisabled,
		CR.UncPath,
		ISNULL((SELECT SUM(SSF.FsrmQuotaSizeBytes) FROM StorageSpaceFolders AS SSF WHERE SSF.StorageSpaceId = CR.Id), 0) UsedSizeBytes
FROM @Spaces AS C
INNER JOIN StorageSpaces AS CR ON C.SpaceId = CR.Id
WHERE C.ItemPosition BETWEEN @StartRow AND @EndRow'

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int,  @FilterValue nvarchar(50)',
@StartRow, @MaximumRows,  @FilterValue

RETURN
				*/
				#endregion

				var spaces = StorageSpaces
					.Select(s => new
					{
						s.Id,
						s.Name,
						s.ServiceId,
						s.ServerId,
						s.LevelId,
						s.Path,
						s.FsrmQuotaType,
						s.FsrmQuotaSizeBytes,
						s.IsShared,
						s.IsDisabled,
						s.UncPath,
						UsedSizeBytes = StorageSpaceFolders
							.Where(f => f.StorageSpaceId == s.Id)
							.Sum(f => (long?)f.FsrmQuotaSizeBytes) ?? 0
					});

				if (!string.IsNullOrEmpty(filterValue) && !string.IsNullOrEmpty(filterColumn))
				{
					spaces = spaces.Where(DynamicFunctions.ColumnLike(spaces, filterColumn, filterValue));
				}

				var count = spaces.Count();

				if (!string.IsNullOrEmpty(sortColumn))
				{
					spaces = spaces.OrderBy(sortColumn);
				}

				spaces = spaces.Skip(startRow).Take(maximumRows);

				return EntityDataSet(count, spaces);
			}
			else
			{
				return SqlHelper.ExecuteDataset(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetStorageSpacesPaged",
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public IDataReader GetStorageSpaceById(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetStorageSpaceById]
(
	@Id INT
)
AS
	SELECT TOP 1
		SS.Id,
		SS.Name ,
		SS.ServiceId ,
		SS.ServerId ,
		SS.LevelId,
		SS.Path,
		SS.FsrmQuotaType,
		SS.FsrmQuotaSizeBytes,
		SS.IsShared,
		SS.UncPath,
		SS.IsDisabled,
		ISNULL((SELECT SUM(SSF.FsrmQuotaSizeBytes) FROM StorageSpaceFolders AS SSF WHERE SSF.StorageSpaceId = SS.Id), 0) UsedSizeBytes
	FROM [dbo].[StorageSpaces] AS SS
	WHERE SS.Id = @Id
				*/
				#endregion

				var spaces = StorageSpaces
					.Where(s => s.Id == id)
					.Select(s => new
					{
						s.Id,
						s.Name,
						s.ServiceId,
						s.ServerId,
						s.LevelId,
						s.Path,
						s.FsrmQuotaType,
						s.FsrmQuotaSizeBytes,
						s.IsShared,
						s.IsDisabled,
						s.UncPath,
						UsedSizeBytes = StorageSpaceFolders
							.Where(f => f.StorageSpaceId == s.Id)
							.Sum(f => (long?)f.FsrmQuotaSizeBytes) ?? 0
					});
				return EntityDataReader(spaces);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetStorageSpaceById",
					new SqlParameter("@ID", id));
			}
		}

		public IDataReader GetStorageSpaceByServiceAndPath(int serverId, string path)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetStorageSpaceByServiceAndPath] 
(
	@ServerId INT,
	@Path varchar(max)
)
AS
SELECT TOP 1
		SS.Id,
		SS.Name ,
		SS.ServiceId ,
		SS.ServerId ,
		SS.LevelId,
		SS.Path,
		SS.FsrmQuotaType,
		SS.FsrmQuotaSizeBytes,
		SS.IsShared,
		SS.UncPath,
		SS.IsDisabled,
		ISNULL((SELECT SUM(SSF.FsrmQuotaSizeBytes) FROM StorageSpaceFolders AS SSF WHERE SSF.StorageSpaceId = SS.Id), 0) UsedSizeBytes
FROM StorageSpaces AS SS
WHERE SS.ServerId = @ServerId AND SS.Path = @Path
				*/
				#endregion

				var spaces = StorageSpaces
					.Where(s => s.ServerId == serverId && s.Path == path)
					.Select(s => new
					{
						s.Id,
						s.Name,
						s.ServiceId,
						s.ServerId,
						s.LevelId,
						s.Path,
						s.FsrmQuotaType,
						s.FsrmQuotaSizeBytes,
						s.IsShared,
						s.IsDisabled,
						s.UncPath,
						UsedSizeBytes = StorageSpaceFolders
							.Where(f => f.StorageSpaceId == s.Id)
							.Sum(f => (long?)f.FsrmQuotaSizeBytes) ?? 0
					});
				return EntityDataReader(spaces);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetStorageSpaceByServiceAndPath",
					new SqlParameter("@ServerId", serverId),
					new SqlParameter("@Path", path));
			}
		}

		public int UpdateStorageSpace(StorageSpace space)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateStorageSpace]
(
	@ID INT,
	@Name nvarchar(300),
	@ServiceId INT ,
	@ServerId INT,
	@LevelId INT,
	@Path varchar(max),
	@FsrmQuotaType INT,
	@FsrmQuotaSizeBytes BIGINT,
	@IsShared BIT,
	@IsDisabled BIT,
	@UncPath varchar(max)
)
AS
	UPDATE StorageSpaces
	SET Name = @Name, ServiceId = @ServiceId,ServerId=@ServerId,LevelId=@LevelId, Path=@Path,FsrmQuotaType=@FsrmQuotaType,FsrmQuotaSizeBytes=@FsrmQuotaSizeBytes,IsShared=@IsShared,UncPath=@UncPath,IsDisabled=@IsDisabled
	WHERE ID = @ID
				*/
				#endregion

				var sp = StorageSpaces
					.FirstOrDefault(s => s.Id == space.Id);
				if (sp != null)
				{
					sp.Name = space.Name;
					sp.ServiceId = space.ServiceId;
					sp.ServerId = space.ServerId;
					sp.LevelId = space.LevelId;
					sp.Path = space.Path;
					sp.FsrmQuotaType = space.FsrmQuotaType;
					sp.FsrmQuotaSizeBytes = space.FsrmQuotaSizeBytes;
					sp.IsShared = space.IsShared;
					sp.UncPath = space.UncPath;
					sp.IsDisabled = space.IsDisabled;
					SaveChanges();
				}
				return space.Id;
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateStorageSpace",
					new SqlParameter("@ID", space.Id),
					new SqlParameter("@Name", space.Name),
					new SqlParameter("@ServiceId", space.ServiceId),
					new SqlParameter("@ServerId", space.ServerId),
					new SqlParameter("@LevelId", space.LevelId),
					new SqlParameter("@Path", space.Path),
					new SqlParameter("@FsrmQuotaType", space.FsrmQuotaType),
					new SqlParameter("@FsrmQuotaSizeBytes", space.FsrmQuotaSizeBytes),
					new SqlParameter("@IsShared", space.IsShared),
					new SqlParameter("@IsDisabled", space.IsDisabled),
					new SqlParameter("@UncPath", space.UncPath));

				return space.Id;
			}
		}

		public int InsertStorageSpace(StorageSpace space)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[InsertStorageSpace]
(
	@ID INT OUTPUT,
	@Name nvarchar(300),
	@ServiceId INT ,
	@ServerId INT,
	@LevelId INT,
	@Path varchar(max),
	@FsrmQuotaType INT,
	@FsrmQuotaSizeBytes BIGINT,
	@IsShared BIT,
	@IsDisabled BIT,
	@UncPath varchar(max)
)
AS

INSERT INTO StorageSpaces 
(
	Name,
	ServiceId,
	ServerId,
	LevelId,
	Path,
	FsrmQuotaType,
	FsrmQuotaSizeBytes,
	IsShared,
	UncPath,
	IsDisabled
)
VALUES 
(
	@Name,
	@ServiceId,
	@ServerId,
	@LevelId,
	@Path,
	@FsrmQuotaType,
	@FsrmQuotaSizeBytes,
	@IsShared,
	@UncPath,
	@IsDisabled
)

SET @ID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var sp = new Data.Entities.StorageSpace()
				{
					Name = space.Name,
					ServiceId = space.ServiceId,
					ServerId = space.ServerId,
					LevelId = space.LevelId,
					Path = space.Path,
					FsrmQuotaType = space.FsrmQuotaType,
					FsrmQuotaSizeBytes = space.FsrmQuotaSizeBytes,
					IsShared = space.IsShared,
					UncPath = space.UncPath,
					IsDisabled = space.IsDisabled
				};
				StorageSpaces.Add(sp);
				SaveChanges();
				return sp.Id;
			}
			else
			{
				SqlParameter id = new SqlParameter("@ID", SqlDbType.Int);
				id.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"InsertStorageSpace",
					id,
					new SqlParameter("@Name", space.Name),
					new SqlParameter("@ServiceId", space.ServiceId),
					new SqlParameter("@ServerId", space.ServerId),
					new SqlParameter("@LevelId", space.LevelId),
					new SqlParameter("@Path", space.Path),
					new SqlParameter("@FsrmQuotaType", space.FsrmQuotaType),
					new SqlParameter("@FsrmQuotaSizeBytes", space.FsrmQuotaSizeBytes),
					new SqlParameter("@IsShared", space.IsShared),
					new SqlParameter("@IsDisabled", space.IsDisabled),
					new SqlParameter("@UncPath", space.UncPath));

				// read identity
				return Convert.ToInt32(id.Value);
			}
		}

		public void RemoveStorageSpace(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[RemoveStorageSpace]
(
	@ID INT
)
AS
	DELETE FROM StorageSpaces WHERE ID = @ID
				*/
				#endregion

				StorageSpaces.Where(s => s.Id == id).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"RemoveStorageSpace",
					new SqlParameter("@ID", id));
			}
		}

		public DataSet GetStorageSpacesByLevelId(int levelId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetStorageSpacesByLevelId] 
(
	@LevelId INT
)
AS
SELECT
		SS.Id,
		SS.Name ,
		SS.ServiceId ,
		SS.ServerId ,
		SS.LevelId,
		SS.Path,
		SS.FsrmQuotaType,
		SS.FsrmQuotaSizeBytes,
		SS.IsShared,
		SS.UncPath,
		SS.IsDisabled,
		ISNULL((SELECT SUM(SSF.FsrmQuotaSizeBytes) FROM StorageSpaceFolders AS SSF WHERE SSF.StorageSpaceId = SS.Id), 0) UsedSizeBytes
FROM StorageSpaces AS SS
INNER JOIN StorageSpaceLevels AS SSL
ON SSL.Id = SS.LevelId
WHERE SS.LevelId = @LevelId
				*/
				#endregion

				var spaces = StorageSpaces
					.Where(s => s.LevelId == levelId)
					.Join(StorageSpaceLevels, s => s.LevelId, l => l.Id, (s, l) => s)
					.Select(s => new
					{
						s.Id,
						s.Name,
						s.ServiceId,
						s.ServerId,
						s.LevelId,
						s.Path,
						s.FsrmQuotaType,
						s.FsrmQuotaSizeBytes,
						s.IsShared,
						s.IsDisabled,
						s.UncPath,
						UsedSizeBytes = StorageSpaceFolders
							.Where(f => f.StorageSpaceId == s.Id)
							.Sum(f => (long?)f.FsrmQuotaSizeBytes) ?? 0
					});
				return EntityDataSet(spaces);
			}
			else
			{
				return SqlHelper.ExecuteDataset(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetStorageSpacesByLevelId",
					new SqlParameter("@LevelId", levelId));
			}
		}

		public IDataReader GetStorageSpacesByResourceGroupName(string groupName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetStorageSpacesByResourceGroupName] 
(
	@ResourceGroupName varchar(max)
)
AS
SELECT
		SS.Id,
		SS.Name ,
		SS.ServiceId ,
		SS.ServerId ,
		SS.LevelId,
		SS.Path,
		SS.FsrmQuotaType,
		SS.FsrmQuotaSizeBytes,
		SS.IsShared,
		SS.UncPath,
		SS.IsDisabled,
		ISNULL((SELECT SUM(SSF.FsrmQuotaSizeBytes) FROM StorageSpaceFolders AS SSF WHERE SSF.StorageSpaceId = SS.Id), 0) UsedSizeBytes
FROM StorageSpaces AS SS
INNER JOIN StorageSpaceLevelResourceGroups AS SSLRG ON SSLRG.LevelId = SS.LevelId
INNER JOIN ResourceGroups AS RG ON SSLRG.GroupID = RG.GroupID
WHERE RG.GroupName = @ResourceGroupName
				*/
				#endregion

				var spaces = StorageSpaces
					.Join(StorageSpaceLevelResourceGroups
						.Where(g => g.Group.GroupName == groupName), s => s.LevelId, g => g.LevelId, (s, g) => s)
					.Select(s => new
					{
						s.Id,
						s.Name,
						s.ServiceId,
						s.ServerId,
						s.LevelId,
						s.Path,
						s.FsrmQuotaType,
						s.FsrmQuotaSizeBytes,
						s.IsShared,
						s.IsDisabled,
						s.UncPath,
						UsedSizeBytes = StorageSpaceFolders
							.Where(f => f.StorageSpaceId == s.Id)
							.Sum(f => (long?)f.FsrmQuotaSizeBytes) ?? 0
					});
				return EntityDataReader(spaces);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetStorageSpacesByResourceGroupName",
					new SqlParameter("@ResourceGroupName", groupName));
			}
		}

		public int CreateStorageSpaceFolder(StorageSpaceFolder folder)
		{
			folder.Id = CreateStorageSpaceFolder(folder.Name, folder.StorageSpaceId, folder.Path, folder.UncPath, folder.IsShared, folder.FsrmQuotaType, folder.FsrmQuotaSizeBytes);

			return folder.Id;
		}

		public int CreateStorageSpaceFolder(string name, int storageSpaceId, string path, string uncPath, bool isShared, QuotaType quotaType, long fsrmQuotaSizeBytes)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CreateStorageSpaceFolder]
(
	@ID INT OUTPUT,
	@Name varchar(300),
	@StorageSpaceId INT,
	@Path varchar(max),
	@UncPath varchar(max),
	@IsShared BIT,
	@FsrmQuotaType INT,
	@FsrmQuotaSizeBytes BIGINT 
)
AS
INSERT INTO StorageSpaceFolders (	
	Name,
	StorageSpaceId,
	Path,
	UncPath,
	IsShared,
	FsrmQuotaType,
	FsrmQuotaSizeBytes)
VALUES (
	@Name,
	@StorageSpaceId,
	@Path,
	@UncPath,
	@IsShared,
	@FsrmQuotaType,
	@FsrmQuotaSizeBytes)

SET @ID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var folder = new Data.Entities.StorageSpaceFolder()
				{
					Name = name,
					StorageSpaceId = storageSpaceId,
					Path = path,
					UncPath = uncPath,
					IsShared = isShared,
					FsrmQuotaType = quotaType,
					FsrmQuotaSizeBytes = fsrmQuotaSizeBytes
				};
				StorageSpaceFolders.Add(folder);
				SaveChanges();
				return folder.Id;
			}
			else
			{
				SqlParameter id = new SqlParameter("@ID", SqlDbType.Int);
				id.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"CreateStorageSpaceFolder",
					id,
					new SqlParameter("@Name", name),
					new SqlParameter("@StorageSpaceId", storageSpaceId),
					new SqlParameter("@Path", path),
					new SqlParameter("@UncPath", uncPath),
					new SqlParameter("@IsShared", isShared),
					new SqlParameter("@FsrmQuotaType", quotaType),
					new SqlParameter("@FsrmQuotaSizeBytes", fsrmQuotaSizeBytes));

				// read identity
				return Convert.ToInt32(id.Value);
			}
		}

		public int UpdateStorageSpaceFolder(StorageSpaceFolder folder)
		{
			return UpdateStorageSpaceFolder(folder.Id, folder.Name, folder.StorageSpaceId, folder.Path, folder.UncPath,
				folder.IsShared, folder.FsrmQuotaType, folder.FsrmQuotaSizeBytes);
		}

		public int UpdateStorageSpaceFolder(int id, string folderName, int storageSpaceId, string path, string uncPath, bool isShared, QuotaType type, long fsrmQuotaSizeBytes)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateStorageSpaceFolder]
(
	@ID INT,
	@Name varchar(300),
	@StorageSpaceId INT,
	@Path varchar(max),
	@UncPath varchar(max),
	@IsShared BIT,
	@FsrmQuotaType INT,
	@FsrmQuotaSizeBytes BIGINT 
)
AS
UPDATE StorageSpaceFolders
SET
	Name=@Name,
	StorageSpaceId=@StorageSpaceId,
	Path=@Path,
	UncPath=@UncPath,
	IsShared=@IsShared,
	FsrmQuotaType=@FsrmQuotaType,
	FsrmQuotaSizeBytes=@FsrmQuotaSizeBytes
WHERE ID = @ID
				*/
				#endregion

				var folder = StorageSpaceFolders
					.FirstOrDefault(f => f.Id == id);
				if (folder != null) {
					folder.Name = folderName;
					folder.StorageSpaceId = storageSpaceId;
					folder.Path = path;
					folder.UncPath = uncPath;
					folder.IsShared = isShared;
					folder.FsrmQuotaType = type;
					folder.FsrmQuotaSizeBytes = fsrmQuotaSizeBytes;
					SaveChanges();
				}
				return id;
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateStorageSpaceFolder",
					new SqlParameter("@ID", id),
					new SqlParameter("@Name", folderName),
					new SqlParameter("@StorageSpaceId", storageSpaceId),
					new SqlParameter("@Path", path),
					new SqlParameter("@UncPath", uncPath),
					new SqlParameter("@IsShared", isShared),
					new SqlParameter("@FsrmQuotaType", type),
					new SqlParameter("@FsrmQuotaSizeBytes", fsrmQuotaSizeBytes));

				return id;
			}
		}

		public IDataReader GetStorageSpaceFoldersByStorageSpaceId(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetStorageSpaceFoldersByStorageSpaceId]
(
	@StorageSpaceId INT
)
AS
SELECT 
	Id,
	Name,
	StorageSpaceId,
	Path,
	UncPath,
	IsShared,
	FsrmQuotaType,
	FsrmQuotaSizeBytes
FROM StorageSpaceFolders
WHERE StorageSpaceId = @StorageSpaceId
				*/
				#endregion

				var folders = StorageSpaceFolders
					.Where(f => f.StorageSpaceId == id)
					.Select(f => new
					{
						f.Id,
						f.Name,
						f.StorageSpaceId,
						f.Path,
						f.UncPath,
						f.IsShared,
						f.FsrmQuotaType,
						f.FsrmQuotaSizeBytes
					});
				return EntityDataReader(folders);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetStorageSpaceFoldersByStorageSpaceId",
					new SqlParameter("@StorageSpaceId", id));
			}
		}

		public IDataReader GetStorageSpaceFolderById(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetStorageSpaceFolderById]
(
	@ID INT
)
AS
SELECT TOP 1
	Id,
	Name,
	StorageSpaceId,
	Path,
	UncPath,
	IsShared,
	FsrmQuotaType,
	FsrmQuotaSizeBytes
FROM StorageSpaceFolders
WHERE Id = @ID
				*/
				#endregion

				var folder = StorageSpaceFolders
					.Where(f => f.Id == id)
					.Take(1)
					.Select(f => new
					{
						f.Id,
						f.Name,
						f.StorageSpaceId,
						f.Path,
						f.UncPath,
						f.IsShared,
						f.FsrmQuotaType,
						f.FsrmQuotaSizeBytes
					});
				return EntityDataReader(folder);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetStorageSpaceFolderById",
					new SqlParameter("@ID", id));
			}
		}

		public void RemoveStorageSpaceFolder(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[RemoveStorageSpaceFolder]
(
	@ID INT
)
AS
DELETE
FROM StorageSpaceFolders
WHERE ID=@ID
				*/
				#endregion

				StorageSpaceFolders.Where(f => f.Id == id).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"RemoveStorageSpaceFolder",
					new SqlParameter("@ID", id));
			}
		}
#endregion

		#region RDS

		public bool CheckRDSServerExists(string ServerFQDN)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[CheckRDSServer]
(
	@ServerFQDN nvarchar(100),
	@Result int OUTPUT
)
AS

/*
@Result values:
	0 - OK
	-1 - already exists
*//*

SET @Result = 0 -- OK

-- check if the domain already exists
IF EXISTS(
SELECT FqdName FROM RDSServers
WHERE FqdName = @ServerFQDN
)
BEGIN
	SET @Result = -1
	RETURN
END

RETURN
				*/
				#endregion

				return RdsServers.Any(s => s.FqdName == ServerFQDN);
			}
			else
			{
				SqlParameter prmId = new SqlParameter("@Result", SqlDbType.Int);
				prmId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "CheckRDSServer",
					prmId,
					new SqlParameter("@ServerFQDN", ServerFQDN));

				return Convert.ToInt32(prmId.Value) != 0;
			}
		}

		public IDataReader GetRdsServerSettings(int serverId, string settingsName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSServerSettings]
(
	@ServerId int,
	@SettingsName nvarchar(50)
)
AS
	SELECT RDSServerId, PropertyName, PropertyValue, ApplyUsers, ApplyAdministrators
	FROM RDSServerSettings
	WHERE RDSServerId = @ServerId AND SettingsName = @SettingsName			
				*/
				#endregion

				var settings = RdsServerSettings
					.Where(s => s.RdsServerId == serverId && s.SettingsName == settingsName)
					.Select(s => new
					{
						s.RdsServerId,
						s.PropertyName,
						s.PropertyValue,
						s.ApplyUsers,
						s.ApplyAdministrators
					});
				return EntityDataReader(settings);
			}
			else
			{
				return SqlHelper.ExecuteReader(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetRDSServerSettings",
					new SqlParameter("@ServerId", serverId),
					new SqlParameter("@SettingsName", settingsName));
			}
		}

		public void UpdateRdsServerSettings(int serverId, string settingsName, string xml)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateRDSServerSettings]
(
	@ServerId int,
	@SettingsName nvarchar(50),
	@Xml ntext
)
AS

BEGIN TRAN
DECLARE @idoc int
EXEC sp_xml_preparedocument @idoc OUTPUT, @xml

DELETE FROM RDSServerSettings
WHERE RDSServerId = @ServerId AND SettingsName = @SettingsName

INSERT INTO RDSServerSettings
(
	RDSServerId,
	SettingsName,
	ApplyUsers,
	ApplyAdministrators,
	PropertyName,
	PropertyValue	
)
SELECT
	@ServerId,
	@SettingsName,
	ApplyUsers,
	ApplyAdministrators,
	PropertyName,
	PropertyValue
FROM OPENXML(@idoc, '/properties/property',1) WITH 
(
	PropertyName nvarchar(50) '@name',
	PropertyValue ntext '@value',
	ApplyUsers BIT '@applyUsers',
	ApplyAdministrators BIT '@applyAdministrators'
) as PV

exec sp_xml_removedocument @idoc

COMMIT TRAN

RETURN 
				*/
				#endregion

				using (var transaction = Database.BeginTransaction())
				{
					RdsServerSettings
						.Where(s => s.RdsServerId == serverId && s.SettingsName == settingsName)
						.ExecuteDelete();

					var settings = XElement.Parse(xml)
						.Elements()
						.Select(e => new Data.Entities.RdsServerSetting
						{
							RdsServerId = serverId,
							SettingsName = settingsName,
							ApplyUsers = (int)e.Attribute("applyUsers") != 0,
							ApplyAdministrators = (int)e.Attribute("applyAdministrators") != 0,
							PropertyName = (string)e.Attribute("name"),
							PropertyValue = (string)e.Attribute("value")
						});
					RdsServerSettings.AddRange(settings);
					SaveChanges();
					transaction.Commit();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "UpdateRDSServerSettings",
					new SqlParameter("@ServerId", serverId),
					new SqlParameter("@SettingsName", settingsName),
					new SqlParameter("@Xml", xml));
			}
		}

		public int AddRdsCertificate(int serviceId, string content, byte[] hash, string fileName, DateTime? validFrom, DateTime? expiryDate)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddRDSCertificate]
(
	@RDSCertificateId INT OUTPUT,
	@ServiceId INT,
	@Content NTEXT,
	@Hash NVARCHAR(255),
	@FileName NVARCHAR(255),
	@ValidFrom DATETIME,
	@ExpiryDate DATETIME
)
AS
INSERT INTO RDSCertificates
(
	ServiceId,
	Content,
	Hash,
	FileName,
	ValidFrom,
	ExpiryDate	
)
VALUES
(
	@ServiceId,
	@Content,
	@Hash,
	@FileName,
	@ValidFrom,
	@ExpiryDate
)

SET @RDSCertificateId = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var cert = new Data.Entities.RdsCertificate()
				{
					ServiceId = serviceId,
					Content = content,
					Hash = Convert.ToBase64String(hash),
					FileName = fileName,
					ValidFrom = validFrom,
					ExpiryDate = expiryDate
				};
				RdsCertificates.Add(cert);
				SaveChanges();
				return cert.Id;
			}
			else
			{
				SqlParameter rdsCertificateId = new SqlParameter("@RDSCertificateID", SqlDbType.Int);
				rdsCertificateId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddRDSCertificate",
					rdsCertificateId,
					new SqlParameter("@ServiceId", serviceId),
					new SqlParameter("@Content", content),
					new SqlParameter("@Hash", Convert.ToBase64String(hash)),
					new SqlParameter("@FileName", fileName),
					new SqlParameter("@ValidFrom", validFrom),
					new SqlParameter("@ExpiryDate", expiryDate));

				return Convert.ToInt32(rdsCertificateId.Value);
			}
		}

		public IDataReader GetRdsCertificateByServiceId(int serviceId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSCertificateByServiceId]
(
	@ServiceId INT
)
AS
SELECT TOP 1
	Id,
	ServiceId,
	Content, 
	Hash,
	FileName,
	ValidFrom,
	ExpiryDate
	FROM RDSCertificates
	WHERE ServiceId = @ServiceId
	ORDER BY Id DESC
				*/
				#endregion

				var cert = RdsCertificates
					.Where(c => c.ServiceId == serviceId)
					.OrderByDescending(c => c.Id)
					.Take(1)
					.Select(c => new
					{
						c.Id,
						c.ServiceId,
						c.Content,
						c.Hash,
						c.FileName,
						c.ValidFrom,
						c.ExpiryDate
					});
				return EntityDataReader(cert);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSCertificateByServiceId",
					new SqlParameter("@ServiceId", serviceId));
			}
		}

		public IDataReader GetRdsCollectionSettingsByCollectionId(int collectionId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSCollectionSettingsByCollectionId]
(
	@RDSCollectionID INT
)
AS

SELECT TOP 1
	Id,
	RDSCollectionId,
	DisconnectedSessionLimitMin, 
	ActiveSessionLimitMin,
	IdleSessionLimitMin,
	BrokenConnectionAction,
	AutomaticReconnectionEnabled,
	TemporaryFoldersDeletedOnExit,
	TemporaryFoldersPerSession,
	ClientDeviceRedirectionOptions,
	ClientPrinterRedirected,
	ClientPrinterAsDefault,
	RDEasyPrintDriverEnabled,
	MaxRedirectedMonitors,
	SecurityLayer,
	EncryptionLevel,
	AuthenticateUsingNLA

	FROM RDSCollectionSettings
	WHERE RDSCollectionID = @RDSCollectionID
				*/
				#endregion

				var setting = RdsCollectionSettings
					.Where(s => s.RdsCollectionId == collectionId)
					.Take(1)
					.Select(s => new
					{
						s.Id,
						s.RdsCollectionId,
						s.DisconnectedSessionLimitMin,
						s.ActiveSessionLimitMin,
						s.IdleSessionLimitMin,
						s.BrokenConnectionAction,
						s.AutomaticReconnectionEnabled,
						s.TemporaryFoldersDeletedOnExit,
						s.TemporaryFoldersPerSession,
						s.ClientDeviceRedirectionOptions,
						s.ClientPrinterRedirected,
						s.ClientPrinterAsDefault,
						s.RdEasyPrintDriverEnabled,
						s.MaxRedirectedMonitors,
						s.SecurityLayer,
						s.EncryptionLevel,
						s.AuthenticateUsingNla
					});
				return EntityDataReader(setting);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSCollectionSettingsByCollectionId",
					new SqlParameter("@RDSCollectionID", collectionId));
			}
		}

		public int AddRdsCollectionSettings(RdsCollectionSettings settings)
		{
			return AddRdsCollectionSettings(settings.RdsCollectionId, settings.DisconnectedSessionLimitMin, settings.ActiveSessionLimitMin, settings.IdleSessionLimitMin, settings.BrokenConnectionAction,
				settings.AutomaticReconnectionEnabled, settings.TemporaryFoldersDeletedOnExit, settings.TemporaryFoldersPerSession, settings.ClientDeviceRedirectionOptions, settings.ClientPrinterRedirected,
				settings.ClientPrinterAsDefault, settings.RDEasyPrintDriverEnabled, settings.MaxRedirectedMonitors, settings.SecurityLayer, settings.EncryptionLevel, settings.AuthenticateUsingNLA);
		}

		private int AddRdsCollectionSettings(int rdsCollectionId, int disconnectedSessionLimitMin, int activeSessionLimitMin, int idleSessionLimitMin, string brokenConnectionAction,
			 bool automaticReconnectionEnabled, bool temporaryFoldersDeletedOnExit, bool temporaryFoldersPerSession, string clientDeviceRedirectionOptions, bool ClientPrinterRedirected,
			 bool clientPrinterAsDefault, bool rdEasyPrintDriverEnabled, int maxRedirectedMonitors, string SecurityLayer, string EncryptionLevel, bool AuthenticateUsingNLA)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddRDSCollectionSettings]
(
	@RDSCollectionSettingsID INT OUTPUT,
	@RDSCollectionId INT,
	@DisconnectedSessionLimitMin INT, 
	@ActiveSessionLimitMin INT,
	@IdleSessionLimitMin INT,
	@BrokenConnectionAction NVARCHAR(20),
	@AutomaticReconnectionEnabled BIT,
	@TemporaryFoldersDeletedOnExit BIT,
	@TemporaryFoldersPerSession BIT,
	@ClientDeviceRedirectionOptions NVARCHAR(250),
	@ClientPrinterRedirected BIT,
	@ClientPrinterAsDefault BIT,
	@RDEasyPrintDriverEnabled BIT,
	@MaxRedirectedMonitors INT,
	@SecurityLayer NVARCHAR(20),
	@EncryptionLevel NVARCHAR(20),
	@AuthenticateUsingNLA BIT
)
AS

INSERT INTO RDSCollectionSettings
(
	RDSCollectionId,
	DisconnectedSessionLimitMin, 
	ActiveSessionLimitMin,
	IdleSessionLimitMin,
	BrokenConnectionAction,
	AutomaticReconnectionEnabled,
	TemporaryFoldersDeletedOnExit,
	TemporaryFoldersPerSession,
	ClientDeviceRedirectionOptions,
	ClientPrinterRedirected,
	ClientPrinterAsDefault,
	RDEasyPrintDriverEnabled,
	MaxRedirectedMonitors,
	SecurityLayer,
	EncryptionLevel,
	AuthenticateUsingNLA
)
VALUES
(
	@RDSCollectionId,
	@DisconnectedSessionLimitMin, 
	@ActiveSessionLimitMin,
	@IdleSessionLimitMin,
	@BrokenConnectionAction,
	@AutomaticReconnectionEnabled,
	@TemporaryFoldersDeletedOnExit,
	@TemporaryFoldersPerSession,
	@ClientDeviceRedirectionOptions,
	@ClientPrinterRedirected,
	@ClientPrinterAsDefault,
	@RDEasyPrintDriverEnabled,
	@MaxRedirectedMonitors,
	@SecurityLayer,
	@EncryptionLevel,
	@AuthenticateUsingNLA
)

SET @RDSCollectionSettingsID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var setting = new Data.Entities.RdsCollectionSetting()
				{
					RdsCollectionId = rdsCollectionId,
					DisconnectedSessionLimitMin = disconnectedSessionLimitMin,
					ActiveSessionLimitMin = activeSessionLimitMin,
					IdleSessionLimitMin = idleSessionLimitMin,
					BrokenConnectionAction = brokenConnectionAction,
					AutomaticReconnectionEnabled = automaticReconnectionEnabled,
					TemporaryFoldersDeletedOnExit = temporaryFoldersDeletedOnExit,
					TemporaryFoldersPerSession = temporaryFoldersPerSession,
					ClientDeviceRedirectionOptions = clientDeviceRedirectionOptions,
					ClientPrinterRedirected = ClientPrinterRedirected,
					ClientPrinterAsDefault = clientPrinterAsDefault,
					RdEasyPrintDriverEnabled = rdEasyPrintDriverEnabled,
					MaxRedirectedMonitors = maxRedirectedMonitors,
					SecurityLayer = SecurityLayer,
					EncryptionLevel = EncryptionLevel,
					AuthenticateUsingNla = AuthenticateUsingNLA
				};
				RdsCollectionSettings.Add(setting);
				SaveChanges();
				return setting.Id;
			}
			else
			{
				SqlParameter rdsCollectionSettingsId = new SqlParameter("@RDSCollectionSettingsID", SqlDbType.Int);
				rdsCollectionSettingsId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddRDSCollectionSettings",
					rdsCollectionSettingsId,
					new SqlParameter("@RdsCollectionId", rdsCollectionId),
					new SqlParameter("@DisconnectedSessionLimitMin", disconnectedSessionLimitMin),
					new SqlParameter("@ActiveSessionLimitMin", activeSessionLimitMin),
					new SqlParameter("@IdleSessionLimitMin", idleSessionLimitMin),
					new SqlParameter("@BrokenConnectionAction", brokenConnectionAction),
					new SqlParameter("@AutomaticReconnectionEnabled", automaticReconnectionEnabled),
					new SqlParameter("@TemporaryFoldersDeletedOnExit", temporaryFoldersDeletedOnExit),
					new SqlParameter("@TemporaryFoldersPerSession", temporaryFoldersPerSession),
					new SqlParameter("@ClientDeviceRedirectionOptions", clientDeviceRedirectionOptions),
					new SqlParameter("@ClientPrinterRedirected", ClientPrinterRedirected),
					new SqlParameter("@ClientPrinterAsDefault", clientPrinterAsDefault),
					new SqlParameter("@RDEasyPrintDriverEnabled", rdEasyPrintDriverEnabled),
					new SqlParameter("@MaxRedirectedMonitors", maxRedirectedMonitors),
					new SqlParameter("@SecurityLayer", SecurityLayer),
					new SqlParameter("@EncryptionLevel", EncryptionLevel),
					new SqlParameter("@AuthenticateUsingNLA", AuthenticateUsingNLA));

				return Convert.ToInt32(rdsCollectionSettingsId.Value);
			}
		}

		public void UpdateRDSCollectionSettings(RdsCollectionSettings settings)
		{
			UpdateRDSCollectionSettings(settings.Id, settings.RdsCollectionId, settings.DisconnectedSessionLimitMin, settings.ActiveSessionLimitMin, settings.IdleSessionLimitMin, settings.BrokenConnectionAction,
				settings.AutomaticReconnectionEnabled, settings.TemporaryFoldersDeletedOnExit, settings.TemporaryFoldersPerSession, settings.ClientDeviceRedirectionOptions, settings.ClientPrinterRedirected,
				settings.ClientPrinterAsDefault, settings.RDEasyPrintDriverEnabled, settings.MaxRedirectedMonitors, settings.SecurityLayer, settings.EncryptionLevel, settings.AuthenticateUsingNLA);
		}

		public void UpdateRDSCollectionSettings(int id, int rdsCollectionId, int disconnectedSessionLimitMin, int activeSessionLimitMin, int idleSessionLimitMin, string brokenConnectionAction,
			bool automaticReconnectionEnabled, bool temporaryFoldersDeletedOnExit, bool temporaryFoldersPerSession, string clientDeviceRedirectionOptions, bool ClientPrinterRedirected,
			bool clientPrinterAsDefault, bool rdEasyPrintDriverEnabled, int maxRedirectedMonitors, string SecurityLayer, string EncryptionLevel, bool AuthenticateUsingNLA)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateRDSCollectionSettings]
(
	@ID INT,
	@RDSCollectionId INT,
	@DisconnectedSessionLimitMin INT, 
	@ActiveSessionLimitMin INT,
	@IdleSessionLimitMin INT,
	@BrokenConnectionAction NVARCHAR(20),
	@AutomaticReconnectionEnabled BIT,
	@TemporaryFoldersDeletedOnExit BIT,
	@TemporaryFoldersPerSession BIT,
	@ClientDeviceRedirectionOptions NVARCHAR(250),
	@ClientPrinterRedirected BIT,
	@ClientPrinterAsDefault BIT,
	@RDEasyPrintDriverEnabled BIT,
	@MaxRedirectedMonitors INT,
	@SecurityLayer NVARCHAR(20),
	@EncryptionLevel NVARCHAR(20),
	@AuthenticateUsingNLA BIT
)
AS

UPDATE RDSCollectionSettings
SET
	RDSCollectionId = @RDSCollectionId,
	DisconnectedSessionLimitMin = @DisconnectedSessionLimitMin,
	ActiveSessionLimitMin = @ActiveSessionLimitMin,
	IdleSessionLimitMin = @IdleSessionLimitMin,
	BrokenConnectionAction = @BrokenConnectionAction,
	AutomaticReconnectionEnabled = @AutomaticReconnectionEnabled,
	TemporaryFoldersDeletedOnExit = @TemporaryFoldersDeletedOnExit,
	TemporaryFoldersPerSession = @TemporaryFoldersPerSession,
	ClientDeviceRedirectionOptions = @ClientDeviceRedirectionOptions,
	ClientPrinterRedirected = @ClientPrinterRedirected,
	ClientPrinterAsDefault = @ClientPrinterAsDefault,
	RDEasyPrintDriverEnabled = @RDEasyPrintDriverEnabled,
	MaxRedirectedMonitors = @MaxRedirectedMonitors,
	SecurityLayer = @SecurityLayer,
	EncryptionLevel = @EncryptionLevel,
	AuthenticateUsingNLA = @AuthenticateUsingNLA
WHERE ID = @Id
				*/
				#endregion

				var setting = RdsCollectionSettings
					.FirstOrDefault(s => s.Id == id);
				if (setting != null)
				{
					setting.RdsCollectionId = rdsCollectionId;
					setting.DisconnectedSessionLimitMin = disconnectedSessionLimitMin;
					setting.ActiveSessionLimitMin = activeSessionLimitMin;
					setting.IdleSessionLimitMin = idleSessionLimitMin;
					setting.BrokenConnectionAction = brokenConnectionAction;
					setting.AutomaticReconnectionEnabled = automaticReconnectionEnabled;
					setting.TemporaryFoldersDeletedOnExit = temporaryFoldersDeletedOnExit;
					setting.TemporaryFoldersPerSession = temporaryFoldersPerSession;
					setting.ClientDeviceRedirectionOptions = clientDeviceRedirectionOptions;
					setting.ClientPrinterRedirected = ClientPrinterRedirected;
					setting.ClientPrinterAsDefault = clientPrinterAsDefault;
					setting.RdEasyPrintDriverEnabled = rdEasyPrintDriverEnabled;
					setting.MaxRedirectedMonitors = maxRedirectedMonitors;
					setting.SecurityLayer = SecurityLayer;
					setting.EncryptionLevel = EncryptionLevel;
					setting.AuthenticateUsingNla = AuthenticateUsingNLA;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateRDSCollectionSettings",
					new SqlParameter("@Id", id),
					new SqlParameter("@RdsCollectionId", rdsCollectionId),
					new SqlParameter("@DisconnectedSessionLimitMin", disconnectedSessionLimitMin),
					new SqlParameter("@ActiveSessionLimitMin", activeSessionLimitMin),
					new SqlParameter("@IdleSessionLimitMin", idleSessionLimitMin),
					new SqlParameter("@BrokenConnectionAction", brokenConnectionAction),
					new SqlParameter("@AutomaticReconnectionEnabled", automaticReconnectionEnabled),
					new SqlParameter("@TemporaryFoldersDeletedOnExit", temporaryFoldersDeletedOnExit),
					new SqlParameter("@TemporaryFoldersPerSession", temporaryFoldersPerSession),
					new SqlParameter("@ClientDeviceRedirectionOptions", clientDeviceRedirectionOptions),
					new SqlParameter("@ClientPrinterRedirected", ClientPrinterRedirected),
					new SqlParameter("@ClientPrinterAsDefault", clientPrinterAsDefault),
					new SqlParameter("@RDEasyPrintDriverEnabled", rdEasyPrintDriverEnabled),
					new SqlParameter("@MaxRedirectedMonitors", maxRedirectedMonitors),
					new SqlParameter("@SecurityLayer", SecurityLayer),
					new SqlParameter("@EncryptionLevel", EncryptionLevel),
					new SqlParameter("@AuthenticateUsingNLA", AuthenticateUsingNLA));
			}
		}

		public void DeleteRDSCollectionSettings(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteRDSCollectionSettings]
(
	@Id  int
)
AS

DELETE FROM DeleteRDSCollectionSettings
WHERE Id = @Id
				*/
				#endregion

				RdsCollectionSettings.Where(s => s.Id == id).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteRDSCollectionSettings",
					new SqlParameter("@Id", id));
			}
		}

		public IDataReader GetRDSCollectionsByItemId(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSCollectionsByItemId]
(
	@ItemID INT
)
AS
SELECT 
	Id,
	ItemId,
	Name, 
	Description,
	DisplayName
	FROM RDSCollections
	WHERE ItemID = @ItemID
				*/
				#endregion

				var items = RdsCollections
					.Where(c => c.ItemId == itemId);
				return EntityDataReader(items);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSCollectionsByItemId",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public IDataReader GetRDSCollectionByName(string name)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSCollectionByName]
(
	@Name NVARCHAR(255)
)
AS

SELECT TOP 1
	Id,
	Name, 
	ItemId,
	Description,
	DisplayName
	FROM RDSCollections
	WHERE DisplayName = @Name
				*/
				#endregion

				var items = RdsCollections
					.Where(c => c.DisplayName == name)
					.Take(1);
				return EntityDataReader(items);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSCollectionByName",
					new SqlParameter("@Name", name));
			}
		}

		public IDataReader GetRDSCollectionById(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSCollectionById]
(
	@ID INT
)
AS

SELECT TOP 1
	Id,
	ItemId,
	Name, 
	Description,
	DisplayName 
	FROM RDSCollections
	WHERE ID = @ID
				*/
				#endregion

				var collection = RdsCollections
					.Where(c => c.Id == id)
					.Take(1)
					.Select(c => new
					{
						c.Id,
						c.ItemId,
						c.Name,
						c.Description,
						c.DisplayName
					});
				return EntityDataReader(collection);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSCollectionById",
					new SqlParameter("@ID", id));
			}
		}

		public DataSet GetRDSCollectionsPaged(int itemId, string filterColumn, string filterValue, string sortColumn, int startRow, int maximumRows)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSCollectionsPaged]
(
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@ItemID int,
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int
)
AS
-- build query and run it to the temporary table
DECLARE @sql nvarchar(2000)

SET @sql = '

DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows
DECLARE @RDSCollections TABLE
(
	ItemPosition int IDENTITY(0,1),
	RDSCollectionId int
)
INSERT INTO @RDSCollections (RDSCollectionId)
SELECT
	S.ID
FROM RDSCollections AS S
WHERE 
	((@ItemID is Null AND S.ItemID is null)
		or (@ItemID is not Null AND S.ItemID = @ItemID))'

IF @FilterColumn <> '' AND @FilterValue <> ''
SET @sql = @sql + ' AND ' + @FilterColumn + ' LIKE ''%' + @FilterValue + '%'' '

IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + ' SELECT COUNT(RDSCollectionId) FROM @RDSCollections;
SELECT
	CR.ID,
	CR.ItemID,
	CR.Name,
	CR.Description,
	CR.DisplayName
FROM @RDSCollections AS C
INNER JOIN RDSCollections AS CR ON C.RDSCollectionId = CR.ID
WHERE C.ItemPosition BETWEEN @StartRow AND @EndRow'

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int,  @FilterValue nvarchar(50),  @ItemID int',
@StartRow, @MaximumRows,  @FilterValue,  @ItemID

RETURN
				*/
				#endregion

				var collections = RdsCollections
					.Where(c => c.ItemId == itemId)
					.Select(c => new
					{
						c.Id,
						c.ItemId,
						c.Name,
						c.Description,
						c.DisplayName
					});

				if (!string.IsNullOrEmpty(filterValue) && !string.IsNullOrEmpty(filterColumn))
				{
					collections = collections.Where(DynamicFunctions.ColumnLike(collections, filterColumn, filterValue));
				}

				var count = collections.Count();

				if (!string.IsNullOrEmpty(sortColumn)) collections = collections.OrderBy(sortColumn);

				collections = collections.Skip(startRow).Take(maximumRows);

				return EntityDataSet(collections);
			}
			else
			{
				return SqlHelper.ExecuteDataset(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSCollectionsPaged",
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@itemId", itemId),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@maximumRows", maximumRows));
			}
		}

		public int AddRDSCollection(int itemId, string name, string description, string displayName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddRDSCollection]
(
	@RDSCollectionID INT OUTPUT,
	@ItemID INT,
	@Name NVARCHAR(255),
	@Description NVARCHAR(255),
	@DisplayName NVARCHAR(255)
)
AS

INSERT INTO RDSCollections
(
	ItemID,
	Name,
	Description,
	DisplayName
)
VALUES
(
	@ItemID,
	@Name,
	@Description,
	@DisplayName
)

SET @RDSCollectionID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var collection = new Data.Entities.RdsCollection()
				{
					ItemId = itemId,
					Name = name,
					Description = description,
					DisplayName = displayName
				};
				RdsCollections.Add(collection);
				SaveChanges();
				return collection.Id;
			}
			else
			{
				SqlParameter rdsCollectionId = new SqlParameter("@RDSCollectionID", SqlDbType.Int);
				rdsCollectionId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddRDSCollection",
					rdsCollectionId,
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@Name", name),
					new SqlParameter("@Description", description),
					new SqlParameter("@DisplayName", displayName));

				// read identity
				return Convert.ToInt32(rdsCollectionId.Value);
			}
		}

		public int GetOrganizationRdsUsersCount(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOrganizationRdsUsersCount]
(
	@ItemID INT,
	@TotalNumber int OUTPUT
)
AS
SELECT
  @TotalNumber = Count(DISTINCT([AccountId]))
  FROM [dbo].[RDSCollectionUsers]
  WHERE [RDSCollectionId] in (SELECT [ID] FROM [RDSCollections] where [ItemId]  = @ItemId )
RETURN
				*/
				#endregion

				return RdsCollectionUsers
					.Where(u => u.RdsCollection.ItemId == itemId)
					.Count();
			}
			else
			{
				SqlParameter count = new SqlParameter("@TotalNumber", SqlDbType.Int);
				count.Direction = ParameterDirection.Output;

				DataSet ds = SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetOrganizationRdsUsersCount",
					count,
					new SqlParameter("@ItemId", itemId));

				// read identity
				return Convert.ToInt32(count.Value);
			}
		}

		public int GetOrganizationRdsCollectionsCount(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOrganizationRdsCollectionsCount]
(
	@ItemID INT,
	@TotalNumber int OUTPUT
)
AS
SELECT
  @TotalNumber = Count([Id])
  FROM [dbo].[RDSCollections] WHERE [ItemId]  = @ItemId
RETURN
				*/
				#endregion

				return RdsCollections.Count(c => c.ItemId == itemId);
			}
			else
			{
				SqlParameter count = new SqlParameter("@TotalNumber", SqlDbType.Int);
				count.Direction = ParameterDirection.Output;

				DataSet ds = SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetOrganizationRdsCollectionsCount",
					count,
					new SqlParameter("@ItemId", itemId));

				// read identity
				return Convert.ToInt32(count.Value);
			}
		}

		public int GetOrganizationRdsServersCount(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOrganizationRdsServersCount]
(
	@ItemID INT,
	@TotalNumber int OUTPUT
)
AS
SELECT
  @TotalNumber = Count([Id])
  FROM [dbo].[RDSServers] WHERE [ItemId]  = @ItemId
RETURN
				*/
				#endregion

				return RdsServers.Count(s => s.ItemId == itemId);
			}
			else
			{
				SqlParameter count = new SqlParameter("@TotalNumber", SqlDbType.Int);
				count.Direction = ParameterDirection.Output;

				DataSet ds = SqlHelper.ExecuteDataset(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetOrganizationRdsServersCount",
					count,
					new SqlParameter("@ItemId", itemId));

				// read identity
				return Convert.ToInt32(count.Value);
			}
		}

		public void UpdateRDSCollection(RdsCollection collection)
		{
			UpdateRDSCollection(collection.Id, collection.ItemId, collection.Name, collection.Description, collection.DisplayName);
		}

		public void UpdateRDSCollection(int id, int itemId, string name, string description, string displayName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateRDSCollection]
(
	@ID INT,
	@ItemID INT,
	@Name NVARCHAR(255),
	@Description NVARCHAR(255),
	@DisplayName NVARCHAR(255)
)
AS

UPDATE RDSCollections
SET
	ItemID = @ItemID,
	Name = @Name,
	Description = @Description,
	DisplayName = @DisplayName
WHERE ID = @Id
				*/
				#endregion

				var collection = RdsCollections
					.FirstOrDefault(c => c.Id == id);
				if (collection != null)
				{
					collection.ItemId = itemId;
					collection.Name = name;
					collection.Description = description;
					collection.DisplayName = displayName;
					SaveChanges();
				}
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateRDSCollection",
					new SqlParameter("@Id", id),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@Name", name),
					new SqlParameter("@Description", description),
					new SqlParameter("@DisplayName", displayName));
			}
		}

		public void DeleteRDSServerSettings(int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteRDSServerSettings]
(
	@ServerId int
)
AS
	DELETE FROM RDSServerSettings WHERE RDSServerId = @ServerId
				*/
				#endregion

				RdsServerSettings.Where(s => s.RdsServerId == serverId).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteRDSServerSettings",
					new SqlParameter("@ServerId", serverId));
			}
		}

		public void DeleteRDSCollection(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteRDSCollection]
(
	@Id  int
)
AS

UPDATE RDSServers
SET
	RDSCollectionId = Null
WHERE RDSCollectionId = @Id

DELETE FROM RDSCollections
WHERE Id = @Id
				*/
				#endregion

				RdsServers
					.Where(s => s.RdsCollectionId == id)
					.ExecuteUpdate(rc => new Data.Entities.RdsServer {
						RdsCollectionId = null
					});

				RdsCollections
					.Where(c => c.Id == id)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteRDSCollection",
					new SqlParameter("@Id", id));
			}
		}

		public int AddRDSServer(string name, string fqdName, string description, string controller)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddRDSServer]
(
	@RDSServerID INT OUTPUT,
	@Name NVARCHAR(255),
	@FqdName NVARCHAR(255),
	@Description NVARCHAR(255),
	@Controller INT
)
AS
INSERT INTO RDSServers
(
	Name,
	FqdName,
	Description,
	Controller
)
VALUES
(
	@Name,
	@FqdName,
	@Description,
	@Controller
)

SET @RDSServerID = SCOPE_IDENTITY()

RETURN
				*/
				#endregion

				var server = new Data.Entities.RdsServer()
				{
					Name = name,
					FqdName = fqdName,
					Description = description,
					Controller = int.Parse(controller)
				};
				RdsServers.Add(server);
				SaveChanges();
				return server.Id;
			}
			else
			{
				SqlParameter rdsServerId = new SqlParameter("@RDSServerID", SqlDbType.Int);
				rdsServerId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddRDSServer",
					rdsServerId,
					new SqlParameter("@FqdName", fqdName),
					new SqlParameter("@Name", name),
					new SqlParameter("@Description", description),
					new SqlParameter("@Controller", controller));

				// read identity
				return Convert.ToInt32(rdsServerId.Value);
			}
		}

		public IDataReader GetRDSServersByItemId(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSServersByItemId]
(
	@ItemID INT
)
AS
SELECT 
	RS.Id,
	RS.ItemID,
	RS.Name, 
	RS.FqdName,
	RS.Description,
	RS.RdsCollectionId,
	SI.ItemName
	FROM RDSServers AS RS
	LEFT OUTER JOIN  ServiceItems AS SI ON SI.ItemId = RS.ItemId
	WHERE RS.ItemID = @ItemID
				*/
				#endregion

				var servers = RdsServers
					.Where(s => s.ItemId == itemId)
					.GroupJoin(ServiceItems, s => s.ItemId, i => i.ItemId, (s, i) => new
					{
						Server = s,
						Items = i
					})
					.SelectMany(s => s.Items.DefaultIfEmpty(), (s, i) => new
					{
						s.Server.Id,
						s.Server.ItemId,
						s.Server.Name,
						s.Server.FqdName,
						s.Server.Description,
						s.Server.RdsCollectionId,
						ItemName = i != null ? i.ItemName : null
					});
				return EntityDataReader(servers);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSServersByItemId",
					new SqlParameter("@ItemID", itemId));
			}
		}

		public DataSet GetRDSServersPaged(int? itemId, int? collectionId, string filterColumn, string filterValue, string sortColumn, int startRow, int maximumRows, string controller, bool ignoreItemId = false, bool ignoreRdsCollectionId = false)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSServersPaged]
(
	@FilterColumn nvarchar(50) = '',
	@FilterValue nvarchar(50) = '',
	@ItemID int,
	@IgnoreItemId bit,
	@RdsCollectionId int,
	@IgnoreRdsCollectionId bit,
	@SortColumn nvarchar(50),
	@StartRow int,
	@MaximumRows int,
	@Controller int,
	@ControllerName nvarchar(50) = ''
)
AS
-- build query and run it to the temporary table
DECLARE @sql nvarchar(2000)

SET @sql = '

DECLARE @EndRow int
SET @EndRow = @StartRow + @MaximumRows

DECLARE @RDSServer TABLE
(
	ItemPosition int IDENTITY(0,1),
	RDSServerId int
)
INSERT INTO @RDSServer (RDSServerId)
SELECT
	S.ID
FROM RDSServers AS S
LEFT OUTER JOIN  ServiceItems AS SI ON SI.ItemId = S.ItemId
LEFT OUTER JOIN  Services AS SE ON SE.ServiceID = S.Controller
LEFT OUTER JOIN  RDSCollections AS RC ON RC.ID = S.RdsCollectionId
WHERE 
	((((@ItemID is Null AND S.ItemID is null ) or (@IgnoreItemId = 1 ))
		or (@ItemID is not Null AND S.ItemID = @ItemID ))
	and
	(((@RdsCollectionId is Null AND S.RDSCollectionId is null) or @IgnoreRdsCollectionId = 1)
		or (@RdsCollectionId is not Null AND S.RDSCollectionId = @RdsCollectionId)))'

IF @FilterColumn <> '' AND @FilterValue <> ''
SET @sql = @sql + ' AND ' + @FilterColumn + ' LIKE ''%' + @FilterValue + '%'''

IF @Controller <> ''
SET @sql = @sql + ' AND Controller = @Controller '

IF @SortColumn <> '' AND @SortColumn IS NOT NULL
SET @sql = @sql + ' ORDER BY ' + @SortColumn + ' '

SET @sql = @sql + ' SELECT COUNT(RDSServerId) FROM @RDSServer;
SELECT
	ST.ID,
	ST.ItemID,
	ST.Name, 
	ST.FqdName,
	ST.Description,
	ST.RdsCollectionId,
	SI.ItemName,
	ST.ConnectionEnabled,
	ST.Controller,
	SE.ServiceName as ControllerName,
	RC.Name as CollectionName
FROM @RDSServer AS S
INNER JOIN RDSServers AS ST ON S.RDSServerId = ST.ID
LEFT OUTER JOIN  ServiceItems AS SI ON SI.ItemId = ST.ItemId
LEFT OUTER JOIN  Services AS SE ON SE.ServiceID = ST.Controller
LEFT OUTER JOIN  RDSCollections AS RC ON RC.ID = ST.RdsCollectionId
WHERE S.ItemPosition BETWEEN @StartRow AND @EndRow'

exec sp_executesql @sql, N'@StartRow int, @MaximumRows int,  @FilterValue nvarchar(50),  @ItemID int, @RdsCollectionId int, @IgnoreItemId bit, @IgnoreRdsCollectionId bit, @Controller int, @ControllerName nvarchar(50)',
@StartRow, @MaximumRows,  @FilterValue,  @ItemID, @RdsCollectionId, @IgnoreItemId , @IgnoreRdsCollectionId, @Controller, @ControllerName

RETURN
				*/
				#endregion

				var servers = RdsServers
					.Where(s => (ignoreItemId || s.ItemId == itemId) &&
						(ignoreRdsCollectionId || s.RdsCollectionId == collectionId))
					.GroupJoin(ServiceItems, s => s.ItemId, si => si.ItemId, (s, si) => new
					{
						Server = s,
						ServiceItems = si
					})
					.SelectMany(s => s.ServiceItems.DefaultIfEmpty(), (s, si) => new
					{
						s.Server,
						ItemName = si != null ? si.ItemName : null,
					})
					.GroupJoin(Services, s => s.Server.Controller, svc => svc.ServiceId, (s, svc) => new
					{
						s.Server,
						s.ItemName,						
						Services = svc
					})
					.SelectMany(s => s.Services.DefaultIfEmpty(), (s, svc) => new
					{
						s.Server.Id,
						s.Server.ItemId,
						s.Server.Name,
						s.Server.FqdName,
						s.Server.Description,
						s.Server.RdsCollectionId,
						s.Server.ConnectionEnabled,
						s.Server.Controller,
						s.ItemName,
						ControllerName = svc != null ? svc.ServiceName : null,
						CollectionName = s.Server.RdsCollection != null ? s.Server.RdsCollection.Name : null
					});

				if (!string.IsNullOrEmpty(filterColumn) && !string.IsNullOrEmpty(filterValue))
				{
					servers = servers.Where(DynamicFunctions.ColumnLike(servers, filterColumn, filterValue));
				}

				var count = servers.Count();

				if (!string.IsNullOrEmpty(sortColumn))
				{
					if (sortColumn.StartsWith("S.")) sortColumn = sortColumn.Substring(2);
					servers = servers.OrderBy(sortColumn);
				}

				servers = servers.Skip(startRow).Take(maximumRows);

				return EntityDataSet(count, servers);
			}
			else
			{
				return SqlHelper.ExecuteDataset(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSServersPaged",
					new SqlParameter("@FilterColumn", VerifyColumnName(filterColumn)),
					new SqlParameter("@FilterValue", VerifyColumnValue(filterValue)),
					new SqlParameter("@SortColumn", VerifyColumnName(sortColumn)),
					new SqlParameter("@startRow", startRow),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@RdsCollectionId", collectionId),
					new SqlParameter("@IgnoreItemId", ignoreItemId),
					new SqlParameter("@IgnoreRdsCollectionId", ignoreRdsCollectionId),
					new SqlParameter("@maximumRows", maximumRows),
					new SqlParameter("@Controller", controller));
			}
		}

		public IDataReader GetRDSServerById(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSServerById]
(
	@ID INT
)
AS
SELECT TOP 1
	RS.Id,
	RS.ItemID,
	RS.Name, 
	RS.FqdName,
	RS.Description,
	RS.RdsCollectionId,
	RS.ConnectionEnabled,
	SI.ItemName,
	RC.Name AS ""CollectionName""
FROM RDSServers AS RS
LEFT OUTER JOIN  ServiceItems AS SI ON SI.ItemId = RS.ItemId
LEFT OUTER JOIN  RDSCollections AS RC ON RC.ID = RdsCollectionId
WHERE RS.Id = @Id
				*/
				#endregion

				var server = RdsServers
					.Where(s => s.Id == id)
					.GroupJoin(ServiceItems, s => s.ItemId, si => si.ItemId, (s, si) => new
					{
						Server = s,
						Items = si,
						CollectionName = s.RdsCollection != null ? s.RdsCollection.Name : null
					})
					.SelectMany(s => s.Items.DefaultIfEmpty(), (s, si) => new
					{
						s.Server.Id,
						s.Server.ItemId,
						s.Server.Name,
						s.Server.FqdName,
						s.Server.Description,
						s.Server.RdsCollectionId,
						s.Server.ConnectionEnabled,
						ItemName = si != null ? si.ItemName : null,
						s.CollectionName
					})
					.Take(1);
				return EntityDataReader(server);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSServerById",
					new SqlParameter("@ID", id));
			}
		}

		public IDataReader GetRDSServersByCollectionId(int collectionId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSServersByCollectionId]
(
	@RdsCollectionId INT
)
AS
SELECT 
	RS.Id,
	RS.ItemID,
	RS.Name, 
	RS.FqdName,
	RS.Description,
	RS.RdsCollectionId,
	SI.ItemName
FROM RDSServers AS RS
LEFT OUTER JOIN  ServiceItems AS SI ON SI.ItemId = RS.ItemId
WHERE RdsCollectionId = @RdsCollectionId
				*/
				#endregion

				var servers = RdsServers
					.Where(s => s.RdsCollectionId == collectionId)
					.GroupJoin(ServiceItems, s => s.ItemId, si => si.ItemId, (s, si) => new
					{
						Server = s,
						Items = si
					})
					.SelectMany(s => s.Items.DefaultIfEmpty(), (s, si) => new
					{
						s.Server.Id,
						s.Server.ItemId,
						s.Server.Name,
						s.Server.FqdName,
						s.Server.Description,
						s.Server.RdsCollectionId,
						ItemName = si != null ? si.ItemName : null,
					});
				return EntityDataReader(servers);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSServersByCollectionId",
					new SqlParameter("@RdsCollectionId", collectionId));
			}
		}

		public void DeleteRDSServer(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteRDSServer]
(
	@Id  int
)
AS
DELETE FROM RDSServers
WHERE Id = @Id
				*/
				#endregion

				RdsServers.Where(s => s.Id == id).ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteRDSServer",
					new SqlParameter("@Id", id));
			}
		}

		public void UpdateRDSServer(RdsServer server)
		{
			UpdateRDSServer(server.Id, server.ItemId, server.Name, server.FqdName, server.Description,
				 server.RdsCollectionId, server.ConnectionEnabled);
		}

		public void UpdateRDSServer(int id, int? itemId, string name, string fqdName, string description, int? rdsCollectionId, string connectionEnabled)
		{
			byte connEnabled = 1;
			if (!String.IsNullOrEmpty(connectionEnabled))
			{
				if (connectionEnabled.Equals("false") || connectionEnabled.Equals("no") || connectionEnabled.Equals("0")) connEnabled = 0;
			}

			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateRDSServer]
(
	@Id  INT,
	@ItemID INT,
	@Name NVARCHAR(255),
	@FqdName NVARCHAR(255),
	@Description NVARCHAR(255),
	@RDSCollectionId INT,
	@ConnectionEnabled BIT
)
AS

UPDATE RDSServers
SET
	ItemID = @ItemID,
	Name = @Name,
	FqdName = @FqdName,
	Description = @Description,
	RDSCollectionId = @RDSCollectionId,
	ConnectionEnabled = @ConnectionEnabled
WHERE ID = @Id
				*/
				#endregion

				var server = RdsServers
					.FirstOrDefault(s => s.Id == id);
				if (server != null) 
				{
					server.ItemId = itemId;
					server.Name = name;
					server.FqdName = fqdName;
					server.Description = description;
					server.RdsCollectionId = rdsCollectionId;
					server.ConnectionEnabled = connEnabled == 1;
					SaveChanges();
				}
			}
			else
			{

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateRDSServer",
					new SqlParameter("@Id", id),
					new SqlParameter("@ItemID", itemId),
					new SqlParameter("@Name", name),
					new SqlParameter("@FqdName", fqdName),
					new SqlParameter("@Description", description),
					new SqlParameter("@RDSCollectionId", rdsCollectionId),
					new SqlParameter("@ConnectionEnabled", connEnabled));
			}
		}

		public void AddRDSServerToCollection(int serverId, int rdsCollectionId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddRDSServerToCollection]
(
	@Id  INT,
	@RDSCollectionId INT
)
AS

UPDATE RDSServers
SET
	RDSCollectionId = @RDSCollectionId
WHERE ID = @Id
				*/
				#endregion

				RdsServers
					.Where(s => s.Id == serverId)
					.ExecuteUpdate(s => new Data.Entities.RdsServer {
						RdsCollectionId = rdsCollectionId
					});
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddRDSServerToCollection",
					new SqlParameter("@Id", serverId),
					new SqlParameter("@RDSCollectionId", rdsCollectionId));
			}
		}

		public void AddRDSServerToOrganization(int itemId, int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddRDSServerToOrganization]
(
	@Id  INT,
	@ItemID INT
)
AS

UPDATE RDSServers
SET
	ItemID = @ItemID
WHERE ID = @Id
				*/
				#endregion

				RdsServers
					.Where(s => s.Id == serverId)
					.ExecuteUpdate(s => new Data.Entities.RdsServer {
						ItemId = itemId
					});
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddRDSServerToOrganization",
					new SqlParameter("@Id", serverId),
					new SqlParameter("@ItemID", itemId));
			}
		}

		public void RemoveRDSServerFromOrganization(int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[RemoveRDSServerFromOrganization]
(
	@Id  INT
)
AS

UPDATE RDSServers
SET
	ItemID = NULL
WHERE ID = @Id
				*/
				#endregion

				RdsServers
					.Where(s => s.Id == serverId)
					.ExecuteUpdate(s => new Data.Entities.RdsServer {
						ItemId = null
					});
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"RemoveRDSServerFromOrganization",
					new SqlParameter("@Id", serverId));
			}
		}

		public void RemoveRDSServerFromCollection(int serverId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[RemoveRDSServerFromCollection]
(
	@Id  INT
)
AS

UPDATE RDSServers
SET
	RDSCollectionId = NULL
WHERE ID = @Id
				*/
				#endregion

				RdsServers
					.Where(s => s.Id == serverId)
					.ExecuteUpdate(s => new Data.Entities.RdsServer {
						RdsCollectionId = null
					});
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"RemoveRDSServerFromCollection",
					new SqlParameter("@Id", serverId));
			}
		}

		public IDataReader GetRDSCollectionUsersByRDSCollectionId(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
	CREATE PROCEDURE [dbo].[GetRDSCollectionUsersByRDSCollectionId]
(
	@ID INT
)
AS
SELECT 
	[AccountID],
	[ItemID],
	[AccountType],
	[AccountName],
	[DisplayName],
	[PrimaryEmailAddress],
	[MailEnabledPublicFolder],
	[MailboxManagerActions],
	[SamAccountName],
	[CreatedDate],
	[MailboxPlanId],
	[SubscriberNumber],
	[UserPrincipalName],
	[ExchangeDisclaimerId],
	[ArchivingMailboxPlanId],
	[EnableArchiving],
	[LevelID],
	[IsVIP]
FROM ExchangeAccounts
WHERE AccountID IN (Select AccountId from RDSCollectionUsers where RDSCollectionId = @Id)
			*/
				#endregion

				var users = ExchangeAccounts
					.Where(a => a.RdsCollectionUsers.Any(u => u.RdsCollectionId == id))
					.Select(a => new
					{
						a.AccountId,
						a.ItemId,
						a.AccountType,
						a.AccountName,
						a.DisplayName,
						a.PrimaryEmailAddress,
						a.MailEnabledPublicFolder,
						a.MailboxManagerActions,
						a.SamAccountName,
						a.CreatedDate,
						a.MailboxPlanId,
						a.SubscriberNumber,
						a.UserPrincipalName,
						a.ExchangeDisclaimerId,
						a.ArchivingMailboxPlanId,
						a.EnableArchiving,
						a.LevelId,
						a.IsVip
					});
				return EntityDataReader(users);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSCollectionUsersByRDSCollectionId",
					new SqlParameter("@id", id));
			}
		}

		public void AddRDSUserToRDSCollection(int rdsCollectionId, int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddUserToRDSCollection]
(
	@RDSCollectionID INT,
	@AccountId INT
)
AS

INSERT INTO RDSCollectionUsers
(
	RDSCollectionId, 
	AccountID
)
VALUES
(
	@RDSCollectionID,
	@AccountId
)
				*/
				#endregion

				var user = new Data.Entities.RdsCollectionUser()
				{
					RdsCollectionId = rdsCollectionId,
					AccountId = accountId
				};
				RdsCollectionUsers.Add(user);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddUserToRDSCollection",
					new SqlParameter("@RDSCollectionId", rdsCollectionId),
					new SqlParameter("@AccountID", accountId));
			}
		}

		public void RemoveRDSUserFromRDSCollection(int rdsCollectionId, int accountId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[RemoveRDSUserFromRDSCollection]
(
	@AccountId  INT,
	@RDSCollectionId INT
)
AS

DELETE FROM RDSCollectionUsers
WHERE AccountId = @AccountId AND RDSCollectionId = @RDSCollectionId
				*/
				#endregion

				RdsCollectionUsers
					.Where(u => u.AccountId == accountId && u.RdsCollectionId == rdsCollectionId)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"RemoveRDSUserFromRDSCollection",
					new SqlParameter("@RDSCollectionId", rdsCollectionId),
					new SqlParameter("@AccountID", accountId));
			}
		}

		public int GetRDSControllerServiceIDbyFQDN(string fqdnName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSControllerServiceIDbyFQDN]
(
	@RdsfqdnName NVARCHAR(255),
	@Controller int OUTPUT
)
AS

SELECT @Controller = Controller
	FROM RDSServers
	WHERE FqdName = @RdsfqdnName

RETURN
				*/
				#endregion

				return RdsServers
					.Where(s => s.FqdName == fqdnName)
					.Select(s => s.Controller)
					.FirstOrDefault() ?? 0;
			}
			else
			{
				SqlParameter prmController = new SqlParameter("@Controller", SqlDbType.Int);
				prmController.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(ConnectionString, CommandType.StoredProcedure,
					ObjectQualifier + "GetRDSControllerServiceIDbyFQDN",
					new SqlParameter("@RdsfqdnName", fqdnName),
					prmController);

				return Convert.ToInt32(prmController.Value);
			}
		}

#endregion

		#region MX|NX Services

		public IDataReader GetAllPackages()
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetAllPackages]
AS
SELECT
	   [PackageID]
      ,[ParentPackageID]
      ,[UserID]
      ,[PackageName]
      ,[PackageComments]
      ,[ServerID]
      ,[StatusID]
      ,[PlanID]
      ,[PurchaseDate]
      ,[OverrideQuotas]
      ,[BandwidthUpdated]
  FROM [dbo].[Packages]
				*/
				#endregion

				var packages = Packages
					.Select(p => new
					{
						p.PackageId,
						p.ParentPackageId,
						p.UserId,
						p.PackageName,
						p.PackageComments,
						p.ServerId,
						p.StatusId,
						p.PlanId,
						p.PurchaseDate,
						p.OverrideQuotas,
						p.BandwidthUpdated
					});
				return EntityDataReader(packages);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetAllPackages");
			}
		}

		public IDataReader GetDomainDnsRecords(int domainId, DnsRecordType recordType)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDomainDnsRecords]
(
	@DomainId INT,
	@RecordType INT
)
AS
SELECT
	ID,
	DomainId,
	DnsServer,
	RecordType,
	Value,
	Date
  FROM [dbo].[DomainDnsRecords]
  WHERE [DomainId]  = @DomainId AND [RecordType] = @RecordType
				*/
				#endregion

				var records = DomainDnsRecords
					.Where(r => r.DomainId == domainId && r.RecordType == recordType)
					.Select(r => new
					{
						r.Id,
						r.DomainId,
						r.DnsServer,
						r.RecordType,
						r.Value,
						r.Date
					});
				return EntityDataReader(records);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetDomainDnsRecords",
					new SqlParameter("@DomainId", domainId),
					new SqlParameter("@RecordType", recordType));
			}
		}

		public IDataReader GetDomainAllDnsRecords(int domainId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetDomainAllDnsRecords]
(
	@DomainId INT
)
AS
SELECT
	ID,
	DomainId,
	DnsServer,
	RecordType,
	Value,
	Date
  FROM [dbo].[DomainDnsRecords]
  WHERE [DomainId]  = @DomainId 
				*/
				#endregion

				var records = DomainDnsRecords
					.Where(r => r.DomainId == domainId)
					.Select(r => new
					{
						r.Id,
						r.DomainId,
						r.DnsServer,
						r.RecordType,
						r.Value,
						r.Date
					});
				return EntityDataReader(records);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetDomainAllDnsRecords",
					new SqlParameter("@DomainId", domainId));
			}
		}

		public void AddDomainDnsRecord(DnsRecordInfo domainDnsRecord)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddDomainDnsRecord]
(
	@DomainId INT,
	@RecordType INT,
	@DnsServer NVARCHAR(255),
	@Value NVARCHAR(255),
	@Date DATETIME
)
AS

INSERT INTO DomainDnsRecords
(
	DomainId,
	DnsServer,
	RecordType,
	Value,
	Date
)
VALUES
(
	@DomainId,
	@DnsServer,
	@RecordType,
	@Value,
	@Date
)
				*/
				#endregion

				var record = new Data.Entities.DomainDnsRecord()
				{
					DomainId = domainDnsRecord.Id,
					DnsServer = domainDnsRecord.DnsServer,
					RecordType = domainDnsRecord.RecordType,
					Value = domainDnsRecord.Value,
					Date = domainDnsRecord.Date
				};
				DomainDnsRecords.Add(record);
				SaveChanges();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddDomainDnsRecord",
					new SqlParameter("@DomainId", domainDnsRecord.DomainId),
					new SqlParameter("@RecordType", domainDnsRecord.RecordType),
					new SqlParameter("@DnsServer", domainDnsRecord.DnsServer),
					new SqlParameter("@Value", domainDnsRecord.Value),
					new SqlParameter("@Date", domainDnsRecord.Date));
			}
		}

		/* Table ScheduleTasksEmailTemplates does not exist.
		public IDataReader GetScheduleTaskEmailTemplate(string taskId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetScheduleTaskEmailTemplate]
(
	@TaskID [nvarchar](100) 
)
AS
SELECT
	[TaskID],
	[From] ,
	[Subject] ,
	[Template]
  FROM [dbo].[ScheduleTasksEmailTemplates] where [TaskID] = @TaskID 
				/*
				#endregion

				var templates = ScheduleTasksEmailTemplates.
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetScheduleTaskEmailTemplate",
					new SqlParameter("@taskId", taskId));
			}
		} */

		public void DeleteDomainDnsRecord(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteDomainDnsRecord]
(
	@Id  INT
)
AS
DELETE FROM DomainDnsRecords
WHERE Id = @Id
				*/
				#endregion

				DomainDnsRecords
					.Where(r => r.Id == id)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"DeleteDomainDnsRecord",
					new SqlParameter("@Id", id));
			}
		}

		public void UpdateDomainCreationDate(int domainId, DateTime date)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateDomainCreationDate]
(
	@DomainId INT,
	@Date DateTime
)
AS
UPDATE [dbo].[Domains] SET [CreationDate] = @Date
WHERE [DomainID] = @DomainId
				*/
				#endregion

				Domains
					.Where(d => d.DomainId == domainId)
					.ExecuteUpdate(d => new Data.Entities.Domain {
						CreationDate = date
					});
			}
			else
			{
				UpdateDomainDate(domainId, "UpdateDomainCreationDate", date);
			}
		}

		public void UpdateDomainExpirationDate(int domainId, DateTime date)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateDomainExpirationDate]
(
	@DomainId INT,
	@Date DateTime
)
AS
UPDATE [dbo].[Domains] SET [ExpirationDate] = @Date WHERE [DomainID] = @DomainId
				*/
				#endregion

				Domains
					.Where(d => d.DomainId == domainId)
					.ExecuteUpdate(d => new Data.Entities.Domain {
						ExpirationDate = date
					});
			}
			else
			{
				UpdateDomainDate(domainId, "UpdateDomainExpirationDate", date);
			}
		}

		public void UpdateDomainLastUpdateDate(int domainId, DateTime date)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateDomainLastUpdateDate]
(
	@DomainId INT,
	@Date DateTime
)
AS
UPDATE [dbo].[Domains] SET [LastUpdateDate] = @Date WHERE [DomainID] = @DomainId
				*/
				#endregion

				Domains
					.Where(d => d.DomainId == domainId)
					.ExecuteUpdate(d => new Data.Entities.Domain {
						LastUpdateDate = date
					});
			}
			else
			{
				UpdateDomainDate(domainId, "UpdateDomainLastUpdateDate", date);
			}
		}

		private void UpdateDomainDate(int domainId, string storedProcedure, DateTime date)
		{
			if (UseEntityFramework)
			{
				switch (storedProcedure) {
				case "UpdateDomainCreationDate":
					UpdateDomainCreationDate(domainId, date);
					break;
				case "UpdateDomainExpirationDate":
					UpdateDomainExpirationDate(domainId, date);
					break;
				case "UpdateDomainLastUpdateDate":
					UpdateDomainLastUpdateDate(domainId, date);
					break;
				}
			} else {
				SqlHelper.ExecuteNonQuery(
				ConnectionString,
				CommandType.StoredProcedure,
				storedProcedure,
				new SqlParameter("@DomainId", domainId),
				new SqlParameter("@Date", date));
			}
		}

		public void UpdateDomainDates(int domainId, DateTime? domainCreationDate, DateTime? domainExpirationDate, DateTime? domainLastUpdateDate)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateDomainDates]
(
	@DomainId INT,
	@DomainCreationDate DateTime,
	@DomainExpirationDate DateTime,
	@DomainLastUpdateDate DateTime 
)
AS
UPDATE [dbo].[Domains] SET [CreationDate] = @DomainCreationDate, [ExpirationDate] = @DomainExpirationDate, [LastUpdateDate] = @DomainLastUpdateDate WHERE [DomainID] = @DomainId
				*/
				#endregion

				Domains
					.Where(d => d.DomainId == domainId)
					.ExecuteUpdate(d => new Data.Entities.Domain
					{
						CreationDate = domainCreationDate,
						ExpirationDate = domainExpirationDate,
						LastUpdateDate = domainLastUpdateDate
					});
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateDomainDates",
					new SqlParameter("@DomainId", domainId),
					new SqlParameter("@DomainCreationDate", domainCreationDate),
					new SqlParameter("@DomainExpirationDate", domainExpirationDate),
					new SqlParameter("@DomainLastUpdateDate", domainLastUpdateDate));
			}
		}

		public void UpdateWhoisDomainInfo(int domainId, DateTime? domainCreationDate, DateTime? domainExpirationDate, DateTime? domainLastUpdateDate, string registrarName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[UpdateWhoisDomainInfo]
(
	@DomainId INT,
	@DomainCreationDate DateTime,
	@DomainExpirationDate DateTime,
	@DomainLastUpdateDate DateTime,
	@DomainRegistrarName nvarchar(max)
)
AS
UPDATE [dbo].[Domains] SET [CreationDate] = @DomainCreationDate, [ExpirationDate] = @DomainExpirationDate, [LastUpdateDate] = @DomainLastUpdateDate, [RegistrarName] = @DomainRegistrarName WHERE [DomainID] = @DomainId
				*/
				#endregion

				Domains
					.Where(d => d.DomainId == domainId)
					.ExecuteUpdate(d => new Data.Entities.Domain
					{
						CreationDate = domainCreationDate,
						ExpirationDate = domainExpirationDate,
						LastUpdateDate = domainLastUpdateDate,
						RegistrarName = registrarName
					});
			}
			else
			{
				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"UpdateWhoisDomainInfo",
					new SqlParameter("@DomainId", domainId),
					new SqlParameter("@DomainCreationDate", domainCreationDate),
					new SqlParameter("@DomainExpirationDate", domainExpirationDate),
					new SqlParameter("@DomainLastUpdateDate", domainLastUpdateDate),
					new SqlParameter("@DomainRegistrarName", registrarName));
			}
		}
#endregion

		#region Organization Storage Space Folders
		public IDataReader GetOrganizationStoragSpaceFolders(int itemId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOrganizationStoragSpaceFolders]
(
	@ItemId INT
)
AS
	SELECT
		SSF.Id,
		SSF.Name,
		SSF.StorageSpaceId,
		SSF.Path,
		SSF.UncPath,
		SSF.IsShared,
		SSF.FsrmQuotaType,
		SSF.FsrmQuotaSizeBytes
	FROM [ExchangeOrganizationSsFolders] AS OSSF
	INNER JOIN [StorageSpaceFolders] AS SSF ON SSF.Id = OSSF.StorageSpaceFolderId
	WHERE ItemId = @ItemId
				*/
				#endregion

				var folders = ExchangeOrganizationSsFolders
					.Where(e => e.ItemId == itemId)
					.Select(e => new
					{
						e.StorageSpaceFolder.Id,
						e.StorageSpaceFolder.Name,
						e.StorageSpaceFolder.StorageSpaceId,
						e.StorageSpaceFolder.Path,
						e.StorageSpaceFolder.UncPath,
						e.StorageSpaceFolder.IsShared,
						e.StorageSpaceFolder.FsrmQuotaType,
						e.StorageSpaceFolder.FsrmQuotaSizeBytes
					});
				return EntityDataReader(folders);
			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetOrganizationStoragSpaceFolders",
					new SqlParameter("@ItemId", itemId));
			}
		}

		public IDataReader GetOrganizationStoragSpacesFolderByType(int itemId, string type)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetOrganizationStoragSpacesFolderByType]
(
	@ItemId INT,
	@Type varchar(100)
)
AS
	SELECT
		SSF.Id,
		SSF.Name,
		SSF.StorageSpaceId,
		SSF.Path,
		SSF.UncPath,
		SSF.IsShared,
		SSF.FsrmQuotaType,
		SSF.FsrmQuotaSizeBytes
	FROM [ExchangeOrganizationSsFolders] AS OSSF
	INNER JOIN [StorageSpaceFolders] AS SSF ON SSF.Id = OSSF.StorageSpaceFolderId
	WHERE ItemId = @ItemId AND Type = @Type
				*/
				#endregion

				var folders = ExchangeOrganizationSsFolders
					.Where(e => e.ItemId == itemId && e.Type == type)
					.Select(e => new
					{
						e.StorageSpaceFolder.Id,
						e.StorageSpaceFolder.Name,
						e.StorageSpaceFolder.StorageSpaceId,
						e.StorageSpaceFolder.Path,
						e.StorageSpaceFolder.UncPath,
						e.StorageSpaceFolder.IsShared,
						e.StorageSpaceFolder.FsrmQuotaType,
						e.StorageSpaceFolder.FsrmQuotaSizeBytes
					});
				return EntityDataReader(folders);

			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetOrganizationStoragSpacesFolderByType",
					new SqlParameter("@ItemId", itemId),
					new SqlParameter("@Type", type));
			}
		}

		public void DeleteOrganizationStoragSpacesFolder(int id)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[DeleteOrganizationStoragSpacesFolder]
(
	@Id INT
)
AS
	DELETE
	FROM [ExchangeOrganizationSsFolders]
	WHERE StorageSpaceFolderId = @Id
				*/
				#endregion

				ExchangeOrganizationSsFolders
					.Where(f => f.StorageSpaceFolderId == id)
					.ExecuteDelete();
			}
			else
			{
				SqlHelper.ExecuteNonQuery(ConnectionString,
					CommandType.StoredProcedure,
					"DeleteOrganizationStoragSpacesFolder",
					new SqlParameter("@ID", id));
			}
		}

		public int AddOrganizationStoragSpacesFolder(int itemId, string type, int storageSpaceFolderId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddOrganizationStoragSpacesFolder]
(
	@Id INT OUTPUT,
	@ItemId INT,
	@Type varchar(100),
	@StorageSpaceFolderId INT
)
AS
	INSERT INTO [ExchangeOrganizationSsFolders]
	(
		ItemId,
		Type,
		StorageSpaceFolderId
	)
	VALUES 
	(
		@ItemId,
		@Type,
		@StorageSpaceFolderId
	)

	SET @Id = @StorageSpaceFolderId
				*/
				#endregion

				var folder = new Data.Entities.ExchangeOrganizationSsFolder()
				{
					ItemId = itemId,
					Type = type,
					StorageSpaceFolderId = storageSpaceFolderId
				};
				ExchangeOrganizationSsFolders.Add(folder);
				SaveChanges();
				return storageSpaceFolderId;
			}
			else
			{
				SqlParameter outParam = new SqlParameter("@ID", SqlDbType.Int);
				outParam.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddOrganizationStoragSpacesFolder",
					outParam,
					new SqlParameter("@ItemId", itemId),
					new SqlParameter("@Type", type),
					new SqlParameter("@StorageSpaceFolderId", storageSpaceFolderId));

				return Convert.ToInt32(outParam.Value);
			}
		}

		/* Stored procedure is not in Database
		public IDataReader GetOrganizationStorageSpacesFolderById(int itemId, int folderId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
				*//*
				#endregion

			}
			else
			{
				return SqlHelper.ExecuteReader(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetOrganizationStorageSpacesFolderById",
					new SqlParameter("@ItemId", itemId),
					new SqlParameter("@ID", folderId));
			}
		}*/
		#endregion

		#region RDS Messages

		public DataSet GetRDSMessagesByCollectionId(int rdsCollectionId)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[GetRDSMessages]
(
	@RDSCollectionId INT
)
AS
SELECT Id, RDSCollectionId, MessageText, UserName, [Date] FROM [dbo].[RDSMessages] WHERE RDSCollectionId = @RDSCollectionId
RETURN
				*/
				#endregion

				var messages = RdsMessages
					.Where(m => m.RdsCollectionId == rdsCollectionId)
					.Select(m => new { m.Id, m.RdsCollectionId, m.MessageText, m.UserName, m.Date });
				return EntityDataSet(messages);
			}
			else
			{
				return SqlHelper.ExecuteDataset(
					ConnectionString,
					CommandType.StoredProcedure,
					"GetRDSMessages",
					new SqlParameter("@RDSCollectionId", rdsCollectionId));
			}
		}

		public int AddRDSMessage(int rdsCollectionId, string messageText, string userName)
		{
			if (UseEntityFramework)
			{
				#region Stored Procedure
				/*
CREATE PROCEDURE [dbo].[AddRDSMessage]
(
	@RDSMessageId INT OUTPUT,
	@RDSCollectionId INT,
	@MessageText NTEXT,
	@UserName NVARCHAR(255),
	@Date DATETIME
)
AS
INSERT INTO RDSMessages
(
	RDSCollectionId,
	[MessageText],
	UserName,
	[Date]
)
VALUES
(
	@RDSCollectionId,
	@MessageText,
	@UserName,
	@Date
)

SET @RDSMessageId = SCOPE_IDENTITY()

RETURN				*/
				#endregion

				var message = new Data.Entities.RdsMessage()
				{
					RdsCollectionId = rdsCollectionId,
					MessageText = messageText,
					UserName = userName,
					Date = DateTime.Now
				};
				RdsMessages.Add(message);
				SaveChanges();
				return message.Id;
			}
			else
			{
				SqlParameter rdsMessageId = new SqlParameter("@RDSMessageID", SqlDbType.Int);
				rdsMessageId.Direction = ParameterDirection.Output;

				SqlHelper.ExecuteNonQuery(
					ConnectionString,
					CommandType.StoredProcedure,
					"AddRDSMessage",
					rdsMessageId,
					new SqlParameter("@RDSCollectionId", rdsCollectionId),
					new SqlParameter("@MessageText", messageText),
					new SqlParameter("@UserName", userName),
					new SqlParameter("@Date", DateTime.Now));

				return Convert.ToInt32(rdsMessageId.Value);
			}
		}

		#endregion

	}
}
